# 0401-0500-Easy

* [0401\-0500\-Easy](#0401-0500-easy)
  * [401\.二进制手表(3)](#401%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A83)
  * [404\.左叶子之和(2)](#404%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C2)
  * [405\.数字转换为十六进制数(2)](#405%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B02)
  * [409\.最长回文串(2)](#409%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B22)
  * [412\.Fizz Buzz(1)](#412fizz-buzz1)
  * [414\.第三大的数(2)](#414%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B02)
  * [415\.字符串相加(2)](#415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A02)
  * [434\.字符串中的单词数(2)](#434%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B02)
  * [437\.路径总和III(4)](#437%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciii4)
  * [441\.排列硬币(3)](#441%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%813)
  * [443\.压缩字符串(1)](#443%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B21)
  * [447\.回旋镖的数量(1)](#447%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F1)
  * [448\.找到所有数组中消失的数字(3)](#448%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%973)
  * [453\.最小移动次数使数组元素相等(2)](#453%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%892)
  * [455\.分发饼干(1)](#455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B21)
  * [459\.重复的子字符串(2)](#459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B22)
  * [461\.汉明距离(3)](#461%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB3)
  * [463\.岛屿的周长(3)](#463%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF3)
  * [475\.供暖器(2)](#475%E4%BE%9B%E6%9A%96%E5%99%A82)
  * [476\.数字的补数(3)](#476%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B03)
  * [482\.密钥格式化(2)](#482%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%962)
  * [485\.最大连续1的个数(2)](#485%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B02)
  * [492\.构造矩形(1)](#492%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A21)
  * [496\.下一个更大元素 I(3)](#496%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i3)
  * [500\.键盘行(4)](#500%E9%94%AE%E7%9B%98%E8%A1%8C4)
* [0401\-0500\-Medium](#0401-0500-medium)
  * [406\.根据身高重建队列(2)](#406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%972)
  * [416\.分割等和子集(3)](#416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%863)
  * [438\.找到字符串中所有字母异位词(2)](#438%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D2)
  * [442\.数组中重复的数据(5)](#442%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE5)
  * [445\.两数相加II(3)](#445%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0ii3)
  * [486\.预测赢家(3)](#486%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B63)
  * [494\.目标和(5)](#494%E7%9B%AE%E6%A0%87%E5%92%8C5)
  * [491\.递增子序列(2)](#491%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%972)
  * [498\.对角线遍历(2)](#498%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%862)
* [0401\-0500\-Hard](#0401-0500-hard)
  * [410\.分割数组的最大值(3)](#410%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC3)
  * [460\.LFU缓存](#460lfu%E7%BC%93%E5%AD%98)
    * [题目](#%E9%A2%98%E7%9B%AE)
    * [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)


## 401.二进制手表(3)

- 题目

```
二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。
每个 LED 代表一个 0 或 1，最低位在右侧。
例如，上面的二进制手表读取 “3:25”。
给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。

案例:输入: n = 1
返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]

注意事项:
输出的顺序没有要求。
小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 暴力法 | O(1)       | O(1)       |
| 02   | 暴力法 | O(1)       | O(1)       |
| 03   | 回溯法 | O(2^n)     | O(n)       |

```go
func binCount(num int) int {
	count := make([]int, 0)
	for num != 0 {
		temp := num % 2
		count = append(count, temp)
		num = num / 2
	}
	countNum := 0
	for i := 0; i < len(count); i++ {
		if count[i] == 1 {
			countNum++
		}
	}
	return countNum
}

func readBinaryWatch(num int) []string {
	res := make([]string, 0)
	for i := 0; i < 12; i++ {
		for j := 0; j < 60; j++ {
			if binCount(i)+binCount(j) == num {
				res = append(res, fmt.Sprintf("%d:%02d", i, j))
			}
		}
	}
	return res
}

#
func readBinaryWatch(num int) []string {
	res := make([]string, 0)
	for i := 0; i < 12; i++ {
		for j := 0; j < 60; j++ {
			hour := fmt.Sprintf("%b", i)
			minute := fmt.Sprintf("%b", j)
			if strings.Count(hour, "1")+strings.Count(minute, "1") == num {
				res = append(res, fmt.Sprintf("%d:%02d", i, j))
			}
		}
	}
	return res
}

#
func readBinaryWatch(num int) []string {
	res := make([]string, 0)
	ledS := make([]bool, 10)

	var dfs func(int, int)
	dfs = func(idx, num int) {
		if num == 0 {
			// 满足条件
			m, h := get(ledS[:6]), get(ledS[6:])
			if h < 12 && m < 60 {
				res = append(res, fmt.Sprintf("%d:%02d", h, m))
			}
			return
		}
		for i := idx; i < 11-num; i++ {
			ledS[i] = true
			dfs(i+1, num-1)
			ledS[i] = false
		}
	}
	dfs(0, num)
	return res
}

func get(ledS []bool) int {
	bs := []int{1, 2, 4, 8, 16, 32}
	var sum int
	size := len(ledS)
	for i := 0; i < size; i++ {
		if ledS[i] {
			sum += bs[i]
		}
	}
	return sum
}
```

## 404.左叶子之和(2)

- 题目

```
计算给定二叉树的所有左叶子之和。
示例：
    3
   / \
  9  20
    /  \
   15   7
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |
| 02   | 迭代 | O(n)       | O(n)       |

```go
func sumOfLeftLeaves(root *TreeNode) int {
	if root == nil {
		return 0
	}
	if root.Left == nil {
		return sumOfLeftLeaves(root.Right)
	}
	if root.Left.Left == nil && root.Left.Right == nil {
		return root.Left.Val + sumOfLeftLeaves(root.Right)
	}
	return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)
}


#
func sumOfLeftLeaves(root *TreeNode) int {
	sum := 0
	if root == nil{
		return 0
	}
	queue := make([]*TreeNode,0)
	queue = append(queue, root)
	for len(queue) > 0{
		node := queue[0]
		queue = queue[1:]
		if node.Left != nil && node.Left.Left == nil && node.Left.Right == nil{
			sum = sum + node.Left.Val
		}
		if node.Left != nil{
			queue = append(queue, node.Left)
		}
		if node.Right != nil{
			queue = append(queue, node.Right)
		}
	}
	return sum
}
```

## 405.数字转换为十六进制数(2)

- 题目

```
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
注意:
    十六进制中所有字母(a-f)都必须是小写。
    十六进制字符串中不能包含多余的前导零。
    如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
    给定的数确保在32位有符号整数范围内。
    不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
示例 1： 输入:26 输出:"1a"
示例 2： 输入:-1 输出:"ffffffff"
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 位运算 | O(1)       | O(1)       |
| 02   | 遍历   | O(1)       | O(1)       |

```go
var h = []string{
	"0", "1", "2", "3", "4", "5", "6", "7",
	"8", "9", "a", "b", "c", "d", "e", "f",
}

func toHex(num int) string {
	hex := ""
	if num == 0 {
		return "0"
	}

	for i := 0; i < 8 && num != 0; i++ {
		hex = h[num&15] + hex
		num = num >> 4
	}
	return hex
}

#
var h = []string{
	"0", "1", "2", "3", "4", "5", "6", "7",
	"8", "9", "a", "b", "c", "d", "e", "f",
}

func toHex(num int) string {
	res := ""
	if num == 0{
		return "0"
	}
	if num < 0 {
		num = num + 4294967296
	}

	for num != 0{
		temp := num % 16
		res = h[temp] + res
		num = num / 16
	}
	return res
}
```

## 409.最长回文串(2)

- 题目

```
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。
注意:假设字符串的长度不会超过 1010。
示例 1:输入:"abccccdd"输出:7
解释:我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组辅助 | O(n)       | O(1)       |
| 02   | 哈希辅助 | O(n)       | O(1)       |

```go
func longestPalindrome(s string) int {
	ret := 0
	a := [123]int{}
	for i := range s {
		a[s[i]]++
	}
	hasOdd := 0
	for i := range a {
		if a[i] == 0 {
			continue
		}
		if a[i] % 2 == 0 {
			ret += a[i]
		} else {
			ret += a[i] - 1
			hasOdd = 1
		}
	}
	return ret + hasOdd
}

#
func longestPalindrome(s string) int {
	ret := 0
	a := make(map[byte]int)
	for i := range s {
		a[s[i]]++
	}
	hasOdd := 0
	for i := range a {
		if a[i] == 0 {
			continue
		}
		if a[i]%2 == 0 {
			ret += a[i]
		} else {
			ret += a[i] - 1
			hasOdd = 1
		}
	}
	return ret + hasOdd
}
```

## 412.Fizz Buzz(1)

- 题目

```
写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。

示例：n = 15,
返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
func fizzBuzz(n int) []string {
	ret := make([]string, n)
	for i := range ret {
		x := i + 1
		switch {
		case x%15 == 0:
			ret[i] = "FizzBuzz"
		case x%5 == 0:
			ret[i] = "Buzz"
		case x%3 == 0:
			ret[i] = "Fizz"
		default:
			ret[i] = strconv.Itoa(x)
		}
	}
	return ret
}
```

## 414.第三大的数(2)

- 题目

```
给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。
示例 1:输入: [3, 2, 1]输出: 1
解释: 第三大的数是 1.
示例 2:输入: [1, 2]输出: 2
解释: 第三大的数不存在, 所以返回最大的数 2 .
示例 3:输入: [2, 2, 3, 1]输出: 1
解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n)       | O(1)       |
| 02   | 排序遍历 | O(nlog(n)) | O(1)       |

```go
func thirdMax(nums []int) int {
	max1, max2, max3 := math.MinInt64, math.MinInt64, math.MinInt64
	for _, n := range nums {
		if n == max1 || n == max2 {
			continue
		}
		switch {
		case max1 < n:
			max1, max2, max3 = n, max1, max2
		case max2 < n:
			max2, max3 = n, max2
		case max3 < n:
			max3 = n
		}
	}

	if max3 == math.MinInt64 {
		return max1
	}
	return max3
}

#
func thirdMax(nums []int) int {

	sort.Ints(nums)
	if len(nums) < 3 {
		return nums[len(nums)-1]
	}

	k := 2
	maxValue := nums[len(nums)-1]
	for i := len(nums) - 2; i >= 0; i-- {
		if nums[i] != nums[i+1] {
			k--
		}
		if k == 0 {
			return nums[i]
		}
	}
	return maxValue
}
```

## 415.字符串相加(2)

- 题目

```
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：
num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 模拟遍历     | O(n)       | O(1)       |
| 02   | 逆置进位模拟 | O(n)       | O(1)       |

```go
func addStrings(num1 string, num2 string) string {
	if len(num1) > len(num2) {
		num1, num2 = num2, num1
	}
	n1, n2 := len(num1), len(num2)
	a1, a2 := []byte(num1), []byte(num2)
	carry := byte(0)
	buf := make([]byte, n2+1)
	buf[0] = '1'

	for i := 1; i <= n2; i++ {
		if i <= n1 {
			buf[n2+1-i] = a1[n1-i] - '0'
		}
		buf[n2+1-i] = buf[n2+1-i] + a2[n2-i] + carry

		if buf[n2+1-i] > '9' {
			buf[n2+1-i] = buf[n2+1-i] - 10
			carry = byte(1)
		} else {
			carry = byte(0)
		}
	}
	if carry == 1 {
		return string(buf)
	}
	return string(buf[1:])
}

#
func addStrings(num1 string, num2 string) string {
	if len(num1) > len(num2) {
		num1, num2 = num2, num1
	}
	n1, n2 := len(num1), len(num2)
	a1, a2 := []byte(num1), []byte(num2)
	a1 = reverse(a1)
	a2 = reverse(a2)

	carry := 0
	buf := make([]byte, 0)
	for i := 0; i < n2; i++ {
		temp := 0
		if i < n1 {
			temp = int(a1[i] - '0')
		}
		temp = int(a2[i]-'0') + temp + carry
		if temp > 9 {
			buf = append(buf, byte(temp-10+'0'))
			carry = 1
		} else {
			buf = append(buf, byte(temp+'0'))
			carry = 0
		}
	}
	if carry == 1 {
		buf = append(buf, byte('1'))
	}
	return string(reverse(buf))
}

func reverse(arr []byte) []byte {
	for i := 0; i < len(arr)/2; i++ {
		arr[i], arr[len(arr)-1-i] = arr[len(arr)-1-i], arr[i]
	}
	return arr
}
```

## 434.字符串中的单词数(2)

- 题目

```
统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。
请注意，你可以假定字符串里不包括任何不可打印的字符。
示例:输入: "Hello, my name is John"输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |

```go
func countSegments(s string) int {
	if len(s) == 0 {
		return 0
	}
	return len(strings.Fields(s))
}

#
func countSegments(s string) int {
	count := 0
	for i := 0; i < len(s); i++{
		if (i == 0 || s[i-1] == ' ') && s[i] != ' '{
			count++
		}
	}
	return count
}
```

## 437.路径总和III(4)

- 题目

```
给定一个二叉树，它的每个结点都存放着一个整数值。
找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
示例：
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:
1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

- 解题思路

| No.  | 思路  | 时间复杂度 | 空间复杂度 |
| ---- | ----- | ---------- | ---------- |
| 01   | 递归  | O(n^2)     | O(n)       |
| 02   | 2次递归 | O(n^2)        |    O(n)        |
| 03 | 迭代+递归 | O(n^2) | O(n) |
| 04 | 保存路径 | O(n^2) | O(n) |

```go
func pathSum(root *TreeNode, sum int) int {
	if root == nil {
		return 0
	}
	res := 0
	var helper func(*TreeNode, int)
	helper = func(node *TreeNode, sum int) {
		if node == nil {
			return
		}
		sum = sum - node.Val
		// 路径不需要从根节点开始，也不需要在叶子节点结束
		if sum == 0 {
			res++
		}
		helper(node.Left, sum)
		helper(node.Right, sum)
	}
	helper(root, sum)
	return res + pathSum(root.Left, sum) + pathSum(root.Right, sum)
}

#
func helper(node *TreeNode, sum int) int {
	if node == nil {
		return 0
	}
	sum = sum - node.Val
	res := 0
	if sum == 0 {
		res = 1
	}
	return res + helper(node.Left, sum) + helper(node.Right, sum)
}

func pathSum(root *TreeNode, sum int) int {
	if root == nil {
		return 0
	}
	return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)
}

# 迭代+递归
func helper(node *TreeNode, sum int, curSum int) int {
	res := 0
	curSum = curSum + node.Val
	if curSum == sum {
		res++
	}
	if node.Left != nil {
		res += helper(node.Left, sum, curSum)
	}
	if node.Right != nil {
		res += helper(node.Right, sum, curSum)
	}
	return res
}

func pathSum(root *TreeNode, sum int) int {
	if root == nil {
		return 0
	}
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	res := 0
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		tempSum := 0
		res += helper(node, sum, tempSum)
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	return res
}

#
func helper(node *TreeNode, sum int, path []int, level int) int {
	if node == nil {
		return 0
	}
	res := 0
	if sum == node.Val {
		res = 1
	}
	temp := node.Val
	for i := level - 1; i >= 0; i-- {
		temp = temp + path[i]
		if temp == sum {
			res++
		}
	}
	path[level] = node.Val
	return res + helper(node.Left, sum, path, level+1) + 
		helper(node.Right, sum, path, level+1)
}

func pathSum(root *TreeNode, sum int) int {
	return helper(root, sum, make([]int, 1001), 0)
}
```

## 441.排列硬币(3)

- 题目

```
你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。
给定一个数字 n，找出可形成完整阶梯行的总行数。
n 是一个非负整数，并且在32位有符号整型的范围内。
示例 1:n = 5
硬币可排列成以下几行:
¤
¤ ¤
¤ ¤
因为第三行不完整，所以返回2.
示例 2:n = 8
硬币可排列成以下几行:
¤
¤ ¤
¤ ¤ ¤
¤ ¤
因为第四行不完整，所以返回3.
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数学法   | O(1)       | O(1)       |
| 02   | 迭代     | O(n^1/2)   | O(1)       |
| 03   | 二分查找 | O(log(n))  | O(1)       |

```go
func arrangeCoins(n int) int {
	return int(math.Sqrt(float64(2*n)+0.25) - 0.5)
}

#
func arrangeCoins(n int) int {
	i := 1
	for i <= n{
		n = n - i
		i++
	}
	return i-1
}

#
func arrangeCoins(n int) int {
	if n == 0{
		return 0
	}
	left, right := 1, n
	for left < right{
		mid := left + (right-left)/2
		if mid * (mid+1)/2 < n{
			left = mid + 1
		}else {
			right = mid
		}
	}
	if left*(left+1)/2 == n{
		return left
	}
	return left-1
}
```

## 443.压缩字符串(1)

- 题目

```
给定一组字符，使用原地算法将其压缩。
压缩后的长度必须始终小于或等于原数组长度。
数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。
在完成原地修改输入数组后，返回数组的新长度。
进阶：你能否仅使用O(1) 空间解决问题？

示例 1：输入：["a","a","b","b","c","c","c"]
输出：返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]
说明："aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。

示例 2：输入：["a"]
输出：返回1，输入数组的前1个字符应该是：["a"]
说明：没有任何字符串被替代。

示例 3：输入：["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：返回4，输入数组的前4个字符应该是：["a","b","1","2"]。
说明：由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
注意每个数字在数组中都有它自己的位置。
注意：
    所有字符都有一个ASCII值在[35, 126]区间内。
    1 <= len(chars) <= 1000。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 双指针 | O(n)       | O(1)       |

```go
func compress(chars []byte) int {
	j := 0
	count := 1
	for i := 0; i < len(chars); i++ {
		char := chars[i]
		if i+1 < len(chars) && char == chars[i+1] {
			count++
		} else {
			chars[j] = char
			j++
			if count > 1 {
				for _, num := range strconv.Itoa(count) {
					chars[j] = byte(num)
					j++
				}
			}
			count = 1
		}
	}
	return j
}
```

## 447.回旋镖的数量(1)

- 题目

```
给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，
其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。

找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。
示例:
输入:[[0,0],[1,0],[2,0]]
输出:2
解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 哈希辅助+遍历 | O(n^2)     | O(n)       |

```go
func numberOfBoomerangs(points [][]int) int {
	res := 0
	size := len(points)
	if size < 3 {
		return 0
	}
	for i := 0; i < size; i++ {
		dMap := make(map[int]int, size)
		for j := 0; j < size; j++ {
			if i == j {
				continue
			}
			d := dSquare(points[i], points[j])
			if _, ok := dMap[d]; ok {
				dMap[d]++
			} else {
				dMap[d] = 1
			}
		}
		// 相同距离的v个点，总共有 v*(v-1)种排列
		for _, v := range dMap {
			res = res + v*(v-1)
		}
	}
	return res
}

func dSquare(p1, p2 []int) int {
	x := p2[0] - p1[0]
	y := p2[1] - p1[1]
	return x*x + y*y
}
```

## 448.找到所有数组中消失的数字(3)

- 题目

```
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在 [1, n] 范围之间没有出现在数组中的数字。
您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:输入:[4,3,2,7,8,2,3,1]输出:[5,6]
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历交换 | O(n)       | O(1)       |
| 02   | 遍历置反 | O(n)       | O(1)       |
| 03   | 哈希辅助 | O(n)       | O(n)       |

```go
func findDisappearedNumbers(nums []int) []int {
	for i := 0; i < len(nums); i++ {
		for nums[i] != nums[nums[i]-1] {
			nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]
		}
	}
	res := make([]int, 0)
	for i, n := range nums {
		if n != i+1 {
			res = append(res, i+1)
		}
	}
	return res
}

#
func findDisappearedNumbers(nums []int) []int {
	for i := 0; i < len(nums); i++ {
		value := nums[i]
		if value < 0{
			value = -value
		}
		if nums[value-1] > 0{
			nums[value-1] = -nums[value-1]
		}
	}
	res := make([]int, 0)
	for key, value := range nums {
		if value > 0{
			res = append(res, key+1)
		}
	}
	return res
}

#
func findDisappearedNumbers(nums []int) []int {
	m := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		m[nums[i]] = 1
	}
	res := make([]int, 0)
	for i := 0; i < len(nums); i++ {
		if _, ok := m[i+1]; !ok {
			res = append(res, i+1)
		}
	}
	return res
}
```

## 453.最小移动次数使数组元素相等(2)

- 题目

```
给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。
示例:输入:[1,2,3]输出:3
解释:只需要3次移动（注意每次移动会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数学公式 | O(n)       | O(1)       |
| 02   | 排序遍历 | O(nlog(n)) | O(1)       |

```go
func minMoves(nums []int) int {
	sum := 0
	min := nums[0]
	for _, n := range nums {
		sum += n
		if min > n {
			min = n
		}
	}
	return sum - min*len(nums)
}

#
func minMoves(nums []int) int {
	sum := 0
	sort.Ints(nums)
	for i := 1; i < len(nums); i++{
		sum = sum + nums[i] - nums[0]
	}
	return sum
}
```

## 455.分发饼干(1)

- 题目

```
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；
并且每块饼干 j ，都有一个尺寸 sj 。
如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。

示例 1:输入: [1,2,3], [1,1]  输出: 1
解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。

示例 2:输入: [1,2], [1,2,3] 输出: 2
解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.
```

- 解题思路

| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- | ---------- |
| 01   | 排序双指针 | O(nlog(n)) | O(1)       |

```go
func findContentChildren(g []int, s []int) int {
	sort.Ints(g)
	sort.Ints(s)
	var i, j int
	for i < len(g) && j < len(s) {
		if g[i] <= s[j] {
			i++
		}
		j++
	}
	return i
}
```

## 459.重复的子字符串(2)

- 题目

```
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。
给定的字符串只含有小写英文字母，并且长度不超过10000。
示例 1:输入: "abab"输出: True
解释: 可由子字符串 "ab" 重复两次构成。
示例 2:输入: "aba"输出: False
示例 3:输入: "abcabcabcabc"输出: True
解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 2倍去除首尾匹配 | O(n)       | O(1)       |
| 02   | 暴力匹配        | O(n^2)     | O(1)       |

```go
func repeatedSubstringPattern(s string) bool {
	if len(s) == 0 {
		return false
	}

	size := len(s)
	ss := (s + s)[1 : size*2-1]
	return strings.Contains(ss, s)
}

#
func repeatedSubstringPattern(s string) bool {
	if len(s) == 0 {
		return false
	}
	size := len(s)
	for i := 1; i < size; i++ {
		if size%i == 0 {
			count := size / i
			if strings.Repeat(s[0:i], count) == s {
				return true
			}
		}
	}
	return false
}
```

## 461.汉明距离(3)

- 题目

```
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。
注意：
0 ≤ x, y < 231.
示例:
输入: x = 1, y = 4输出: 2
解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 位运算+遍历统计 | O(1)       | O(1)       |
| 02   | 位运算          | O(1)       | O(1)       |
| 03   | 内置函数        | O(1)       | O(1)       |

```go
func hammingDistance(x int, y int) int {
	x = x ^ y
	res := 0
	for x > 0 {
		if x&1 == 1{
			res++
		}
		x = x >> 1
	}
	return res
}

#
func hammingDistance(x int, y int) int {
	x = x ^ y
	res := 0
	for x > 0 {
		res++
		x = x & (x-1)
	}
	return res
}

#
func hammingDistance(x int, y int) int {
	x = x ^ y
	return bits.OnesCount(uint(x))
}
```

## 463.岛屿的周长(3)

- 题目

```
给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。
整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。
网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

示例 :
输入:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]
输出: 16
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 暴力法      | O(n^2)     | O(1)       |
| 02   | 暴力法      | O(n^2)     | O(1)       |
| 03   | 深度优先搜索 | O(n^2) | O(n^2) |

```go
func islandPerimeter(grid [][]int) int {
	var dx = []int{-1, 1, 0, 0}
	var dy = []int{0, 0, -1, 1}
	m, n := len(grid), len(grid[0])
	res := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 0 {
				continue
			}
			res += 4
			for k := 0; k < 4; k++ {
				x := i + dx[k]
				y := j + dy[k]
				if (0 <= x && x < m && 0 <= y && y < n) && grid[x][y] == 1 {
					res--
				}
			}
		}
	}
	return res
}

#
func islandPerimeter(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	res := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 0 {
				continue
			}
			res += 4
			if i > 0 && grid[i-1][j] == 1 {
				res -= 2
			}
			if j > 0 && grid[i][j-1] == 1 {
				res -= 2
			}
		}
	}
	return res
}

#
func islandPerimeter(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 1 {
				return dfs(grid, i, j)
			}
		}
	}
	return 0
}

func dfs(grid [][]int, i, j int) int {
	// 边界+1
	if !(0 <= i && i < len(grid) && 0 <= j && j < len(grid[0])) {
		return 1
	}
	// 水域+1
	if grid[i][j] == 0 {
		return 1
	}
	if grid[i][j] != 1 {
		return 0
	}
	grid[i][j] = 2
	return dfs(grid, i-1, j) +
		dfs(grid, i+1, j) +
		dfs(grid, i, j-1) +
		dfs(grid, i, j+1)
}
```

## 475.供暖器(2)

- 题目

```
冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。
说明:
    给出的房屋和供暖器的数目是非负数且不会超过 25000。
    给出的房屋和供暖器的位置均是非负数且不会超过10^9。
    只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。
    所有供暖器都遵循你的半径标准，加热的半径也一样。
    
示例 1:输入: [1,2,3],[2] 输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。

示例 2:输入: [1,2,3,4],[1,4] 输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 排序双指针   | O(nlog(n)) | O(1)       |
| 02   | 排序二分查找 | O(nlog(n)) | O(1)       |

```go
func findRadius(houses []int, heaters []int) int {
	if len(heaters) == 0 {
		return 0
	}
	sort.Ints(houses)
	sort.Ints(heaters)
	res := 0
	j := 0
	for i := 0; i < len(houses); i++ {
		// 找到最近的一个供暖器, >=确保出现重复的供暖器会往后走
		for j < len(heaters)-1 &&
			Abs(houses[i], heaters[j]) >= Abs(houses[i], heaters[j+1]) {
			j++
		}
		res = Max(Abs(houses[i], heaters[j]), res)
	}
	return res
}

func Abs(a, b int) int {
	if a > b {
		return a - b
	}
	return b - a
}

func Max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

#
func findRadius(houses []int, heaters []int) int {
	if len(heaters) == 0 {
		return 0
	}
	sort.Ints(houses)
	sort.Ints(heaters)
	res := 0
	length := len(heaters)
	for i := 0; i < len(houses); i++ {
		left := 0
		right := length - 1
		for left < right {
			mid := left + (right-left)/2
			if heaters[mid] < houses[i] {
				left = mid + 1
			} else {
				right = mid
			}
		}
		dis := 0
		if heaters[left] < houses[i] {
			dis = houses[i] - heaters[left]
		} else if heaters[left] > houses[i] {
			if left == 0 {
				dis = heaters[0] - houses[i]
			} else {
				dis = Min(heaters[left]-houses[i], houses[i]-heaters[left-1])
			}
		}
		res = Max(res, dis)
	}
	return res
}

func Min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func Max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 476.数字的补数(3)

- 题目

```
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

示例 1:输入: 5 输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
示例 2:输入: 1 输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
注意:
    给定的整数保证在 32 位带符号整数的范围内。
    你可以假定二进制数不包含前导零位。
    本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 位运算 | O(log(n))  | O(1)       |
| 02   | 位运算 | O(log(n))  | O(1)       |
| 03   | 遍历   | O(log(n))  | O(1)       |

```go
func findComplement(num int) int {
	temp := 1
	for num >= temp {
		temp = temp << 1
	}
	return temp - 1 - num
}

#
func findComplement(num int) int {
	temp := num
	res := 0
	for temp > 0 {
		temp = temp >> 1
		res = res << 1
		res++
	}
	return res ^ num
}

#
func findComplement(num int) int {
	res := 0
	if num == 0 {
		return 1
	}
	if num == 1 {
		return 0
	}

	exp := 1
	for num > 0 {
		temp := num % 2
		if temp == 0 {
			res = res + exp
			exp = exp * 2
		} else {
			exp = exp * 2
		}
		num = num / 2
	}
	return res
}
```

## 482.密钥格式化(2)

- 题目

```
有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。
其中， N 个 '-' 将字符串分成了 N+1 组。

给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符；
而第一个分组中，至少要包含 1 个字符。
两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。
给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

示例 1：输入：S = "5F3Z-2e-9-w", K = 4 输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；注意，两个额外的破折号需要删掉。

示例 2：输入：S = "2-5g-3-J", K = 2 输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，
第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
提示:
    S 的长度可能很长，请按需分配大小。K 为正整数。
    S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-'
    S 非空
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n)       | O(1)       |
| 02   | 遍历     | O(n)       | O(1)       |

```go
func licenseKeyFormatting(S string, K int) string {
	arr := strings.Join(strings.Split(strings.ToUpper(S), "-"), "")
	count := len(arr) / K
	first := len(arr) % K
	if first > 0 {
		count++
	}
	str := arr[:first]
	if first != 0 {
		count = count - 1
	}
	for i := 0; i < count; i++ {
		str = str + "-" + arr[first+i*K:first+(i+1)*K]
	}
	return strings.Trim(str, "-")
}

#
func licenseKeyFormatting(S string, K int) string {
	res := make([]rune, 0)
	temp := []rune(S)
	count := 0
	for i := len(temp) - 1; i >= 0; i-- {
		value := temp[i]
		if value >= 'a' {
			value = value - 'a' + 'A'
		}
		if value == '-' {
			continue
		}
		count++
		res = append([]rune{value}, res...)
		if count == K {
			res = append([]rune{'-'}, res...)
			count = 0
		}
	}
	if len(res) == 0 {
		return ""
	}
	if res[0] == '-' {
		res = res[1:]
	}
	return string(res)
}
```

## 485.最大连续1的个数(2)

- 题目

```
给定一个二进制数组， 计算其中最大连续1的个数。
示例 1:输入: [1,1,0,1,1,1]输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
注意：
    输入的数组只包含 0 和1。
    输入数组的长度是正整数，且不超过 10,000。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 双指针 | O(n)       | O(1)       |
| 02   | 单指针 | O(n)       | O(1)       |

```go
func findMaxConsecutiveOnes(nums []int) int {
	max := 0
	for i, j := 0, -1; i < len(nums); i++ {
		if nums[i] == 0 {
			j = i
		} else {
			if max < i-j {
				max = i - j
			}
		}
	}
	return max
}

#
func findMaxConsecutiveOnes(nums []int) int {
	max := 0
	count := 0
	for _, v := range nums {
		if v == 1 {
			count++
		} else {
			if count > max {
				max = count
			}
			count = 0
		}
	}
	if count > max {
		max = count
	}
	return max
}
```

## 492.构造矩形(1)

- 题目

```
作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 
现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

1. 你设计的矩形页面必须等于给定的目标面积。
2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。
3. 长度 L 和宽度 W 之间的差距应当尽可能小。

你需要按顺序输出你设计的页面的长度 L 和宽度 W。
示例：
输入: 4 输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 
所以输出长度 L 为 2， 宽度 W 为 2。
说明:
    给定的面积不大于 10,000,000 且为正整数。
    你设计的页面的长度和宽度必须都是正整数。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 开方向下遍历 | O(n)       | O(1)       |

```go
func constructRectangle(area int) []int {
	for i := int(math.Sqrt(float64(area))); i > 1; i-- {
		if area%i == 0 {
			return []int{area / i, i}
		}
	}
	return []int{area, 1}
}
```

## 496.下一个更大元素 I(3)

- 题目

```
给定两个没有重复元素的数组nums1 和 nums2 ，其中nums1 是 nums2 的子集。
找到 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。
如果不存在，对应位置输出 -1 。
示例 1:
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。

示例 2:
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
提示：
    nums1和nums2中所有元素是唯一的。
    nums1和nums2 的数组大小都不超过1000。
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 哈希辅助    | O(n^2)     | O(n)       |
| 02   | 哈希辅助    | O(n^2)     | O(n)       |
| 02   | 栈+哈希辅助 | O(n)       | O(n)       |

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
	m := make(map[int]int)
	for i, n := range nums2 {
		m[n] = i
	}
	res := make([]int, len(nums1))
	for i, n := range nums1 {
		res[i] = -1
		for j := m[n] + 1; j < len(nums2); j++ {
			if n < nums2[j] {
				res[i] = nums2[j]
				break
			}
		}
	}
	return res
}

#
func nextGreaterElement(nums1 []int, nums2 []int) []int {
	m := make(map[int]int)
	res := make([]int, len(nums1))
	for i := 0; i < len(nums2); i++ {
		for j := i + 1; j < len(nums2); j++ {
			if nums2[j] > nums2[i] {
				m[nums2[i]] = nums2[j]
				break
			}
		}
	}
	for key, value := range nums1 {
		if _, ok := m[value]; ok {
			res[key] = m[value]
		} else {
			res[key] = -1
		}
	}
	return res
}

#
func nextGreaterElement(nums1 []int, nums2 []int) []int {
	m := make(map[int]int)
	res := make([]int, len(nums1))
	stack := make([]int, 0)
	for i := 0; i < len(nums2); i++ {
		if len(stack) > 0 {
			for len(stack) > 0 && nums2[i] > stack[len(stack)-1] {
				top := stack[len(stack)-1]
				m[top] = nums2[i]
				stack = stack[:len(stack)-1]
			}
		}
		stack = append(stack, nums2[i])
	}
	for key, value := range nums1 {
		if _, ok := m[value]; ok {
			res[key] = m[value]
		} else {
			res[key] = -1
		}
	}
	return res
}
```

## 500.键盘行(4)

- 题目

```
给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。
示例：
输入: ["Hello", "Alaska", "Dad", "Peace"]
输出: ["Alaska", "Dad"]
注意：
    你可以重复使用键盘上同一字符。
    你可以假设输入的字符串将只包含字母。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n^2)     | O(1)       |
| 02   | 哈希辅助 | O(n^2)     | O(1)       |
| 03   | 遍历     | O(n^2)     | O(1)       |
| 04   | 内置函数 | O(n^2)     | O(1)       |

```go
func findWords(words []string) []string {
	m := make(map[byte]int)
	m['q'] = 1
	m['w'] = 1
	m['e'] = 1
	m['r'] = 1
	m['t'] = 1
	m['y'] = 1
	m['u'] = 1
	m['i'] = 1
	m['o'] = 1
	m['p'] = 1
	m['a'] = 2
	m['s'] = 2
	m['d'] = 2
	m['f'] = 2
	m['g'] = 2
	m['h'] = 2
	m['j'] = 2
	m['k'] = 2
	m['l'] = 2
	m['z'] = 3
	m['x'] = 3
	m['c'] = 3
	m['v'] = 3
	m['b'] = 3
	m['n'] = 3
	m['m'] = 3

	res := make([]string, 0)
	for i := 0; i < len(words); i++ {
		b := []byte(strings.ToLower(words[i]))
		level := m[b[0]]
		flag := true
		for j := 1; j < len(b); j++ {
			if m[b[j]] != level {
				flag = false
				break
			}
		}
		if flag {
			res = append(res, words[i])
		}
	}
	return res
}

#
var qRow = map[byte]bool{
	'q': true,
	'w': true,
	'e': true,
	'r': true,
	't': true,
	'y': true,
	'u': true,
	'i': true,
	'o': true,
	'p': true,
}

var aRow = map[byte]bool{
	'a': true,
	's': true,
	'd': true,
	'f': true,
	'g': true,
	'h': true,
	'j': true,
	'k': true,
	'l': true,
}

var zRow = map[byte]bool{
	'z': true,
	'x': true,
	'c': true,
	'v': true,
	'b': true,
	'n': true,
	'm': true,
}

func findWords(words []string) []string {
	res := make([]string, 0, len(words))
	for _, word := range words {
		w := strings.ToLower(word)
		if isAllIn(w, qRow) || isAllIn(w, aRow) || isAllIn(w, zRow) {
			res = append(res, word)
		}
	}
	return res
}

func isAllIn(s string, Row map[byte]bool) bool {
	for i := range s {
		if !Row[s[i]] {
			return false
		}
	}
	return true
}

#
func findWords(words []string) []string {
	res := make([]string, 0, len(words))
	for _, word := range words {
		w := strings.ToLower(word)
		flag := 0
		for _, m := range w {
			switch m {
			case 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p':
				if flag != 0 && flag != 1 {
					flag = 4
					break
				}
				flag = 1
			case 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l':
				if flag != 0 && flag != 2 {
					flag = 4
					break
				}
				flag = 2
			case 'z', 'x', 'c', 'v', 'b', 'n', 'm':
				if flag != 0 && flag != 3 {
					flag = 4
					break
				}
				flag = 3
			default:
				flag = 4
			}
		}
		if flag != 0 && flag != 4 {
			res = append(res, word)
		}
	}
	return res
}

#
func findWords(words []string) []string {
	res := make([]string, 0, len(words))
	q := "qwertyuiopQWERTYUIOP"
	a := "asdfghjklASDFGHJKL"
	z := "zxcvbnmZXCVBNM"
	for _, word := range words {
		qLen, aLen, zLen := 0, 0, 0
		for i := 0; i < len(word); i++ {
			if strings.Contains(q, string(word[i])) {
				qLen++
			}
			if strings.Contains(a, string(word[i])) {
				aLen++
			}
			if strings.Contains(z, string(word[i])) {
				zLen++
			}
		}
		if qLen == len(word) || aLen == len(word) || zLen == len(word) {
			res = append(res, word)
		}
	}
	return res
}
```

# 0401-0500-Medium

## 402.移掉K位数字(1)

- 题目

```
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
注意:num 的长度小于 10002 且 ≥ k。
    num 不会包含任何前导零。
示例 1 :输入: num = "1432219", k = 3 输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
示例 2 :输入: num = "10200", k = 1 输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
示例 3 :输入: num = "10", k = 2 输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 单调栈-贪心 | O(n)       | O(n)       |

```go
func removeKdigits(num string, k int) string {
	stack := make([]byte, 0)
	res := ""
	for i := 0; i < len(num); i++ {
		value := num[i]
		// 栈顶元素打大于后面的元素，摘除栈顶元素（因为前面的更大，需要删除了才能变的最小）
		for len(stack) > 0 && stack[len(stack)-1] > value && k > 0 {
			stack = stack[:len(stack)-1]
			k--
		}
		stack = append(stack, value)
	}
	stack = stack[:len(stack)-k]
	res = strings.TrimLeft(string(stack), "0")
	if res == "" {
		return "0"
	}
	return res
}
```

## 406.根据身高重建队列(2)

- 题目

```
假设有打乱顺序的一群人站成一个队列。 
每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 
编写一个算法来重建这个队列。
注意： 总人数少于1100人。
示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(n^2)     | O(n)       |
| 02   | 排序遍历 | O(n^2)     | O(n)       |

```go
func reconstructQueue(people [][]int) [][]int {
	sort.Slice(people, func(i, j int) bool {
		if people[i][0] == people[j][0] {
			return people[i][1] < people[j][1] // k 递增
		}
		return people[i][0] > people[j][0] // 升高 递减
	})
	for i := 0; i < len(people); i++ {
		index := people[i][1]
		p := people[i]
		copy(people[index+1:i+1], people[index:i+1]) // 后移
		people[index] = p
	}
	return people
}

# 2
func reconstructQueue(people [][]int) [][]int {
	sort.Slice(people, func(i, j int) bool {
		if people[i][0] == people[j][0] {
			return people[i][1] < people[j][1] // k 递增
		}
		return people[i][0] > people[j][0] // 升高 递减
	})
	for i := 0; i < len(people); i++ {
		index := people[i][1]
		p := people[i]
		// copy(people[index+1:i+1], people[index:i+1]) // 后移
		for j := i; j > index; j-- {
			people[j] = people[j-1]
		}
		people[index] = p
	}
	return people
}
```

## 416.分割等和子集(3)

- 题目

```
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:每个数组中的元素不会超过 100
    数组的大小不会超过 200
示例 1:输入: [1, 5, 11, 5] 输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
示例 2:输入: [1, 2, 3, 5] 输出: false 
解释: 数组不能分割成两个元素和相等的子集.
```

- 解题思路

| No.  | 思路      | 时间复杂度 | 空间复杂度 |
| ---- | --------- | ---------- | ---------- |
| 01   | 动态规划  | O(n^2)     | O(n^2)     |
| 02   | 动态规划  | O(n^2)     | O(n)       |
| 03   | 回溯-递归 | O(n!)      | O(n)       |

```go
func canPartition(nums []int) bool {
	sum := 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	if sum%2 == 1 {
		return false
	}
	target := sum / 2
	// 题目转换为0-1背包问题，容量为sum/2
	dp := make([][]bool, len(nums)+1)
	for i := 0; i <= len(nums); i++ {
		dp[i] = make([]bool, target+1)
		dp[i][0] = true
	}
	for i := 1; i <= len(nums); i++ {
		for j := 1; j <= target; j++ {
			if j-nums[i-1] < 0 {
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]
			}
		}
	}
	return dp[len(nums)][target]
}

# 2 
func canPartition(nums []int) bool {
	sum := 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	if sum%2 == 1 {
		return false
	}
	target := sum / 2
	// 题目转换为0-1背包问题，容量为sum/2
	dp := make([]bool, target+1)
	dp[0] = true
	for i := 0; i < len(nums); i++ {
		for j := target; j >= 0; j-- {
			if j-nums[i] >= 0 && dp[j-nums[i]] == true {
				dp[j] = true
			}
		}
	}
	return dp[target]
}

# 3
func canPartition(nums []int) bool {
	sort.Ints(nums)
	sum := 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	if sum%2 == 1 {
		return false
	}
	target := sum / 2
	return dfs(nums, target, 0)
}

func dfs(nums []int, target int, index int) bool {
	if target == 0 {
		return true
	}
	for i := index; i < len(nums); i++ {
		if index < i && nums[i] == nums[i-1] {
			continue
		}
		if target-nums[i] < 0 {
			return false
		}
		if dfs(nums, target-nums[i], i+1) == true {
			return true
		}
	}
	return false
}
```

## 429.N叉树的层序遍历(2)

- 题目

```
给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。
例如，给定一个 3叉树 :
返回其层序遍历:
[
     [1],
     [3,2,4],
     [5,6]
]
说明:
    树的深度不会超过 1000。
    树的节点总数不会超过 5000。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 层序遍历 | O(n)       | O(n)       |
| 02   | 递归     | O(n)       | O(n)       |

```go
func levelOrder(root *Node) [][]int {
	res := make([][]int, 0)
	if root == nil {
		return res
	}
	queue := make([]*Node, 0)
	queue = append(queue, root)
	for len(queue) > 0 {
		temp := make([]int, 0)
		length := len(queue)
		for i := 0; i < length; i++ {
			if queue[i] != nil {
				temp = append(temp, queue[i].Val)
				for j := 0; j < len(queue[i].Children); j++ {
					queue = append(queue, queue[i].Children[j])
				}
			}
		}
		res = append(res, temp)
		queue = queue[length:]
	}
	return res
}

# 2
var res [][]int

func levelOrder(root *Node) [][]int {
	res = make([][]int, 0)
	if root == nil {
		return res
	}
	dfs(root, 0)
	return res
}

func dfs(root *Node, level int) {
	if root == nil {
		return
	}
	if len(res) == level {
		res = append(res, make([]int, 0))
	}
	res[level] = append(res[level], root.Val)
	for i := 0; i < len(root.Children); i++ {
		dfs(root.Children[i], level+1)
	}
}
```

## 435.无重叠区间(4)

- 题目

```
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:可以认为区间的终点总是大于它的起点。
    区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:输入: [ [1,2], [1,2], [1,2] ]输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:输入: [ [1,2], [2,3] ] 输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 贪心     | O(nlog(n)) | O(1)       |
| 02   | 贪心     | O(nlog(n)) | O(1)       |
| 03   | 动态规划 | O(n^2)     | O(n)       |
| 04   | 动态规划 | O(n^2)     | O(n)       |

```go
func eraseOverlapIntervals(intervals [][]int) int {
	if len(intervals) == 0 {
		return 0
	}
	// 按照结束时间排序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][1] < intervals[j][1]
	})
	count := 1
	end := intervals[0][1]
	for i := 0; i < len(intervals); i++ {
		node := intervals[i]
		if node[0] >= end {
			end = node[1]
			count++
		}
	}
	return len(intervals) - count
}

# 2
func eraseOverlapIntervals(intervals [][]int) int {
	if len(intervals) == 0 {
		return 0
	}
	// 按照结束时间排序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][1] < intervals[j][1]
	})
	count := 0
	end := intervals[0][1]
	for i := 1; i < len(intervals); i++ {
		node := intervals[i]
		if node[0] >= end {
			end = node[1]
		} else {
			if node[1] < end {
				end = node[1]
			}
			count++
		}
	}
	return count
}

# 3
func eraseOverlapIntervals(intervals [][]int) int {
	if len(intervals) == 0 {
		return 0
	}
	// 按照结束时间排序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][1] < intervals[j][1]
	})
	dp := make([]int, len(intervals))
	dp[0] = 1
	res := 1
	for i := 1; i < len(intervals); i++ {
		count := 0
		for j := i - 1; j >= 0; j-- {
			if intervals[j][1] <= intervals[i][0] {
				count = max(dp[j], count)
			}
		}
		dp[i] = count + 1
		res = max(res, dp[i])
	}
	return len(intervals) - res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 4
func eraseOverlapIntervals(intervals [][]int) int {
	if len(intervals) == 0 {
		return 0
	}
	// 按照结束时间排序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][1] < intervals[j][1]
	})
	dp := make([]int, len(intervals))
	dp[0] = 1
	res := 1
	for i := 1; i < len(intervals); i++ {
		count := 0
		for j := i - 1; j >= 0; j-- {
			if intervals[j][1] <= intervals[i][0] {
				count = max(dp[j], count)
				break
			}
		}
		dp[i] = max(dp[i-1], count+1)
		res = max(res, dp[i])
	}
	return len(intervals) - res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 438.找到字符串中所有字母异位词(2)

- 题目

```
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。
说明：字母异位词指字母相同，但排列不同的字符串。
    不考虑答案输出的顺序。
示例 1:输入: s: "cbaebabacd" p: "abc"输出: [0, 6]
解释:起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
示例 2:输入: s: "abab" p: "ab"输出: [0, 1, 2]
解释:起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 滑动窗口 | O(n)       | O(1)       |
| 02   | 滑动窗口 | O(n)       | O(1)       |

```go
func findAnagrams(s string, p string) []int {
	res := make([]int, 0)
	if len(p) > len(s) {
		return res
	}
	arr1, arr2 := [26]int{}, [26]int{}
	for i := 0; i < len(p); i++ {
		arr1[p[i]-'a']++
		arr2[s[i]-'a']++
	}
	for i := 0; i < len(s)-len(p); i++ {
		if arr1 == arr2 {
			res = append(res, i)
		}
		arr2[s[i]-'a']--
		arr2[s[i+len(p)]-'a']++
	}
	if arr1 == arr2 {
		res = append(res, len(s)-len(p))
	}
	return res
}

# 2
func findAnagrams(s string, p string) []int {
	res := make([]int, 0)
	if len(p) > len(s) {
		return res
	}
	m1, m2 := make(map[byte]int), make(map[byte]int)
	for i := 0; i < len(p); i++ {
		m1[p[i]-'a']++
		m2[s[i]-'a']++
	}
	for i := 0; i < len(s)-len(p); i++ {
		if compare(m1, m2) {
			res = append(res, i)
		}
		m2[s[i]-'a']--
		if m2[s[i]-'a'] == 0 {
			delete(m2, s[i]-'a')
		}
		m2[s[i+len(p)]-'a']++
	}
	if compare(m1, m2) {
		res = append(res, len(s)-len(p))
	}
	return res
}

func compare(m1, m2 map[byte]int) bool {
	if len(m1) != len(m2) {
		return false
	}
	for k := range m1 {
		if m2[k] != m1[k] {
			return false
		}
	}
	return true
}
```

## 442.数组中重复的数据(5)

- 题目

```
给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。
找到所有出现两次的元素。
你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？
示例：输入: [4,3,2,7,8,2,3,1] 输出:[2,3]
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(n)       |
| 02   | 置反     | O(n)       | O(1)       |
| 03   | 置换     | O(n)       | O(1)       |
| 04   | 累加     | O(n)       | O(1)       |
| 05   | 排序     | O(nlog(n)) | O(1)       |

```go
func findDuplicates(nums []int) []int {
	res := make([]int, 0)
	m := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		m[nums[i]]++
	}
	for k, v := range m {
		if v == 2 {
			res = append(res, k)
		}
	}
	return res
}

# 2
func findDuplicates(nums []int) []int {
	res := make([]int, 0)
	for i := 0; i < len(nums); i++ {
		index := abs(nums[i]) - 1
		if nums[index] < 0 {
			res = append(res, abs(nums[i]))
		} else {
			nums[index] = -nums[index]
		}
	}
	return res
}

func abs(a int) int {
	if a >= 0 {
		return a
	}
	return -a
}

# 3
func findDuplicates(nums []int) []int {
	res := make([]int, 0)
	for i := 0; i < len(nums); i++ {
		for nums[nums[i]-1] != nums[i] {
			nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
		}
	}
	for i := 0; i < len(nums); i++ {
		if nums[i]-1 != i {
			res = append(res, nums[i])
		}
	}
	return res
}

# 4
func findDuplicates(nums []int) []int {
	res := make([]int, 0)
	n := len(nums)
	for i := 0; i < n; i++ {
		index := nums[i]%(n+1) - 1
		nums[index] = nums[index] + (n + 1)
	}
	for i := 0; i < n; i++ {
		if nums[i]/(n+1) == 2 {
			res = append(res, i+1)
		}
	}
	return res
}

# 5
func findDuplicates(nums []int) []int {
	if len(nums) == 0 {
		return nil
	}
	sort.Ints(nums)
	res := make([]int, 0)
	prev := nums[0]
	count := 1
	for i := 1; i < len(nums); i++ {
		if prev == nums[i] {
			count++
		} else {
			if count == 2 {
				res = append(res, nums[i-1])
			}
			prev = nums[i]
			count = 1
		}
	}
	if count == 2 {
		res = append(res, nums[len(nums)-1])
	}
	return res
}
```

## 445.两数相加II(3)

- 题目

```
给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。
它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
你可以假设除了数字 0 之外，这两个数字都不会以零开头。
进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。
示例：输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 8 -> 0 -> 7
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 反转遍历 | O(n)       | O(n)       |
| 02   | 栈辅助   | O(n)       | O(n)       |
| 03   | 递归     | O(n)       | O(n)       |

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	l1 = reverse(l1)
	l2 = reverse(l2)
	res := &ListNode{}
	cur := res
	carry := 0
	for l1 != nil || l2 != nil || carry > 0 {
		sum := carry
		if l1 != nil {
			sum += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			sum += l2.Val
			l2 = l2.Next
		}
		carry = sum / 10 // 进位
		cur.Next = &ListNode{Val: sum % 10}
		cur = cur.Next
	}
	return reverse(res.Next)
}

func reverse(head *ListNode) *ListNode {
	var result *ListNode
	var temp *ListNode
	for head != nil {
		temp = head.Next
		head.Next = result
		result = head
		head = temp
	}
	return result
}

# 2
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	stack1 := make([]int, 0)
	stack2 := make([]int, 0)
	for l1 != nil {
		stack1 = append(stack1, l1.Val)
		l1 = l1.Next
	}
	for l2 != nil {
		stack2 = append(stack2, l2.Val)
		l2 = l2.Next
	}
	var res *ListNode
	carry := 0
	for len(stack1) > 0 || len(stack2) > 0 || carry > 0 {
		if len(stack1) > 0 {
			carry = carry + stack1[len(stack1)-1]
			stack1 = stack1[:len(stack1)-1]
		}
		if len(stack2) > 0 {
			carry = carry + stack2[len(stack2)-1]
			stack2 = stack2[:len(stack2)-1]
		}
		temp := &ListNode{
			Val:  carry % 10,
			Next: res,
		}
		carry = carry / 10
		res = temp
	}
	return res
}

# 3
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	a, b := l1, l2
	length1, length2 := 0, 0
	for a != nil {
		length1++
		a = a.Next
	}
	for b != nil {
		length2++
		b = b.Next
	}
	res, carry := add(l1, l2, length1, length2)
	if carry > 0 {
		return &ListNode{Val: carry, Next: res}
	}
	return res
}

func add(l1, l2 *ListNode, length1, length2 int) (res *ListNode, carry int) {
	if l1 != nil && l2 != nil {
		if l1.Next == nil && l2.Next == nil {
			val := l1.Val + l2.Val
			carry = val / 10
			res = &ListNode{Val: val % 10, Next: nil}
			return
		}
	}
	a := &ListNode{}
	var b, n int
	if length1 > length2 {
		a, b = add(l1.Next, l2, length1-1, length2)
		n = l1.Val + b
	} else if length1 < length2 {
		a, b = add(l1, l2.Next, length1, length2-1)
		n = l2.Val + b
	} else {
		a, b = add(l1.Next, l2.Next, length1-1, length2-1)
		n = l1.Val + l2.Val + b
	}
	res = &ListNode{Val: n % 10, Next: a}
	carry = n / 10
	return
}
```

## 449.序列化和反序列化二叉搜索树(2)

- 题目

```
序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，
以便稍后在同一个或另一个计算机环境中重建。
设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 
您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。
编码的字符串应尽可能紧凑。
注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(n)       |
| 02   | 迭代 | O(n)       | O(n)       |

```go
type Codec struct {
	res []string
}

func Constructor() Codec {
	return Codec{}
}

func (this *Codec) serialize(root *TreeNode) string {
	if root == nil {
		return "#"
	}
	return strconv.Itoa(root.Val) + "," + this.serialize(root.Left) + "," + this.serialize(root.Right)
}

func (this *Codec) deserialize(data string) *TreeNode {
	this.res = strings.Split(data, ",")
	return this.dfsDeserialize()
}

func (this *Codec) dfsDeserialize() *TreeNode {
	node := this.res[0]
	this.res = this.res[1:]
	if node == "#" {
		return nil
	}
	value, _ := strconv.Atoi(node)
	return &TreeNode{
		Val:   value,
		Left:  this.dfsDeserialize(),
		Right: this.dfsDeserialize(),
	}
}

# 2
type Codec struct {
	res []string
}

func Constructor() Codec {
	return Codec{}
}

func (this *Codec) serialize(root *TreeNode) string {
	if root == nil {
		return ""
	}
	res := make([]string, 0)
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		if node != nil {
			res = append(res, strconv.Itoa(node.Val))
			queue = append(queue, node.Left, node.Right)
		} else {
			res = append(res, "#")
		}
	}
	return strings.Join(res, ",")
}

func (this *Codec) deserialize(data string) *TreeNode {
	if len(data) == 0 || data == "" {
		return nil
	}
	res := strings.Split(data, ",")
	root := &TreeNode{}
	root.Val, _ = strconv.Atoi(res[0])
	res = res[1:]
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) > 0 {
		if res[0] != "#" {
			left, _ := strconv.Atoi(res[0])
			queue[0].Left = &TreeNode{Val: left}
			queue = append(queue, queue[0].Left)
		}
		if res[1] != "#" {
			right, _ := strconv.Atoi(res[1])
			queue[0].Right = &TreeNode{Val: right}
			queue = append(queue, queue[0].Right)
		}
		queue = queue[1:]
		res = res[2:]
	}
	return root
}
```

## 450.删除二叉搜索树中的节点(2)

- 题目

```
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，
并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：
    首先找到需要删除的节点；
    如果找到了，删除它。
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。
示例:root = [5,3,6,2,4,null,7] key = 3
    5
   / \
  3   6
 / \   \
2   4   7
给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
    5
   / \
  4   6
 /     \
2       7
另一个正确答案是 [5,2,6,null,4,null,7]。
    5
   / \
  2   6
   \   \
    4   7
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(log(n))  | O(log(n))  |
| 02   | 递归 | O(log(n))  | O(log(n))  |

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}
	if key < root.Val {
		root.Left = deleteNode(root.Left, key)
	} else if key > root.Val {
		root.Right = deleteNode(root.Right, key)
	} else {
		if root.Left == nil {
			return root.Right
		}
		if root.Right == nil {
			return root.Left
		}
		// 找到右节点的最小值，把左节点给最小值
		minNode := root.Right
		for minNode.Left != nil {
			minNode = minNode.Left
		}
		minNode.Left = root.Left
		root = root.Right
	}
	return root
}

# 2
func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}
	if key < root.Val {
		root.Left = deleteNode(root.Left, key)
	} else if key > root.Val {
		root.Right = deleteNode(root.Right, key)
	} else {
		if root.Left == nil {
			return root.Right
		}
		if root.Right == nil {
			return root.Left
		}
		// 找到左节点的最大值，把右节点给最大值
		maxNode := root.Left
		for maxNode.Right != nil {
			maxNode = maxNode.Right
		}
		maxNode.Right = root.Right
		root = root.Left
	}
	return root
}
```

## 451.根据字符出现频率排序(2)

- 题目

```
给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1:输入:"tree"输出:"eert"
解释:'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
示例 2:输入:"cccaaa"输出:"cccaaa"
解释:'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
示例 3:输入:"Aabb"输出:"bbAa"
解释:此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(nlog(n)) | O(n)       |
| 02   | 堆辅助   | O(nlog(n)) | O(n)       |

```go
func frequencySort(s string) string {
	m := make(map[int]int)
	for i := 0; i < len(s); i++ {
		m[int(s[i])]++
	}
	arr := make([][2]int, 0)
	for k, v := range m {
		arr = append(arr, [2]int{k, v})
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i][1] > arr[j][1]
	})
	res := ""
	for i := range arr {
		for j := 0; j < arr[i][1]; j++ {
			res = res + string(arr[i][0])
		}
	}
	return res
}

# 2
func frequencySort(s string) string {
	m := make(map[byte]string)
	for i := 0; i < len(s); i++ {
		m[s[i]] = m[s[i]] + string(s[i])
	}
	var h HeapString
	heap.Init(&h)
	for _, v := range m {
		heap.Push(&h, v)
	}
	res := ""
	for h.Len() > 0 {
		str := heap.Pop(&h).(string)
		res = res + str
	}
	return res
}

type HeapString []string

func (h HeapString) Len() int {
	return len(h)
}

func (h HeapString) Less(i int, j int) bool {
	return len(h[i]) >= len(h[j])
}

func (h HeapString) Swap(i int, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *HeapString) Push(x interface{}) {
	*h = append(*h, x.(string))
}

func (h *HeapString) Pop() interface{} {
	n := len(*h)
	val := (*h)[n-1]
	*h = (*h)[:n-1]
	return val
}
```

## 454.四数相加II(2)

- 题目

```
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，
使得 A[i] + B[j] + C[k] + D[l] = 0。
为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。
所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
例如:输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
输出:2
解释:两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n^2)     | O(n^2)     |
| 02   | 哈希辅助 | O(n^2)     | O(n^2)     |

```go
func fourSumCount(A []int, B []int, C []int, D []int) int {
	res := 0
	m := make(map[int]int)
	for _, a := range A {
		for _, b := range B {
			m[a+b]++
		}
	}
	for _, c := range C {
		for _, d := range D {
			res = res + m[0-c-d]
		}
	}
	return res
}

# 2
func fourSumCount(A []int, B []int, C []int, D []int) int {
	res := 0
	mA := make(map[int]int)
	mB := make(map[int]int)
	for _, a := range A {
		for _, b := range B {
			mA[a+b]++
		}
	}
	for _, c := range C {
		for _, d := range D {
			mB[c+d]++
		}
	}
	for k, v := range mA {
		res = res + v*mB[-k]
	}
	return res
}
```

## 457.环形数组循环

### 题目

```
给定一个含有正整数和负整数的环形数组 nums。 如果某个索引中的数 k 为正数，则向前移动 k 个索引。
相反，如果是负数 (-k)，则向后移动 k 个索引。
因为数组是环形的，所以可以假设最后一个元素的下一个元素是第一个元素，而第一个元素的前一个元素是最后一个元素。
确定 nums 中是否存在循环（或周期）。循环必须在相同的索引处开始和结束并且循环长度 > 1。
此外，一个循环中的所有运动都必须沿着同一方向进行。换句话说，一个循环中不能同时包括向前的运动和向后的运动。
示例 1：输入：[2,-1,1,2,2] 输出：true
解释：存在循环，按索引 0 -> 2 -> 3 -> 0 。循环长度为 3 。
示例 2：输入：[-1,2] 输出：false
解释：按索引 1 -> 1 -> 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。
示例 3:输入：[-2,1,-1,-2,-2] 输出：false
解释：按索引 1 -> 2 -> 1 -> ... 的运动无法构成循环，因为按索引 1 -> 2 的运动是向前的运动，
而按索引 2 -> 1 的运动是向后的运动。一个循环中的所有运动都必须沿着同一方向进行。
提示：-1000 ≤ nums[i] ≤ 1000
    nums[i] ≠ 0
    0 ≤ nums.length ≤ 5000
进阶：你能写出时间时间复杂度为 O(n) 和额外空间复杂度为 O(1) 的算法吗？
```

### 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(2^n)     | O(n)       |

```go

```

## 486.预测赢家(3)

- 题目

```
给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，
随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。
每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。
最终获得分数总和最多的玩家获胜。
给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。
示例 1：输入：[1, 5, 2] 输出：False
解释：一开始，玩家1可以从1和2中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。
如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False 。
示例 2：输入：[1, 5, 233, 7] 输出：True
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。
无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。
提示：1 <= 给定的数组长度 <= 20.
    数组里所有分数都为非负数且不会大于 10000000 。
    如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 递归          | O(2^n)     | O(n)       |
| 02   | 动态规划-一维 | O(n^2)     | O(n)       |
| 03   | 动态规划-二维 | O(n^2)     | O(n^2)     |

```go
func PredictTheWinner(nums []int) bool {
	return dfs(nums, 0, len(nums)-1) >= 0
}

func dfs(nums []int, start, end int) int {
	if start > end {
		return 0
	}
	// 玩家得分：自己得分-对手得分
	left := nums[start] - dfs(nums, start+1, end)
	right := nums[end] - dfs(nums, start, end-1)
	return max(left, right)

}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func PredictTheWinner(nums []int) bool {
	dp := make([]int, len(nums))
	for i := 0; i < len(nums); i++ {
		dp[i] = nums[i]
	}
	for i := len(nums) - 2; i >= 0; i-- {
		for j := i + 1; j < len(nums); j++ {
			dp[j] = max(nums[i]-dp[j], nums[j]-dp[j-1])
		}
	}
	return dp[len(nums)-1] >= 0
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func PredictTheWinner(nums []int) bool {
	n := len(nums)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, n)
		dp[i][i] = nums[i]
	}
	for i := n - 2; i >= 0; i-- {
		for j := i + 1; j < n; j++ {
			// 玩家得分：自己得分-对手得分
			dp[i][j] = max(nums[i]-dp[i+1][j], nums[j]-dp[i][j-1])
		}
	}
	return dp[0][n-1] >= 0
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 491.递增子序列(2)

- 题目

```
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
示例:输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
说明:给定数组的长度不会超过15。
    数组中的整数范围是 [-100,100]。
    给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 深度优先搜索-回溯 | O(2^n)     | O(2^n)     |
| 02   | 深度优先搜索-回溯 | O(2^n)     | O(2^n)     |

```go
var res [][]int

func findSubsequences(nums []int) [][]int {
	res = make([][]int, 0)
	dfs(nums, 0, math.MinInt32, make([]int, 0))
	return res
}

func dfs(nums []int, index int, prev int, arr []int) {
	if index == len(nums) {
		if len(arr) >= 2 {
			temp := make([]int, len(arr))
			copy(temp, arr)
			res = append(res, temp)
		}
		return
	}
	if prev <= nums[index] {
		arr = append(arr, nums[index])
		dfs(nums, index+1, nums[index], arr)
		arr = arr[:len(arr)-1]
	}
	if prev != nums[index] {
		dfs(nums, index+1, prev, arr)
	}
}

# 2
var res [][]int

func findSubsequences(nums []int) [][]int {
	res = make([][]int, 0)
	dfs(nums, 0, make([]int, 0))
	return res
}

func dfs(nums []int, index int, arr []int) {
	if len(arr) >= 2 {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
	}
	m := make(map[int]bool)
	for i := index; i < len(nums); i++ {
		if m[nums[i]] == true || (len(arr) > 0 && nums[i] < arr[len(arr)-1]) {
			continue
		}
		m[nums[i]] = true
		dfs(nums, i+1, append(arr, nums[i]))
	}
}
```

## 494.目标和(5)

- 题目

```
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。
对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
示例：输入：nums: [1, 1, 1, 1, 1], S: 3 输出：5
解释：
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
一共有5种方法让最终目标和为3。
提示：数组非空，且长度不会超过 20 。
    初始的数组的和不会超过 1000 。
    保证返回的最终结果能被 32 位整数存下。
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 递归            | O(2^n)     | O(n)       |
| 02   | 动态规划        | O(2^n)     | O(n)       |
| 03   | 回溯            | O(2^n)     | O(n)       |
| 04   | 动态规划-01背包 | O(n^2)     | O(n)       |
| 05   | 动态规划        | O(n^2)     | O(n^2)     |

```go
func findTargetSumWays(nums []int, S int) int {
	if len(nums) == 0 {
		return 0
	}
	if len(nums) == 1 {
		if nums[0] == 0 && S == 0 {
			return 2
		}
		if nums[0] == S || nums[0] == -S {
			return 1
		}
	}
	value := nums[0]
	nums = nums[1:]
	return findTargetSumWays(nums, S-value) + findTargetSumWays(nums, S+value)
}

# 2
func findTargetSumWays(nums []int, S int) int {
	dp := make(map[int]int)
	dp[nums[0]]++
	dp[-nums[0]]++
	for i := 1; i < len(nums); i++ {
		temp := make(map[int]int)
		for k, v := range dp {
			temp[k-nums[i]] = temp[k-nums[i]] + v
			temp[k+nums[i]] = temp[k+nums[i]] + v
		}
		dp = temp
	}
	return dp[S]
}

# 3
var res int

func findTargetSumWays(nums []int, S int) int {
	res = 0
	dfs(nums, 0, S)
	return res
}

func dfs(nums []int, index int, target int) {
	if index == len(nums) {
		if target == 0 {
			res++
		}
		return
	}
	target = target + nums[index]
	dfs(nums, index+1, target)
	target = target - nums[index]
	//
	target = target - nums[index]
	dfs(nums, index+1, target)
	target = target + nums[index]
}

# 4
func findTargetSumWays(nums []int, S int) int {
	sum := 0
	// 非负整数数组
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	if sum < int(math.Abs(float64(S))) || (sum+S)%2 == 1 {
		return 0
	}
	// 一个正数x,一个负数背包y => x+y=sum, x-y=S => (sum+S)/2=x
	target := (sum + S) / 2
	dp := make([]int, target+1)
	dp[0] = 1
	for i := 1; i <= len(nums); i++ {
        // 从后往前，避免覆盖
		for j := target; j >= 0; j-- {
			if j >= nums[i-1] {
				// 背包足够大，都选
				dp[j] = dp[j] + dp[j-nums[i-1]]
			} else {
				// 容量不够，不选
				dp[j] = dp[j]
			}
		}
	}
	return dp[target]
}

# 5
func findTargetSumWays(nums []int, S int) int {
	sum := 0
	// 非负整数数组
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	if sum < int(math.Abs(float64(S))) || (sum+S)%2 == 1 {
		return 0
	}
	// 一个正数x,一个负数背包y => x+y=sum, x-y=S => (sum+S)/2=x
	target := (sum + S) / 2
	// 在前i个物品中选择，若当前背包的容量为j，则最多有x种方法可以恰好装满背包。
	dp := make([][]int, len(nums)+1)
	for i := 0; i <= len(nums); i++ {
		dp[i] = make([]int, target+1)
		dp[i][0] = 1 // 容量为0， 只有都不选
	}
	for i := 1; i <= len(nums); i++ {
		for j := 0; j <= target; j++ {
			if j >= nums[i-1] {
				// 背包足够大，都选
				dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]
			} else {
				// 容量不够，不选
				dp[i][j] = dp[i-1][j]
			}
		}
	}
	return dp[len(nums)][target]
}
```

## 495.提莫攻击(1)

- 题目

```
在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，
他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。
现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。
你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。
示例1:输入: [1,4], 2 输出: 4
原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。 所以最终输出 4 秒。
示例2:输入: [1,2], 2 输出: 3
原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。
由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。 所以最终输出 3 。
提示：你可以假定时间序列数组的总长度不超过 10000。
    你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
func findPoisonedDuration(timeSeries []int, duration int) int {
	res := 0
	if len(timeSeries) == 0 {
		return 0
	}
	for i := 0; i < len(timeSeries)-1; i++ {
		res = res + min(timeSeries[i+1]-timeSeries[i], duration)
	}
	return res + duration
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
```

## 498.对角线遍历(2)

- 题目

```
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，
对角线遍历如下图所示。
示例:
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出:  [1,2,4,7,5,3,6,8,9]
说明:给定矩阵中的元素总数不会超过 100000 。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n^2)     | O(n^2)     |
| 02   | 遍历 | O(n^2)     | O(n^2)     |

```go
func findDiagonalOrder(matrix [][]int) []int {
	res := make([]int, 0)
	if len(matrix) == 0 {
		return res
	}
	n, m := len(matrix), len(matrix[0])
	if n == 1 {
		return matrix[0]
	}
	i, j := 0, 0
	flag := false
	for j < m {
		a, b := i, j
		temp := make([]int, 0)
		temp = append(temp, matrix[a][b])
		// 从左下往右上
		for a != 0 && b != m-1 {
			a--
			b++
			temp = append(temp, matrix[a][b])
		}
		if flag == true {
			reverse(temp)
			flag = false
		} else {
			flag = true
		}
		res = append(res, temp...)
		if i != n-1 {
			i++
		} else {
			j++
		}
	}
	return res
}

func reverse(arr []int) {
	for i := 0; i < len(arr)/2; i++ {
		arr[i], arr[len(arr)-1-i] = arr[len(arr)-1-i], arr[i]
	}
}

# 2
func findDiagonalOrder(matrix [][]int) []int {
	res := make([]int, 0)
	if len(matrix) == 0 {
		return res
	}
	n, m := len(matrix), len(matrix[0])
	if n == 1 {
		return matrix[0]
	}
	// 右边拼接一个相同的，依次遍历
	for i := 0; i < n+m-1; i++ {
		temp := make([]int, 0)
		var a, b int
		if i < m {
			a = 0
			b = i
		} else {
			a = i - m + 1
			b = m - 1
		}
		for a < n && b >= 0 {
			temp = append(temp, matrix[a][b])
			a, b = a+1, b-1
		}
		if i%2 == 0 {
			reverse(temp)
		}
		res = append(res, temp...)
	}
	return res
}

func reverse(arr []int) {
	for i := 0; i < len(arr)/2; i++ {
		arr[i], arr[len(arr)-1-i] = arr[len(arr)-1-i], arr[i]
	}
}
```

# 0401-0500-Hard

## 410.分割数组的最大值(3)

- 题目

```
给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。
设计一个算法使得这 m 个子数组各自和的最大值最小。
注意:数组长度 n 满足以下条件:
    1 ≤ n ≤ 1000
    1 ≤ m ≤ min(50, n)
示例:输入: nums = [7,2,5,10,8] m = 2输出:18
解释:一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 二分查找        | O(nlog(n)) | O(1)       |
| 02   | 动态规划+前缀和 | O(n^3)     | O(n^2)     |
| 03   | 二分查找        | O(nlog(n)) | O(1)       |

```go
func splitArray(nums []int, m int) int {
	left, right := 0, 0 // 最小值，最大值
	for i := 0; i < len(nums); i++ {
		right = right + nums[i]
		if left < nums[i] {
			left = nums[i]
		}
	}
	for left < right {
		mid := left + (right-left)/2
		// 继续尝试
		if check(nums, mid, m) {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

// 区间和的最大值为target时，所得出的区间数
func check(arr []int, target int, m int) bool {
	sum := 0
	count := 1
	for i := 0; i < len(arr); i++ {
		// 当sum加上当前值超过了target
		// 我们就把当前取的值作为新的一段分割子数组的开头，并将count加1
		if sum+arr[i] > target {
			count++
			sum = arr[i]
		} else {
			sum = sum + arr[i]
		}
	}
	return count <= m
}

# 2
func splitArray(nums []int, m int) int {
	n := len(nums)
	dp := make([][]int, n+1)
	sub := make([]int, n+1)
	for i := 0; i < n+1; i++ {
		dp[i] = make([]int, m+1)
		for j := 0; j < m+1; j++ {
			dp[i][j] = math.MaxInt32
		}
	}
	for i := 0; i < n; i++ {
		sub[i+1] = sub[i] + nums[i]
	}
	// dp[i][j]表示前i个数字被分割成j段的结果
	// 0<=k<i枚举所有可以被分成j-1段的情况
	// 前 k个数被分割为j−1段，而第 k+1到第i个数为第j段
	// dp[i][j] = min{max(dp[k][j-1], sum(k+1, i))}
	dp[0][0] = 0
	for i := 1; i <= n; i++ {
		// 分成m段，可能不够分，最多分min(i,m)
		for j := 1; j <= min(i, m); j++ {
			for k := 0; k < i; k++ {
				dp[i][j] = min(dp[i][j], max(dp[k][j-1], sub[i]-sub[k]))
			}
		}
	}
	return dp[n][m]
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func splitArray(nums []int, m int) int {
	left, right := 0, 0 // 最小值，最大值
	for i := 0; i < len(nums); i++ {
		right = right + nums[i]
		if left < nums[i] {
			left = nums[i]
		}
	}
	for left < right {
		mid := left + (right-left)/2
		// 分割数太多，继续尝试
		if check(nums, mid, m) > m {
			left = mid + 1
		} else {
			right = mid
		}
	}
	return left
}

// 区间和的最大值为target时，所得出的区间数
func check(arr []int, target int, m int) int {
	sum := 0
	count := 1
	for i := 0; i < len(arr); i++ {
		// 当sum加上当前值超过了target
		// 我们就把当前取的值作为新的一段分割子数组的开头，并将count加1
		if sum+arr[i] > target {
			count++
			sum = 0
		}
		sum = sum + arr[i]
	}
	return count
}
```

## 460.LFU缓存

### 题目

```
请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。
    get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
    put(key, value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。
    当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。
    在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。
「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。
进阶：你是否可以在 O(1) 时间复杂度内执行两项操作？
示例：LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回 1
cache.put(3, 3);    // 去除 key 2
cache.get(2);       // 返回 -1 (未找到key 2)
cache.get(3);       // 返回 3
cache.put(4, 4);    // 去除 key 1
cache.get(1);       // 返回 -1 (未找到 key 1)
cache.get(3);       // 返回 3
cache.get(4);       // 返回 4
```

### 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 反转遍历 | O(n)       | O(n)       |

```go

```

