

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>0501-0600-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="0601-0700-Easy" href="0601-0700.html" />
    <link rel="prev" title="0401-0500-Easy" href="0401-0500.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">0501-0600-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">501.二叉搜索树中的众数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">504.七进制数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">506.相对名次(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">507.完美数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">509.斐波那契数(6)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">520.检测大写字母(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i-1">521.最长特殊序列Ⅰ(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">530.二叉搜索树的最小绝对差(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-diff-3">532.数组中的K-diff数对(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">538.把二叉搜索树转换为累加树(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-2">541.反转字符串II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">543.二叉树的直径(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i-2">551.学生出勤记录 I(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iii-2">557.反转字符串中的单词 III(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#n-2">559.N叉树的最大深度(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">561.数组拆分 I(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">563.二叉树的坡度(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">566.重塑矩阵(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">572.另一个树的子树(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">575.分糖果(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">581.最短无序连续子数组(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">589.N叉树的前序遍历(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">590.N叉树的后序遍历(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">594.最长和谐子序列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-1">598.范围求和 II(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19">599.两个列表的最小索引总和(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">0501-0600-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id20">503.下一个更大元素II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">508.出现次数最多的子树元素和(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">513.找树左下角的值(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">515.在每个树行中找最大值(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">516.最长回文子序列(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">518.零钱兑换II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">519.随机翻转矩阵(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-3">522.最长特殊序列II(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">523.连续的子数组和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">525.连续数组(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">526.优美的排列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">529.扫雷游戏(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">537.复数乘法(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">539.最小时间差(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">540.有序数组中的单一元素(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">542.01矩阵(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">547.朋友圈(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">554.砖墙(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-4">560.和为K的子数组(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">565.数组嵌套(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">567.字符串的排列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">576.出界的路径数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id40">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id41">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id42">583.两个字符串的删除操作(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43">593.有效的正方形(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">0501-0600-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ipo-2">502.IPO(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">514.自由之路(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id45">552.学生出勤记录II(1)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html">Mysql-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#mysql-medium">Mysql-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#mysql-hard">Mysql-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>0501-0600-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/0501-0600.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>0501-0600-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#0501-0600-easy">0501-0600-Easy</a><ul>
<li><a class="reference external" href="#501%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B02">501.二叉搜索树中的众数(2)</a></li>
<li><a class="reference external" href="#504%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B03">504.七进制数(3)</a></li>
<li><a class="reference external" href="#506%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A11">506.相对名次(1)</a></li>
<li><a class="reference external" href="#507%E5%AE%8C%E7%BE%8E%E6%95%B01">507.完美数(1)</a></li>
<li><a class="reference external" href="#509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B06">509.斐波那契数(6)</a></li>
<li><a class="reference external" href="#520%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D2">520.检测大写字母(2)</a></li>
<li><a class="reference external" href="#521%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%E2%85%B01">521.最长特殊序列Ⅰ(1)</a></li>
<li><a class="reference external" href="#530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE3">530.二叉搜索树的最小绝对差(3)</a></li>
<li><a class="reference external" href="#532%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84k-diff%E6%95%B0%E5%AF%B93">532.数组中的K-diff数对(3)</a></li>
<li><a class="reference external" href="#538%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%912">538.把二叉搜索树转换为累加树(2)</a></li>
<li><a class="reference external" href="#541%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2ii2">541.反转字符串II(2)</a></li>
<li><a class="reference external" href="#543%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%842">543.二叉树的直径(2)</a></li>
<li><a class="reference external" href="#551%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-i2">551.学生出勤记录 I(2)</a></li>
<li><a class="reference external" href="#557%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii2">557.反转字符串中的单词 III(2)</a></li>
<li><a class="reference external" href="#559n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A62">559.N叉树的最大深度(2)</a></li>
<li><a class="reference external" href="#561%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-i2">561.数组拆分 I(2)</a></li>
<li><a class="reference external" href="#563%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A62">563.二叉树的坡度(2)</a></li>
<li><a class="reference external" href="#566%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B52">566.重塑矩阵(2)</a></li>
<li><a class="reference external" href="#572%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%913">572.另一个树的子树(3)</a></li>
<li><a class="reference external" href="#575%E5%88%86%E7%B3%96%E6%9E%9C2">575.分糖果(2)</a></li>
<li><a class="reference external" href="#581%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%843">581.最短无序连续子数组(3)</a></li>
<li><a class="reference external" href="#589n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%862">589.N叉树的前序遍历(2)</a></li>
<li><a class="reference external" href="#590n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%862">590.N叉树的后序遍历(2)</a></li>
<li><a class="reference external" href="#594%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%972">594.最长和谐子序列(2)</a></li>
<li><a class="reference external" href="#598%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-ii1">598.范围求和 II(1)</a></li>
<li><a class="reference external" href="#599%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C2">599.两个列表的最小索引总和(2)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0501-0600-medium">0501-0600-Medium</a><ul>
<li><a class="reference external" href="#516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%973">516.最长回文子序列(3)</a></li>
<li><a class="reference external" href="#518%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii2">518.零钱兑换II(2)</a></li>
<li><a class="reference external" href="#523%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C2">523.连续的子数组和(2)</a></li>
<li><a class="reference external" href="#54201%E7%9F%A9%E9%98%B53">542.01矩阵(3)</a></li>
<li><a class="reference external" href="#560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%844">560.和为K的子数组(4)</a></li>
<li><a class="reference external" href="#567%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%972">567.字符串的排列(2)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0501-0600-hard">0501-0600-Hard</a><ul>
<li><a class="reference external" href="#502ipo">502.IPO</a><ul>
<li><a class="reference external" href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a class="reference external" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="section" id="id1">
<h2>501.二叉搜索树中的众数(2)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：
    结点左子树中所含结点的值小于等于当前结点的值
    结点右子树中所含结点的值大于等于当前结点的值
    左子树和右子树都是二叉搜索树
例如：
给定 BST [1,null,2,2],
   1
    \
     2
    /
   2
返回[2].
提示：如果众数超过1个，不需考虑输出顺序
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归+哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归+中序遍历</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findMode(root *TreeNode) []int {
	m := map[int]int{}
	dfs(root, m)
	max := -1
	res := make([]int, 0)
	for i, v := range m {
		if max &lt;= v {
			if max &lt; v {
				max = v
				res = res[0:0]
			}
			res = append(res, i)
		}
	}
	return res
}

func dfs(root *TreeNode, rec map[int]int) {
	if root == nil {
		return
	}
	rec[root.Val]++
	dfs(root.Left, rec)
	dfs(root.Right, rec)
}

#
var max int
var res []int
var cur int
var count int

func findMode(root *TreeNode) []int {
	res = make([]int, 0)
	max, cur, count = 0, 0, 0
	dfs(root)
	return res
}

// 中序遍历保证利用二叉搜索树的性质，得到的结果是升序的
func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)
	if root.Val != cur {
		count = 0
	}
	count++
	if max &lt; count {
		max = count
		res = []int{root.Val}
	} else if max == count {
		res = append(res, root.Val)
	}
	cur = root.Val
	dfs(root.Right)
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>504.七进制数(3)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数，将其转化为7进制，并以字符串形式输出。
示例 1:输入: 100 输出: &quot;202&quot;
示例 2: 输入: -7 输出: &quot;-10&quot;
注意: 输入范围是 [-1e7, 1e7] 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func convertToBase7(num int) string {
	if num == 0 {
		return &quot;0&quot;
	}

	minus := &quot;&quot;
	if num &lt; 0 {
		minus = &quot;-&quot;
		num = -1 * num
	}

	s := &quot;&quot;
	for num &gt; 0 {
		s = fmt.Sprintf(&quot;%d&quot;, num%7) + s
		num = num / 7
	}
	return minus + s
}

#
func convertToBase7(num int) string {
	return strconv.FormatInt(int64(num), 7)
}

#
func convertToBase7(num int) string {
	if num &lt; 0 {
		return &quot;-&quot; + convertToBase7(-1*num)
	}
	if num &lt; 7 {
		return strconv.Itoa(num)
	}
	return convertToBase7(num/7) + strconv.Itoa(num%7)
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>506.相对名次(1)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。
前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”
（&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;）。
(注：分数越高的选手，排名越靠前。)

示例 1:
输入: [5, 4, 3, 2, 1]
输出: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]
解释: 前三名运动员的成绩为前三高的，
因此将会分别被授予 “金牌”，“银牌”和“铜牌” (&quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;).
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。
提示:
    N 是一个正整数并且不会超过 10000。
    所有运动员的成绩都不相同。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序+遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">findRelativeRanks</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">nums</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="s">&quot;Gold Medal&quot;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="s">&quot;Silver Medal&quot;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="s">&quot;Bronze Medal&quot;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span> <span class="o">-</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>507.完美数(1)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。
给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False
示例：输入: 28 输出: True 解释: 28 = 1 + 2 + 4 + 7 + 14
提示：输入的数字 n 不会超过 100,000,000. (1e8)
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^1/2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">checkPerfectNumber</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">num</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">num</span><span class="o">/</span><span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">num</span><span class="o">%</span><span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="p">(</span><span class="nx">num</span> <span class="o">/</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sum</span> <span class="o">==</span> <span class="nx">num</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>509.斐波那契数(6)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
给定 N，计算 F(N)。
示例 1：输入：2输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：输入：3输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：输入：4输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
提示：
    0 ≤ N ≤ 30
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历+数组</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(2^n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>公式法</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>矩阵快速幂</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>06</td>
<td>矩阵快速幂</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	n1, n2 := 0, 1
	for i := 2; i &lt;= N; i++ {
		n1, n2 = n2, n1+n2
	}
	return n2
}

#
func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	res := make([]int, N+1)
	res[0] = 0
	res[1] = 1
	for i := 2; i &lt;= N; i++ {
		res[i] = res[i-1] + res[i-2]
	}
	return res[N]
}

#
func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	return fib(N-1) + fib(N-2)
}

#
func fib(N int) int {
	temp1 := (1 + math.Sqrt(5)) / 2
	temp2 := (1 - math.Sqrt(5)) / 2
	fn := math.Round((math.Pow(temp1, float64(N))- math.Pow(temp2, float64(N)))/ math.Sqrt(5))
	return int(fn)
}

# 5
func fib(N int) int {
	if N == 0 {
		return 0
	}
	/*
		ans = [Fn+1 Fn
			   Fn Fn-1]
			= [ 1 0
		 		0 1]
	*/
	ans := matrix{
		a: 1,
		b: 0,
		c: 0,
		d: 1,
	}
	m := matrix{
		a: 1,
		b: 1,
		c: 1,
		d: 0,
	}
	for N &gt; 0 {
		if N%2 == 1 {
			ans = multi(ans, m)
		}
		m = multi(m, m)
		N = N &gt;&gt; 1
	}
	return ans.b
}

/*
a b
c d
*/
type matrix struct {
	a, b, c, d int
}

// 矩阵乘法
func multi(x, y matrix) matrix {
	newA := x.a*y.a + x.b*y.c
	newB := x.a*y.b + x.b*y.d
	newC := x.c*y.a + x.d*y.c
	newD := x.c*y.b + x.d*y.d
	return matrix{
		a: newA,
		b: newB,
		c: newC,
		d: newD,
	}
}

# 6
func fib(N int) int {
	if N == 0 {
		return 0
	}
	/*
		ans = [Fn+1 Fn
			   Fn Fn-1]
			= [ 1 0
		 		0 1]
	*/
	ans := matrix{
		a: 1,
		b: 0,
		c: 0,
		d: 1,
	}
	m := matrix{
		a: 1,
		b: 1,
		c: 1,
		d: 0,
	}
	for N &gt; 0 {
		ans = multi(ans, m)
		N--
	}
	return ans.b
}

/*
a b
c d
*/
type matrix struct {
	a, b, c, d int
}

// 矩阵乘法
func multi(x, y matrix) matrix {
	newA := x.a*y.a + x.b*y.c
	newB := x.a*y.b + x.b*y.d
	newC := x.c*y.a + x.d*y.c
	newD := x.c*y.b + x.d*y.d
	return matrix{
		a: newA,
		b: newB,
		c: newC,
		d: newD,
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>520.检测大写字母(2)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个单词，你需要判断单词的大写使用是否正确。
我们定义，在以下情况时，单词的大写用法是正确的：
    全部字母都是大写，比如&quot;USA&quot;。
    单词中所有字母都不是大写，比如&quot;leetcode&quot;。
    如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。
否则，我们定义这个单词没有正确使用大写字母。
示例 1:输入: &quot;USA&quot;输出: True
示例 2:输入: &quot;FlaG&quot;输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>正则</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func detectCapitalUse(word string) bool {
	if word == &quot;&quot; {
		return false
	}
	count := 0
	for i := 0; i &lt; len(word); i++ {
		if word[i] &gt;= &#39;A&#39; &amp;&amp; word[i] &lt;= &#39;Z&#39; {
			count++
		}
	}

	if count == 0 || count == len(word) ||
		(count == 1 &amp;&amp; word[0] &gt;= &#39;A&#39; &amp;&amp; word[0] &lt;= &#39;Z&#39;) {
		return true
	}
	return false
}

#
func detectCapitalUse(word string) bool {
	pattern := &quot;(^[a-z]+)$|(^[A-Z]+)$|(^[A-Z]{1}[a-z]*)$&quot;
	isMatch, _ := regexp.MatchString(pattern, word)
	return isMatch
}
</pre></div>
</div>
</div>
<div class="section" id="i-1">
<h2>521.最长特殊序列Ⅰ(1)<a class="headerlink" href="#i-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。
「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

示例 1：输入: &quot;aba&quot;, &quot;cdc&quot; 输出: 3 
解释: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)，两者均为自身的子序列且不是对方的子序列。
示例 2：输入：a = &quot;aaa&quot;, b = &quot;bbb&quot;输出：3
示例 3：输入：a = &quot;aaa&quot;, b = &quot;aaa&quot;输出：-1
提示：
    两个字符串长度均处于区间 [1 - 100] 。
    字符串中的字符仅含有 &#39;a&#39;~&#39;z&#39; 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>比较</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">findLUSlength</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>530.二叉搜索树的最小绝对差(3)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
示例：
输入：

   1
    \
     3
    /
   2

输出：1
解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
提示：
    树中至少有 2 个节点。
    本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归+中序遍历</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归+遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var minDiff, previous int
func getMinimumDifference(root *TreeNode) int {
	minDiff, previous  = math.MaxInt32, math.MaxInt32
	dfs(root)
	return minDiff
}

func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)

	newDiff := diff(previous, root.Val)
	if minDiff &gt; newDiff {
		minDiff = newDiff
	}
	previous = root.Val
	dfs(root.Right)
}

func diff(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}

#
func getMinimumDifference(root *TreeNode) int {
	arr := make([]int, 0)
	dfs(root, &amp;arr)
	minDiff := arr[1] - arr[0]
	for i := 2; i &lt; len(arr); i++ {
		if minDiff &gt; arr[i]-arr[i-1] {
			minDiff = arr[i] - arr[i-1]
		}
	}
	return minDiff
}

func dfs(root *TreeNode, arr *[]int) {
	if root == nil {
		return
	}
	dfs(root.Left, arr)
	*arr = append(*arr, root.Val)
	dfs(root.Right, arr)
}
</pre></div>
</div>
</div>
<div class="section" id="k-diff-3">
<h2>532.数组中的K-diff数对(3)<a class="headerlink" href="#k-diff-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。
这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.

示例 1: 输入: [3, 1, 4, 1, 5], k = 2 输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
示例 2:输入:[1, 2, 3, 4, 5], k = 1 输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
示例 3:输入: [1, 3, 1, 5, 4], k = 0 输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。
注意:
    数对 (i, j) 和数对 (j, i) 被算作同一数对。
    数组的长度不超过10,000。
    所有输入的整数的范围在 [-1e7, 1e7]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>单哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>双哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findPairs(nums []int, k int) int {
	if k &lt; 0 {
		return 0
	}
	record := make(map[int]int)
	for _, num := range nums {
		record[num]++
	}
	res := 0
	if k == 0 {
		for _, count := range record {
			if count &gt; 1 {
				res++
			}
		}
		return res
	} else {
		for n := range record {
			if record[n-k] &gt; 0 {
				res++
			}
		}
		return res
	}
}

#
func findPairs(nums []int, k int) int {
	if k &lt; 0 {
		return 0
	}
	m := make(map[int]bool)
	res := make(map[int]bool)
	for _, value := range nums {
		if m[value-k] {
			res[value-k] = true
		}
		if m[value+k] {
			res[value] = true
		}
		m[value] = true
	}
	return len(res)
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>538.把二叉搜索树转换为累加树(2)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，
使得每个节点的值是原来的节点值加上所有大于它的节点值之和。
例如：
输入: 原始二叉搜索树:
              5
            /   \
           2     13
输出: 转换为累加树:
             18
            /   \
          20     13
注意：
本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func convertBST(root *TreeNode) *TreeNode {
	sum := 0
	dfs(root, &amp;sum)
	return root
}

func dfs(root *TreeNode, sum *int) {
	if root == nil {
		return
	}
	dfs(root.Right, sum)
	*sum = *sum + root.Val
	root.Val = *sum
	dfs(root.Left, sum)
}

#
func convertBST(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}
	stack := make([]*TreeNode, 0)
	temp := root
	sum := 0
	for {
		if temp != nil {
			stack = append(stack, temp)
			temp = temp.Right
		} else if len(stack) != 0 {
			temp = stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			temp.Val = temp.Val + sum
			sum = temp.Val
			temp = temp.Left
		} else {
			break
		}
	}
	return root
}
</pre></div>
</div>
</div>
<div class="section" id="ii-2">
<h2>541.反转字符串II(2)<a class="headerlink" href="#ii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。
如果剩余少于 k 个字符，则将剩余的所有全部反转。
如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。

示例:
输入: s = &quot;abcdefg&quot;, k = 2
输出: &quot;bacdfeg&quot;
要求:
    该字符串只包含小写的英文字母。
    给定字符串的长度和 k 在[1, 10000]范围内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func reverseStr(s string, k int) string {
	arr := []byte(s)
	for i := 0; i &lt; len(s); i = i + 2*k {
		j := min(i+k, len(s))
		reverse(arr[i:j])
	}
	return string(arr)
}

func reverse(arr []byte) {
	i, j := 0, len(arr)-1
	for i &lt; j {
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
}

func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}

#
func reverseStr(s string, k int) string {
	arr := []byte(s)
	for i := 0; i &lt; len(s); i = i + k {
		if i%(2*k) == 0 {
			j := i + k
			if len(arr) &lt; j {
				j = len(arr)
			}
			reverse(arr[i:j])
		}
	}
	return string(arr)
}

func reverse(arr []byte) {
	i, j := 0, len(arr)-1
	for i &lt; j {
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>543.二叉树的直径(2)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。
这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树
          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res int
func diameterOfBinaryTree(root *TreeNode) int {
	res = 0
	dfs(root)
	return res
}

func dfs(root *TreeNode) int {
	if root == nil {
		return 0
	}
	left := dfs(root.Left)
	right := dfs(root.Right)
	path := max(left, right)
	res = max(left+right, res) // 当前节点最大直径与当前保存最大值比较
	return path + 1 // 以该节点为根的最大深度
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

#
func diameterOfBinaryTree(root *TreeNode) int {
	if root == nil {
		return 0
	}
	max := 0
	stack := make([]*TreeNode, 0)
	m := make(map[*TreeNode]int)

	cur := root
	var prev *TreeNode
	for cur != nil || len(stack) != 0 {
		for cur != nil {
			stack = append(stack, cur)
			cur = cur.Left
		}
		cur = stack[len(stack)-1]
		if cur.Right == nil || cur.Right == prev {
			cur = stack[len(stack)-1]
			stack = stack[:len(stack)-1]

			leftLen := 0
			rightLen := 0
			if v, ok := m[cur.Left]; ok {
				leftLen = v
			}
			if v, ok := m[cur.Right]; ok {
				rightLen = v
			}
			if leftLen &gt; rightLen {
				m[cur] = leftLen + 1
			} else {
				m[cur] = rightLen + 1
			}
			if max &lt; leftLen+rightLen {
				max = leftLen + rightLen
			}
			prev = cur
			cur = nil
		} else {
			cur = cur.Right
		}
	}
	return max
}
</pre></div>
</div>
</div>
<div class="section" id="i-2">
<h2>551.学生出勤记录 I(2)<a class="headerlink" href="#i-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：
    &#39;A&#39; : Absent，缺勤
    &#39;L&#39; : Late，迟到
    &#39;P&#39; : Present，到场
如果一个学生的出勤记录中不超过一个&#39;A&#39;(缺勤)并且不超过两个连续的&#39;L&#39;(迟到),那么这个学生会被奖赏。
你需要根据这个学生的出勤记录判断他是否会被奖赏。

示例 1:输入: &quot;PPALLP&quot;输出: True
示例 2:输入: &quot;PPALLL&quot;输出: False
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func checkRecord(s string) bool {
	if strings.Count(s, &quot;A&quot;) &lt;= 1 &amp;&amp; strings.Count(s, &quot;LLL&quot;) == 0 {
		return true
	}
	return false
}

#
func checkRecord(s string) bool {
	aNum := 0
	lNum := 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;A&#39; {
			aNum++
		}
		if s[i] == &#39;L&#39; {
			lNum++
		} else {
			lNum = 0
		}
		if aNum == 2 {
			return false
		}
		if lNum == 3 {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="iii-2">
<h2>557.反转字符串中的单词 III(2)<a class="headerlink" href="#iii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
示例 1:
输入: &quot;Let&#39;s take LeetCode contest&quot;
输出: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot; 

注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
</pre></div>
</div>
<ul class="simple">
<li>解题思路分析</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
func reverseWords(s string) string {
	strS := strings.Split(s, &quot; &quot;)
	for i, s := range strS {
		strS[i] = reverse(s)
	}
	return strings.Join(strS, &quot; &quot;)
}

func reverse(s string) string {
	arr := []byte(s)
	i, j := 0, len(arr)-1
	for i &lt; j {
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
	return string(arr)
}

#
func reverseWords(s string) string {
	arr := []byte(s)
	j := 0
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == &#39; &#39; {
			reverse(arr, j, i-1)
			j = i + 1
		}
	}
	reverse(arr, j, len(arr)-1)
	return string(arr)
}

func reverse(arr []byte, i, j int) []byte {
	for i &lt; j {
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
	return arr
}
</pre></div>
</div>
</div>
<div class="section" id="n-2">
<h2>559.N叉树的最大深度(2)<a class="headerlink" href="#n-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
例如，给定一个 3叉树 :
我们应返回其最大深度，3。
说明:
    树的深度不会超过 1000。
    树的节点总不会超过 5000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxDepth(root *Node) int {
	if root == nil {
		return 0
	}
	depth := 0
	for _, node := range root.Children {
		depth = max(depth, maxDepth(node))
	}
	return depth + 1
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

#
func maxDepth(root *Node) int {
	if root == nil {
		return 0
	}
	queue := make([]*Node, 0)
	depth := 0
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		length := len(queue)
		for i := 0; i &lt; length; i++ {
			temp := queue[0]
			for _, node := range temp.Children {
				queue = append(queue, node)
			}
			queue = queue[1:]
		}
		depth++
	}
	return depth
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>561.数组拆分 I(2)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，
使得从1 到 n 的 min(ai, bi) 总和最大。

示例 1:输入: [1,4,3,2]输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
提示:
    n 是正整数,范围在 [1, 10000].
    数组中的元素范围在 [-10000, 10000].
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>P</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func arrayPairSum(nums []int) int {
	sort.Ints(nums)
	sum := 0
	for k, v := range nums {
		if k%2 == 0 {
			sum = sum + v
		}
	}
	return sum
}

#
func arrayPairSum(nums []int) int {
	var arr [20010]int
	for _, num := range nums {
		arr[num+10000]++
	}
	sum := 0
	needAdd := true
	for num, count := range arr {
		for count &gt; 0 {
			if needAdd {
				sum = sum + num - 10000
			}
			needAdd = !needAdd
			count--
		}
	}
	return sum
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>563.二叉树的坡度(2)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，计算整个树的坡度。
一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。

示例:

输入: 
         1
       /   \
      2     3
输出: 1
解释: 
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
注意:
    任何子树的结点的和不会超过32位整数的范围。
    坡度的值不会超过32位整数的范围。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var total int

func findTilt(root *TreeNode) int {
	total = 0
	dfs(root)
	return total
}

func dfs(root *TreeNode) int {
	if root == nil {
		return 0
	}
	left := dfs(root.Left)
	right := dfs(root.Right)
	total = total + abs(left, right)
	return left + right + root.Val // 返回节点之和
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}

#
func findTilt(root *TreeNode) int {
	if root == nil {
		return 0
	}
	stack := make([]*TreeNode, 0)
	stack = append(stack, root)
	list := make([]*TreeNode, 0)
	total := 0
	for len(stack) &gt; 0 {
		node := stack[len(stack)-1]
		stack = stack[0 : len(stack)-1]
		list = append([]*TreeNode{node}, list...)
		if node.Left != nil {
			stack = append(stack, node.Left)
		}
		if node.Right != nil {
			stack = append(stack, node.Right)
		}
	}
	for i := range list {
		node := list[i]
		left := 0
		right := 0
		if node.Left != nil {
			left = node.Left.Val
		}
		if node.Right != nil {
			right = node.Right.Val
		}
		total = total + abs(left, right)
		node.Val = left + right + node.Val
	}
	return total
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>566.重塑矩阵(2)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。
给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。
如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

示例 1:输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。

示例 2:输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
注意：
    给定矩阵的宽和高范围在 [1, 100]。
    给定的 r 和 c 都是正数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func matrixReshape(nums [][]int, r int, c int) [][]int {
	row, col := len(nums), len(nums[0])
	if (row*col != r*c) || (row == r &amp;&amp; col == c) {
		return nums
	}
	res := make([][]int, r)
	for i := 0; i &lt; len(res); i++ {
		res[i] = make([]int, c)
	}
	for i := 0; i &lt; r*c; i++ {
		res[i/c][i%c] = nums[i/col][i%col]
	}
	return res
}

#
func matrixReshape(nums [][]int, r int, c int) [][]int {
	row, col := len(nums), len(nums[0])
	if (row*col != r*c) || (row == r &amp;&amp; col == c) {
		return nums
	}
	res := make([][]int, 0)
	arr := make([]int, 0)
	count := 0
	for _, num := range nums {
		for _, value := range num {
			arr = append(arr, value)
			count++
			if count == c {
				res = append(res, arr)
				arr = []int{}
				count = 0
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>572.另一个树的子树(3)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。
s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
示例 1:
给定的树 s:
     3
    / \
   4   5
  / \
 1   2

给定的树 t：
   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：

     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：
   4
  / \
 1   2
返回 false。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归+字符串辅助</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>03</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isSubtree(s *TreeNode, t *TreeNode) bool {
	if s == nil {
		return false
	}
	return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)
}

func isSame(s *TreeNode, t *TreeNode) bool {
	if s == nil || t == nil{
		return t == s
	}
	return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right) &amp;&amp; s.Val == t.Val
}

#
func isSubtree(s *TreeNode, t *TreeNode) bool {
	sStr := dfs(s, &quot;&quot;)
	tStr := dfs(t, &quot;&quot;)
	return strings.Contains(sStr, tStr)
}

func dfs(s *TreeNode, pre string) string {
	if s == nil {
		return pre
	}
	return fmt.Sprintf(&quot;#%d%s%s&quot;, s.Val, dfs(s.Left, &quot;l&quot;), dfs(s.Right, &quot;r&quot;))
}

#
func isSubtree(s *TreeNode, t *TreeNode) bool {
	sStr := preOrder(s)
	tStr := preOrder(t)
	return strings.Contains(sStr, tStr)
}

func preOrder(root *TreeNode) string {
	if root == nil {
		return &quot;&quot;
	}
	res := &quot;!&quot;
	stack := make([]*TreeNode,0)
	temp := root
	for {
		for temp != nil{
			res += strconv.Itoa(temp.Val)
			res += &quot;!&quot;
			stack = append(stack, temp)
			temp = temp.Left
		}
		res += &quot;#!&quot;
		if len(stack) &gt; 0{
			node := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			temp = node.Right
		}else {
			break
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>575.分糖果(2)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。
你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

示例 1:输入: candies = [1,1,2,2,3,3] 输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。
     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。

示例 2 : 输入: candies = [1,1,2,3] 输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。
这样使得妹妹可以获得的糖果种类数最多。

注意:
    数组的长度为[2, 10,000]，并且确定为偶数。
    数组中数字的大小在范围[-100,000, 100,000]内。 
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func distributeCandies(candies []int) int {
	n := len(candies)
	r := make(map[int]bool, n)
	for _, c := range candies {
		r[c] = true
	}
	return min(len(r), n/2)
}

func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}

#
func distributeCandies(candies []int) int {
	length := len(candies)
	half := length / 2
	count := 1
	sort.Ints(candies)
	for i := 1; i &lt; length; i++ {
		if candies[i] != candies[i-1] {
			count++
		}
	}
	if count &gt;= half {
		return half
	}
	return count
}
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>581.最短无序连续子数组(3)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
你找到的子数组应是最短的，请输出它的长度。
示例 1:输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :
    输入的数组长度范围在 [1, 10,000]。
    输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>2次遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findUnsortedSubarray(nums []int) int {
	length := len(nums)
	left, right := 0, -1
	min, max := nums[length-1], nums[0]
	for i := 1; i &lt; length; i++ {
		if max &lt;= nums[i] {
			max = nums[i]
		} else {
			right = i
		}
		j := length - i - 1
		if min &gt;= nums[j] {
			min = nums[j]
		} else {
			left = j
		}
	}
	return right - left + 1
}

#
func findUnsortedSubarray(nums []int) int {
	length := len(nums)
	right := -1
	max := nums[0]
	for i := 1; i &lt; length; i++ {
		if max &lt;= nums[i] {
			max = nums[i]
		} else {
			right = i
		}
	}
	if right == 0 {
		// 针对升序，特殊处理
		// 如去掉判断
		// 需要保证left,right初始值满足right-left+1=0
		return 0
	}
	left := 0
	min := nums[length-1]
	for i := length - 2; i &gt;= 0; i-- {
		if min &gt;= nums[i] {
			min = nums[i]
		} else {
			left = i
		}
	}
	return right - left + 1
}

#
func findUnsortedSubarray(nums []int) int {
	temp := make([]int,len(nums))
	copy(temp,nums)
	sort.Ints(temp)
	i, j := 0, len(nums)-1
	for i &lt; len(nums) &amp;&amp; nums[i] == temp[i]{
		i++
	}
	for i+1 &lt; j &amp;&amp; nums[j] == temp[j]{
		j--
	}
	return j-i+1
}
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>589.N叉树的前序遍历(2)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 N 叉树，返回其节点值的前序遍历。
例如，给定一个 3叉树 :
返回其前序遍历: [1,3,5,6,2,4]。
说明: 递归法很简单，你可以使用迭代法完成此题吗?
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res []int

func preorder(root *Node) []int {
	res = make([]int, 0)
	dfs(root)
	return res
}

func dfs(root *Node) {
	if root == nil {
		return
	}
	res = append(res, root.Val)
	for _, value := range root.Children {
		dfs(value)
	}
}

#
func preorder(root *Node) []int {
	res := make([]int, 0)
	if root == nil {
		return res
	}
	stack := make([]*Node, 0)
	stack = append(stack, root)
	for len(stack) &gt; 0 {
		temp := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		res = append(res, temp.Val)
		for i := len(temp.Children) - 1; i &gt;= 0; i-- {
			stack = append(stack, temp.Children[i])
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>590.N叉树的后序遍历(2)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 N 叉树，返回其节点值的后序遍历。

例如，给定一个 3叉树 :

返回其后序遍历: [5,6,3,2,4,1].
说明: 递归法很简单，你可以使用迭代法完成此题吗?
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res []int
func postorder(root *Node) []int {
	res = make([]int, 0)
	dfs(root)
	return res
}

func dfs(root *Node) {
	if root == nil {
		return
	}
	for _, value := range root.Children {
		dfs(value)
	}
	res = append(res, root.Val)
}

#
// 后序：(左右)根
// 前序：根(左右)=&gt;根(右左)=&gt;左右根
func postorder(root *Node) []int {
	res := make([]int, 0)
	if root == nil {
		return res
	}
	stack := make([]*Node, 0)
	stack = append(stack, root)
	for len(stack) &gt; 0 {
		temp := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		res = append(res, temp.Val)
		for i := 0; i &lt; len(temp.Children); i++ {
			stack = append(stack, temp.Children[i])
		}
	}
	for i := 0; i &lt; len(res)/2; i++ {
		res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>594.最长和谐子序列(2)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。
现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。
示例 1:输入: [1,3,2,2,5,2,3,7]输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
说明: 输入的数组长度最大不超过20,000.
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findLHS(nums []int) int {
	m := make(map[int]int, len(nums))
	for _, n := range nums {
		m[n]++
	}
	res := 0
	for key, value := range m {
		value2, ok := m[key+1]
		if ok {
			t := value + value2
			if res &lt; t {
				res = t
			}
		}
	}
	return res
}

#
func findLHS(nums []int) int {
	sort.Ints(nums)
	res := 0
	left := 0
	for i := 0; i &lt; len(nums); i++ {
		for nums[i]-nums[left] &gt; 1 {
			left++
		}
		if nums[i]-nums[left] == 1 {
			if res &lt; i-left+1 {
				res = i - left + 1
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="ii-1">
<h2>598.范围求和 II(1)<a class="headerlink" href="#ii-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。
操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，
含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。
在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。

示例 1:输入: m = 3, n = 3operations = [[2,2],[3,3]] 输出: 4
解释: 初始状态, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
执行完操作 [2,2] 后, M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]
执行完操作 [3,3] 后, M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
注意:
    m 和 n 的范围是 [1,40000]。
    a 的范围是 [1,m]，b 的范围是 [1,n]。
    操作数目不超过 10000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数学</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxCount</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ops</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ops</span> <span class="p">{</span>
		<span class="nx">m</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">o</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">o</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>599.两个列表的最小索引总和(2)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。
你可以假设总是存在一个答案。

示例 1:输入:
[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]
[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]
输出: [&quot;Shogun&quot;]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。

示例 2:
输入:
[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]
[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]
输出: [&quot;Shogun&quot;]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。

提示:
    两个列表的长度范围都在 [1, 1000]内。
    两个列表中的字符串的长度将在[1，30]的范围内。
    下标从0开始，到列表的长度减1。
    两个列表都没有重复的元素。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>I</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findRestaurant(list1 []string, list2 []string) []string {
	if len(list1) &gt; len(list2) {
		list1, list2 = list2, list1
	}
	m2 := make(map[string]int, len(list2))
	for i := range list2 {
		m2[list2[i]] = i
	}
	min := 2000
	res := make([]string, 0, 1000)
	for key, value := range list1 {
		if key2, ok := m2[value]; ok {
			if min == key+key2 {
				res = append(res, value)
			}
			if min &gt; key+key2 {
				min = key + key2
				res = []string{value}
			}
		}
	}
	return res
}

#
func findRestaurant(list1 []string, list2 []string) []string {
	min := 2000
	res := make([]string, 0, 1000)
	for key1, value1 := range list1 {
		for key2, value2 := range list2{
			if value1 == value2{
				if min == key1+key2 {
					res = append(res, value1)
				}
				if min &gt; key1+key2 {
					min = key1 + key2
					res = []string{value1}
				}
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>0501-0600-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id20">
<h2>503.下一个更大元素II(2)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。
数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，
这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。
示例 1:输入: [1,2,1] 输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
注意: 输入数组的长度不会超过 10000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func nextGreaterElements(nums []int) []int {
	res := make([]int, len(nums))
	if len(nums) == 0 {
		return res
	}
	for i := 0; i &lt; len(nums); i++ {
		res[i] = -1
	}
	stack := make([]int, 0)
	for i := 0; i &lt; len(nums)*2; i++ {
		index := i % len(nums)
		for len(stack) &gt; 0 &amp;&amp; nums[index] &gt; nums[stack[len(stack)-1]] {
			if res[stack[len(stack)-1]] == -1 {
				res[stack[len(stack)-1]] = nums[index]
			}
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, index)
	}
	return res
}

# 2
func nextGreaterElements(nums []int) []int {
	res := make([]int, len(nums))
	if len(nums) == 0 {
		return res
	}
	stack := make([]int, 0)
	for i := 2*len(nums) - 1; i &gt;= 0; i-- {
		index := i % len(nums)
		for len(stack) &gt; 0 &amp;&amp; nums[index] &gt;= stack[len(stack)-1] {
			stack = stack[:len(stack)-1]
		}
		if len(stack) == 0 {
			res[index] = -1
		} else {
			res[index] = stack[len(stack)-1]
		}
		stack = append(stack, nums[index])
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>508.出现次数最多的子树元素和(1)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。
一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。
你需要返回出现次数最多的子树元素和。
如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。
示例 1：输入:
  5
 /  \
2   -3
返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。
示例 2：输入：
  5
 /  \
2   -5
返回 [2]，只有 2 出现两次，-5 只出现 1 次。
提示： 假设任意子树元素和均可以用 32 位有符号整数表示。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">findFrequentTreeSum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
			<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">v</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">k</span><span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">maxValue</span> <span class="o">==</span> <span class="nx">v</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span> <span class="o">+</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">sum</span><span class="p">]</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>513.找树左下角的值(2)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，在树的最后一行找到最左边的值。
示例 1:输入:
    2
   / \
  1   3
输出:1
示例 2:输入:
        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7
输出:7
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>层序遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findBottomLeftValue(root *TreeNode) int {
	res := 0
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		length := len(queue)
		res = queue[0].Val
		for i := 0; i &lt; length; i++ {
			if queue[i].Left != nil {
				queue = append(queue, queue[i].Left)
			}
			if queue[i].Right != nil {
				queue = append(queue, queue[i].Right)
			}
		}
		queue = queue[length:]
	}
	return res
}

# 2
var res int
var maxLevel int

func findBottomLeftValue(root *TreeNode) int {
	res = 0
	maxLevel = -1
	if root == nil {
		return res
	}
	dfs(root, 0)
	return res
}

func dfs(root *TreeNode, level int) {
	if root == nil {
		return
	}
	dfs(root.Left, level+1)
	if level &gt; maxLevel {
		maxLevel = level
		res = root.Val
	}
	dfs(root.Right, level+1)
}
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>515.在每个树行中找最大值(2)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>您需要在二叉树的每一行中找到最大的值。
示例：输入: 
          1
         / \
        3   2
       / \   \  
      5   3   9 
输出: [1, 3, 9]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>层序遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func largestValues(root *TreeNode) []int {
	res := make([]int, 0)
	if root == nil {
		return res
	}
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		length := len(queue)
		maxValue := math.MinInt32
		for i := 0; i &lt; length; i++ {
			if queue[i].Left != nil {
				queue = append(queue, queue[i].Left)
			}
			if queue[i].Right != nil {
				queue = append(queue, queue[i].Right)
			}
			if maxValue &lt; queue[i].Val {
				maxValue = queue[i].Val
			}
		}
		res = append(res, maxValue)
		queue = queue[length:]
	}
	return res
}

# 2
var res []int

func largestValues(root *TreeNode) []int {
	res = make([]int, 0)
	if root == nil {
		return res
	}
	dfs(root, 0)
	return res
}

func dfs(root *TreeNode, level int) {
	if root == nil {
		return
	}
	if level &gt;= len(res) {
		res = append(res, math.MinInt32)
	}
	res[level] = max(res[level], root.Val)
	dfs(root.Left, level+1)
	dfs(root.Right, level+1)
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>516.最长回文子序列(3)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
示例 1:输入:&quot;bbbab&quot;输出:4
一个可能的最长回文子序列为 &quot;bbbb&quot;。
示例 2:输入:&quot;cbbd&quot;输出:2
一个可能的最长回文子序列为 &quot;bb&quot;。
提示：
    1 &lt;= s.length &lt;= 1000
    s 只包含小写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestPalindromeSubseq(s string) int {
	if len(s) &lt;= 1 {
		return len(s)
	}
	n := len(s)
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
		dp[i][i] = 1
	}
	for i := n - 2; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			if s[i] == s[j] {
				dp[i][j] = dp[i+1][j-1] + 2 // 内层+2
			} else {
				dp[i][j] = max(dp[i+1][j], dp[i][j-1])
			}
		}
	}
	return dp[0][n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func longestPalindromeSubseq(s string) int {
	if len(s) &lt;= 1 {
		return len(s)
	}
	n := len(s)
	dp := make([]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = 1
	}
	for i := n - 1; i &gt;= 0; i-- {
		prev := 0
		for j := i + 1; j &lt; n; j++ {
			temp := dp[j]
			if s[i] == s[j] {
				dp[j] = prev + 2 // 内层+2
			} else {
				dp[j] = max(dp[j], dp[j-1])
			}
			prev = temp
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
var dp [][]int

func longestPalindromeSubseq(s string) int {
	if len(s) &lt;= 1 {
		return len(s)
	}
	n := len(s)
	dp = make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
	}
	return dfs(s, 0, n-1)
}

func dfs(s string, i, j int) int {
	if i == j {
		return 1
	}
	if i &gt; j {
		return 0
	}
	if dp[i][j] &gt; 0 {
		return dp[i][j]
	}
	if s[i] == s[j] {
		dp[i][j] = dfs(s, i+1, j-1) + 2
	} else {
		dp[i][j] = max(dfs(s, i+1, j), dfs(s, i, j-1))
	}
	return dp[i][j]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>518.零钱兑换II(2)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
示例 1:输入: amount = 5, coins = [1, 2, 5] 输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2:输入: amount = 3, coins = [2] 输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
示例 3:输入: amount = 10, coins = [10]  输出: 1
注意:你可以假设：
    0 &lt;= amount (总金额) &lt;= 5000
    1 &lt;= coin (硬币面额) &lt;= 5000
    硬币种类不超过 500 种
    结果符合 32 位符号整数
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划-二维</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划-一维</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func change(amount int, coins []int) int {
	n := len(coins)
	dp := make([][]int, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]int, amount+1)
		dp[i][0] = 1 // 金额为0的情况，只有都不选，组合情况为1
	}
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= amount; j++ {
			if j-coins[i-1] &gt;= 0 {
				dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
			} else {
				dp[i][j] = dp[i-1][j]
			}
		}
	}
	return dp[n][amount]
}

# 2
func change(amount int, coins []int) int {
	n := len(coins)
	dp := make([]int, amount+1)
	dp[0] = 1
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= amount; j++ {
			if j-coins[i-1] &gt;= 0 {
				dp[j] = dp[j] + dp[j-coins[i-1]]
			}
		}
	}
	return dp[amount]
}
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>519.随机翻转矩阵(1)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>题中给出一个 n_rows 行 n_cols 列的二维矩阵，且所有值被初始化为 0。
要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回该值的位置下标 [row_id,col_id]；
同样编写一个 reset 函数，将所有的值都重新置为 0。
尽量最少调用随机函数 Math.random()，并且优化时间和空间复杂度。
注意:1 &lt;= n_rows, n_cols &lt;= 10000
0 &lt;= row.id &lt; n_rows 并且 0 &lt;= col.id &lt; n_cols
当矩阵中没有值为 0 时，不可以调用 flip 函数
调用 flip 和 reset 函数的次数加起来不会超过 1000 次
示例 1：输入:  [&quot;Solution&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;flip&quot;]  [[2,3],[],[],[],[]]
输出: [null,[0,1],[1,2],[1,0],[1,1]]
示例 2：输入:  [&quot;Solution&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;reset&quot;,&quot;flip&quot;] [[1,2],[],[],[],[]]
输出: [null,[0,0],[0,1],null,[0,0]]
输入语法解释：
输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。
flip 和 reset 没有参数，参数总会以列表形式给出，哪怕该列表为空
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Solution</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span>     <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span>
	<span class="nx">rows</span>  <span class="kt">int</span>
	<span class="nx">cols</span>  <span class="kt">int</span>
	<span class="nx">total</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">(</span><span class="nx">n_rows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n_cols</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Solution</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Solution</span><span class="p">{</span>
		<span class="nx">m</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
		<span class="nx">rows</span><span class="p">:</span>  <span class="nx">n_rows</span><span class="p">,</span>
		<span class="nx">cols</span><span class="p">:</span>  <span class="nx">n_cols</span><span class="p">,</span>
		<span class="nx">total</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">Solution</span><span class="p">)</span> <span class="nx">Flip</span><span class="p">()</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">total</span> <span class="o">&gt;=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">rows</span><span class="o">*</span><span class="nx">this</span><span class="p">.</span><span class="nx">cols</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">index</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">rows</span> <span class="o">*</span> <span class="nx">this</span><span class="p">.</span><span class="nx">cols</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">index</span><span class="o">/</span><span class="nx">this</span><span class="p">.</span><span class="nx">cols</span><span class="p">,</span> <span class="nx">index</span><span class="o">%</span><span class="nx">this</span><span class="p">.</span><span class="nx">cols</span>
		<span class="nx">this</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">this</span><span class="p">.</span><span class="nx">total</span><span class="o">++</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">Solution</span><span class="p">)</span> <span class="nx">Reset</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">total</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ii-3">
<h2>522.最长特殊序列II(3)<a class="headerlink" href="#ii-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定字符串列表，你需要从它们中找出最长的特殊序列。
最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。
子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。
空序列为所有字符串的子序列，任何字符串为其自身的子序列。
输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。
示例：输入: &quot;aba&quot;, &quot;cdc&quot;, &quot;eae&quot; 输出: 3
提示：所有给定的字符串长度不会超过 10 。
给定字符串列表的长度将在 [2, 50 ] 之间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findLUSlength(strs []string) int {
	m := make(map[string]int)
	for i := 0; i &lt; len(strs); i++ {
		total := 1 &lt;&lt; (len(strs[i]))
		for j := 0; j &lt; total; j++ {
			s := &quot;&quot;
			for k := 0; k &lt; len(strs[i]); k++ {
				if (j&gt;&gt;k)&amp;1 != 0 {
					s = s + string(strs[i][k])
				}
			}
			m[s]++
		}
	}
	res := -1
	for k, v := range m {
		if v == 1 &amp;&amp; len(k) &gt; res {
			res = len(k)
		}
	}
	return res
}

# 2
func findLUSlength(strs []string) int {
	res := -1
	var j int
	for i := 0; i &lt; len(strs); i++ {
		for j = 0; j &lt; len(strs); j++ {
			if i == j {
				continue
			}
			if judge(strs[i], strs[j]) == true {
				break
			}
		}
		if j == len(strs) &amp;&amp; len(strs[i]) &gt; res {
			res = len(strs[i])
		}
	}

	return res
}

func judge(a, b string) bool {
	j := 0
	for i := 0; i &lt; len(b) &amp;&amp; j &lt; len(a); i++ {
		if a[j] == b[i] {
			j++
		}
	}
	return j == len(a)
}

# 3
func findLUSlength(strs []string) int {
	sort.Slice(strs, func(i, j int) bool {
		return len(strs[i]) &gt; len(strs[j])
	})
	res := -1
	var j int
	for i := 0; i &lt; len(strs); i++ {
		for j = 0; j &lt; len(strs); j++ {
			if i == j {
				continue
			}
			if judge(strs[i], strs[j]) == true {
				break
			}
		}
		if j == len(strs) {
			return len(strs[i])
		}
	}
	return res
}

func judge(a, b string) bool {
	j := 0
	for i := 0; i &lt; len(b) &amp;&amp; j &lt; len(a); i++ {
		if a[j] == b[i] {
			j++
		}
	}
	return j == len(a)
}
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>523.连续的子数组和(2)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，
其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。
示例 1：输入：[23,2,4,6,7], k = 6 输出：True
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。
示例 2：输入：[23,2,6,4,7], k = 6 输出：True
解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
说明：
    数组的长度不会超过 10,000 。
    你可以认为所有数字总和在 32 位有符号整数范围内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和-暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func checkSubarraySum(nums []int, k int) bool {
	if len(nums) == 0 {
		return false
	}
	m := make(map[int]int)
	m[0] = -1
	sum := 0
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
		if k != 0 {
			sum = sum % k
		}
		if _, ok := m[sum]; ok {
			// 确保数组大小至少为2
			if i-m[sum] &gt;= 2 {
				return true
			}
		} else {
			m[sum] = i
		}
	}
	return false
}

# 2
func checkSubarraySum(nums []int, k int) bool {
	if len(nums) == 0 {
		return false
	}
	arr := make([]int, len(nums))
	arr[0] = nums[0]
	for i := 1; i &lt; len(nums); i++ {
		arr[i] = arr[i-1] + nums[i]
	}
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			sum := arr[j] - arr[i] + nums[i]
			if sum == k || (k != 0 &amp;&amp; sum%k == 0) {
				return true
			}
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>525.连续数组(1)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:输入: [0,1] 输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
示例 2:输入: [0,1,0] 输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
注意: 给定的二进制数组的长度不会超过50000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">findMaxLength</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
   <span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
   <span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
   <span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   	<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
   		<span class="nx">total</span><span class="o">--</span>
   	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   		<span class="nx">total</span><span class="o">++</span>
   	<span class="p">}</span>
   	<span class="k">if</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">total</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
   		<span class="nx">m</span><span class="p">[</span><span class="nx">total</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
   	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   		<span class="k">if</span> <span class="nx">i</span><span class="o">-</span><span class="nx">first</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
   			<span class="nx">res</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">first</span>
   		<span class="p">}</span>
   	<span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>526.优美的排列(2)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，
使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
第 i 位的数字能被 i 整除
i 能被第 i 位上的数字整除
现在给定一个整数 N，请问可以构造多少个优美的排列？
示例1:输入: 2 输出: 2
解释: 
第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除
第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
说明:N 是一个正整数，并且不会超过15。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n!)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func countArrangement(n int) int {
	res = make([][]int, 0)
	dfs(n, make([]int, 0), make([]bool, n+1))
	fmt.Println(res)
	return len(res)
}

func dfs(n int, path []int, visited []bool) {
	if len(path) == n {
		temp := make([]int, len(path))
		copy(temp, path)
		res = append(res, temp)
		return
	}
	for i := 1; i &lt;= n; i++ {
		index := len(path) + 1
		if visited[i] == false &amp;&amp; (i%index == 0 || index%i == 0) {
			visited[i] = true
			dfs(n, append(path, i), visited)
			visited[i] = false
		}
	}
}

# 2
var res int

func countArrangement(n int) int {
	res = 0
	dfs(n, make([]int, 0), make([]bool, n+1))
	return res
}

func dfs(n int, path []int, visited []bool) {
	if len(path) == n {
		res++
		return
	}
	for i := 1; i &lt;= n; i++ {
		index := len(path) + 1
		if visited[i] == false &amp;&amp; (i%index == 0 || index%i == 0) {
			visited[i] = true
			dfs(n, append(path, i), visited)
			visited[i] = false
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>529.扫雷游戏(2)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>让我们一起来玩扫雷游戏！
给定一个代表游戏板的二维字符矩阵。 &#39;M&#39; 代表一个未挖出的地雷，&#39;E&#39; 代表一个未挖出的空方块，
&#39;B&#39; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，
数字（&#39;1&#39; 到 &#39;8&#39;）表示有多少地雷与这块已挖出的方块相邻，&#39;X&#39; 则表示一个已挖出的地雷。
现在给出在所有未挖出的方块中（&#39;M&#39;或者&#39;E&#39;）的下一个点击位置（行和列索引），根据以下规则，
返回相应位置被点击后对应的面板：
    如果一个地雷（&#39;M&#39;）被挖出，游戏就结束了- 把它改为 &#39;X&#39;。
    如果一个没有相邻地雷的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;），
    并且所有和其相邻的未挖出方块都应该被递归地揭露。
    如果一个至少与一个地雷相邻的空方块（&#39;E&#39;）被挖出，修改它为数字（&#39;1&#39;到&#39;8&#39;），表示相邻地雷的数量。
    如果在此次点击中，若无更多方块可被揭露，则返回面板。
示例 1：输入: [[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]
Click : [3,0]
输出: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]
解释:示例 2：输入: 
[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]
Click : [1,2]
输出: 
[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]
解释:
注意：输入矩阵的宽和高的范围为 [1,50]。
    点击的位置只能是未被挖出的方块 (&#39;M&#39; 或者 &#39;E&#39;)，这也意味着面板至少包含一个可点击的方块。
    输入面板不会是游戏结束的状态（即有地雷已被挖出）。
    简单起见，未提及的规则在这个问题中可被忽略。
    例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var dx = []int{-1, 1, 0, 0, 1, 1, -1, -1}
var dy = []int{0, 0, -1, 1, 1, -1, 1, -1}

func updateBoard(board [][]byte, click []int) [][]byte {
	x, y := click[0], click[1]
	if board[x][y] == &#39;M&#39; {
		board[x][y] = &#39;X&#39;
	} else {
		dfs(board, x, y)
	}
	return board
}

func dfs(board [][]byte, x, y int) {
	count := 0
	for i := 0; i &lt; 8; i++ {
		newX := dx[i] + x
		newY := dy[i] + y
		if newX &lt; 0 || newX &gt;= len(board) || newY &lt; 0 || newY &gt;= len(board[0]) {
			continue
		}
		if board[newX][newY] == &#39;M&#39; {
			count++
		}
	}
	if count &gt; 0 {
		board[x][y] = byte(count + &#39;0&#39;)
	} else {
		board[x][y] = &#39;B&#39;
		for i := 0; i &lt; 8; i++ {
			newX := dx[i] + x
			newY := dy[i] + y
			if newX &lt; 0 || newX &gt;= len(board) ||
				newY &lt; 0 || newY &gt;= len(board[0]) ||
				board[newX][newY] != &#39;E&#39; {
				continue
			}
			dfs(board, newX, newY)
		}
	}
}

# 2
var dx = []int{-1, 1, 0, 0, 1, 1, -1, -1}
var dy = []int{0, 0, -1, 1, 1, -1, 1, -1}

func updateBoard(board [][]byte, click []int) [][]byte {
	x, y := click[0], click[1]
	if board[x][y] == &#39;M&#39; {
		board[x][y] = &#39;X&#39;
	} else {
		bfs(board, x, y)
	}
	return board
}

func bfs(board [][]byte, x, y int) {
	visited := make([][]bool, len(board))
	for i := 0; i &lt; len(board); i++ {
		visited[i] = make([]bool, len(board[i]))
	}
	queue := make([][2]int, 0)
	queue = append(queue, [2]int{x, y})
	visited[x][y] = true
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		count := 0
		a := node[0]
		b := node[1]
		for j := 0; j &lt; 8; j++ {
			newX := dx[j] + a
			newY := dy[j] + b
			if newX &lt; 0 || newX &gt;= len(board) ||
				newY &lt; 0 || newY &gt;= len(board[0]) ||
				visited[newX][newY] == true {
				continue
			}
			if board[newX][newY] == &#39;M&#39; {
				count++
			}
		}
		if count &gt; 0 {
			board[a][b] = byte(count + &#39;0&#39;)
		} else {
			board[a][b] = &#39;B&#39;
			for j := 0; j &lt; 8; j++ {
				newX := dx[j] + a
				newY := dy[j] + b
				if newX &lt; 0 || newX &gt;= len(board) ||
					newY &lt; 0 || newY &gt;= len(board[0]) ||
					board[newX][newY] != &#39;E&#39; ||
					visited[newX][newY] == true {
					continue
				}
				queue = append(queue, [2]int{newX, newY})
				visited[newX][newY] = true
			}
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>537.复数乘法(2)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个表示复数的字符串。
返回表示它们乘积的字符串。注意，根据定义 i2 = -1 。
示例 1:输入: &quot;1+1i&quot;, &quot;1+1i&quot; 输出: &quot;0+2i&quot;
解释: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。
示例 2:输入: &quot;1+-1i&quot;, &quot;1+-1i&quot; 输出: &quot;0+-2i&quot;
解释: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 
注意:输入字符串不包含额外的空格。
输入字符串将以 a+bi 的形式给出，其中整数 a 和 b 的范围均在 [-100, 100] 之间。输出也应当符合这种形式。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func complexNumberMultiply(a string, b string) string {
	a1, a2 := getValue(a)
	b1, b2 := getValue(b)
	return fmt.Sprintf(&quot;%d+%di&quot;, a1*b1-a2*b2, a1*b2+a2*b1)
}

func getValue(str string) (a, b int) {
	arr := strings.Split(str, &quot;+&quot;)
	a, _ = strconv.Atoi(arr[0])
	b, _ = strconv.Atoi(arr[1][:len(arr[1])-1])
	return a, b
}

# 2
func complexNumberMultiply(a string, b string) string {
	var a1, a2, b1, b2 int
	fmt.Sscanf(a, &quot;%d+%di&quot;, &amp;a1, &amp;a2)
	fmt.Sscanf(b, &quot;%d+%di&quot;, &amp;b1, &amp;b2)
	return fmt.Sprintf(&quot;%d+%di&quot;, a1*b1-a2*b2, a1*b2+a2*b1)
}
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>539.最小时间差(2)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 24 小时制（小时:分钟 &quot;HH:MM&quot;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
示例 1：输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;] 输出：1
示例 2：输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]输出：0
提示：2 &lt;= timePoints &lt;= 2 * 104
timePoints[i] 格式为 &quot;HH:MM&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findMinDifference(timePoints []string) int {
	m := make(map[int]bool)
	for i := 0; i &lt; len(timePoints); i++ {
		value := getValue(timePoints[i])
		if _, ok := m[value]; ok {
			return 0
		}
		m[value] = true
	}
	arr := make([]int, 0)
	for k := range m {
		arr = append(arr, k)
	}
	sort.Ints(arr)
	res := math.MaxInt32
	arr = append(arr, arr[0]+1440)
	for i := 1; i &lt; len(arr); i++ {
		if res &gt; arr[i]-arr[i-1] {
			res = arr[i] - arr[i-1]
		}
	}
	return res
}

func getValue(str string) int {
	hour, _ := strconv.Atoi(str[:2])
	minute, _ := strconv.Atoi(str[3:])
	return hour*60 + minute
}

# 2
func findMinDifference(timePoints []string) int {
	arr := make([]int, 0)
	for i := 0; i &lt; len(timePoints); i++ {
		value := getValue(timePoints[i])
		arr = append(arr, value)
	}
	sort.Ints(arr)
	res := math.MaxInt32
	arr = append(arr, arr[0]+1440)
	for i := 1; i &lt; len(arr); i++ {
		if res &gt; arr[i]-arr[i-1] {
			res = arr[i] - arr[i-1]
		}
	}
	return res
}

func getValue(str string) int {
	hour, _ := strconv.Atoi(str[:2])
	minute, _ := strconv.Atoi(str[3:])
	return hour*60 + minute
}
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>540.有序数组中的单一元素(3)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
示例 1:输入: [1,1,2,3,3,4,4,8,8]输出: 2
示例 2:输入: [3,3,7,7,10,11,11]输出: 10
注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>异或</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func singleNonDuplicate(nums []int) int {
	for i := 0; i &lt; len(nums)-1; i = i + 2 {
		if nums[i] != nums[i+1] {
			return nums[i]
		}
	}
	return nums[len(nums)-1]
}

# 2
func singleNonDuplicate(nums []int) int {
	n := len(nums)
	left, right := 0, n-1
	for left &lt; right {
		mid := left + (right-left)/2
		if mid%2 == 1 {
			mid--
		}
		if nums[mid] == nums[mid+1] {
			left = mid + 2
		} else {
			right = mid
		}
	}
	return nums[left]
}

# 3
func singleNonDuplicate(nums []int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		res = res ^ nums[i]
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>542.01矩阵(3)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
示例 1: 输入:
0 0 0
0 1 0
0 0 0
输出:
0 0 0
0 1 0
0 0 0
示例 2: 输入:
0 0 0
0 1 0
1 1 1
输出:
0 0 0
0 1 0
1 2 1
注意:
    给定矩阵的元素个数不超过 10000。
    给定矩阵中至少有一个元素是 0。
    矩阵中的元素只在四个方向上相邻: 上、下、左、右。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func updateMatrix(matrix [][]int) [][]int {
	n := len(matrix)
	m := len(matrix[0])
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == 1 {
				dp[i][j] = math.MaxInt32 / 10
				if i &gt; 0 {
					dp[i][j] = min(dp[i][j], dp[i-1][j]+1)
				}
				if j &gt; 0 {
					dp[i][j] = min(dp[i][j], dp[i][j-1]+1)
				}
			} else {
				dp[i][j] = 0
			}
		}
	}
	for i := n - 1; i &gt;= 0; i-- {
		for j := m - 1; j &gt;= 0; j-- {
			if dp[i][j] &gt; 1 {
				if i &lt; n-1 {
					dp[i][j] = min(dp[i][j], dp[i+1][j]+1)
				}
				if j &lt; m-1 {
					dp[i][j] = min(dp[i][j], dp[i][j+1]+1)
				}
			}
		}
	}
	return dp
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func updateMatrix(matrix [][]int) [][]int {
	n := len(matrix)
	m := len(matrix[0])
	queue := make([][2]int, 0)
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == 0 {
				queue = append(queue, [2]int{i, j})
			} else {
				matrix[i][j] = -1
			}
		}
	}
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		for i := 0; i &lt; 4; i++ {
			x := node[0] + dx[i]
			y := node[1] + dy[i]
			if 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m &amp;&amp; matrix[x][y] == -1 {
				matrix[x][y] = matrix[node[0]][node[1]] + 1
				queue = append(queue, [2]int{x, y})
			}
		}
	}
	return matrix
}

# 3
func updateMatrix(matrix [][]int) [][]int {
	n := len(matrix)
	m := len(matrix[0])
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == 1 {
				matrix[i][j] = math.MaxInt32 / 10
				if i &gt; 0 {
					matrix[i][j] = min(matrix[i][j], matrix[i-1][j]+1)
				}
				if j &gt; 0 {
					matrix[i][j] = min(matrix[i][j], matrix[i][j-1]+1)
				}
			} else {
				matrix[i][j] = 0
			}
		}
	}
	for i := n - 1; i &gt;= 0; i-- {
		for j := m - 1; j &gt;= 0; j-- {
			if matrix[i][j] &gt; 1 {
				if i &lt; n-1 {
					matrix[i][j] = min(matrix[i][j], matrix[i+1][j]+1)
				}
				if j &lt; m-1 {
					matrix[i][j] = min(matrix[i][j], matrix[i][j+1]+1)
				}
			}
		}
	}
	return matrix
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>547.朋友圈(3)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。
如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。
所谓的朋友圈，是指所有朋友的集合。
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。
如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。
你必须输出所有学生中的已知的朋友圈总数。
示例 1：输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2 
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回 2 。
示例 2：输入：
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出：1
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，
所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。
提示：1 &lt;= N &lt;= 200
M[i][i] == 1
M[i][j] == M[j][i]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>并查集</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findCircleNum(M [][]int) int {
	n := len(M)
	fa = Init(n)
	count = n
	for i := 0; i &lt; n; i++ {
		for j := i + 1; j &lt; n; j++ {
			if M[i][j] == 1 {
				union(i, j)
			}
		}
	}
	return getCount()
}

var fa []int
var count int

// 初始化
func Init(n int) []int {
	arr := make([]int, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = i
	}
	count = n
	return arr
}

// 查询
func find(x int) int {
	if fa[x] == x {
		return x
	}
	// 路径压缩
	fa[x] = find(fa[x])
	return fa[x]
}

// 合并
func union(i, j int) {
	x, y := find(i), find(j)
	if x != y {
		fa[x] = y
		count--
	}
}

func query(i, j int) bool {
	return find(i) == find(j)
}

func getCount() int {
	return count
}

# 2
var arr []bool

func findCircleNum(M [][]int) int {
	n := len(M)
	arr = make([]bool, n)
	res := 0
	for i := 0; i &lt; n; i++ {
		if arr[i] == false {
			dfs(M, i)
			res++
		}
	}
	return res
}

func dfs(M [][]int, index int) {
	for i := 0; i &lt; len(M); i++ {
		if arr[i] == false &amp;&amp; M[index][i] == 1 {
			arr[i] = true
			dfs(M, i)
		}
	}
}

# 3
func findCircleNum(M [][]int) int {
	n := len(M)
	arr := make([]bool, n)
	res := 0
	queue := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		if arr[i] == false {
			queue = append(queue, i)
			for len(queue) &gt; 0 {
				node := queue[0]
				queue = queue[1:]
				arr[node] = true
				for j := 0; j &lt; n; j++ {
					if M[node][j] == 1 &amp;&amp; arr[j] == false {
						queue = append(queue, j)
					}
				}
			}
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>554.砖墙(1)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你的面前有一堵矩形的、由多行砖块组成的砖墙。 这些砖块高度相同但是宽度不同。
你现在要画一条自顶向下的、穿过最少砖块的垂线。
砖墙由行的列表表示。 每一行都是一个代表从左至右每块砖的宽度的整数列表。
如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。
你需要找出怎样画才能使这条线穿过的砖块数量最少，并且返回穿过的砖块数量。
你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。
示例：输入: [[1,2,2,1],
      [3,1,2],
      [1,3,2],
      [2,4],
      [3,1,2],
      [1,3,1,1]]
输出: 2
解释: 提示：每一行砖块的宽度之和应该相等，并且不能超过 INT_MAX。
每一行砖块的数量在 [1,10,000] 范围内， 墙的高度在 [1,10,000] 范围内， 总的砖块数量不超过 20,000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">leastBricks</span><span class="p">(</span><span class="nx">wall</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">maxCount</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">wall</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">wall</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span> <span class="o">+</span> <span class="nx">wall</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
            <span class="nx">m</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="o">++</span> <span class="c1">// 保留去除开头和结尾的位置(空隙地方)</span>
			<span class="k">if</span> <span class="nx">maxCount</span> <span class="o">&lt;=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">{</span>
				<span class="nx">maxCount</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">wall</span><span class="p">)</span> <span class="o">-</span> <span class="nx">maxCount</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-4">
<h2>560.和为K的子数组(4)<a class="headerlink" href="#k-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明:数组的长度为 [1, 20,000]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和-遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>前缀和-哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>前缀和-哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func subarraySum(nums []int, k int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		sum := 0
		for j := i; j &lt; len(nums); j++ {
			sum = sum + nums[j]
			if sum == k {
				res++
			}
		}
	}
	return res
}

# 2
func subarraySum(nums []int, k int) int {
	if len(nums) == 0 {
		return 0
	}
	res := 0
	arr := make([]int, len(nums)+1)
	arr[0] = 0
	for i := 1; i &lt;= len(nums); i++ {
		arr[i] = arr[i-1] + nums[i-1]
	}
	for i := 0; i &lt;= len(nums); i++ {
		for j := 0; j &lt; i; j++ {
			if arr[i]-arr[j] == k {
				res++
			}
		}
	}
	return res
}

# 3
func subarraySum(nums []int, k int) int {
	res := 0
	m := make(map[int]int)
	m[0] = 1 // 保证第一个k的存在
	sum := 0
	// sum[i:j]= sum[0:j]-sum[0:i]，把sum[i:j]设为k，
	// 于是可以转化为sum[0:j]-k=sum[0:i]
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
		if _, ok := m[sum-k]; ok {
			res = res + m[sum-k]
		}
		m[sum]++
	}
	return res
}

# 4
func subarraySum(nums []int, k int) int {
	res := 0
	m := make(map[int][]int)
	m[0] = []int{-1} // 保证第一个k的存在
	sum := 0
	// sum[i:j]= sum[0:j]-sum[0:i]，把sum[i:j]设为k，
	// 于是可以转化为sum[0:j]-k=sum[0:i]
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
		if _, ok := m[sum-k]; ok {
			res = res + len(m[sum-k])
            // 输出满足条件的子数组下标
			// for _, v := range m[sum-k] {
			//	fmt.Println(v+1, i)
			// }
		}
		m[sum] = append(m[sum], i)
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>565.数组嵌套(4)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，
其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。
假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，
之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。
示例 1:输入: A = [5,4,0,3,1,6,2] 输出: 4
解释:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
提示：N是[1, 20,000]之间的整数。
A中不含有重复的元素。
A中的元素大小在[0, N-1]之间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历交换</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>并查集</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func arrayNesting(nums []int) int {
	m := make(map[int]bool)
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		if m[nums[i]] == true {
			continue
		}
		count := 0
		cur := i
		for {
			count++
			m[cur] = true
			cur = nums[cur]
			if cur == i {
				break
			}
		}
		if count &gt; res {
			res = count
		}
	}
	return res
}

# 2
func arrayNesting(nums []int) int {
	m := make(map[int]bool)
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		if m[nums[i]] == true {
			continue
		}
		count := 0
		cur := i
		for {
			count++
			m[cur] = true
			cur = nums[cur]
			if m[cur] == true {
				break
			}
		}
		if count &gt; res {
			res = count
		}
	}
	return res
}

# 3
func arrayNesting(nums []int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		count := 1
		for nums[i] != i {
			count++
			nums[i], nums[nums[i]] = nums[nums[i]], nums[i]
		}
		if count &gt; res {
			res = count
		}
	}
	return res
}

# 4
func arrayNesting(nums []int) int {
	res := 0
	fa = Init(len(nums))
	for i := 0; i &lt; len(nums); i++ {
		union(i, nums[i])
	}
	m := make(map[int]int)
	for i := 0; i &lt; len(fa); i++ {
		m[find(i)]++
	}
	for _, v := range m {
		if v &gt; res {
			res = v
		}
	}
	return res
}

var fa []int

// 初始化
func Init(n int) []int {
	arr := make([]int, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = i
	}
	return arr
}

// 查询
func find(x int) int {
	if fa[x] == x {
		return x
	}
	// 路径压缩
	fa[x] = find(fa[x])
	return fa[x]
}

// 合并
func union(i, j int) {
	x, y := find(i), find(j)
	if x != y {
		fa[x] = y
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>567.字符串的排列(2)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的子串。
示例1:输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot; 输出: True
解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).
示例2:输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot; 输出: False
注意：输入的字符串只包含小写字母
两个字符串的长度都在 [1, 10,000] 之间
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func checkInclusion(s1 string, s2 string) bool {
	if len(s1) &gt; len(s2) {
		return false
	}
	arr1, arr2 := [26]int{}, [26]int{}
	for i := 0; i &lt; len(s1); i++ {
		arr1[s1[i]-&#39;a&#39;]++
		arr2[s2[i]-&#39;a&#39;]++
	}
	for i := 0; i &lt; len(s2)-len(s1); i++ {
		if arr1 == arr2 {
			return true
		}
		arr2[s2[i]-&#39;a&#39;]--
		arr2[s2[i+len(s1)]-&#39;a&#39;]++
	}
	return arr1 == arr2
}

# 2
func checkInclusion(s1 string, s2 string) bool {
	if len(s1) &gt; len(s2) {
		return false
	}
	m1, m2 := make(map[byte]int), make(map[byte]int)
	for i := 0; i &lt; len(s1); i++ {
		m1[s1[i]-&#39;a&#39;]++
		m2[s2[i]-&#39;a&#39;]++
	}
	for i := 0; i &lt; len(s2)-len(s1); i++ {
		if compare(m1, m2) {
			return true
		}
		m2[s2[i]-&#39;a&#39;]--
		if m2[s2[i]-&#39;a&#39;] == 0 {
			delete(m2, s2[i]-&#39;a&#39;)
		}
		m2[s2[i+len(s1)]-&#39;a&#39;]++
	}
	return compare(m1, m2)
}

func compare(m1, m2 map[byte]int) bool {
	if len(m1) != len(m2) {
		return false
	}
	for k := range m1 {
		if m2[k] != m1[k] {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>576.出界的路径数<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<div class="section" id="id40">
<h3>题目<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，
或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。
找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。
示例 1：输入: m = 2, n = 2, N = 2, i = 0, j = 0 输出: 6
解释:
示例 2：输入: m = 1, n = 3, N = 3, i = 0, j = 1 输出: 12
解释:
说明:球一旦出界，就不能再被移动回网格内。
网格的长度和高度在 [1,50] 的范围内。
N 在 [0,50] 的范围内。
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h3>解题思路<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id42">
<h2>583.两个字符串的删除操作(3)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，
每步可以删除任意一个字符串中的一个字符。
示例：输入: &quot;sea&quot;, &quot;eat&quot; 输出: 2
解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;
提示：给定单词的长度不超过500。
给定单词中的字符只含有小写字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minDistance(word1 string, word2 string) int {
	a, b := len(word1), len(word2)
	// 最长公共子序列
	dp := make([][]int, a+1)
	for i := 0; i &lt;= a; i++ {
		dp[i] = make([]int, b+1)
	}
	for i := 1; i &lt;= a; i++ {
		for j := 1; j &lt;= b; j++ {
			if word1[i-1] == word2[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j])
			}
		}
	}
	return a + b - 2*dp[a][b]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func minDistance(word1 string, word2 string) int {
	a, b := len(word1), len(word2)
	dp := make([][]int, a+1)
	for i := 0; i &lt;= a; i++ {
		dp[i] = make([]int, b+1)
		dp[i][0] = i
	}
	for i := 0; i &lt;= b; i++ {
		dp[0][i] = i
	}
	for i := 1; i &lt;= a; i++ {
		for j := 1; j &lt;= b; j++ {
			if word1[i-1] == word2[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else {
				dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1
			}
		}
	}
	return dp[a][b]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
var m [][]int

func minDistance(word1 string, word2 string) int {
	a, b := len(word1), len(word2)
	m = make([][]int, a+1)
	for i := 0; i &lt;= a; i++ {
		m[i] = make([]int, b+1)
		for j := 0; j &lt;= b; j++ {
			m[i][j] = -1
		}
	}
	total := dfs(word1, word2, 0, 0)
	return a + b - 2*total
}

func dfs(word1 string, word2 string, i, j int) int {
	if len(word1) == i || len(word2) == j {
		return 0
	}
	if m[i][j] &gt; -1 {
		return m[i][j]
	}
	if word1[i] == word2[j] {
		m[i][j] = dfs(word1, word2, i+1, j+1) + 1
	} else {
		m[i][j] = max(dfs(word1, word2, i, j+1), dfs(word1, word2, i+1, j))
	}
	return m[i][j]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2>593.有效的正方形(2)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定二维空间中四点的坐标，返回四点是否可以构造一个正方形。
一个点的坐标（x，y）由一个有两个整数的整数数组表示。
示例:输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] 输出: True
注意:所有输入整数都在 [-10000，10000] 范围内。
一个有效的正方形有四个等长的正长和四个等角（90度角）。
输入点没有顺序。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>几何</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>几何</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func validSquare(p1 []int, p2 []int, p3 []int, p4 []int) bool {
	m := make(map[int]int)
	m[getDis(p1, p2)]++
	m[getDis(p1, p3)]++
	m[getDis(p1, p4)]++
	m[getDis(p2, p3)]++
	m[getDis(p2, p4)]++
	m[getDis(p3, p4)]++
	a, b := 0, 0
	for k, v := range m {
		if v == 2 {
			a = k
		} else if v == 4 {
			b = k
		} else {
			return false
		}
	}
	return len(m) == 2 &amp;&amp; a == 2*b
}

func getDis(a, b []int) int {
	return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1])
}

# 2
func validSquare(p1 []int, p2 []int, p3 []int, p4 []int) bool {
	arr := make([]int, 0)
	arr = append(arr, getDis(p1, p2))
	arr = append(arr, getDis(p1, p3))
	arr = append(arr, getDis(p1, p4))
	arr = append(arr, getDis(p2, p3))
	arr = append(arr, getDis(p2, p4))
	arr = append(arr, getDis(p3, p4))
	sort.Ints(arr)
	return arr[0] &gt; 0 &amp;&amp; arr[0] == arr[3] &amp;&amp; arr[4] == arr[5] &amp;&amp; arr[0]*2 == arr[4]
}

func getDis(a, b []int) int {
	return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1])
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>0501-0600-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="ipo-2">
<h2>502.IPO(2)<a class="headerlink" href="#ipo-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，
力扣 希望在 IPO 之前开展一些项目以增加其资本。 
由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。
帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。
给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。
最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。
示例 1:输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].
输出: 4
解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
注意:假设所有输入数字都是非负整数。
    表示利润和资本的数组的长度不超过 50000。
    答案保证在 32 位有符号整数范围内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findMaximizedCapital(k int, W int, Profits []int, Capital []int) int {
	maxProfit := &amp;ProfitNode{}
	minCapital := &amp;CapitalNode{}
	heap.Init(maxProfit)
	heap.Init(minCapital)
	for i := 0; i &lt; len(Profits); i++ {
		heap.Push(minCapital, Node{
			Profits: Profits[i],
			Capital: Capital[i],
		})
	}
	for i := 0; i &lt; k; i++ {
		for minCapital.Len() &gt; 0 {
			node := heap.Pop(minCapital).(Node)
			if node.Capital &lt;= W {
				heap.Push(maxProfit, node)
			} else {
				heap.Push(minCapital, node)
				break
			}
		}
		if maxProfit.Len() == 0 {
			return W
		}
		node := heap.Pop(maxProfit).(Node)
		W = W + node.Profits
	}
	return W
}

type Node struct {
	Profits int
	Capital int
}

type ProfitNode []Node

func (h ProfitNode) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h ProfitNode) Less(i, j int) bool {
	return h[i].Profits &gt; h[j].Profits
}

func (h ProfitNode) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *ProfitNode) Push(x interface{}) {
	*h = append(*h, x.(Node))
}

func (h *ProfitNode) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

type CapitalNode []Node

func (h CapitalNode) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h CapitalNode) Less(i, j int) bool {
	return h[i].Capital &lt; h[j].Capital
}

func (h CapitalNode) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *CapitalNode) Push(x interface{}) {
	*h = append(*h, x.(Node))
}

func (h *CapitalNode) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
type Node struct {
	profit  int
	capital int
}

func findMaximizedCapital(k int, W int, Profits []int, Capital []int) int {
	arr := make([]Node, 0)
	for i := 0; i &lt; len(Profits); i++ {
		arr = append(arr, Node{
			profit:  Profits[i],
			capital: Capital[i],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i].profit &gt; arr[j].profit
	})
	index := 0
	for k &gt; 0 {
		if index == len(arr) {
			return W
		}
		// 挑选一个满足条件的项目，利润最大即可
		if arr[index].capital &lt;= W {
			k--
			W = W + arr[index].profit
			arr = append(arr[:index], arr[index+1:]...)
			index = 0
			continue
		}
		index++
	}
	return W
}
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>514.自由之路(2)<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，
并使用表盘拼写特定关键词才能开门。
给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。
您需要算出能够拼写关键词中所有字符的最少步数。
最初，ring 的第一个字符与12:00方向对齐。
您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，
然后按下中心按钮，以此逐个拼写完 key 中的所有字符。
旋转 ring 拼出 key 字符 key[i] 的阶段中：
您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。
旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。
按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
示例：输入: ring = &quot;godding&quot;, key = &quot;gd&quot; 输出: 4
解释: 对于 key 的第一个字符 &#39;g&#39;，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 &#39;d&#39;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。
提示：ring 和 key 的字符串长度取值范围均为 1 至 100；
两个字符串中都只有小写字符，并且均可能存在重复字符；
字符串 key 一定可以由字符串 ring 旋转拼出。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^3)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n^3)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findRotateSteps(ring string, key string) int {
	maxValue := math.MaxInt32 / 10
	n := len(key)
	m := len(ring)
	dp := make([][]int, n) // dp[i][j] =&gt; key[:i+1]，ring[:j+1]的最少步数
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
		for j := 0; j &lt; m; j++ {
			dp[i][j] = maxValue
		}
	}
	arr := [26][]int{}
	for i := 0; i &lt; len(ring); i++ {
		value := int(ring[i] - &#39;a&#39;)
		arr[value] = append(arr[value], i)
	}
	for _, v := range arr[key[0]-&#39;a&#39;] {
		dp[0][v] = min(v, m-v) + 1 // 移到次数
	}
	for i := 1; i &lt; n; i++ {
		for _, j := range arr[key[i]-&#39;a&#39;] { // 枚举当前字母位置
			for _, k := range arr[key[i-1]-&#39;a&#39;] { // 枚举上一个字母位置
				minValue := min(abs(j-k), m-abs(j-k))
				dp[i][j] = min(dp[i][j], dp[i-1][k]+minValue+1)
			}
		}
	}
	res := math.MaxInt32
	for i := 0; i &lt; m; i++ {
		res = min(res, dp[n-1][i])
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}

# 2
var dp [][]int
var arr [26][]int

func findRotateSteps(ring string, key string) int {
	n := len(key)
	m := len(ring)
	dp = make([][]int, n) // dp[i][j] =&gt; key[:i+1]，ring[:j+1]的最少步数
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
		for j := 0; j &lt; m; j++ {
			dp[i][j] = -1
		}
	}
	arr = [26][]int{}
	for i := 0; i &lt; len(ring); i++ {
		value := int(ring[i] - &#39;a&#39;)
		arr[value] = append(arr[value], i)
	}
	return n + dfs(key, ring, 0, 0)
}

func dfs(key, ring string, keyIndex, ringIndex int) int {
	if keyIndex == len(key) {
		return 0
	}
	if dp[keyIndex][ringIndex] != -1 {
		return dp[keyIndex][ringIndex]
	}
	cur := int(key[keyIndex] - &#39;a&#39;)
	res := math.MaxInt32
	for _, v := range arr[cur] {
		minValue := min(abs(ringIndex-v), len(ring)-abs(ringIndex-v))
		res = min(res, minValue+dfs(key, ring, keyIndex+1, v))
	}
	dp[keyIndex][ringIndex] = res
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h2>552.学生出勤记录II(1)<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个正整数 n，返回长度为 n 的所有可被视为可奖励的出勤记录的数量。 
答案可能非常大，你只需返回结果mod 109 + 7的值。
学生出勤记录是只包含以下三个字符的字符串：
&#39;A&#39; : Absent，缺勤
&#39;L&#39; : Late，迟到
&#39;P&#39; : Present，到场
如果记录不包含多于一个&#39;A&#39;（缺勤）或超过两个连续的&#39;L&#39;（迟到），则该记录被视为可奖励的。
示例 1:输入: n = 2 输出: 8 
解释：有8个长度为2的记录将被视为可奖励：
&quot;PP&quot; , &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot;
只有&quot;AA&quot;不会被视为可奖励，因为缺勤次数超过一次。
注意：n 的值不会超过100000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mod</span> <span class="p">=</span> <span class="mi">1000000007</span>

<span class="kd">func</span> <span class="nx">checkRecord</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 0A 0L</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 0A 1L</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 0A 2L</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 1A 0L</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 1A 1L</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 1A 2L</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
		<span class="nx">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="nx">mod</span>                         <span class="c1">// +P</span>
		<span class="nx">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                                                 <span class="c1">// +L</span>
		<span class="nx">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                                                 <span class="c1">// +L</span>
		<span class="nx">temp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">%</span> <span class="nx">mod</span> <span class="c1">// 0、1、2+A，3、4、5+P</span>
		<span class="nx">temp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>                                                 <span class="c1">// +L</span>
		<span class="nx">temp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>                                                 <span class="c1">// +L</span>
		<span class="nx">dp</span> <span class="p">=</span> <span class="nx">temp</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="p">(</span><span class="nx">res</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1000000007</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="0601-0700.html" class="btn btn-neutral float-right" title="0601-0700-Easy" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="0401-0500.html" class="btn btn-neutral float-left" title="0401-0500-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>