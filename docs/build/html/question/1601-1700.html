

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1601-1700-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="1701-1800-Easy" href="1701-1800.html" />
    <link rel="prev" title="1501-1600-Easy" href="1501-1600.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">1601-1700-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">1603.设计停车系统(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">1608.特殊数组的特征值(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">1614.括号的最大嵌套深度(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">1619.删除某些元素后的数组均值(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1624.两个相同字符之间的最长子字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">1629.按键持续时间最长的键(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">1636.按照频率将数组升序排序(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">1640.能否连接形成数组(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">1646.获取生成数组中的最大值(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">1652.拆炸弹(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">1656.设计有序流(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">1662.检查两个字符串数组是否相等(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">1668.最大重复子字符串(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">1672.最富有客户的资产总量(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#goal-2">1678.设计Goal解析器(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">1684.统计一致字符串的数目(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">1688.比赛中的配对次数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">1694.重新格式化电话号码(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">1700.无法吃午餐的学生数量(1)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">1601-1700-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id19">1604.警告一小时内使用相同员工卡大于等于三次的人(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">1605.给定行和列的和求可行矩阵(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">1609.奇偶树(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">1615.最大网络秩(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">1616.分割两个字符串得到回文串</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id24">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id26">1620.网络信号最好的坐标(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-2">1621.大小为K的不重叠线段的数目(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">1625.执行操作后字典序最小的字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">1626.无矛盾的最佳球队(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">1630.等差子数组(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">1637.两点之间不包含任何点的最宽垂直面积(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">1638.统计只差一个字符的子串数目(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">1641.统计字典序元音字符串的数目(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">1642.可以到达的最远建筑(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">1647.字符频次唯一的最小删除次数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">1648.销售价值减少的颜色球(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">1653.使字符串平衡的最少删除次数(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">1654.到家的最少跳跃次数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">1657.确定两个字符串是否接近(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#x0-2">1658.将x减到0的最小操作数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">1663.具有给定数值的最小字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">1664.生成平衡数组的方案数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id41">1669.合并两个链表(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id42">1670.设计前中后队列(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43">1673.找出最具竞争力的子序列(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">1674.使数组互补的最少操作次数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-3">1679.K和数对的最大数目(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id45">1680.连接连续二进制数字(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id46">1685.有序数组中差绝对值之和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vi-1">1686.石子游戏VI(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id47">1689.十-二进制数的最少数目(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vii-4">1690.石子游戏VII(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id48">1695.删除子数组的最大得分(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vi-4">1696.跳跃游戏VI(4)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">1601-1700-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id49">1665.完成所有任务的最少初始能量(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id50">1671.得到山形数组的最少删除次数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id51">1691.堆叠长方体的最大高度(1)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html">Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#medium">Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#hard">Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>1601-1700-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/1601-1700.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>1601-1700-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>1603.设计停车系统(2)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。
请你实现 ParkingSystem 类：
    ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，
    三个参数分别对应每种停车位的数目。
    bool addCar(int carType) 检车是否有 carType 对应的停车位。 
    carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。
    一辆车只能停在  carType 对应尺寸的停车位中。
    如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。
示例 1：输入：[&quot;ParkingSystem&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;]
[[1, 1, 0], [1], [2], [3], [1]]
输出：[null, true, true, false, false]
解释：ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位
parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位
parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位
parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了
提示： 0 &lt;= big, medium, small &lt;= 1000
    carType 取值为 1， 2 或 3
    最多会调用 addCar 函数 1000 次
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type ParkingSystem struct {
	arr   [3]int
	total [3]int
}

func Constructor(big int, medium int, small int) ParkingSystem {
	return ParkingSystem{
		arr:   [3]int{big, medium, small},
		total: [3]int{0, 0, 0},
	}
}

func (this *ParkingSystem) AddCar(carType int) bool {
	index := carType - 1
	if this.total[index] &lt; this.arr[index] {
		this.total[index]++
		return true
	}
	return false
}

# 2
type ParkingSystem struct {
	arr [3]int
}

func Constructor(big int, medium int, small int) ParkingSystem {
	return ParkingSystem{
		arr: [3]int{big, medium, small},
	}
}

func (this *ParkingSystem) AddCar(carType int) bool {
	if this.arr[carType-1] &gt; 0 {
		this.arr[carType-1]--
		return true
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>1608.特殊数组的特征值(3)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个非负整数数组 nums 。
如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，
那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
注意： x 不必 是 nums 的中的元素。
如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。
否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
示例 1：输入：nums = [3,5] 输出：2
解释：有 2 个元素（3 和 5）大于或等于 2 。
示例 2：输入：nums = [0,0] 输出：-1
解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。
如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。
如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。
如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。
x 不能取更大的值，因为 nums 中只有两个元素。
示例 3：输入：nums = [0,4,3,0,4] 输出：3
解释：有 3 个元素大于或等于 3 。
示例 4：输入：nums = [3,6,7,7,0] 输出：-1
提示：1 &lt;= nums.length &lt;= 100
    0 &lt;= nums[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>计数排序</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func specialArray(nums []int) int {
	arr := make([]int, 1001)
	for i := 0; i &lt; len(nums); i++ {
		arr[nums[i]]++
	}
	for i := len(arr) - 2; i &gt;= 0; i-- {
		arr[i] = arr[i] + arr[i+1]
	}
	for i := 0; i &lt;= len(nums); i++ {
		if arr[i] == i {
			return i
		}
	}
	return -1
}

# 2
func specialArray(nums []int) int {
	for i := 0; i &lt;= len(nums); i++ {
		count := 0
		for j := 0; j &lt; len(nums); j++ {
			if nums[j] &gt;= i {
				count++
			}
		}
		if count == i {
			return i
		}
	}
	return -1
}

# 3
func specialArray(nums []int) int {
	sort.Ints(nums)
	n := len(nums)
	if nums[0] &gt;= n {
		return n
	}
	for i := 1; i &lt; n; i++ {
		target := n - i
		if nums[i] &gt;= target &amp;&amp; target &gt; nums[i-1] {
			return target
		}
	}
	return -1
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>1614.括号的最大嵌套深度(2)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果字符串满足一下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：
    字符串是一个空字符串 &quot;&quot;，或者是一个不为 &quot;(&quot; 或 &quot;)&quot; 的单字符。
    字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
    字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：
    depth(&quot;&quot;) = 0
    depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
    depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)，其中 A 是一个 有效括号字符串
例如：&quot;&quot;、&quot;()()&quot;、&quot;()(()())&quot; 都是 有效括号字符串（嵌套深度分别为 0、1、2），
而 &quot;)(&quot; 、&quot;(()&quot; 都不是 有效括号字符串 。
给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。
示例 1：输入：s = &quot;(1+(2*3)+((8)/4))+1&quot; 输出：3
解释：数字 8 在嵌套的 3 层括号中。
示例 2：输入：s = &quot;(1)+((2))+(((3)))&quot; 输出：3
示例 3：输入：s = &quot;1+(2*3)/(2-1)&quot; 输出：1
示例 4：输入：s = &quot;1&quot; 输出：0
提示： 1 &lt;= s.length &lt;= 100
    s 由数字 0-9 和字符 &#39;+&#39;、&#39;-&#39;、&#39;*&#39;、&#39;/&#39;、&#39;(&#39;、&#39;)&#39; 组成
    题目数据保证括号表达式 s 是 有效的括号表达式
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxDepth(s string) int {
	res := 0
	count := 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;(&#39; {
			count++
		} else if s[i] == &#39;)&#39; {
			if count &gt; res {
				res = count
			}
			count--
		}
	}
	return res
}

# 2
func maxDepth(s string) int {
	res := 0
	stack := make([]byte, 0)
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;(&#39; {
			stack = append(stack, s[i])
		} else if s[i] == &#39;)&#39; {
			stack = stack[:len(stack)-1]
		}
		if len(stack) &gt; res {
			res = len(stack)
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>1619.删除某些元素后的数组均值(2)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。
与 标准答案 误差在 10-5 的结果都被视为正确结果。
示例 1：输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] 输出：2.00000
解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。
示例 2：输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] 输出：4.00000
示例 3：输入：arr =[6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,
3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
输出：4.77778
示例 4：输入：arr =[9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,
7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]
输出：5.27778
示例 5：输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,
9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,
7,2,10,7,7,8,2,0,1,1]
输出：5.29167
提示：20 &lt;= arr.length &lt;= 1000
arr.length 是 20 的 倍数 
0 &lt;= arr[i] &lt;= 105
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func trimMean(arr []int) float64 {
	temp := make([]float64, 0)
	for i := 0; i &lt; len(arr); i++ {
		temp = append(temp, float64(arr[i]))
	}
	sort.Float64s(temp)
	var sum float64
	count := int(float64(len(arr)) * 0.05)
	for i := count; i &lt; len(temp)-count; i++ {
		sum = sum + temp[i]
	}
	return sum / float64(len(arr)-2*count)
}

# 2
func trimMean(arr []int) float64 {
	n := len(arr)
	count := n / 20
	sort.Ints(arr)
	sum := 0
	for i := count; i &lt; n-count; i++ {
		sum += arr[i]
	}
	return float64(sum) / float64(n-2*count)
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>1624.两个相同字符之间的最长子字符串(2)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。
如果不存在这样的子字符串，返回 -1 。
子字符串 是字符串中的一个连续字符序列。
示例 1：输入：s = &quot;aa&quot; 输出：0
解释：最优的子字符串是两个 &#39;a&#39; 之间的空子字符串。
示例 2：输入：s = &quot;abca&quot; 输出：2
解释：最优的子字符串是 &quot;bc&quot; 。
示例 3：输入：s = &quot;cbzxy&quot; 输出：-1
解释：s 中不存在出现出现两次的字符，所以返回 -1 。
示例 4：输入：s = &quot;cabbac&quot; 输出：4
解释：最优的子字符串是 &quot;abba&quot; ，其他的非最优解包括 &quot;bb&quot; 和 &quot;&quot; 。
提示：1 &lt;= s.length &lt;= 300  s 只含小写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxLengthBetweenEqualCharacters(s string) int {
	m := make(map[byte]int)
	res := -1
	for i := 0; i &lt; len(s); i++ {
		if value, ok := m[s[i]]; ok {
			res = max(res, i-value-1)
		} else {
			m[s[i]] = i
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maxLengthBetweenEqualCharacters(s string) int {
	res := -1
	for i := 0; i &lt; len(s); i++ {
		for j := i + 1; j &lt; len(s); j++ {
			if s[i] == s[j] {
				res = max(res, j-i-1)
			}
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>1629.按键持续时间最长的键(1)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。
给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。
releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。
字符串和数组的 下标都从 0 开始 。
第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。
测试人员想要找出按键 持续时间最长 的键。
第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，
第 0 次按键的持续时间为 releaseTimes[0] 。
注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。
请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。
示例 1：输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot; 输出：&quot;c&quot;
解释：按键顺序和持续时间如下：
按下 &#39;c&#39; ，持续时间 9（时间 0 按下，时间 9 松开）
按下 &#39;b&#39; ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）
按下 &#39;c&#39; ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）
按下 &#39;d&#39; ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）
按键持续时间最长的键是 &#39;b&#39; 和 &#39;c&#39;（第二次按下时），持续时间都是 20
&#39;c&#39; 按字母顺序排列比 &#39;b&#39; 大，所以答案是 &#39;c&#39;
示例 2：输入：releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot; 输出：&quot;a&quot;
解释：按键顺序和持续时间如下：
按下 &#39;s&#39; ，持续时间 12
按下 &#39;p&#39; ，持续时间 23 - 12 = 11
按下 &#39;u&#39; ，持续时间 36 - 23 = 13
按下 &#39;d&#39; ，持续时间 46 - 36 = 10
按下 &#39;a&#39; ，持续时间 62 - 46 = 16
按键持续时间最长的键是 &#39;a&#39; ，持续时间 16
提示： releaseTimes.length == n
    keysPressed.length == n
    2 &lt;= n &lt;= 1000
    0 &lt;= releaseTimes[i] &lt;= 109
    releaseTimes[i] &lt; releaseTimes[i+1]
    keysPressed 仅由小写英文字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">slowestKey</span><span class="p">(</span><span class="nx">releaseTimes</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">keysPressed</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="nx">releaseTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">releaseTimes</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">releaseTimes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="nx">releaseTimes</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
			<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">releaseTimes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">releaseTimes</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">releaseTimes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="nx">releaseTimes</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">maxValue</span> <span class="o">&amp;&amp;</span>
			<span class="nx">keysPressed</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">keysPressed</span><span class="p">[</span><span class="nx">res</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">keysPressed</span><span class="p">[</span><span class="nx">res</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>1636.按照频率将数组升序排序(1)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。
如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 
请你返回排序后的数组。
示例 1：输入：nums = [1,1,2,2,2,3] 输出：[3,1,1,2,2,2]
解释：&#39;3&#39; 频率为 1，&#39;1&#39; 频率为 2，&#39;2&#39; 频率为 3 。
示例 2：输入：nums = [2,3,1,3,2] 输出：[1,3,3,2,2]
解释：&#39;2&#39; 和 &#39;3&#39; 频率都为 2 ，所以它们之间按照数值本身降序排序。
示例 3：输入：nums = [-1,1,-6,4,5,-6,1,4,1] 输出：[5,-1,4,4,-6,-6,1,1,1]
提示：1 &lt;= nums.length &lt;= 100
    -100 &lt;= nums[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>自定义排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">frequencySort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">})</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>1640.能否连接形成数组(2)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 arr ，数组中的每个整数 互不相同 。
另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。
请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。
如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。
示例 1：输入：arr = [85], pieces = [[85]]输出：true
示例 2：输入：arr = [15,88], pieces = [[88],[15]] 输出：true
解释：依次连接 [15] 和 [88]
示例 3：输入：arr = [49,18,16], pieces = [[16,18,49]] 输出：false
解释：即便数字相符，也不能重新排列 pieces[0]
示例 4：输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]] 输出：true
解释：依次连接 [91]、[4,64] 和 [78]
示例 5：输入：arr = [1,3,5,7], pieces = [[2,4,6,8]] 输出：false
提示：1 &lt;= pieces.length &lt;= arr.length &lt;= 100
    sum(pieces[i].length) == arr.length
    1 &lt;= pieces[i].length &lt;= arr.length
    1 &lt;= arr[i], pieces[i][j] &lt;= 100
    arr 中的整数 互不相同
    pieces 中的整数 互不相同（也就是说，如果将 pieces 扁平化成一维数组，数组中的所有整数互不相同）
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历标记</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func canFormArray(arr []int, pieces [][]int) bool {
	for i := 0; i &lt; len(pieces); i++ {
		value := pieces[i]
		length := len(value)
		flag := false
		for j := 0; j &lt; len(arr); j++ {
			if arr[j] == value[0] {
				flag = true
				for k := j; k &lt; j+length &amp;&amp; k &lt; len(arr); k++ {
					if arr[k] != value[k-j] {
						return false
					} else {
						arr[k] = 0
					}
				}
				break
			}
		}
		if flag == false {
			return false
		}
	}
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] != 0 {
			return false
		}
	}
	return true
}

# 2
func canFormArray(arr []int, pieces [][]int) bool {
	m := make(map[int]int)
	for i := 0; i &lt; len(arr); i++ {
		m[arr[i]] = i
	}
	for i := 0; i &lt; len(pieces); i++ {
		if _, ok := m[pieces[i][0]]; !ok {
			return false
		}
		for k := 0; k &lt; len(pieces[i])-1; k++ {
			if m[pieces[i][k+1]]-m[pieces[i][k]] != 1 {
				return false
			}
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>1646.获取生成数组中的最大值(1)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：
nums[0] = 0
nums[1] = 1
当 2 &lt;= 2 * i &lt;= n 时，nums[2 * i] = nums[i]
当 2 &lt;= 2 * i + 1 &lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]
返回生成数组 nums 中的 最大 值。
示例 1：输入：n = 7 输出：3
解释：根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
示例 2：输入：n = 2 输出：1
解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
示例 3：输入：n = 3 输出：2
解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
提示：0 &lt;= n &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">getMaximumGenerated</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>1652.拆炸弹(1)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。
为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。
如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。
如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。
如果 k == 0 ，将第 i 个数字用 0 替换。
由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。
给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！
示例 1：输入：code = [5,7,1,4], k = 3 输出：[12,10,16,13]
解释：每个数字都被接下来 3 个数字之和替换。
解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。
示例 2：输入：code = [1,2,3,4], k = 0 输出：[0,0,0,0]
解释：当 k 为 0 时，所有数字都被 0 替换。
示例 3：输入：code = [2,4,9,3], k = -2 输出：[12,5,6,13]
解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。
如果 k 是负数，那么和为 之前 的数字。
提示：n == code.length
1 &lt;= n &lt;= 100
1 &lt;= code[i] &lt;= 100
-(n - 1) &lt;= k &lt;= n - 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">decrypt</span><span class="p">(</span><span class="nx">code</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">code</span><span class="p">[(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span><span class="o">%</span><span class="nx">n</span><span class="p">]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">code</span><span class="p">[(</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span><span class="o">%</span><span class="nx">n</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sum</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="nx">x</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>1656.设计有序流(1)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。
不存在 id 相同的两个 (id, value) 对。
设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。
实现 OrderedStream 类：
OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。
String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：
如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，
并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。
否则，返回一个空列表。
示例：输入[&quot;OrderedStream&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;]
[[5], [3, &quot;ccccc&quot;], [1, &quot;aaaaa&quot;], [2, &quot;bbbbb&quot;], [5, &quot;eeeee&quot;], [4, &quot;ddddd&quot;]]
输出[null, [], [&quot;aaaaa&quot;], [&quot;bbbbb&quot;, &quot;ccccc&quot;], [], [&quot;ddddd&quot;, &quot;eeeee&quot;]]
解释: OrderedStream os= new OrderedStream(5);
os.insert(3, &quot;ccccc&quot;); // 插入 (3, &quot;ccccc&quot;)，返回 []
os.insert(1, &quot;aaaaa&quot;); // 插入 (1, &quot;aaaaa&quot;)，返回 [&quot;aaaaa&quot;]
os.insert(2, &quot;bbbbb&quot;); // 插入 (2, &quot;bbbbb&quot;)，返回 [&quot;bbbbb&quot;, &quot;ccccc&quot;]
os.insert(5, &quot;eeeee&quot;); // 插入 (5, &quot;eeeee&quot;)，返回 []
os.insert(4, &quot;ddddd&quot;); // 插入 (4, &quot;ddddd&quot;)，返回 [&quot;ddddd&quot;, &quot;eeeee&quot;]
提示：1 &lt;= n &lt;= 1000
1 &lt;= id &lt;= n
value.length == 5
value 仅由小写字母组成
每次调用 insert 都会使用一个唯一的 id
恰好调用 n 次 insert
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">OrderedStream</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">ptr</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">OrderedStream</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">OrderedStream</span><span class="p">{</span>
		<span class="nx">arr</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
		<span class="nx">ptr</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">OrderedStream</span><span class="p">)</span> <span class="nx">Insert</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">ptr</span> <span class="p">&lt;</span> <span class="nx">id</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">this</span><span class="p">.</span><span class="nx">ptr</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>1662.检查两个字符串数组是否相等(2)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。
数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。
示例 1：输入：word1 = [&quot;ab&quot;, &quot;c&quot;], word2 = [&quot;a&quot;, &quot;bc&quot;] 输出：true
解释：word1 表示的字符串为 &quot;ab&quot; + &quot;c&quot; -&gt; &quot;abc&quot;
word2 表示的字符串为 &quot;a&quot; + &quot;bc&quot; -&gt; &quot;abc&quot;
两个字符串相同，返回 true
示例 2：输入：word1 = [&quot;a&quot;, &quot;cb&quot;], word2 = [&quot;ab&quot;, &quot;c&quot;] 输出：false
示例 3：输入：word1  = [&quot;abc&quot;, &quot;d&quot;, &quot;defg&quot;], word2 = [&quot;abcddefg&quot;] 输出：true
提示：1 &lt;= word1.length, word2.length &lt;= 103
1 &lt;= word1[i].length, word2[i].length &lt;= 103
1 &lt;= sum(word1[i].length), sum(word2[i].length) &lt;= 103
word1[i] 和 word2[i] 由小写字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func arrayStringsAreEqual(word1 []string, word2 []string) bool {
	return strings.Join(word1,&quot;&quot;) == strings.Join(word2,&quot;&quot;)
}

# 2
func arrayStringsAreEqual(word1 []string, word2 []string) bool {
	str1 := &quot;&quot;
	str2 := &quot;&quot;
	for i := 0; i &lt; len(word1); i++ {
		str1 = str1 + word1[i]
	}
	for i := 0; i &lt; len(word2); i++ {
		str2 = str2 + word2[i]
	}
	return str1 == str2
}
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>1668.最大重复子字符串(1)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，
那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。
如果 word 不是 sequence 的子串，那么重复值 k 为 0 。
给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。
示例 1：输入：sequence = &quot;ababc&quot;, word = &quot;ab&quot; 输出：2
解释：&quot;abab&quot; 是 &quot;ababc&quot; 的子字符串。
示例 2：输入：sequence = &quot;ababc&quot;, word = &quot;ba&quot; 输出：1
解释：&quot;ba&quot; 是 &quot;ababc&quot; 的子字符串，但 &quot;baba&quot; 不是 &quot;ababc&quot; 的子字符串。
示例 3：输入：sequence = &quot;ababc&quot;, word = &quot;ac&quot; 输出：0
解释：&quot;ac&quot; 不是 &quot;ababc&quot; 的子字符串。
提示：1 &lt;= sequence.length &lt;= 100
1 &lt;= word.length &lt;= 100
sequence 和 word 都只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxRepeating</span><span class="p">(</span><span class="nx">sequence</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">word</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">sequence</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Repeat</span><span class="p">(</span><span class="nx">word</span><span class="p">,</span> <span class="nx">i</span><span class="p">))</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>1672.最富有客户的资产总量(1)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i位客户在第 j 家银行托管的资产数量。
返回最富有客户所拥有的 资产总量 。
客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。
示例 1：输入：accounts = [[1,2,3],[3,2,1]] 输出：6
解释：第 1 位客户的资产总量 = 1 + 2 + 3 = 6
第 2 位客户的资产总量 = 3 + 2 + 1 = 6
两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。
示例 2：输入：accounts = [[1,5],[7,3],[3,5]] 输出：10
解释：第 1 位客户的资产总量 = 6
第 2 位客户的资产总量 = 10 
第 3 位客户的资产总量 = 8
第 2 位客户是最富有的，资产总量是 10
示例 3：输入：accounts = [[2,8,7],[7,1,3],[1,9,5]] 输出：17
提示：m == accounts.length
n == accounts[i].length
1 &lt;= m, n &lt;= 50
1 &lt;= accounts[i][j] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maximumWealth</span><span class="p">(</span><span class="nx">accounts</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">accounts</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">accounts</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">accounts</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">sum</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="goal-2">
<h2>1678.设计Goal解析器(2)<a class="headerlink" href="#goal-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请你设计一个可以解释字符串 command 的 Goal 解析器 。
command 由 &quot;G&quot;、&quot;()&quot; 和/或 &quot;(al)&quot; 按某种顺序组成。
Goal 解析器会将 &quot;G&quot; 解释为字符串 &quot;G&quot;、&quot;()&quot; 解释为字符串 &quot;o&quot; ，&quot;(al)&quot; 解释为字符串 &quot;al&quot; 。
然后，按原顺序将经解释得到的字符串连接成一个字符串。
给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。
示例 1：输入：command = &quot;G()(al)&quot; 输出：&quot;Goal&quot;
解释：Goal 解析器解释命令的步骤如下所示：
G -&gt; G
() -&gt; o
(al) -&gt; al
最后连接得到的结果是 &quot;Goal&quot;
示例 2：输入：command = &quot;G()()()()(al)&quot; 输出：&quot;Gooooal&quot;
示例 3：输入：command = &quot;(al)G(al)()()G&quot; 输出：&quot;alGalooG&quot;
提示：1 &lt;= command.length &lt;= 100
command 由 &quot;G&quot;、&quot;()&quot; 和/或 &quot;(al)&quot; 按某种顺序组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func interpret(command string) string {
	command = strings.ReplaceAll(command, &quot;(al)&quot;, &quot;al&quot;)
	command = strings.ReplaceAll(command, &quot;()&quot;, &quot;o&quot;)
	return command
}

# 2
func interpret(command string) string {
	res := &quot;&quot;
	for i := 0; i &lt; len(command); {
		if command[i] == &#39;G&#39; {
			res = res + &quot;G&quot;
			i = i + 1
		} else if command[i] == &#39;(&#39; {
			if command[i+1] == &#39;)&#39; {
				res = res + &quot;o&quot;
				i = i + 2
			} else {
				res = res + &quot;al&quot;
				i = i + 4
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>1684.统计一致字符串的数目(1)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。
如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致 字符串。
请你返回 words 数组中 一致 字符串的数目。
示例 1：输入：allowed = &quot;ab&quot;, words = [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;] 输出：2
解释：字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#39;a&#39; 和 &#39;b&#39; 。
示例 2：输入：allowed = &quot;abc&quot;, words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;] 输出：7
解释：所有字符串都是一致的。
示例 3：输入：allowed = &quot;cad&quot;, words = [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;] 输出：4
解释：字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。
提示：1 &lt;= words.length &lt;= 104
1 &lt;= allowed.length &lt;= 26
1 &lt;= words[i].length &lt;= 10
allowed 中的字符 互不相同 。
words[i] 和 allowed 只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countConsistentStrings</span><span class="p">(</span><span class="nx">allowed</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">words</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allowed</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">allowed</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">words</span> <span class="p">{</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="kc">true</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">word</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>1688.比赛中的配对次数(2)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：
如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。
总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。
如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。
总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。
返回在比赛中进行的配对次数，直到决出获胜队伍为止。
示例 1：输入：n = 7 输出：6
解释：比赛详情：
- 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。
- 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。
- 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。
总配对次数 = 3 + 2 + 1 = 6
示例 2：输入：n = 14 输出：13
解释：比赛详情：
- 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。
- 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 
- 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。
- 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。
总配对次数 = 7 + 3 + 2 + 1 = 13
提示：1 &lt;= n &lt;= 200
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numberOfMatches(n int) int {
	res := 0
	for n &gt; 1 {
		res = res + n/2
		n = n/2 + n%2
	}
	return res
}

# 2
func numberOfMatches(n int) int {
	// 共有n个队伍,一个冠军,需要淘汰n-1个 队伍。
	// 每一场比赛淘汰一个队伍,因此进行了n-1场比赛。
	return n - 1
}
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>1694.重新格式化电话号码(1)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串形式的电话号码 number 。number 由数字、空格 &#39; &#39;、和破折号 &#39;-&#39; 组成。
请你按下述方式重新格式化电话号码。
首先，删除 所有的空格和破折号。
其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：
2 个数字：单个含 2 个数字的块。
3 个数字：单个含 3 个数字的块。
4 个数字：两个分别含 2 个数字的块。
最后用破折号将这些块连接起来。
注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。
返回格式化后的电话号码。
示例 1：输入：number = &quot;1-23-45 6&quot; 输出：&quot;123-456&quot;
解释：数字是 &quot;123456&quot;
步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 &quot;123&quot; 。
步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 &quot;456&quot; 。
连接这些块后得到 &quot;123-456&quot; 。
示例 2：输入：number = &quot;123 4-567&quot; 输出：&quot;123-45-67&quot;
解释：数字是 &quot;1234567&quot;.
步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 &quot;123&quot; 。
步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 &quot;45&quot; 和 &quot;67&quot; 。
连接这些块后得到 &quot;123-45-67&quot; 。
示例 3：输入：number = &quot;123 4-5678&quot; 输出：&quot;123-456-78&quot;
解释：数字是 &quot;12345678&quot; 。
步骤 1：第 1 个块 &quot;123&quot; 。
步骤 2：第 2 个块 &quot;456&quot; 。
步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 &quot;78&quot; 。
连接这些块后得到 &quot;123-456-78&quot; 。
示例 4：输入：number = &quot;12&quot; 输出：&quot;12&quot;
示例 5：输入：number = &quot;--17-5 229 35-39475 &quot; 输出：&quot;175-229-353-94-75&quot;
提示：2 &lt;= number.length &lt;= 100
number 由数字和字符 &#39;-&#39; 及 &#39; &#39; 组成。
number 中至少含 2 个数字。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">reformatNumber</span><span class="p">(</span><span class="nx">number</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ReplaceAll</span><span class="p">(</span><span class="nx">number</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
	<span class="nx">str</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ReplaceAll</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">str</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span>
		<span class="nx">str</span> <span class="p">=</span> <span class="nx">str</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">str</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">str</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>1700.无法吃午餐的学生数量(1)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。
所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：
如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。
否则，这名学生会 放弃这个三明治 并回到队列的尾部。
这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。
给你两个整数数组 students 和 sandwiches ，
其中 sandwiches[i] 是栈里面第 i个三明治的类型（i = 0 是栈的顶部）， 
students[j] 是初始队列里第 j名学生对三明治的喜好（j = 0 是队列的最开始位置）。
请你返回无法吃午餐的学生数量。
示例 1：输入：students = [1,1,0,0], sandwiches = [0,1,0,1] 输出：0 
解释：- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，
三明治栈为 sandwiches = [1,0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。
所以所有学生都有三明治吃。
示例 2：输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1] 输出：3
提示：1 &lt;= students.length, sandwiches.length &lt;= 100
students.length == sandwiches.length
sandwiches[i] 要么是 0 ，要么是 1 。
students[i] 要么是 0 ，要么是 1 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countStudents</span><span class="p">(</span><span class="nx">students</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">sandwiches</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">students</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">students</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">a</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">b</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sandwiches</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">sandwiches</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">a</span><span class="o">--</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">sandwiches</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span><span class="o">--</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>1601-1700-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id19">
<h2>1604.警告一小时内使用相同员工卡大于等于三次的人(2)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>力扣公司的员工都使用员工卡来开办公室的门。
每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。
如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。
给你字符串数组 keyName 和 keyTime ，
其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。
使用时间的格式是 24小时制 ，形如 &quot;HH:MM&quot; ，比方说 &quot;23:51&quot; 和 &quot;09:49&quot; 。
请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。
请注意 &quot;10:00&quot; - &quot;11:00&quot; 视为一个小时时间范围内，
而 &quot;23:51&quot; - &quot;00:10&quot; 不被视为一小时内，因为系统记录的是某一天内的使用情况。
示例 1：输入：keyName = [&quot;daniel&quot;,&quot;daniel&quot;,&quot;daniel&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;], 
keyTime = [&quot;10:00&quot;,&quot;10:40&quot;,&quot;11:00&quot;,&quot;09:00&quot;,&quot;11:00&quot;,&quot;13:00&quot;,&quot;15:00&quot;]
输出：[&quot;daniel&quot;]
解释：&quot;daniel&quot; 在一小时内使用了 3 次员工卡（&quot;10:00&quot;，&quot;10:40&quot;，&quot;11:00&quot;）。
示例 2：输入：keyName = [&quot;alice&quot;,&quot;alice&quot;,&quot;alice&quot;,&quot;bob&quot;,&quot;bob&quot;,&quot;bob&quot;,&quot;bob&quot;], 
keyTime = [&quot;12:01&quot;,&quot;12:00&quot;,&quot;18:00&quot;,&quot;21:00&quot;,&quot;21:20&quot;,&quot;21:30&quot;,&quot;23:00&quot;]
输出：[&quot;bob&quot;]
解释：&quot;bob&quot; 在一小时内使用了 3 次员工卡（&quot;21:00&quot;，&quot;21:20&quot;，&quot;21:30&quot;）。
示例 3：输入：keyName = [&quot;john&quot;,&quot;john&quot;,&quot;john&quot;], keyTime = [&quot;23:58&quot;,&quot;23:59&quot;,&quot;00:01&quot;]
输出：[]
示例 4：输入：keyName = [&quot;leslie&quot;,&quot;leslie&quot;,&quot;leslie&quot;,&quot;clare&quot;,&quot;clare&quot;,&quot;clare&quot;,&quot;clare&quot;], 
keyTime = [&quot;13:00&quot;,&quot;13:20&quot;,&quot;14:00&quot;,&quot;18:00&quot;,&quot;18:51&quot;,&quot;19:30&quot;,&quot;19:49&quot;]
输出：[&quot;clare&quot;,&quot;leslie&quot;]
提示：1 &lt;= keyName.length, keyTime.length &lt;= 105
    keyName.length == keyTime.length
    keyTime 格式为 &quot;HH:MM&quot; 。
    保证 [keyName[i], keyTime[i]] 形成的二元对 互不相同 。
    1 &lt;= keyName[i].length &lt;= 10
    keyName[i] 只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希+排序+遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希+排序+滑动窗口</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func alertNames(keyName []string, keyTime []string) []string {
	m := make(map[string][]int)
	for i := 0; i &lt; len(keyName); i++ {
		m[keyName[i]] = append(m[keyName[i]], strToInt(keyTime[i]))
	}
	res := make([]string, 0)
	for k, v := range m {
		sort.Ints(v)
		first := v[0]
		second := v[0]
		count := 1
		for i := 1; i &lt; len(v); i++ {
			if v[i] &gt; first &amp;&amp; v[i]-first &lt;= 60 {
				second = v[i]
				count++
			} else {
				first = second
				second = v[i]
				count = 2
			}
			if count &gt;= 3 {
				res = append(res, k)
				break
			}
		}
	}
	sort.Strings(res)
	return res
}

func strToInt(str string) int {
	arr := strings.Split(str, &quot;:&quot;)
	hour, _ := strconv.Atoi(arr[0])
	minute, _ := strconv.Atoi(arr[1])
	return hour*60 + minute
}

# 2
func alertNames(keyName []string, keyTime []string) []string {
	m := make(map[string][]int)
	for i := 0; i &lt; len(keyName); i++ {
		m[keyName[i]] = append(m[keyName[i]], strToInt(keyTime[i]))
	}
	res := make([]string, 0)
	for k, v := range m {
		sort.Ints(v)
		for i := 0; i &lt; len(v)-2; i++ {
			if v[i+2]-v[i] &lt;= 60 {
				res = append(res, k)
				break
			}
		}
	}
	sort.Strings(res)
	return res
}

func strToInt(str string) int {
	arr := strings.Split(str, &quot;:&quot;)
	hour, _ := strconv.Atoi(arr[0])
	minute, _ := strconv.Atoi(arr[1])
	return hour*60 + minute
}
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>1605.给定行和列的和求可行矩阵(1)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， 
colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。
请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，
且该矩阵满足 rowSum 和 colSum 的要求。
请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。
示例 1：输入：rowSum = [3,8], colSum = [4,7] 输出：[[3,0],
      [1,7]]
解释：第 0 行：3 + 0 = 0 == rowSum[0]
第 1 行：1 + 7 = 8 == rowSum[1]
第 0 列：3 + 1 = 4 == colSum[0]
第 1 列：0 + 7 = 7 == colSum[1]
行和列的和都满足题目要求，且所有矩阵元素都是非负的。
另一个可行的矩阵为：[[1,2],
                  [3,5]]
示例 2：输入：rowSum = [5,7,10], colSum = [8,6,8] 
输出：[[0,5,0],
      [6,1,0],
      [2,0,8]]
示例 3：输入：rowSum = [14,9], colSum = [6,9,8]
输出：[[0,9,5],
      [6,0,3]]
示例 4：输入：rowSum = [1,0], colSum = [1]
输出：[[1],
      [0]]
示例 5：输入：rowSum = [0], colSum = [0]
输出：[[0]]
提示：1 &lt;= rowSum.length, colSum.length &lt;= 500
    0 &lt;= rowSum[i], colSum[i] &lt;= 108
    sum(rows) == sum(columns)
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">restoreMatrix</span><span class="p">(</span><span class="nx">rowSum</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">colSum</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rowSum</span><span class="p">)</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">colSum</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">value</span> <span class="o">:=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">rowSum</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">colSum</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
			<span class="nx">rowSum</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rowSum</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">value</span>
			<span class="nx">colSum</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">colSum</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="nx">value</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>1609.奇偶树(1)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
    二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
    偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
    奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。
示例 1：输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出：true
解释：每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，
因此这是一棵奇偶树。
示例 2：输入：root = [5,4,2,3,3,7] 输出：false
解释：每一层的节点值分别是：
0 层：[5]
1 层：[4,2]
2 层：[3,3,7]
2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。
示例 3：输入：root = [5,9,1,3,5,7] 输出：false
解释：1 层上的节点值应为偶数。
示例 4：输入：root = [1]输出：true
示例 5：输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17] 输出：true
提示：树中节点数在范围 [1, 105] 内
    1 &lt;= Node.val &lt;= 106
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>层序遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">isEvenOddTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
	<span class="nx">level</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">temp</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Val</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">level</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">temp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">temp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">j</span><span class="p">],</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="nx">level</span><span class="o">%</span><span class="mi">2</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">length</span><span class="p">:]</span>
		<span class="nx">level</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>1615.最大网络秩(1)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。
每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。
两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。
如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。
整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。
给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。
示例 1：输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] 输出：4
解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。
位于 0 和 1 之间的道路只计算一次。
示例 2：输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5
解释：共有 5 条道路与城市 1 或 2 相连。
示例 3：输入：n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] 输出：5
解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。
提示：2 &lt;= n &lt;= 100
0 &lt;= roads.length &lt;= n * (n - 1) / 2
roads[i].length == 2
0 &lt;= ai, bi &lt;= n-1
ai != bi
每对城市之间 最多只有一条 道路相连
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maximalNetworkRank</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">roads</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">roads</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">roads</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">roads</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">a</span><span class="o">*</span><span class="mi">100</span><span class="o">+</span><span class="nx">b</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">b</span><span class="o">*</span><span class="mi">100</span><span class="o">+</span><span class="nx">a</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">value</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="mi">100</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">value</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">value</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>1616.分割两个字符串得到回文串<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<div class="section" id="id24">
<h3>题目<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。
由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，
同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。
请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。
当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。
比方说， s = &quot;abc&quot; 那么 &quot;&quot; + &quot;abc&quot; ， &quot;a&quot; + &quot;bc&quot; ， &quot;ab&quot; + &quot;c&quot; 和 &quot;abc&quot; + &quot;&quot; 都是合法分割。
如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。
请注意， x + y 表示连接字符串 x 和 y 。
示例 1：输入：a = &quot;x&quot;, b = &quot;y&quot; 输出：true
解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：
aprefix = &quot;&quot;, asuffix = &quot;x&quot;
bprefix = &quot;&quot;, bsuffix = &quot;y&quot;
那么 aprefix + bsuffix = &quot;&quot; + &quot;y&quot; = &quot;y&quot; 是回文串。
示例 2：输入：a = &quot;ulacfd&quot;, b = &quot;jizalu&quot; 输出：true
解释：在下标为 3 处分割：
aprefix = &quot;ula&quot;, asuffix = &quot;cfd&quot;
bprefix = &quot;jiz&quot;, bsuffix = &quot;alu&quot;
那么 aprefix + bsuffix = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot; 是回文串。
提示：1 &lt;= a.length, b.length &lt;= 105
    a.length == b.length
    a 和 b 都只包含小写英文字母
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h3>解题思路<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>1620.网络信号最好的坐标(1)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个数组 towers 和一个整数 radius ，数组中包含一些网络信号塔，
其中 towers[i] = [xi, yi, qi] 表示第 i 个网络信号塔的坐标是 (xi, yi) 且信号强度参数为 qi 。
所有坐标都是在  X-Y 坐标系内的 整数 坐标。两个坐标之间的距离用 欧几里得距离 计算。
整数 radius 表示一个塔 能到达 的 最远距离 。
如果一个坐标跟塔的距离在 radius 以内，那么该塔的信号可以到达该坐标。
在这个范围以外信号会很微弱，所以 radius 以外的距离该塔是 不能到达的 。
如果第 i 个塔能到达 (x, y) ，那么该塔在此处的信号为 ⌊qi / (1 + d)⌋ ，其中 d 是塔跟此坐标的距离。
一个坐标的 网络信号 是所有 能到达 该坐标的塔的信号强度之和。
请你返回 网络信号 最大的整数坐标点。如果有多个坐标网络信号一样大，请你返回字典序最小的一个坐标。
注意：坐标 (x1, y1) 字典序比另一个坐标 (x2, y2) 小：要么 x1 &lt; x2 ，要么 x1 == x2 且 y1 &lt; y2 。
⌊val⌋ 表示小于等于 val 的最大整数（向下取整函数）。
示例 1：输入：towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2 输出：[2,1]
解释：坐标 (2, 1) 信号强度之和为 13
- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7
- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2
- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4
没有别的坐标有更大的信号强度。
示例 2：输入：towers = [[23,11,21]], radius = 9 输出：[23,11]
示例 3：输入：towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2 输出：[1,2]
示例 4：输入：towers = [[2,1,9],[0,1,9]], radius = 2 输出：[0,1]
解释：坐标 (0, 1) 和坐标 (2, 1) 都是强度最大的位置，但是 (0, 1) 字典序更小。
提示：1 &lt;= towers.length &lt;= 50
towers[i].length == 3
0 &lt;= xi, yi, qi &lt;= 50
1 &lt;= radius &lt;= 50
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">bestCoordinate</span><span class="p">(</span><span class="nx">towers</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">radius</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">towers</span><span class="p">);</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">towers</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">towers</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nx">towers</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
				<span class="nx">d</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">b</span><span class="o">-</span><span class="nx">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">b</span><span class="o">-</span><span class="nx">j</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="nx">radius</span><span class="o">*</span><span class="nx">radius</span> <span class="p">{</span>
					<span class="nx">value</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">d</span><span class="p">)))</span>
					<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Floor</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
				<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">sum</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-2">
<h2>1621.大小为K的不重叠线段的数目(2)<a class="headerlink" href="#k-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一维空间的 n 个点，其中第 i 个点（编号从 0 到 n-1）位于 x = i 处，
请你找到 恰好 k 个不重叠 线段且每个线段至少覆盖两个点的方案数。
线段的两个端点必须都是 整数坐标 。
这 k 个线段不需要全部覆盖全部 n 个点，且它们的端点 可以 重合。
请你返回 k 个不重叠线段的方案数。由于答案可能很大，请将结果对 109 + 7 取余 后返回。
示例 1：输入：n = 4, k = 2 输出：5
解释：如图所示，两个线段分别用红色和蓝色标出。
上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，
{(1,2),(2,3)}，{(0,1),(1,2)} 。
示例 2：输入：n = 3, k = 1 输出：3
解释：总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。
示例 3：输入：n = 30, k = 7 输出：796297179
解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。
示例 4：输入：n = 5, k = 3 输出：7
示例 5：输入：n = 3, k = 2 输出：1
提示：2 &lt;= n &lt;= 1000
1 &lt;= k &lt;= n-1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>数学-组合</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var mod = 1000000007

func numberOfSets(n int, k int) int {
	dp := make([][][2]int, n)
	// dp[i][j][0] =&gt;0到i的点，构造成j条线段的方案数, 第j条线段的右端点没有使用i
	// dp[i][j][1] =&gt;0到i的点，构造成j条线段的方案数, 第j条线段的右端点使用i
	for i := 0; i &lt; n; i++ {
		dp[i] = make([][2]int, n)
	}
	dp[0][0][0] = 1
	for i := 1; i &lt; n; i++ {
		for j := 0; j &lt;= k; j++ {
			dp[i][j][0] = (dp[i-1][j][0] + dp[i-1][j][1]) % mod // 没有使用i
			dp[i][j][1] = dp[i-1][j][1]                         // 使用i：扩展右侧
			if j &gt; 0 {
				dp[i][j][1] = (dp[i][j][1] + dp[i-1][j-1][0] + dp[i-1][j-1][1]) % mod // 使用i：新开一个
			}
		}
	}
	return (dp[n-1][k][0] + dp[n-1][k][1]) % mod
}

# 2

# 2
var mod = 1000000007

func numberOfSets(n int, k int) int {
	// 共享k-1个点+n个点 =&gt; n+k-1个点
	// 共 n+k−1 个数中选择 2k 个
	return C(n+k-1, 2*k)
}

func C(n, m int) int {
	a := multiMod(n, n-m+1)
	b := multiMod(m, 1)
	return a * powMod(b, mod-2) % mod
}

func multiMod(n, m int) int {
	res := 1
	for i := m; i &lt;= n; i++ {
		res = (res * i) % mod
	}
	return res
}

func powMod(a, b int) int {
	res := 1
	for b &gt; 0 {
		if b%2 == 1 {
			res = (res * a) % mod
		}
		a = a * a % mod
		b = b / 2
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>1625.执行操作后字典序最小的字符串(2)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。
你可以在 s 上按任意顺序多次执行下面两个操作之一：
累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。
例如，s = &quot;3456&quot; 且 a = 5，则执行此操作后 s 变成 &quot;3951&quot;。
轮转：将 s 向右轮转 b 位。例如，s = &quot;3456&quot; 且 b = 1，则执行此操作后 s 变成 &quot;6345&quot;。
请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。
如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：
在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符出现在字母表中的时间早于 b 中的对应字符。
例如，&quot;0158” 字典序比 &quot;0190&quot; 小，因为不同的第一个位置是在第三个字符，显然 &#39;5&#39; 出现在 &#39;9&#39; 之前。
示例 1：输入：s = &quot;5525&quot;, a = 9, b = 2 输出：&quot;2050&quot;
解释：执行操作如下：
初态：&quot;5525&quot;
轮转：&quot;2555&quot;
累加：&quot;2454&quot;
累加：&quot;2353&quot;
轮转：&quot;5323&quot;
累加：&quot;5222&quot;
累加：&quot;5121&quot;
轮转：&quot;2151&quot;
累加：&quot;2050&quot;
无法获得字典序小于 &quot;2050&quot; 的字符串。
示例 2：输入：s = &quot;74&quot;, a = 5, b = 1 输出：&quot;24&quot;
解释：执行操作如下：
初态：&quot;74&quot;
轮转：&quot;47&quot;
累加：&quot;42&quot;
轮转：&quot;24&quot;
无法获得字典序小于 &quot;24&quot; 的字符串。
示例 3：输入：s = &quot;0011&quot;, a = 4, b = 2 输出：&quot;0011&quot;
解释：无法获得字典序小于 &quot;0011&quot; 的字符串。
示例 4：输入：s = &quot;43987654&quot;, a = 7, b = 3 输出：&quot;00553311&quot;
提示：2 &lt;= s.length &lt;= 100
s.length 是偶数
s 仅由数字 0 到 9 组成
1 &lt;= a &lt;= 9
1 &lt;= b &lt;= s.length - 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var m map[string]bool
var res string

func findLexSmallestString(s string, a int, b int) string {
	res = s
	m = make(map[string]bool)
	dfs(s, a, b)
	return res
}

func dfs(s string, a, b int) {
	if m[s] == true {
		return
	}
	m[s] = true
	if s &lt; res {
		res = s
	}
	dfs(add(s, a), a, b)
	dfs(s[b:]+s[:b], a, b)
}

func add(s string, a int) string {
	res := []byte(s)
	for i := 1; i &lt; len(s); i = i + 2 {
		res[i] = byte(&#39;0&#39; + (int(s[i]-&#39;0&#39;)+a)%10)
	}
	return string(res)
}

# 2
func findLexSmallestString(s string, a int, b int) string {
	res := s
	m := make(map[string]bool)
	queue := make([]string, 0)
	queue = append(queue, s)
	for len(queue) &gt; 0 {
		str := queue[0]
		queue = queue[1:]
		if m[str] == true {
			continue
		}
		m[str] = true
		if str &lt; res {
			res = str
		}
		queue = append(queue, str[b:]+str[:b])
		queue = append(queue, add(str, a))
	}
	return res
}

func add(s string, a int) string {
	res := []byte(s)
	for i := 1; i &lt; len(s); i = i + 2 {
		res[i] = byte(&#39;0&#39; + (int(s[i]-&#39;0&#39;)+a)%10)
	}
	return string(res)
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>1626.无矛盾的最佳球队(1)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。
球队的得分是球队中所有球员的分数 总和 。
然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。
如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。
给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。
请你返回 所有可能的无矛盾球队中得分最高那支的分数 。
示例 1：输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5] 输出：34
解释：你可以选中所有球员。
示例 2：输入：scores = [4,5,6,5], ages = [2,1,2,1] 输出：16
解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。
示例 3：输入：scores = [1,2,3,5], ages = [8,9,10,1] 输出：6
解释：最佳的选择是前 3 名球员。
提示： 1 &lt;= scores.length, ages.length &lt;= 1000
    scores.length == ages.length
    1 &lt;= scores[i] &lt;= 10^6
    1 &lt;= ages[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">bestTeamScore</span><span class="p">(</span><span class="nx">scores</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">ages</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ages</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">ages</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]})</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>1630.等差子数组(1)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。
更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] == s[1] - s[0] 都成立。
例如，下面这些都是 等差数列 ：
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
下面的数列 不是等差数列 ：
1, 1, 2, 5, 7
给你一个由 n 个整数组成的数组 nums，和两个由 m 个整数组成的数组 l 和 r，后两个数组表示 m 组范围查询，
其中第 i 个查询对应范围 [l[i], r[i]] 。所有数组的下标都是 从 0 开始 的。
返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], ... , 
nums[r[i]] 可以 重新排列 形成 等差数列 ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。
示例 1：输入：nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5] 输出：[true,false,true]
解释：第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。
第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。
第 2 个查询，对应子数组 [5,9,3,7] 。可以重新排列为等差数列 [3,5,7,9] 。
示例 2：输入：nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], 
l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
输出：[false,true,false,false,true,true]
提示：n == nums.length
    m == l.length
    m == r.length
    2 &lt;= n &lt;= 500
    1 &lt;= m &lt;= 500
    0 &lt;= l[i] &lt; r[i] &lt; n
    -105 &lt;= nums[i] &lt;= 105
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(n^2*log(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">checkArithmeticSubarrays</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">l</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">r</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">l</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="kc">true</span>
		<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">l</span><span class="p">[</span><span class="nx">i</span><span class="p">]:</span><span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">flag</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>1637.两点之间不包含任何点的最宽垂直面积(1)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，
请你返回两点之间内部不包含任何点的 最宽垂直面积 的宽度。
垂直面积 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。
最宽垂直面积 为宽度最大的一个垂直面积。
请注意，垂直区域 边上 的点 不在 区域内。
示例 1：输入：points = [[8,7],[9,9],[7,4],[9,7]] 输出：1
解释：红色区域和蓝色区域都是最优区域。
示例 2：输入：points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] 输出：3
提示： n == points.length
    2 &lt;= n &lt;= 105
    points[i].length == 2
    0 &lt;= xi, yi &lt;= 109
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxWidthOfVerticalArea</span><span class="p">(</span><span class="nx">points</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">points</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>1638.统计只差一个字符的子串数目(3)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，
是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。
比方说， &quot;computer&quot; 和 &quot;computation&quot; 加粗部分只有一个字符不同： 
&#39;e&#39;/&#39;a&#39; ，所以这一对子字符串会给答案加 1 。
请你返回满足上述条件的不同子字符串对数目。
一个 子字符串 是一个字符串中连续的字符。
示例 1：输入：s = &quot;aba&quot;, t = &quot;baba&quot; 输出：6
解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：
(&quot;aba&quot;, &quot;baba&quot;)
(&quot;aba&quot;, &quot;baba&quot;)
(&quot;aba&quot;, &quot;baba&quot;)
(&quot;aba&quot;, &quot;baba&quot;)
(&quot;aba&quot;, &quot;baba&quot;)
(&quot;aba&quot;, &quot;baba&quot;)
加粗部分分别表示 s 和 t 串选出来的子字符串。
示例 2：输入：s = &quot;ab&quot;, t = &quot;bb&quot; 输出：3
解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：
(&quot;ab&quot;, &quot;bb&quot;)
(&quot;ab&quot;, &quot;bb&quot;)
(&quot;ab&quot;, &quot;bb&quot;)
加粗部分分别表示 s 和 t 串选出来的子字符串。
示例 3：输入：s = &quot;a&quot;, t = &quot;a&quot; 输出：0
示例 4：输入：s = &quot;abe&quot;, t = &quot;bbc&quot; 输出：10
提示：1 &lt;= s.length, t.length &lt;= 100
    s 和 t 都只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^3)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^4)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func countSubstrings(s string, t string) int {
	res := 0
	for i := 0; i &lt; len(s); i++ {
		for j := 0; j &lt; len(t); j++ {
			diff := 0
			for k := 0; i+k &lt; len(s) &amp;&amp; j+k &lt; len(t); k++ {
				if s[i+k] != t[j+k] {
					diff++
				}
				if diff &gt; 1 {
					break
				}
				if diff == 1 {
					res++
				}
			}
		}
	}
	return res
}

# 2
func countSubstrings(s string, t string) int {
	res := 0
	for i := 0; i &lt; len(s); i++ {
		for j := i + 1; j &lt;= len(s); j++ {
			length := j - i
			newStr := s[i:j]
			for k := 0; k &lt;= len(t)-length; k++ {
				b := t[k : k+length]
				if compare(newStr, b) {
					res++
				}
			}
		}
	}
	return res
}

func compare(a, b string) bool {
	count := 0
	for i := 0; i &lt; len(a); i++ {
		if a[i] != b[i] {
			count++
		}
		if count &gt;= 2 {
			return false
		}
	}
	if count == 0 {
		return false
	}
	return true
}

# 3
func countSubstrings(s, t string) int {
	res := 0
	m, n := len(s), len(t)
	// dp以s[i]和t[j]结尾的所有子串对中，满足恰好只有一个字符不同的字符串对的数目
	dp := make([][]int, m+1)
	for i := 0; i &lt;= m; i++ {
		dp[i] = make([]int, n+1)
	}
	// 以s[i]和t[j]为结尾的子串，最多有多少个连续相同的字符
	same := make([][]int, m+1)
	for i := 0; i &lt;= m; i++ {
		same[i] = make([]int, n+1)
	}
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if s[i] == t[j] {
				dp[i+1][j+1] = dp[i+1][j+1] + dp[i][j]
				same[i+1][j+1] = same[i][j] + 1
			} else {
				dp[i+1][j+1] = same[i][j] + 1
			}
			res = res + dp[i+1][j+1]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>1641.统计字典序元音字符串的数目(3)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。
字符串 s 按 字典序排列 需要满足：对于所有有效的 i，
s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。
示例 1：输入：n = 1 输出：5
解释：仅由元音组成的 5 个字典序字符串为 [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;]
示例 2：输入：n = 2 输出：15
解释：仅由元音组成的 15 个字典序字符串为
[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;]
注意，&quot;ea&quot; 不是符合题意的字符串，因为 &#39;e&#39; 在字母表中的位置比 &#39;a&#39; 靠后
示例 3：输入：n = 33 输出：66045
提示：1 &lt;= n &lt;= 50 
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func countVowelStrings(n int) int {
	dp := make([][5]int, n+1)
	dp[0][0], dp[0][1], dp[0][2], dp[0][3], dp[0][4] = 1, 1, 1, 1, 1
	for i := 1; i &lt;= n; i++ {
		for j := 0; j &lt; 5; j++ {
			for k := 0; k &lt;= j; k++ {
				dp[i][j] = dp[i][j] + dp[i-1][k]
			}
		}
	}
	res := 0
	for i := 0; i &lt; 5; i++ {
		res = res + dp[n-1][i]
	}
	return res
}

# 2
func countVowelStrings(n int) int {
	dp := make([]int, 5)
	dp[0] = 1
	for i := 0; i &lt; n; i++ {
		for j := 1; j &lt; 5; j++ {
			dp[j] = dp[j] + dp[j-1]
		}
	}
	res := 0
	for i := 0; i &lt; 5; i++ {
		res = res + dp[i]
	}
	return res
}

# 3
// 将n个小球放到m个盒子里，盒子可以空：C(n+m-1, m-1) m=5 =&gt; C(n+4,4)
// 在n+4中选择4个整数(4*3*2)
func countVowelStrings(n int) int {
	return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24
}
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>1642.可以到达的最远建筑(2)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 bricks 和梯子 ladders 。
你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。
当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时：
如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块
如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块
如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。
示例 1：输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 输出：4
解释：从建筑物 0 出发，你可以按此方案完成旅程：
- 不使用砖块或梯子到达建筑物 1 ，因为 4 &gt;= 2
- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 &lt; 7
- 不使用砖块或梯子到达建筑物 3 ，因为 7 &gt;= 6
- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 &lt; 9
无法越过建筑物 4 ，因为没有更多砖块或梯子。
示例 2：输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 输出：7
示例 3：输入：heights = [14,3,19,3], bricks = 17, ladders = 0 输出：3
提示：1 &lt;= heights.length &lt;= 105
1 &lt;= heights[i] &lt;= 106
0 &lt;= bricks &lt;= 109
0 &lt;= ladders &lt;= heights.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(nlog(n)^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func furthestBuilding(heights []int, bricks int, ladders int) int {
	if len(heights) &lt;= 1 {
		return 0
	}
	intHeap := &amp;IntHeap{}
	heap.Init(intHeap)
	need := 0
	for i := 1; i &lt; len(heights); i++ {
		need = heights[i] - heights[i-1]
		if need &lt;= 0 {
			continue
		}
		heap.Push(intHeap, need)
		if intHeap.Len() &gt; ladders {
			need = heap.Pop(intHeap).(int)
			if need &gt; bricks {
				return i - 1
			}
			bricks = bricks - need
		}
	}
	return len(heights) - 1
}

type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

func (h IntHeap) Less(i, j int) bool {
	return h[i] &lt; h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
func furthestBuilding(heights []int, bricks int, ladders int) int {
	left, right := 0, len(heights)
	res := 0
	for left &lt;= right {
		mid := left + (right-left)/2
		if check(heights[0:mid], bricks, ladders) {
			left = mid + 1
			res = mid
		} else {
			right = mid - 1
		}
	}
	return res - 1
}

func check(heights []int, bricks int, ladders int) bool {
	arr := make([]int, 0)
	for i := 1; i &lt; len(heights); i++ {
		need := heights[i] - heights[i-1]
		if need &gt; 0 {
			arr = append(arr, need)
		}
	}
	sort.Ints(arr)
	i := 0
	for ; i &lt; len(arr); i++ {
		if bricks-arr[i] &gt;= 0 {
			bricks = bricks - arr[i]
			continue
		}
		if ladders &gt; 0 {
			ladders--
			continue
		}
		break
	}
	return i == len(arr)
}
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>1647.字符频次唯一的最小删除次数(1)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果字符串 s 中 不存在 两个不同字符 频次 相同的情况，就称 s 是 优质字符串 。
给你一个字符串 s，返回使 s 成为 优质字符串 需要删除的 最小 字符数。
字符串中字符的 频次 是该字符在字符串中的出现次数。
例如，在字符串 &quot;aab&quot; 中，&#39;a&#39; 的频次是 2，而 &#39;b&#39; 的频次是 1 。
示例 1：输入：s = &quot;aab&quot; 输出：0
解释：s 已经是优质字符串。
示例 2：输入：s = &quot;aaabbbcc&quot; 输出：2
解释：可以删除两个 &#39;b&#39; , 得到优质字符串 &quot;aaabcc&quot; 。
另一种方式是删除一个 &#39;b&#39; 和一个 &#39;c&#39; ，得到优质字符串 &quot;aaabbc&quot; 。
示例 3：输入：s = &quot;ceabaacb&quot; 输出：2
解释：可以删除两个 &#39;c&#39; 得到优质字符串 &quot;eabaab&quot; 。
注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）
提示：1 &lt;= s.length &lt;= 10^5  s 仅含小写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序+贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minDeletions</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
	<span class="nx">M</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">M</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="nx">M</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">M</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
				<span class="nx">M</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">j</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">j</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>1648.销售价值减少的颜色球(2)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。
这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。
比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。
这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）
给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。
同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。
请你返回卖了 orders 个球以后 最大 总价值之和。
由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。
示例 1：输入：inventory = [2,5], orders = 4 输出：14
解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。
最大总和为 2 + 5 + 4 + 3 = 14 。
示例 2：输入：inventory = [3,5], orders = 6 输出：19
解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。
最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。
示例 3：输入：inventory = [2,8,4,10,6], orders = 20 输出：110
示例 4：输入：inventory = [1000000000], orders = 1000000000 输出：21
解释：卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 
500000000500000000 对 109 + 7 取余为 21 。
提示：1 &lt;= inventory.length &lt;= 105
1 &lt;= inventory[i] &lt;= 109
1 &lt;= orders &lt;= min(sum(inventory[i]), 109)
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxProfit(inventory []int, orders int) int {
	inventory = append(inventory, 0) // 避免第一个数特判
	sort.Ints(inventory)
	n := len(inventory)
	res := 0
	// 每次把当前数减到前一个数
	for i := n - 1; i &gt;= 1; i-- {
		if orders &lt;= 0 {
			break
		}
		total := (n - i) * (inventory[i] - inventory[i-1])
		if total &lt;= orders { // 够用
			sum := (inventory[i-1] + 1 + inventory[i]) * (inventory[i] - inventory[i-1]) / 2 * (n - i)
			res = (res + sum) % 1000000007
			orders = orders - total
		} else { // 不够用
			a, b := orders/(n-i), orders%(n-i)
			start := inventory[i] - a + 1
			sum := (start+inventory[i])*a/2*(n-i) + b*(start-1)
			res = (res + sum) % 1000000007
			orders = 0
		}
	}
	return res
}

# 2
func maxProfit(inventory []int, orders int) int {
	left, right := 0, math.MaxInt32
	target := 0
	for left &lt;= right {
		target = left + (right-left)/2
		sum := 0
		count := 0
		for i := 0; i &lt; len(inventory); i++ {
			if inventory[i] &gt;= target {
				count++
				sum = sum + (inventory[i] - target)
			}
		}
		if sum &gt; orders { // 过小
			left = target + 1
		} else if sum+count &lt;= orders { // 过小
			right = target - 1
		} else {
			break
		}
	}
	res := 0
	temp := 0
	for i := 0; i &lt; len(inventory); i++ {
		if inventory[i] &gt; target {
			res = (res + getCount(target+1, inventory[i])) % 1000000007
			temp = temp + inventory[i] - target
		}
	}
	return (res + (orders-temp)*target) % 1000000007
}

func getCount(a, b int) int {
	return (a + b) * (b - a + 1) / 2
}
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>1653.使字符串平衡的最少删除次数(4)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s ，它仅包含字符 &#39;a&#39; 和 &#39;b&#39;。
你可以删除 s 中任意数目的字符，使得 s 平衡 。
我们称 s 平衡的 当不存在下标对 (i,j) 满足 i &lt; j 且 s[i] = &#39;b&#39; 同时 s[j]= &#39;a&#39; 。
请你返回使 s 平衡 的 最少 删除次数。
示例 1：输入：s = &quot;aababbab&quot; 输出：2
解释：你可以选择以下任意一种方案：
下标从 0 开始，删除第 2 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aaabbb&quot;），
下标从 0 开始，删除第 3 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aabbbb&quot;）。
示例 2：输入：s = &quot;bbaaaaabb&quot; 输出：2
解释：唯一的最优解是删除最前面两个字符。
提示：1 &lt;= s.length &lt;= 105
s[i] 要么是 &#39;a&#39; 要么是 &#39;b&#39;。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前缀和+后缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minimumDeletions(s string) int {
	n := len(s)
	dpA := make([]int, n)
	dpB := make([]int, n)
	if s[0] == &#39;a&#39; {
		dpA[0] = 1
	}
	for i := 1; i &lt; n; i++ {
		if s[i] == &#39;a&#39; {
			dpA[i] = dpA[i-1] + 1
		} else {
			dpA[i] = dpA[i-1]
		}
	}
	if s[n-1] == &#39;b&#39; {
		dpB[n-1] = 1
	}
	for i := n - 2; i &gt;= 0; i-- {
		if s[i] == &#39;b&#39; {
			dpB[i] = dpB[i+1] + 1
		} else {
			dpB[i] = dpB[i+1]
		}
	}
	res := 0
	for i := 0; i &lt; n; i++ {
		res = max(res, dpA[i]+dpB[i])
	}
	return n - res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func minimumDeletions(s string) int {
	res := 0
	stack := make([]byte, 0)
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;b&#39; {
			stack = append(stack, &#39;b&#39;)
		} else {
			// 遇到&#39;ba&#39;则删掉，并次数+1
			if len(stack) &gt; 0 {
				res++
				stack = stack[:len(stack)-1]
			}
		}
	}
	return res
}

# 3
func minimumDeletions(s string) int {
	aCount := 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;a&#39; {
			aCount = aCount + 1
		}
	}
	res := aCount
	bCount := 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;a&#39; {
			aCount--
		} else {
			bCount++
		}
		// 要删除：前面b的个数+后面a的个数
		res = min(res, aCount+bCount)
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 4
func minimumDeletions(s string) int {
	n := len(s)
	dp := make([][2]int, n+1)
	// dp[n][0]以a结尾需要删除的次数
	// dp[n][1]以b结尾需要删除的次数
	for i := 0; i &lt; n; i++ {
		if s[i] == &#39;a&#39; {
			dp[i+1][0] = dp[i][0]
			dp[i+1][1] = dp[i][1] + 1
		} else {
			dp[i+1][0] = dp[i][0] + 1
			dp[i+1][1] = min(dp[i][0], dp[i][1])
		}
	}
	return min(dp[n][0], dp[n][1])
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>1654.到家的最少跳跃次数(2)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一只跳蚤的家在数轴上的位置 x 处。请你帮助它从位置 0 出发，到达它的家。
跳蚤跳跃的规则如下：
它可以 往前 跳恰好 a 个位置（即往右跳）。
它可以 往后 跳恰好 b 个位置（即往左跳）。
它不能 连续 往后跳 2 次。
它不能跳到任何 forbidden 数组中的位置。
跳蚤可以往前跳 超过 它的家的位置，但是它 不能跳到负整数 的位置。
给你一个整数数组 forbidden ，其中 forbidden[i] 是跳蚤不能跳到的位置，同时给你整数 a， b 和 x ，
请你返回跳蚤到家的最少跳跃次数。
如果没有恰好到达 x 的可行方案，请你返回 -1 。
示例 1：输入：forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9 输出：3
解释：往前跳 3 次（0 -&gt; 3 -&gt; 6 -&gt; 9），跳蚤就到家了。
示例 2：输入：forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11 输出：-1
示例 3：输入：forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7 输出：2
解释：往前跳一次（0 -&gt; 16），然后往回跳一次（16 -&gt; 7），跳蚤就到家了。
提示：1 &lt;= forbidden.length &lt;= 1000
1 &lt;= a, b, forbidden[i] &lt;= 2000
0 &lt;= x &lt;= 2000
forbidden 中所有位置互不相同。
位置 x 不在 forbidden 中。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>广度优先搜索</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>深度优先搜索</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minimumJumps(forbidden []int, a int, b int, x int) int {
	m := make([]bool, 6001)
	for i := 0; i &lt; len(forbidden); i++ {
		m[forbidden[i]] = true
	}
	queue := make([][2]int, 0)
	queue = append(queue, [2]int{0, 0})
	res := -1
	for len(queue) &gt; 0 {
		length := len(queue)
		res++
		for i := 0; i &lt; length; i++ {
			index, dir := queue[i][0], queue[i][1]
			if index == x {
				return res
			}
			if dir == 0 &amp;&amp; index-b &gt; 0 &amp;&amp; m[index-b] == false { // 向后跳-b
				m[index-b] = true
				queue = append(queue, [2]int{index - b, 1})
			}
			if index+a &lt; len(m) &amp;&amp; m[index+a] == false { // 向前跳+a
				m[index+a] = true
				queue = append(queue, [2]int{index + a, 0})
			}
		}
		queue = queue[length:]
	}
	return -1
}

# 2
var m []bool

func minimumJumps(forbidden []int, a int, b int, x int) int {
	m = make([]bool, 6001)
	for i := 0; i &lt; len(forbidden); i++ {
		m[forbidden[i]] = true
	}
	return dfs(0, 0, a, b, x)
}

func dfs(index int, dir int, a int, b int, x int) int {
	if index == x {
		return 0
	}
	res := -1
	if index+a &lt; len(m) &amp;&amp; m[index+a] == false { // 向前跳+a
		m[index+a] = true
		res = dfs(index+a, 0, a, b, x)
		if res != -1 {
			return res + 1
		}
	}
	if dir == 0 &amp;&amp; index-b &gt; 0 &amp;&amp; m[index-b] == false { // 向后跳-b
		res = dfs(index-b, 1, a, b, x)
		if res != -1 {
			return res + 1
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>1657.确定两个字符串是否接近(1)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：
操作 1：交换任意两个 现有 字符。
例如，abcde -&gt; aecdb
操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。
例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）
你可以根据需要对任意一个字符串多次使用这两种操作。
给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。
示例 1：输入：word1 = &quot;abc&quot;, word2 = &quot;bca&quot; 输出：true
解释：2 次操作从 word1 获得 word2 。
执行操作 1：&quot;abc&quot; -&gt; &quot;acb&quot;
执行操作 1：&quot;acb&quot; -&gt; &quot;bca&quot;
示例 2：输入：word1 = &quot;a&quot;, word2 = &quot;aa&quot; 输出：false
解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
示例 3：输入：word1 = &quot;cabbba&quot;, word2 = &quot;abbccc&quot; 输出：true
解释：3 次操作从 word1 获得 word2 。
执行操作 1：&quot;cabbba&quot; -&gt; &quot;caabbb&quot;
执行操作 2：&quot;caabbb&quot; -&gt; &quot;baaccc&quot;
执行操作 2：&quot;baaccc&quot; -&gt; &quot;abbccc&quot;
示例 4：输入：word1 = &quot;cabbba&quot;, word2 = &quot;aabbss&quot; 输出：false
解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
 提示：1 &lt;= word1.length, word2.length &lt;= 105
word1 和 word2 仅包含小写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">closeStrings</span><span class="p">(</span><span class="nx">word1</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">word2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">arr1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
	<span class="nx">arr2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
	<span class="nx">m1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint8</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="nx">m2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint8</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr1</span><span class="p">[</span><span class="nx">word1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">arr2</span><span class="p">[</span><span class="nx">word2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">m1</span><span class="p">[</span><span class="nx">word1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">m2</span><span class="p">[</span><span class="nx">word2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m1</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m2</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">true</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">arr1</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">arr2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x0-2">
<h2>1658.将x减到0的最小操作数(2)<a class="headerlink" href="#x0-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，
然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
示例 1：输入：nums = [1,1,4,2,3], x = 5 输出：2
解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
示例 2：输入：nums = [5,6,7,8,9], x = 4 输出：-1
示例 3：输入：nums = [3,2,20,1,1,3], x = 10 输出：5
解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
提示：1 &lt;= nums.length &lt;= 105
1 &lt;= nums[i] &lt;= 104
1 &lt;= x &lt;= 109
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前后缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minOperations(nums []int, x int) int {
	n := len(nums)
	res := n + 1
	sum := 0
	for i := 0; i &lt; n; i++ {
		sum = sum + nums[i]
	}
	if sum &lt; x {
		return -1
	}
	if sum == x {
		return n
	}
	left := make([]int, n)
	right := make([]int, n)
	mLeft := make(map[int]int)
	mRight := make(map[int]int)
	left[0] = nums[0]
	mLeft[nums[0]] = 0
	right[n-1] = nums[n-1]
	mRight[nums[n-1]] = n - 1
	if left[0] == x || right[n-1] == x {
		return 1
	}
	for i := 1; i &lt; n; i++ {
		left[i] = left[i-1] + nums[i]
		mLeft[left[i]] = i
		if left[i] == x {
			res = min(res, i+1)
		}
	}
	for i := n - 2; i &gt;= 0; i-- {
		right[i] = right[i+1] + nums[i]
		mRight[right[i]] = i
		if right[i] == x {
			res = min(res, n-i)
		}
	}
	for i := 1; i &lt; n; i++ {
		left := left[i]
		if index, ok := mRight[x-left]; ok &amp;&amp; i &lt; index {
			target := n - (index - i - 1)
			res = min(res, target)
		}
	}
	if res == n+1 {
		return -1
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func minOperations(nums []int, x int) int {
	n := len(nums)
	sum := 0
	for i := 0; i &lt; n; i++ {
		sum = sum + nums[i]
	}
	target := sum - x
	left := 0
	right := 0
	res := -1
	cur := 0
	// 和为sum-x的最长连续子数组
	for left &lt; n {
		if right &lt; n {
			cur = cur + nums[right]
			right++
		}
		for cur &gt; target &amp;&amp; left &lt; n {
			cur = cur - nums[left]
			left++
		}
		if cur == target {
			res = max(res, right-left)
		}
		if right == n {
			left++
		}
	}
	if res == -1 {
		return -1
	}
	return n - res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>1663.具有给定数值的最小字符串(2)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，
c 的数值为 3 ，以此类推。
字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。
例如，字符串 &quot;abe&quot; 的数值等于 1 + 2 + 5 = 8 。
给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。
注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况：
x 是 y 的一个前缀；
如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。
示例 1：输入：n = 3, k = 27 输出：&quot;aay&quot;
解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。
示例 2：输入：n = 5, k = 73 输出：&quot;aaszz&quot;
提示：1 &lt;= n &lt;= 105
n &lt;= k &lt;= 26 * n
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func getSmallestString(n int, k int) string {
	res := &quot;&quot;
	k = k - n
	a := k / 25
	b := k % 25
	right := a
	var left, middle int
	if b == 0 {
		left = n - right
		middle = 0
	} else {
		left = n - right - 1
		middle = b
	}
	res = res + strings.Repeat(&quot;a&quot;, left)
	if middle &gt; 0 {
		res = res + string(&#39;a&#39;+middle)
	}
	res = res + strings.Repeat(&quot;z&quot;, right)
	return res
}

# 2
func getSmallestString(n int, k int) string {
	arr := make([]byte, n)
	k = k - n
	for i := n - 1; i &gt;= 0; i-- {
		if k &gt; 25 {
			arr[i] = &#39;z&#39;
			k = k - 25
		} else {
			arr[i] = byte(&#39;a&#39; + k)
			k = 0
		}
	}
	return string(arr)
}
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>1664.生成平衡数组的方案数(2)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。
请注意剩下元素的下标可能会因为删除操作而发生改变。
比方说，如果 nums = [6,1,7,4,1] ，那么：
选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。
选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。
选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。
如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。
请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。
示例 1：输入：nums = [2,1,6,4] 输出：1
解释：删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。
删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。
删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。
删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。
只有一种让剩余数组成为平衡数组的方案。
示例 2：输入：nums = [1,1,1] 输出：3
解释：你可以删除任意元素，剩余数组都是平衡数组。
示例 3：输入：nums = [1,2,3] 输出：0
解释：不管删除哪个元素，剩下数组都不是平衡数组。
提示：1 &lt;= nums.length &lt;= 105
1 &lt;= nums[i] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func waysToMakeFair(nums []int) int {
	res := 0
	a := 0
	b := 0
	for i := 0; i &lt; len(nums); i++ {
		if i%2 == 0 {
			a = a + nums[i]
		} else {
			b = b + nums[i]
		}
	}
	x, y := 0, 0
	for i := 0; i &lt; len(nums); i++ {
		if i%2 == 0 {
			a = a - nums[i]
		} else {
			b = b - nums[i]
		}
		even := x + b
		odd := y + a
		if even == odd {
			res++
		}
		if i%2 == 0 {
			x = x + nums[i]
		} else {
			y = y + nums[i]
		}
	}
	return res
}

# 2
func waysToMakeFair(nums []int) int {
	n := len(nums)
	dp := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		if i%2 == 0 {
			dp[i+1] = dp[i] + nums[i]
		} else {
			dp[i+1] = dp[i] - nums[i]
		}
	}
	res := 0
	for i := 0; i &lt; n; i++ {
		// dp[i]表示索引i左边部分奇偶元素差值，
		// dp[n] - dp[i+1]表示索引i右边部分奇偶元素差值
		if dp[i] == dp[n]-dp[i+1] {
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h2>1669.合并两个链表(2)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。
请你将 list1 中第 a 个节点到第 b 个节点删除，并将list2 接在被删除节点的位置。
下图中蓝色边和节点展示了操作后的结果：
请你返回结果链表的头指针。
示例 1：输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
输出：[0,1,2,1000000,1000001,1000002,5]
解释：我们删除 list1 中第三和第四个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。
示例 2：输入：list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
输出：[0,1,1000000,1000001,1000002,1000003,1000004,6]
解释：上图中蓝色的边和节点为答案链表。
提示：3 &lt;= list1.length &lt;= 104
1 &lt;= a &lt;= b &lt; list1.length - 1
1 &lt;= list2.length &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func mergeInBetween(list1 *ListNode, a int, b int, list2 *ListNode) *ListNode {
	res := &amp;ListNode{}
	temp := res
	for i := 0; i &lt; a; i++{
		temp.Next = list1
		temp = temp.Next
		list1 = list1.Next
	}
	for list2 != nil{
		temp.Next = list2
		temp = temp.Next
		list2 = list2.Next
	}
	for i := a; i &lt;= b; i++{
		list1 = list1.Next
	}
	for list1 != nil{
		temp.Next = list1
		temp = temp.Next
		list1 = list1.Next
	}
	return  res.Next
}

# 2
func mergeInBetween(list1 *ListNode, a int, b int, list2 *ListNode) *ListNode {
	cur := list1
	for i := 0; i &lt; a-1; i++ {
		cur = cur.Next
	}
	temp := cur.Next
	for i := 0; i &lt; (b - a + 1); i++ {
		temp = temp.Next
	}
	cur.Next = list2
	for cur.Next != nil {
		cur = cur.Next
	}
	cur.Next = temp
	return list1
}
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h2>1670.设计前中后队列(1)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。
请你完成 FrontMiddleBack 类：
FrontMiddleBack() 初始化队列。
void pushFront(int val) 将 val 添加到队列的 最前面 。
void pushMiddle(int val) 将 val 添加到队列的 正中间 。
void pushBack(int val) 将 val 添加到队里的 最后面 。
int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：
将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。
从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。
示例 1：输入：
[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, 
&quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]
[[], [1], [2], [3], [4], [], [], [], [], []]
输出：[null, null, null, null, null, 1, 3, 4, 2, -1]
解释：FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // 返回 1 -&gt; [4, 3, 2]
q.popMiddle();    // 返回 3 -&gt; [4, 2]
q.popMiddle();    // 返回 4 -&gt; [2]
q.popBack();      // 返回 2 -&gt; []
q.popFront();     // 返回 -1 -&gt; [] （队列为空）
提示：1 &lt;= val &lt;= 109
最多调用 1000 次 pushFront， pushMiddle， pushBack， popFront， popMiddle 和 popBack 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">FrontMiddleBackQueue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="nx">FrontMiddleBackQueue</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">FrontMiddleBackQueue</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">FrontMiddleBackQueue</span><span class="p">)</span> <span class="nx">PushFront</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">val</span><span class="p">},</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">FrontMiddleBackQueue</span><span class="p">)</span> <span class="nx">PushMiddle</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mid</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">mid</span><span class="p">],</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">val</span><span class="p">},</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">FrontMiddleBackQueue</span><span class="p">)</span> <span class="nx">PushBack</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">FrontMiddleBackQueue</span><span class="p">)</span> <span class="nx">PopFront</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="kt">int</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">FrontMiddleBackQueue</span><span class="p">)</span> <span class="nx">PopMiddle</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">mid</span> <span class="kt">int</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">mid</span><span class="p">],</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">FrontMiddleBackQueue</span><span class="p">)</span> <span class="nx">PopBack</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="kt">int</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">arr</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2>1673.找出最具竞争力的子序列(1)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。
数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。
在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，
那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 
例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。
示例 1：输入：nums = [3,5,2,6], k = 2 输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，
[2,6] 最具竞争力。
示例 2：输入：nums = [2,4,3,3,5,4,9,6], k = 4 输出：[2,3,3,4]
提示：1 &lt;= nums.length &lt;= 105
0 &lt;= nums[i] &lt;= 109
1 &lt;= k &lt;= nums.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">mostCompetitive</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">k</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="nx">k</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">// 栈顶元素打大于后面的元素，摘除栈顶元素（因为前面的更大，需要删除了才能变的最小）</span>
		<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">k</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="nx">k</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">stack</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>1674.使数组互补的最少操作次数(1)<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个长度为 偶数 n 的整数数组 nums 和一个整数 limit 。
每一次操作，你可以将 nums 中的任何整数替换为 1 到 limit 之间的另一个整数。
如果对于所有下标 i（下标从 0 开始），nums[i] + nums[n - 1 - i] 都等于同一个数，
则数组 nums 是 互补的 。
例如，数组 [1,2,3,4] 是互补的，因为对于所有下标 i ，nums[i] + nums[n - 1 - i] = 5 。
返回使数组 互补 的 最少 操作次数。
示例 1：输入：nums = [1,2,4,3], limit = 4 输出：1
解释：经过 1 次操作，你可以将数组 nums 变成 [1,2,2,3]（加粗元素是变更的数字）：
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。
示例 2：输入：nums = [1,2,2,1], limit = 2 输出：2
解释：经过 2 次操作，你可以将数组 nums 变成 [2,2,2,2] 。你不能将任何数字变更为 3 ，因为 3 &gt; limit 。
示例 3：输入：nums = [1,2,1,2], limit = 2 输出：0
解释：nums 已经是互补的。
提示：n == nums.length
2 &lt;= n &lt;= 105
1 &lt;= nums[i] &lt;= limit &lt;= 105
n 是偶数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>差分数组</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minMoves</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">limit</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">limit</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">// 1、首先[2,2*limit]都加2=&gt;操作2次</span>
		<span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
		<span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">limit</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nx">limit</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
		<span class="c1">// 2、将[1+min(a,b),limit+max(a,b)] 减1=&gt;操作1次</span>
		<span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)]</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">limit</span><span class="o">+</span><span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">limit</span><span class="o">+</span><span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="c1">// 3、将[a+b]减1，目标值=&gt;操作0次</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">n</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">limit</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">res</span> <span class="p">&gt;</span> <span class="nx">sum</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">sum</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-3">
<h2>1679.K和数对的最大数目(3)<a class="headerlink" href="#k-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 和一个整数 k 。
每一步操作中，你需要从数组中选出和为 k 的两个整数，并将它们移出数组。
返回你可以对数组执行的最大操作数。
示例 1：输入：nums = [1,2,3,4], k = 5 输出：2
解释：开始时 nums = [1,2,3,4]：
- 移出 1 和 4 ，之后 nums = [2,3]
- 移出 2 和 3 ，之后 nums = []
不再有和为 5 的数对，因此最多执行 2 次操作。
示例 2：输入：nums = [3,1,3,4,3], k = 6 输出：1
解释：开始时 nums = [3,1,3,4,3]：
- 移出前两个 3 ，之后nums = [1,4,3]
不再有和为 6 的数对，因此最多执行 1 次操作。
提示：1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i] &lt;= 10^9
1 &lt;= k &lt;= 10^9
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>哈希</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxOperations(nums []int, k int) int {
	res := 0
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		if m[k-nums[i]] &gt; 0 {
			res++
			m[k-nums[i]]--
		} else {
			m[nums[i]]++
		}
	}
	return res
}

# 2
func maxOperations(nums []int, k int) int {
	sort.Ints(nums)
	res := 0
	left := 0
	right := len(nums) - 1
	for left &lt; right {
		sum := nums[left] + nums[right]
		if sum == k {
			res++
			left++
			right--
		} else if sum &gt; k {
			right--
		} else {
			left++
		}
	}
	return res
}

# 3
func maxOperations(nums []int, k int) int {
	res := 0
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		m[nums[i]]++
	}
	for key := range m {
		res = res + min(m[key], m[k-key])
	}
	return res / 2
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h2>1680.连接连续二进制数字(2)<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n ，请你将 1 到 n 的二进制表示连接起来，
并返回连接结果对应的 十进制 数字对 109 + 7 取余的结果。
示例 1：输入：n = 1 输出：1
解释：二进制的 &quot;1&quot; 对应着十进制的 1 。
示例 2：输入：n = 3 输出：27
解释：二进制下，1，2 和 3 分别对应 &quot;1&quot; ，&quot;10&quot; 和 &quot;11&quot; 。
将它们依次连接，我们得到 &quot;11011&quot; ，对应着十进制的 27 。
示例 3：输入：n = 12 输出：505379714
解释：连接结果为 &quot;1101110010111011110001001101010111100&quot; 。
对应的十进制数字为 118505380540 。
对 10^9 + 7 取余后，结果为 505379714 。
提示：1 &lt;= n &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>package main

import &quot;math/bits&quot;

func main() {

}

func concatenatedBinary(n int) int {
	res := 0
	for i := 1; i &lt;= n; i++ {
		length := bits.Len(uint(i))
		res = (res&lt;&lt;length + i) % 1000000007
	}
	return res
}

# 2
func concatenatedBinary(n int) int {
	res := 0
	length := 0
	for i := 1; i &lt;= n; i++ {
		if i&amp;(i-1) == 0 {
			length++
		}
		res = (res&lt;&lt;length + i) % 1000000007
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id46">
<h2>1685.有序数组中差绝对值之和(2)<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个 非递减 有序整数数组 nums 。
请你建立并返回一个整数数组 result，它跟 nums 长度相同，
且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。
换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，
其中 0 &lt;= j &lt; nums.length 且 j != i （下标从 0 开始）。
示例 1：输入：nums = [2,3,5] 输出：[4,3,5]
解释：假设数组下标从 0 开始，那么
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。
示例 2：输入：nums = [1,4,6,8,10] 输出：[24,15,13,15,21]
提示：2 &lt;= nums.length &lt;= 105
1 &lt;= nums[i] &lt;= nums[i + 1] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func getSumAbsoluteDifferences(nums []int) []int {
	n := len(nums)
	res := make([]int, 0)
	right := 0 // 右边和
	left := 0  // 左边和
	for i := 1; i &lt; n; i++ {
		right = right + (nums[i] - nums[0])
	}
	res = append(res, right)
	for i := 1; i &lt; n; i++ {
		diff := nums[i] - nums[i-1]
		left = left + diff*i
		right = right - diff*(n-i)
		res = append(res, left+right)
	}
	return res
}

# 2
func getSumAbsoluteDifferences(nums []int) []int {
	n := len(nums)
	res := make([]int, 0)
	arr := make([]int, 0)
	sum := 0
	for i := 0; i &lt; n; i++ {
		sum = sum + nums[i]
		arr = append(arr, sum)
	}
	res = append(res, sum-n*nums[0])
	for i := 1; i &lt; n; i++ {
		left := nums[i]*i - arr[i-1]              // 左边和
		right := (sum - arr[i]) - nums[i]*(n-1-i) // 右边和
		res = append(res, left+right)
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="vi-1">
<h2>1686.石子游戏VI(1)<a class="headerlink" href="#vi-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Alice 和 Bob 轮流玩一个游戏，Alice 先手。
一堆石子里总共有 n 个石子，轮到某个玩家时，他可以移出一个石子并得到这个石子的价值。
Alice 和 Bob 对石子价值有不一样的的评判标准 。双方都知道对方的评判标准。
给你两个长度为 n 的整数数组 aliceValues 和 bobValues 。
aliceValues[i] 和 bobValues[i] 分别表示 Alice 和 Bob 认为第 i 个石子的价值。
所有石子都被取完后，得分较高的人为胜者。
如果两个玩家得分相同，那么为平局。两位玩家都会采用 最优策略 进行游戏。
请你推断游戏的结果，用如下的方式表示：
如果 Alice 赢，返回 1 。
如果 Bob 赢，返回 -1 。
如果游戏平局，返回 0 。
示例 1：输入：aliceValues = [1,3], bobValues = [2,1] 输出：1
解释：如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。
Bob 只能选择石子 0 ，得到 2 分。
Alice 获胜。
示例 2：输入：aliceValues = [1,2], bobValues = [3,1] 输出：0
解释：Alice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。
打平。
示例 3：输入：aliceValues = [2,4,3], bobValues = [1,6,7] 输出：-1
解释：不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。
比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。
Bob 会获胜。
提示：n == aliceValues.length == bobValues.length
1 &lt;= n &lt;= 105
1 &lt;= aliceValues[i], bobValues[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">stoneGameVI</span><span class="p">(</span><span class="nx">aliceValues</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">bobValues</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">aliceValues</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span><span class="p">,</span> <span class="nx">aliceValues</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">bobValues</span><span class="p">[</span><span class="nx">i</span><span class="p">]}</span>
	<span class="p">}</span>
	<span class="c1">// 贪心策略：将两组石头的价值相加，每次取价值最大的那一组</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">aliceValues</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">bobValues</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id47">
<h2>1689.十-二进制数的最少数目(1)<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果一个十进制数字不含任何前导零，且每一位上的数字不是 0 就是 1 ，那么该数字就是一个 十-二进制数 。
例如，101 和 1100 都是 十-二进制数，而 112 和 3001 不是。
给你一个表示十进制整数的字符串 n ，返回和为 n 的 十-二进制数 的最少数目。
示例 1：输入：n = &quot;32&quot; 输出：3
解释：10 + 11 + 11 = 32
示例 2：输入：n = &quot;82734&quot; 输出：8
示例 3：输入：n = &quot;27346209830709182346&quot; 输出：9
提示：1 &lt;= n.length &lt;= 105
n 仅由数字组成
n 不含任何前导零并总是表示正整数
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minPartitions</span><span class="p">(</span><span class="nx">n</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">value</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">value</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="vii-4">
<h2>1690.石子游戏VII(4)<a class="headerlink" href="#vii-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。
有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，
并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。
鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。
爱丽丝的目标是最大限度地 扩大得分的差值 。
给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，
如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。
示例 1：输入：stones = [5,3,1,4,2] 输出：6
解释：
- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。
- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。
- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。
- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。
- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。
得分的差值 18 - 12 = 6 。
示例 2：输入：stones = [7,90,5,1,100,10,10,2] 输出：122
提示：n == stones.length
2 &lt;= n &lt;= 1000
1 &lt;= stones[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func stoneGameVII(stones []int) int {
	n := len(stones)
	arr := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		arr[i+1] = arr[i] + stones[i]
	}
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
	}
	for j := 2; j &lt;= n; j++ {
		for i := 0; i+j &lt;= n; i++ {
			left := arr[i+j] - arr[i+1] - dp[i+1][i+j-1] // 左边得分-得分
			right := arr[i+j-1] - arr[i] - dp[i][i+j-2]  // 右边得分-得分
			dp[i][i+j-1] = max(left, right)
		}
	}
	return dp[0][n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
var dp [][]int
var arr []int

func stoneGameVII(stones []int) int {
	n := len(stones)
	arr = make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		arr[i+1] = arr[i] + stones[i]
	}
	dp = make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
		for j := 0; j &lt; n; j++ {
			if i == j {
				continue
			}
			dp[i][j] = -1
		}
	}
	dfs(0, n-1)
	return dp[0][n-1]
}

func dfs(i, j int) int {
	if dp[i][j] != -1 {
		return dp[i][j]
	}
	left := arr[j+1] - arr[i+1] - dfs(i+1, j)
	right := arr[j] - arr[i] - dfs(i, j-1)
	dp[i][j] = max(left, right)
	return dp[i][j]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func stoneGameVII(stones []int) int {
	n := len(stones)
	arr := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		arr[i+1] = arr[i] + stones[i]
	}
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
	}
	for i := n - 2; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			left := arr[j+1] - arr[i+1] - dp[i+1][j] // 左边得分-得分
			right := arr[j] - arr[i] - dp[i][j-1]    // 右边得分-得分
			dp[i][j] = max(left, right)
		}
	}
	return dp[0][n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 4
func stoneGameVII(stones []int) int {
	n := len(stones)
	arr := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		arr[i+1] = arr[i] + stones[i]
	}
	dp := make([]int, n)
	for i := n - 2; i &gt;= 0; i-- {
		sum := stones[i]
		for j := i + 1; j &lt; n; j++ {
			sum = sum + stones[j]
			left := sum - stones[i] - dp[j]    // 左边得分-得分
			right := sum - stones[j] - dp[j-1] // 右边得分-得分
			dp[j] = max(left, right)
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h2>1695.删除子数组的最大得分(1)<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。
删除子数组的 得分 就是子数组各元素之 和 。
返回 只删除一个 子数组可获得的 最大得分 。
如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。
示例 1：输入：nums = [4,2,4,5,6] 输出：17
解释：最优子数组是 [2,4,5,6]
示例 2：输入：nums = [5,2,1,2,5,2,1,2,5] 输出：8
解释：最优子数组是 [5,2,1] 或 [1,2,5]
提示：1 &lt;= nums.length &lt;= 105
1 &lt;= nums[i] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maximumUniqueSubarray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">m</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]]</span><span class="o">--</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">-</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
			<span class="nx">left</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">sum</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="vi-4">
<h2>1696.跳跃游戏VI(4)<a class="headerlink" href="#vi-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。
也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。
你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。
请你返回你能得到的 最大得分 。
示例 1：输入：nums = [1,-1,-2,4,-7,3], k = 2 输出：7
解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。
示例 2：输入：nums = [10,-5,-2,4,0,3], k = 3 输出：17
解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。
示例 3：输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 输出：0
提示：1 &lt;= nums.length, k &lt;= 105
-104 &lt;= nums[i] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxResult(nums []int, k int) int {
	n := len(nums)
	dp := make([]int, n)
	if k &gt; n {
		k = n
	}
	dp[0] = nums[0]
	maxValue := nums[0]
	for i := 1; i &lt; len(nums); i++ {
		if i &lt;= k { // 在前k个，dp[i] = maxValue + nums[i]
			dp[i] = maxValue + nums[i]
			maxValue = max(maxValue, dp[i])
		} else {
			if maxValue == dp[i-1-k] { // 需要重新找maxValue
				maxValue = getMaxValue(dp[i-k : i])
			}
			dp[i] = maxValue + nums[i]
			maxValue = max(maxValue, dp[i])
		}
	}
	return dp[n-1]
}

func getMaxValue(arr []int) int {
	maxValue := arr[0]
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] &gt; maxValue {
			maxValue = arr[i]
		}
	}
	return maxValue
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maxResult(nums []int, k int) int {
	n := len(nums)
	dp := make([]int, n)
	if k &gt; n {
		k = n
	}
	dp[0] = nums[0]
	maxValue := nums[0]
	maxIndex := 0
	for i := 1; i &lt; len(nums); i++ {
		if i &lt;= k { // 在前k个，dp[i] = maxValue + nums[i]
			dp[i] = maxValue + nums[i]
			if dp[i] &gt;= maxValue {
				maxValue = dp[i]
				maxIndex = i
			}
		} else {
			if i-k &gt; maxIndex {
				maxValue = dp[maxIndex+1]
				for j := maxIndex + 1; j &lt; i; j++ {
					if dp[j] &gt;= maxValue {
						maxValue = dp[j]
						maxIndex = j
					}
				}
			}
			dp[i] = maxValue + nums[i]
			if dp[i] &gt;= maxValue {
				maxValue = dp[i]
				maxIndex = i
			}
		}
	}
	return dp[n-1]
}

# 3
func maxResult(nums []int, k int) int {
	n := len(nums)
	if k &gt; n {
		k = n
	}
	res := nums[0]
	stack := make([][2]int, 0)
	stack = append(stack, [2]int{0, nums[0]})
	for i := 1; i &lt; len(nums); i++ {
		if stack[0][0] &lt; i-k {
			stack = stack[1:]
		}
		res = stack[0][1] + nums[i]
		for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1][1] &lt; res {
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, [2]int{i, res})
	}
	return res
}

# 4
func maxResult(nums []int, k int) int {
	n := len(nums)
	if k &gt; n {
		k = n
	}
	res := nums[0]
	intHeap := make(IntHeap, 0)
	heap.Init(&amp;intHeap)
	heap.Push(&amp;intHeap, [2]int{0, nums[0]})
	for i := 1; i &lt; len(nums); i++ {
		for i-intHeap[0][0] &gt; k { // 不满足删除
			heap.Pop(&amp;intHeap)
		}
		res = intHeap[0][1] + nums[i]
		heap.Push(&amp;intHeap, [2]int{i, res})
	}
	return res
}

type IntHeap [][2]int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h IntHeap) Less(i, j int) bool {
	return h[i][1] &gt; h[j][1]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.([2]int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>1601-1700-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="id49">
<h2>1665.完成所有任务的最少初始能量(1)<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个任务数组 tasks ，其中 tasks[i] = [actuali, minimumi] ：
actuali 是完成第 i 个任务 需要耗费 的实际能量。
minimumi 是开始第 i 个任务前需要达到的最低能量。
比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。
如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。
你可以按照 任意顺序 完成任务。
请你返回完成所有任务的 最少 初始能量。
示例 1：输入：tasks = [[1,2],[2,4],[4,8]] 输出：8
解释：一开始有 8 能量，我们按照如下顺序完成任务：
    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。
    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。
    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。
注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。
示例 2：输入：tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]] 输出：32
解释：一开始有 32 能量，我们按照如下顺序完成任务：
    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。
    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。
    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。
    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。
    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。
示例 3：输入：tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] 输出：27
解释：一开始有 27 能量，我们按照如下顺序完成任务：
    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。
    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。
    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。
    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。
    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。
    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。
提示：1 &lt;= tasks.length &lt;= 105
1 &lt;= actuali &lt;= minimumi &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minimumEffort</span><span class="p">(</span><span class="nx">tasks</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">tasks</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">tasks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nx">tasks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">tasks</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nx">tasks</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tasks</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">total</span><span class="o">+</span><span class="nx">tasks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">tasks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id50">
<h2>1671.得到山形数组的最少删除次数(1)<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们定义 arr 是 山形数组 当且仅当它满足：
arr.length &gt;= 3
存在某个下标 i （从 0 开始） 满足 0 &lt; i &lt; arr.length - 1 且：
arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]
arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]
给你整数数组 nums，请你返回将 nums 变成 山形状数组的最少 删除次数。
示例 1：输入：nums = [1,3,1] 输出：0
解释：数组本身就是山形数组，所以我们不需要删除任何元素。
示例 2：输入：nums = [2,1,1,5,6,2,3,1]输出：3
解释：一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。
示例 3：输入：nums = [4,3,2,1,1,2,3,1]输出：4
提示：输入：nums = [1,2,3,4,4,3,2,1]输出：1
提示：3 &lt;= nums.length &lt;= 1000
1 &lt;= nums[i] &lt;= 109
题目保证 nums 删除一些元素后一定能得到山形数组。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minimumMountainRemovals</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">left</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
				<span class="nx">left</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">left</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">right</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
				<span class="nx">right</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">right</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">left</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">right</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h2>1691.堆叠长方体的最大高度(1)<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你 n 个长方体 cuboids ，
其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。
请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。
如果 widthi &lt;= widthj 且 lengthi &lt;= lengthj 且 heighti &lt;= heightj ，
你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。
返回 堆叠长方体 cuboids 可以得到的 最大高度 。
示例 1：输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]] 输出：190
解释：第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。
第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。
第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。
总高度是 95 + 50 + 45 = 190 。
示例 2：输入：cuboids = [[38,25,45],[76,35,3]] 输出：76
解释：无法将任何长方体放在另一个上面。
选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。
示例 3：输入：cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
输出：102
解释：重新排列长方体后，可以看到所有长方体的尺寸都相同。
你可以把 11x7 的一面朝下，这样它们的高度就是 17 。
堆叠长方体的最大高度为 6 * 17 = 102 。
提示：n == cuboids.length
1 &lt;= n &lt;= 100
1 &lt;= widthi, lengthi, heighti &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序+动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxHeight</span><span class="p">(</span><span class="nx">cuboids</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cuboids</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="o">:=</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
		<span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">cuboids</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cuboids</span><span class="p">)</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
				<span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
				<span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">cuboids</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">cuboids</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="1701-1800.html" class="btn btn-neutral float-right" title="1701-1800-Easy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="1501-1600.html" class="btn btn-neutral float-left" title="1501-1600-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>