

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1001-1100-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="1101-1200-Easy" href="1101-1200.html" />
    <link rel="prev" title="0901-1000-Easy" href="0901-1000.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">1001-1100-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">1002.查找常用字符(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-4">1005.K次取反后最大化的数组和(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">1009.十进制整数的反码(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">1010.总持续时间可被60整除的歌曲(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">1013.将数组分成和相等的三个部分(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1018.可被5整除的二进制前缀(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">1021.删除最外层的括号(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">1022.从根到叶的二进制数之和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">1025.除数博弈(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">1029.两地调度(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">1030.距离顺序排列矩阵单元格(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">1033.移动石子直到连续(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">1037.有效的回旋镖(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">1042.不邻接植花(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">1046.最后一块石头的重量(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">1047.删除字符串中的所有相邻重复项(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">1051.高度检查器(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">1071.字符串的最大公因子(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bigram-1">1078.Bigram 分词(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">1089.复写零(3)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">1001-1100-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id19">1003.检查替换后的词是否有效(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iii-2">1004.最大连续1的个数III(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">1006.笨阶乘(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">1007.行相等的最少多米诺旋转(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">1008.前序遍历构造二叉搜索树(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#d-1">1011.在D天内送达包裹的能力(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">1014.最佳观光组合(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-1">1015.可被K整除的最小整数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">1019.链表中的下一个更大节点(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">1020.飞地的数量(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">1023.驼峰式匹配(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">1024.视频拼接(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">1026.节点与其祖先之间的最大差值(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">1027.最长等差数列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">1035.不相交的线(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">1038.把二叉搜索树转换为累加树(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii">1040.移动石子直到连续II</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id32">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id33">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id34">1041.困于环中的机器人(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">1043.分隔数组以得到最大和(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">1048.最长字符串链(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-2">1049.最后一块石头的重量II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">1052.爱生气的书店老板(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">1053.交换一次的先前排列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">1054.距离相等的条形码(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">1079.活字印刷(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id41">1081.不同字符的最小子序列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id42">1090.受标签影响的最大值(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43">1091.二进制矩阵中的最短路径(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">1093.大样本统计(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id45">1094.拼车(1)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">1001-1100-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id46">1028.从先序遍历还原二叉树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">解题思路</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>1001-1100-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/1001-1100.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>1001-1100-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#1001-1100-easy">1001-1100-Easy</a><ul>
<li><a class="reference external" href="#1002%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A62">1002.查找常用字符(2)</a></li>
<li><a class="reference external" href="#1005k%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C4">1005.K次取反后最大化的数组和(4)</a></li>
<li><a class="reference external" href="#1009%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%813">1009.十进制整数的反码(3)</a></li>
<li><a class="reference external" href="#1010%E6%80%BB%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E5%8F%AF%E8%A2%AB60%E6%95%B4%E9%99%A4%E7%9A%84%E6%AD%8C%E6%9B%B22">1010.总持续时间可被60整除的歌曲(2)</a></li>
<li><a class="reference external" href="#1013%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%862">1013.将数组分成和相等的三个部分(2)</a></li>
<li><a class="reference external" href="#1018%E5%8F%AF%E8%A2%AB5%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%801">1018.可被5整除的二进制前缀(1)</a></li>
<li><a class="reference external" href="#1021%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B73">1021.删除最外层的括号(3)</a></li>
<li><a class="reference external" href="#1022%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C2">1022.从根到叶的二进制数之和(2)</a></li>
<li><a class="reference external" href="#1025%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%882">1025.除数博弈(2)</a></li>
<li><a class="reference external" href="#1029%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A62">1029.两地调度(2)</a></li>
<li><a class="reference external" href="#1030%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC3">1030.距离顺序排列矩阵单元格(3)</a></li>
<li><a class="reference external" href="#1033%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD2">1033.移动石子直到连续(2)</a></li>
<li><a class="reference external" href="#1037%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%963">1037.有效的回旋镖(3)</a></li>
<li><a class="reference external" href="#1042%E4%B8%8D%E9%82%BB%E6%8E%A5%E6%A4%8D%E8%8A%B11">1042.不邻接植花(1)</a></li>
<li><a class="reference external" href="#1046%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F2">1046.最后一块石头的重量(2)</a></li>
<li><a class="reference external" href="#1047%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B92">1047.删除字符串中的所有相邻重复项(2)</a></li>
<li><a class="reference external" href="#1051%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A82">1051.高度检查器(2)</a></li>
<li><a class="reference external" href="#1071%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%902">1071.字符串的最大公因子(2)</a></li>
<li><a class="reference external" href="#1078bigram-%E5%88%86%E8%AF%8D1">1078.Bigram 分词(1)</a></li>
<li><a class="reference external" href="#1089%E5%A4%8D%E5%86%99%E9%9B%B63">1089.复写零(3)</a></li>
</ul>
</li>
<li><a class="reference external" href="#1001-1100-medium">1001-1100-Medium</a><ul>
<li><a class="reference external" href="#1014%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%881">1014.最佳观光组合(1)</a></li>
<li><a class="reference external" href="#1035%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF3">1035.不相交的线(3)</a></li>
<li><a class="reference external" href="#1081%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%972">1081.不同字符的最小子序列(2)</a></li>
</ul>
</li>
</ul>
<div class="section" id="id1">
<h2>1002.查找常用字符(2)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。
例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。
你可以按任意顺序返回答案。
示例 1：输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;] 输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]
示例 2：输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;] 输出：[&quot;c&quot;,&quot;o&quot;]
提示：
    1 &lt;= A.length &lt;= 100
    1 &lt;= A[i].length &lt;= 100
    A[i][j] 是小写字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历-数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历-数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">commonChars</span><span class="p">(</span><span class="n">A</span> <span class="p">[]</span><span class="n">string</span><span class="p">)</span> <span class="p">[]</span><span class="n">string</span> <span class="p">{</span>
	<span class="n">arr</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="nb">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">v</span><span class="o">-</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="nb">int</span><span class="p">{}</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">v</span><span class="o">-</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="n">func</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="nb">int</span><span class="p">)</span> <span class="nb">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>

<span class="c1">#</span>
<span class="n">func</span> <span class="n">commonChars</span><span class="p">(</span><span class="n">A</span> <span class="p">[]</span><span class="n">string</span><span class="p">)</span> <span class="p">[]</span><span class="n">string</span> <span class="p">{</span>
	<span class="n">arr</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([][</span><span class="mi">26</span><span class="p">]</span><span class="nb">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">minValue</span> <span class="p">:</span><span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">minValue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minValue</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">minValue</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
			<span class="n">minValue</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="n">func</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="nb">int</span><span class="p">)</span> <span class="nb">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-4">
<h2>1005.K次取反后最大化的数组和(4)<a class="headerlink" href="#k-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 A，我们只能用以下方法修改该数组：
我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。
（我们可以多次选择同一个索引 i。）
以这种方式修改数组后，返回数组可能的最大和。
示例 1：输入：A = [4,2,3], K = 1 输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
示例 2：输入：A = [3,-1,0,2], K = 3 输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：输入：A = [2,-3,-1,5,-4], K = 2 输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
提示：
    1 &lt;= A.length &lt;= 10000
    1 &lt;= K &lt;= 10000
    -100 &lt;= A[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序+贪心</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>排序+贪心</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>遍历-找最小</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func largestSumAfterKNegations(A []int, K int) int {
	sort.Ints(A)
	i := 0
	for i &lt; len(A) &amp;&amp; K &gt; 0 {
		if A[i] &lt; 0 {
			A[i] = -A[i]
			i++
			K--
		} else {
			break
		}
	}
	sort.Ints(A)
	if K%2 == 1 {
		A[0] = -A[0]
	}
	return sum(A)
}

func sum(A []int) int {
	res := 0
	for i := 0; i &lt; len(A); i++ {
		res = res + A[i]
	}
	return res
}

# 2
func largestSumAfterKNegations(A []int, K int) int {
	sort.Ints(A)
	i := 0
	for i &lt; len(A)-1 &amp;&amp; K &gt; 0 {
		A[i] = -A[i]
		if A[i] &gt; 0 &amp;&amp; A[i] &gt; A[i+1] {
			i++
		}
		K--
	}
	return sum(A)
}

func sum(A []int) int {
	res := 0
	for i := 0; i &lt; len(A); i++ {
		res = res + A[i]
	}
	return res
}

# 3
func largestSumAfterKNegations(A []int, K int) int {
	arr := make([]int, 201)
	for i := 0; i &lt; len(A); i++ {
		arr[A[i]+100]++
	}
	i := 0
	for K &gt; 0 {
		for arr[i] == 0 {
			i++
		}
		if i &gt; 100 {
			break
		}
		arr[i]--
		arr[200-i]++
		K--
	}
	if K%2 == 1 &amp;&amp; i != 100 {
		for j := i; j &lt; len(arr); j++ {
			if arr[j] &gt; 0 {
				arr[j]--
				arr[200-j]++
				break
			}
		}
	}
	res := 0
	for i := 0; i &lt; len(arr); i++ {
		res = res + (i-100)*arr[i]
	}
	return res
}

# 4
func largestSumAfterKNegations(A []int, K int) int {
	for K &gt; 0 {
		minIndex, minValue := findMin(A)
		if minValue &gt; 0 {
			break
		}
		A[minIndex] = -A[minIndex]
		K--
	}
	if K%2 == 1 {
		minIndex, _ := findMin(A)
		A[minIndex] = -A[minIndex]
	}
	res := 0
	for i := 0; i &lt; len(A); i++ {
		res = res + A[i]
	}
	return res
}

func findMin(A []int) (int, int) {
	res := A[0]
	index := 0
	for i := 1; i &lt; len(A); i++ {
		if res &gt; A[i] {
			res = A[i]
			index = i
		}
	}
	return index, res
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>1009.十进制整数的反码(3)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 &quot;101&quot;，11 可以用二进制 &quot;1011&quot; 表示，
依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。
二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 &quot;101&quot; 的二进制反码为 &quot;010&quot;。
给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。
示例 1：输入：5 输出：2
解释：5 的二进制表示为 &quot;101&quot;，其二进制反码为 &quot;010&quot;，也就是十进制中的 2 。
示例 2：输入：7 输出：0
解释：7 的二进制表示为 &quot;111&quot;，其二进制反码为 &quot;000&quot;，也就是十进制中的 0 。
示例 3：输入：10 输出：5
解释：10 的二进制表示为 &quot;1010&quot;，其二进制反码为 &quot;0101&quot;，也就是十进制中的 5 。
提示：
    0 &lt;= N &lt; 10^9
    本题与 476：https://leetcode-cn.com/problems/number-complement/ 相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>位运算</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>位运算</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>/*
101+010=1000=111+1
*/
func bitwiseComplement(N int) int {
	temp := 2
	for N &gt;= temp {
		temp = temp &lt;&lt; 1
	}
	return temp - 1 - N
}

#
/*
101^111=010
*/
func bitwiseComplement(N int) int {
	temp := N
	res := 1
	for temp &gt; 1 {
		temp = temp &gt;&gt; 1
		res = res &lt;&lt; 1
		res++
	}
	return res ^ N
}

#
func bitwiseComplement(N int) int {
	res := 0
	if N == 0 {
		return 1
	}
	if N == 1 {
		return 0
	}
	exp := 1
	for N &gt; 0 {
		if N%2 == 0 {
			res = res + exp
		}
		exp = exp * 2
		N = N / 2
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>1010.总持续时间可被60整除的歌曲(2)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。
返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。
形式上，我们希望索引的数字 i 和 j 满足  i &lt; j 且有 (time[i] + time[j]) % 60 == 0。
示例 1：输入：[30,20,150,100,40] 输出：3
解释：这三对的总持续时间可被 60 整数：
(time[0] = 30, time[2] = 150): 总持续时间 180
(time[1] = 20, time[3] = 100): 总持续时间 120
(time[1] = 20, time[4] = 40): 总持续时间 60
示例 2：输入：[60,60,60] 输出：3
解释：所有三对的总持续时间都是 120，可以被 60 整数。
提示：
    1 &lt;= time.length &lt;= 60000
    1 &lt;= time[i] &lt;= 500
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numPairsDivisibleBy60(time []int) int {
	m := make(map[int]int)
	for i := 0; i &lt; len(time); i++ {
		m[time[i]%60]++
	}
	res := 0
	for key, value := range m {
		if key == 0 || key == 30 {
			res = res + (value-1)*value/2
		} else {
			if v, ok := m[60-key]; ok &amp;&amp; v &gt; 0 {
				res = res + v*value
				m[key] = 0
				m[60-key] = 0
			}
		}
	}
	return res
}

#
func numPairsDivisibleBy60(time []int) int {
	res := 0
	arr := make([]int,60)
	for i := range time{
		if time[i] % 60 == 0{
			res = res + arr[0]
		}else {
			res = res + arr[60-time[i]%60]
		}
		arr[time[i]%60]++
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>1013.将数组分成和相等的三个部分(2)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。
形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + ... + A[i] 
== A[i+1] + A[i+2] + ... + A[j-1] 
== A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。
示例 1：输入：[0,2,1,-6,6,-7,9,1,2,0,1] 输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
示例 2：输入：[0,2,1,-6,6,7,9,-1,2,0,1] 输出：false
示例 3：输入：[3,3,6,5,-2,2,5,1,-9,4] 输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4

提示：
    3 &lt;= A.length &lt;= 50000
    -10^4 &lt;= A[i] &lt;= 10^4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func canThreePartsEqualSum(A []int) bool {
	length := len(A)
	if length &lt; 3 {
		return false
	}
	sum := 0
	for i := 0; i &lt; length; i++ {
		sum = sum + A[i]
	}
	if sum%3 != 0 {
		return false
	}
	target := sum / 3
	count := 0
	temp := 0
	for i := 0; i &lt; len(A); i++ {
		temp = temp + A[i]
		if temp == target {
			temp = 0
			count++
		}
	}
	if count &gt;= 3 {
		return true
	}
	return false
}

#
func canThreePartsEqualSum(A []int) bool {
	length := len(A)
	if length &lt; 3 {
		return false
	}
	sum := 0
	for i := 0; i &lt; length; i++ {
		sum = sum + A[i]
	}
	if sum%3 != 0 {
		return false
	}
	target := sum / 3
	left, right := 1, len(A)-2
	leftValue, rightValue := A[0], A[len(A)-1]
	for left &lt; right {
		for left &lt; right &amp;&amp; leftValue != target {
			leftValue = leftValue + A[left]
			left++
		}
		for left &lt; right &amp;&amp; rightValue != target {
			rightValue = rightValue + A[right]
			right--
		}
		if leftValue == target &amp;&amp; rightValue == target {
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>1018.可被5整除的二进制前缀(1)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定由若干 0 和 1 组成的数组 A。我们定义 N_i：
从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。
返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。
示例 1：输入：[0,1,1] 输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。
示例 2：输入：[1,1,1] 输出：[false,false,false]
示例 3：输入：[0,1,1,1,1,1] 输出：[true,false,false,false,true,false]
示例 4：输入：[1,1,1,0,1] 输出：[false,false,false,false,false]
提示：
    1 &lt;= A.length &lt;= 30000
    A[i] 为 0 或 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历-求余</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">prefixesDivBy5</span><span class="p">(</span><span class="nx">A</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">A</span><span class="p">))</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="p">=</span> <span class="p">(</span><span class="nx">temp</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">5</span>
		<span class="k">if</span> <span class="nx">temp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>1021.删除最外层的括号(3)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有效括号字符串为空 (&quot;&quot;)、&quot;(&quot; + A + &quot;)&quot; 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。
例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 &quot;(()(()))&quot; 都是有效的括号字符串。
如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），
其中 A 和 B 都是非空有效括号字符串。
给出一个非空有效字符串 S，考虑将其进行原语化分解，
使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。
对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。
示例 1：输入：&quot;(()())(())&quot; 输出：&quot;()()()&quot;
解释：
输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，
删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;。

示例 2：输入：&quot;(()())(())(()(()))&quot; 输出：&quot;()()()()(())&quot;
解释：
输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;，
删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;。
示例 3：输入：&quot;()()&quot; 输出：&quot;&quot;
解释： 输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;，
删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; = &quot;&quot;。
提示：
    S.length &lt;= 10000
    S[i] 为 &quot;(&quot; 或 &quot;)&quot;
    S 是一个有效括号字符串
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeOuterParentheses(S string) string {
	if len(S) == 0 {
		return &quot;&quot;
	}
	res := &quot;&quot;
	stack := make([]byte, 0)
	stack = append(stack, S[0])
	last := 0
	for i := 1; i &lt; len(S); i++ {
		if len(stack) &gt; 0 &amp;&amp; S[i] == &#39;)&#39; &amp;&amp; stack[len(stack)-1] == &#39;(&#39; {
			stack = stack[:len(stack)-1]
			if len(stack) == 0 {
				res = res + S[last+1:i]
				last = i + 1
			}
		} else {
			stack = append(stack, S[i])
		}
	}
	return res
}

#
func removeOuterParentheses(S string) string {
	res := &quot;&quot;
	count := 0
	last := 0
	for i := 0; i &lt; len(S); i++ {
		if S[i] == &#39;(&#39; {
			count++
		} else {
			count--
		}
		if count == 1 &amp;&amp; S[i] == &#39;(&#39; {
			last = i
		}
		if count == 0 {
			res = res + S[last+1:i]
		}
	}
	return res
}

#
func removeOuterParentheses(S string) string {
	if len(S) == 0 {
		return &quot;&quot;
	}
	res := &quot;&quot;
	stack := make([]byte, 0)
	for i := 0; i &lt; len(S); i++ {
		if S[i] == &#39;)&#39; {
			stack = stack[:len(stack)-1]
		}
		if len(stack) &gt; 0 {
			res = res + string(S[i])
		}
		if S[i] == &#39;(&#39; {
			stack = append(stack, S[i])
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>1022.从根到叶的二进制数之和(2)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。
例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。
对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。
以 10^9 + 7 为模，返回这些数字之和。
示例：输入：[1,0,1,0,1,0,1] 输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
提示：
    树中的结点数介于 1 和 1000 之间。
    node.val 为 0 或 1 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res int

func sumRootToLeaf(root *TreeNode) int {
	res = 0
	dfs(root, 0)
	return res
}

func dfs(root *TreeNode, sum int) {
	if root == nil {
		return
	}
	sum = sum*2 + root.Val
	if root.Left == nil &amp;&amp; root.Right == nil {
		res = (res + sum) % 1000000007
	}
	dfs(root.Left, sum)
	dfs(root.Right, sum)
}

#
type Node struct {
	node *TreeNode
	sum  int
}

func sumRootToLeaf(root *TreeNode) int {
	res := 0
	stack := make([]Node, 0)
	stack = append(stack, Node{
		node: root,
		sum:  0,
	})
	for len(stack) &gt; 0 {
		node, sum := stack[len(stack)-1].node, stack[len(stack)-1].sum
		stack = stack[:len(stack)-1]
		sum = sum*2 + node.Val
		if node.Left == nil &amp;&amp; node.Right == nil {
			res = (res + sum) % 1000000007
		}
		if node.Left != nil {
			stack = append(stack, Node{
				node: node.Left,
				sum:  sum,
			})
		}
		if node.Right != nil {
			stack = append(stack, Node{
				node: node.Right,
				sum:  sum,
			})
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>1025.除数博弈(2)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：
    选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。
    用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。
只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。
示例 1：输入：2 输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：输入：3 输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
提示：
    1 &lt;= N &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>找规律</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func divisorGame(N int) bool {
	return N % 2 == 0
}

#
func divisorGame(N int) bool {
	dp := make([]bool, N+1)
	dp[1] = false // 1的时候爱丽丝没有选择，失败
	for i := 2; i &lt;= N; i++ {
		for j := 1; j &lt; i; j++ {
			if i%j == 0 &amp;&amp; dp[i-j] == false {
				dp[i] = true
			}
		}
	}
	return dp[N]
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>1029.两地调度(2)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。
返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。
示例：输入：[[10,20],[30,200],[400,50],[30,20]] 输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。
最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
提示：
    1 &lt;= costs.length &lt;= 100
    costs.length 为偶数
    1 &lt;= costs[i][0], costs[i][1] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func twoCitySchedCost(costs [][]int) int {
	sort.Slice(costs, func(i, j int) bool {
		return costs[i][0]-costs[i][1] &lt; costs[j][0]-costs[j][1]
	})
	res := 0
	for i := 0; i &lt; len(costs); i++ {
		if i &lt; len(costs)/2 {
			res = res + costs[i][0]
		} else {
			res = res + costs[i][1]
		}
	}
	return res
}

#
func twoCitySchedCost(costs [][]int) int {
	n := len(costs)
	dp := make([][]int, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]int, n+1)
		for j := i + 1; j &lt;= n; j++ {
			// dp[i][j]表示i个人飞往A市的次数为j的最低费用
			// 无效掉j&gt;i的情况，比如i=3, j=4
			// 因为不存在3个人飞往A市次数为4次的情况
			dp[i][j] = 100000000
		}
	}
	for i := 1; i &lt;= n; i++ {
		dp[i][0] = dp[i-1][0] + costs[i-1][1]
		for j := 1; j &lt;= i; j++ {
			// dp[i][j]表示i个人飞往A市的次数为j的最低费用
			// 其中i-1个人飞往A市的次数为j+当前飞往B市的费用
			// 其中i-1个人飞往A市的次数为j-1+当前飞往A市的费用
			dp[i][j] = min(dp[i-1][j]+costs[i-1][1], dp[i-1][j-1]+costs[i-1][0])
		}
	}
	return dp[n][n/2]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>1030.距离顺序排列矩阵单元格(3)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。
另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。
返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，
其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。
（你可以按任何满足此条件的顺序返回答案。）
示例 1：输入：R = 1, C = 2, r0 = 0, c0 = 0 输出：[[0,0],[0,1]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1]
示例 2：输入：R = 2, C = 2, r0 = 0, c0 = 1 输出：[[0,1],[0,0],[1,1],[1,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]
[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。
示例 3：输入：R = 2, C = 3, r0 = 1, c0 = 2 输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]
其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。
提示：
    1 &lt;= R &lt;= 100
    1 &lt;= C &lt;= 100
    0 &lt;= r0 &lt; R
    0 &lt;= c0 &lt; C
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>I</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int {
	res := make([][]int, 0)
	visited := make([][]bool, R)
	for i := 0; i &lt; R; i++ {
		visited[i] = make([]bool, C)
	}
	list := make([][]int, 0)
	list = append(list, []int{r0, c0})
	visited[r0][c0] = true
	for len(list) &gt; 0 {
		x1, y1 := list[0][0], list[0][1]
		res = append(res, []int{x1, y1})
		list = list[1:]
		for i := 0; i &lt; 4; i++ {
			x := x1 + dx[i]
			y := y1 + dy[i]
			if (0 &lt;= x &amp;&amp; x &lt; R &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; C) &amp;&amp; visited[x][y] == false {
				visited[x][y] = true
				list = append(list, []int{x, y})
			}
		}
	}
	return res
}

#
func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int {
	res := make([][]int, 0)
	for i := 0; i &lt; R; i++ {
		for j := 0; j &lt; C; j++ {
			res = append(res, []int{i, j})
		}
	}
	sort.Slice(res, func(i, j int) bool {
		return abs(res[i][0], r0)+abs(res[i][1], c0) &lt;
			abs(res[j][0], r0)+abs(res[j][1], c0)
	})
	return res
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}

#
func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int {
	res := make([][]int, 0)
	m := make(map[int][][]int)
	max := 0
	for i := 0; i &lt; R; i++ {
		for j := 0; j &lt; C; j++ {
			length := abs(i, r0) + abs(j, c0)
			m[length] = append(m[length], []int{i, j})
			if length &gt; max {
				max = length
			}
		}
	}
	for i := 0; i &lt;= max; i++ {
		for j := 0; j &lt; len(m[i]); j++ {
			res = append(res, m[i][j])
		}
	}
	return res
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>1033.移动石子直到连续(2)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>三枚石子放置在数轴上，位置分别为 a，b，c。
每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。
从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。
当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：
answer = [minimum_moves, maximum_moves]
示例 1：输入：a = 1, b = 2, c = 5 输出：[1, 2]
解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。
示例 2：输入：a = 4, b = 3, c = 2 输出：[0, 0]
解释：我们无法进行任何移动。
提示：
    1 &lt;= a &lt;= 100
    1 &lt;= b &lt;= 100
    1 &lt;= c &lt;= 100
    a != b, b != c, c != a
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>找规律</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>找规律</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numMovesStones(a int, b int, c int) []int {
	arr := []int{a, b, c}
	sort.Ints(arr)
	a, b, c = arr[0], arr[1], arr[2]
	if a &lt; b &amp;&amp; b &lt; c {
		if b-a == 1 &amp;&amp; c-b == 1 {
			return []int{0, 0}
		} else if b-a &gt; 2 &amp;&amp; c-b &gt; 2 {
			return []int{2, c - a - 2}
		} else {
			return []int{1, c - a - 2}
		}
	}
	return []int{0, 0}
}

#
func numMovesStones(a int, b int, c int) []int {
	if a &gt; b {
		a, b = b, a
	}
	if b &gt; c {
		b, c = c, b
	}
	if a &gt; b {
		a, b = b, a
	}
	if a &lt; b &amp;&amp; b &lt; c {
		if b-a == 1 &amp;&amp; c-b == 1 {
			return []int{0, 0}
		} else if b-a &gt; 2 &amp;&amp; c-b &gt; 2 {
			return []int{2, c - a - 2}
		} else {
			return []int{1, c - a - 2}
		}
	}
	return []int{0, 0}
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>1037.有效的回旋镖(3)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。
给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。
示例 1：输入：[[1,1],[2,3],[3,2]] 输出：true
示例 2：输入：[[1,1],[2,2],[3,3]] 输出：false
提示：
    points.length == 3
    points[i].length == 2
    0 &lt;= points[i][j] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>斜率公式</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>鞋带公式</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>判断是否组成三角形</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>// k1=(y1-y0)/(x1-x0) = k2 = (y2-y1)/(x2-x1)
// (x1-x0)*(y2-y1) = (x2-x1)*(y1-y0)
func isBoomerang(points [][]int) bool {
	return (points[1][0]-points[0][0])*(points[2][1]-points[1][1]) !=
		(points[2][0]-points[1][0])*(points[1][1]-points[0][1])
}

#
// 鞋带公式
// S=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2
// S!=0组成三角形
func isBoomerang(points [][]int) bool {
	return points[0][0]*points[1][1]+points[1][0]*points[2][1]+points[2][0]*points[0][1] !=
		points[0][1]*points[1][0]+points[1][1]*points[2][0]+points[2][1]*points[0][0]
}

#
func isBoomerang(points [][]int) bool {
	side1 := side(points[0], points[1])
	side2 := side(points[1], points[2])
	side3 := side(points[0], points[2])
	return side1+side2 &gt; side3 &amp;&amp;
		side2+side3 &gt; side1 &amp;&amp;
		side1+side3 &gt; side2
}

func side(arr1, arr2 []int) float64 {
	res := (arr1[0]-arr2[0])*(arr1[0]-arr2[0]) +
		(arr1[1]-arr2[1])*(arr1[1]-arr2[1])
	return math.Sqrt(float64(res))
}
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>1042.不邻接植花(1)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。
paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。
另外，没有花园有 3 条以上的路径可以进入或者离开。
你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。
以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。
花的种类用  1, 2, 3, 4 表示。保证存在答案。
示例 1：输入：N = 3, paths = [[1,2],[2,3],[3,1]] 输出：[1,2,3]
示例 2：输入：N = 4, paths = [[1,2],[3,4]] 输出：[1,2,1,2]
示例 3：输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] 输出：[1,2,3,4]
提示：
    1 &lt;= N &lt;= 10000
    0 &lt;= paths.size &lt;= 20000
    不存在花园有 4 条或者更多路径可以进入或离开。
    保证存在答案。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>邻接表</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">gardenNoAdj</span><span class="p">(</span><span class="nx">N</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">paths</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
			<span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
			<span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
			<span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
			<span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">res</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">res</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]])</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>1046.最后一块石头的重量(2)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。
那么粉碎的可能结果如下：
    如果 x == y，那么两块石头都会被完全粉碎；
    如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例：输入：[2,7,4,1,8,1] 输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
提示：
    1 &lt;= stones.length &lt;= 30
    1 &lt;= stones[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序</td>
<td>O(n^2*log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h IntHeap) Less(i, j int) bool {
	return h[i] &gt; h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

func lastStoneWeight(stones []int) int {
	intHeap := make(IntHeap, 0)
	heap.Init(&amp;intHeap)
	for i := 0; i &lt; len(stones); i++ {
		heap.Push(&amp;intHeap, stones[i])
	}
	for intHeap.Len() &gt; 1 {
		a := heap.Pop(&amp;intHeap).(int)
		b := heap.Pop(&amp;intHeap).(int)
		if a &gt; b {
			heap.Push(&amp;intHeap, a-b)
		}
	}
	if intHeap.Len() &gt; 0 {
		res := heap.Pop(&amp;intHeap).(int)
		return res
	}
	return 0
}

#
func lastStoneWeight(stones []int) int {
	length := len(stones)
	if length == 1 {
		return stones[0]
	}
	sort.Ints(stones)
	for stones[length-2] != 0 {
		stones[length-1] = stones[length-1] - stones[length-2]
		stones[length-2] = 0
		sort.Ints(stones)
	}
	return stones[length-1]
}
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>1047.删除字符串中的所有相邻重复项(2)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
示例：输入：&quot;abbaca&quot; 输出：&quot;ca&quot;
解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。
之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
提示：
    1 &lt;= S.length &lt;= 20000
    S 仅由小写英文字母组成。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeDuplicates(S string) string {
	stack := make([]int32, 0)
	for _, v := range S {
		stack = append(stack, v)
		for len(stack) &gt; 1 &amp;&amp; stack[len(stack)-1] == stack[len(stack)-2] {
			stack = stack[:len(stack)-2]
		}
	}
	return string(stack)
}

#
func removeDuplicates(S string) string {
	arr := []byte(S)
	for {
		flag := false
		for i := 0; i &lt; len(arr)-1; i++ {
			if arr[i] == arr[i+1] {
				if i+2 != len(arr) {
					arr = append(arr[:i], arr[i+2:]...)
				} else {
					arr = arr[:i]
				}
				flag = true
				break
			}
		}
		if flag == false {
			break
		}
	}
	return string(arr)
}
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>1051.高度检查器(2)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。
请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。
注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。
示例：输入：heights = [1,1,4,2,1,3] 输出：3 
解释：当前数组：[1,1,4,2,1,3] 目标数组：[1,1,1,2,3,4]
在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。
在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。
在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。
示例 2：输入：heights = [5,1,2,3,4] 输出：5
示例 3：输入：heights = [1,2,3,4,5] 输出：0
提示：
    1 &lt;= heights.length &lt;= 100
    1 &lt;= heights[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func heightChecker(heights []int) int {
	temp := make([]int, len(heights))
	copy(temp, heights)
	sort.Ints(temp)
	res := 0
	for i := 0; i &lt; len(temp); i++ {
		if temp[i] != heights[i] {
			res++
		}
	}
	return res
}

#
func heightChecker(heights []int) int {
	arr := make([]int, 101)
	for i := 0; i &lt; len(heights); i++ {
		arr[heights[i]]++
	}
	res := 0
	j := 0
	for i := 1; i &lt;= 100; i++ {
		for arr[i] &gt; 0 {
			if heights[j] != i {
				res++
			}
			arr[i]--
			j++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>1071.字符串的最大公因子(2)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。
返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。
示例 1：输入：str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot; 输出：&quot;ABC&quot;
示例 2：输入：str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot; 输出：&quot;AB&quot;
示例 3：输入：str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot; 输出：&quot;&quot;
提示：
    1 &lt;= str1.length &lt;= 1000
    1 &lt;= str2.length &lt;= 1000
    str1[i] 和 str2[i] 为大写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>辗转相除法</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func gcdOfStrings(str1 string, str2 string) string {
	if str1+str2 != str2+str1 {
		return &quot;&quot;
	}
	if str1 &gt; str2 {
		str1, str2 = str2, str1
	}
	return str1[:gcd(len(str2), len(str1))]
}

func gcd(a, b int) int {
	if b == 0 {
		return a
	}
	return gcd(b, a%b)
}

#
func gcdOfStrings(str1 string, str2 string) string {
	min := len(str1)
	if min &gt; len(str2) {
		min = len(str2)
	}
	for i := len(str2); i &gt;= 1; i-- {
		if len(str1)%i == 0 &amp;&amp; len(str2)%i == 0 &amp;&amp; str1[:i] == str2[:i] {
			a := strings.Repeat(str1[:i], len(str1)/i)
			b := strings.Repeat(str2[:i], len(str2)/i)
			if a == str1 &amp;&amp; b == str2 {
				return str1[:i]
			}
		}
	}
	return &quot;&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="bigram-1">
<h2>1078.Bigram 分词(1)<a class="headerlink" href="#bigram-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出第一个词 first 和第二个词 second，
考虑在某些文本 text 中可能以 &quot;first second third&quot; 形式出现的情况，
其中 second 紧随 first 出现，third 紧随 second 出现。
对于每种这样的情况，将第三个词 &quot;third&quot; 添加到答案中，并返回答案。
示例 1：
输入：text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;
输出：[&quot;girl&quot;,&quot;student&quot;]
示例 2：
输入：text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;
输出：[&quot;we&quot;,&quot;rock&quot;]
提示：
    1 &lt;= text.length &lt;= 1000
    text 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成
    1 &lt;= first.length, second.length &lt;= 10
    first 和 second 由小写英文字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">findOcurrences</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">first</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">second</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Fields</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">second</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>1089.复写零(3)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。
注意：请不要在超过该数组长度的位置写入元素。
要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。
示例 1：输入：[1,0,2,3,0,4,5,0] 输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
示例 2：输入：[1,2,3] 输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
提示：
    1 &lt;= arr.length &lt;= 10000
    0 &lt;= arr[i] &lt;= 9
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历后移</td>
<td>O(n^2)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数组辅助</td>
<td>O(n)</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func duplicateZeros(arr []int) {
	count := 0
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == 0 {
			count++
		}
	}
	for i := len(arr) - 1; i &gt;= 0; i-- {
		if arr[i] == 0 {
			count--
			if i+count &lt; len(arr) {
				arr[i+count] = 0
			}
			if i+count+1 &lt; len(arr) {
				arr[i+count+1] = 0
			}
		} else if i+count &lt; len(arr) {
			arr[i+count] = arr[i]
		}
	}
}

#
func duplicateZeros(arr []int) {
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == 0 {
			for j := len(arr) - 1; j &gt; i; j-- {
				arr[j] = arr[j-1]
			}
			i++
		}
	}
}

#
func duplicateZeros(arr []int) {
	newArr := make([]int, 0)
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == 0 {
			newArr = append(newArr, 0)
		}
		newArr = append(newArr, arr[i])
	}
	for i := 0; i &lt; len(arr); i++ {
		arr[i] = newArr[i]
	}
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>1001-1100-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id19">
<h2>1003.检查替换后的词是否有效(2)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定有效字符串 &quot;abc&quot;。
对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。
（X 或 Y 可以为空。）那么，X + &quot;abc&quot; + Y 也同样是有效的。
例如，如果 S = &quot;abc&quot;，则有效字符串的示例是：&quot;abc&quot;，&quot;aabcbc&quot;，&quot;abcabc&quot;，&quot;abcabcababcc&quot;。
无效字符串的示例是：&quot;abccba&quot;，&quot;ab&quot;，&quot;cababc&quot;，&quot;bac&quot;。
如果给定字符串 S 有效，则返回 true；否则，返回 false。
示例 1：输入：&quot;aabcbc&quot; 输出：true
解释：从有效字符串 &quot;abc&quot; 开始。
然后我们可以在 &quot;a&quot; 和 &quot;bc&quot; 之间插入另一个 &quot;abc&quot;，产生 &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot;，即 &quot;aabcbc&quot;。
示例 2：输入：&quot;abcabcababcc&quot; 输出：true
解释：&quot;abcabcabc&quot; 是有效的，它可以视作在原串后连续插入 &quot;abc&quot;。
然后我们可以在最后一个字母之前插入 &quot;abc&quot;，产生 &quot;abcabcab&quot; + &quot;abc&quot; + &quot;c&quot;，即 &quot;abcabcababcc&quot;。
示例 3：输入：&quot;abccba&quot; 输出：false
示例 4：输入：&quot;cababc&quot; 输出：false
提示：1 &lt;= S.length &lt;= 20000
S[i] 为 &#39;a&#39;、&#39;b&#39;、或 &#39;c&#39;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n)</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isValid(s string) bool {
	stack := make([]byte, 0)
	for i := 0; i &lt; len(s); i++ {
		stack = append(stack, s[i])
		if len(stack) &gt;= 3 &amp;&amp; string(stack[len(stack)-3:]) == &quot;abc&quot; {
			stack = stack[:len(stack)-3]
		}
	}
	return len(stack) == 0
}

# 2
func isValid(s string) bool {
	for strings.Contains(s, &quot;abc&quot;) {
		s = strings.ReplaceAll(s, &quot;abc&quot;, &quot;&quot;)
	}
	return s == &quot;&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="iii-2">
<h2>1004.最大连续1的个数III(2)<a class="headerlink" href="#iii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。
返回仅包含 1 的最长（连续）子数组的长度。
示例 1：输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6
解释： [1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
提示：1 &lt;= A.length &lt;= 20000
    0 &lt;= K &lt;= A.length
    A[i] 为 0 或 1 
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针-滑动窗口</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针-滑动窗口</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestOnes(A []int, K int) int {
	res := 0
	left, right := 0, 0
	for right &lt; len(A) {
		if A[right] == 1 {
			right++
		} else {
			if K &gt; 0 {
				right++
				K--
			} else {
				res = max(res, right-left)
				if A[left] == 0 {
					K++
				}
				left++
			}
		}
	}
	res = max(res, right-left)
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func longestOnes(A []int, K int) int {
	res := 0
	left, right := 0, 0
	count := 0
	for right = 0; right &lt; len(A); right++ {
		if A[right] == 0 {
			count++
		}
		for count &gt; K {
			if A[left] == 0 {
				count--
			}
			left++
		}
		res = max(res, right-left+1)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>1006.笨阶乘(1)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。
例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。
相反，我们设计了一个笨阶乘 clumsy：
在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：
乘法(*)，除法(/)，加法(+)和减法(-)。
例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。
然而，这些运算仍然使用通常的算术运算顺序：
我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。
另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。
实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。
示例 1：输入：4 输出：7
解释：7 = 4 * 3 / 2 + 1
示例 2：输入：10 输出：12
解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
提示：1 &lt;= N &lt;= 10000
-2^31 &lt;= answer &lt;= 2^31 - 1  （答案保证符合 32 位整数。）
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">clumsy</span><span class="p">(</span><span class="nx">N</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">*</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span><span class="o">*</span><span class="nx">i</span><span class="o">*</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">sum</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>1007.行相等的最少多米诺旋转(2)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。
（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）
我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。
返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。
如果无法做到，返回 -1.
示例 1：输入：A = [2,1,2,4,2,2], B = [5,2,6,2,3,2] 输出：2
解释：图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。
如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。
示例 2：输入：A = [3,5,1,2,3], B = [3,6,3,3,4] 输出：-1
解释：在这种情况下，不可能旋转多米诺牌使一行的值相等。
提示：1 &lt;= A[i], B[i] &lt;= 6
2 &lt;= A.length == B.length &lt;= 20000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minDominoRotations(A []int, B []int) int {
	a, b := A[0], B[0]
	resA := check(A, B, a)
	resB := check(A, B, b)
	if resA &gt; 0 &amp;&amp; resB &gt; 0 { // 都行选最少
		return min(resA, resB)
	}
	return max(resA, resB) // 不行选最多
}

func check(A []int, B []int, target int) int {
	a, b := 0, 0
	for i := 0; i &lt; len(A); i++ {
		if A[i] != target &amp;&amp; B[i] != target { // 都不满足直接返回-1
			return -1
		} else if A[i] != target { // A[i]不满足，需要交换
			a++
		} else if B[i] != target { // B[i]不满足，需要交换
			b++
		}
	}
	return min(a, b)
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func minDominoRotations(A []int, B []int) int {
	var arr, arrA, arrB [7]int
	for i := 0; i &lt; len(A); i++ {
		if A[i] == B[i] {
			arr[A[i]]++
		} else {
			arr[A[i]]++
			arr[B[i]]++
			arrA[A[i]]++
			arrB[B[i]]++
		}
	}
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == len(A) {
			return min(arrA[i], arrB[i])
		}
	}
	return -1
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>1008.前序遍历构造二叉搜索树(2)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，
对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。
此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：输入：[8,5,1,7,10,12] 输出：[8,5,10,1,7,null,12]
提示：1 &lt;= preorder.length &lt;= 100
1 &lt;= preorder[i] &lt;= 10^8
preorder 中的值互不相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(nlog(n))</td>
<td align="left">O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td align="left">O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func bstFromPreorder(preorder []int) *TreeNode {
	var root *TreeNode
	for i := 0; i &lt; len(preorder); i++ {
		root = insert(root, &amp;TreeNode{
			Val:   preorder[i],
			Left:  nil,
			Right: nil,
		})
	}
	return root
}

func insert(root *TreeNode, node *TreeNode) *TreeNode {
	if root == nil {
		return node
	}
	if root.Val &lt; node.Val {
		root.Right = insert(root.Right, node)
	} else if root.Val &gt; node.Val {
		root.Left = insert(root.Left, node)
	} else {
		root.Val = node.Val
	}
	return root
}

# 2
func bstFromPreorder(preorder []int) *TreeNode {
	length := len(preorder)
	if length == 0 {
		return nil
	}
	index := length
	for i := 1; i &lt; length; i++ {
		if preorder[i] &gt; preorder[0] {
			index = i
			break
		}
	}
	return &amp;TreeNode{
		Val:   preorder[0],
		Left:  bstFromPreorder(preorder[1:index]),
		Right: bstFromPreorder(preorder[index:]),
	}
}
</pre></div>
</div>
</div>
<div class="section" id="d-1">
<h2>1011.在D天内送达包裹的能力(1)<a class="headerlink" href="#d-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。
我们装载的重量不会超过船的最大运载重量。
返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。
示例 1：输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5 输出：15
解释： 船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10
请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 
(2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 
示例 2：输入：weights = [3,2,2,4,1,4], D = 3 输出：6
解释：船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
示例 3：输入：weights = [1,2,3,1,1], D = 4 输出：3
解释： 第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1
提示：1 &lt;= D &lt;= weights.length &lt;= 50000
    1 &lt;= weights[i] &lt;= 500
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">shipWithinDays</span><span class="p">(</span><span class="nx">weights</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">D</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="nx">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weights</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">weights</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">weights</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
			<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">weights</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="nx">maxValue</span><span class="p">,</span> <span class="nx">sum</span>
	<span class="k">for</span> <span class="nx">left</span> <span class="p">&lt;</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="o">:=</span> <span class="nx">left</span> <span class="o">+</span> <span class="p">(</span><span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
		<span class="nx">count</span> <span class="o">:=</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">weights</span><span class="p">,</span> <span class="nx">mid</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">count</span> <span class="o">&lt;=</span> <span class="nx">D</span> <span class="p">{</span>
			<span class="nx">right</span> <span class="p">=</span> <span class="nx">mid</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">left</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">weights</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weights</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">total</span><span class="o">+</span><span class="nx">weights</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">weights</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
			<span class="nx">total</span> <span class="p">=</span> <span class="nx">weights</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>1014.最佳观光组合(1)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。
一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。
返回一对观光景点能取得的最高分。
示例：输入：[8,1,5,2,6] 输出：11
解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11
提示：2 &lt;= A.length &lt;= 50000
    1 &lt;= A[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxScoreSightseeingPair</span><span class="p">(</span><span class="nx">A</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="nx">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span>
	<span class="c1">// A[i]+A[j]+i-j=&gt; max(A[i]+i)+(A[j]-j) (i&lt;j)</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">A</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="nx">j</span><span class="o">+</span><span class="nx">maxValue</span><span class="p">)</span>
		<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">maxValue</span><span class="p">,</span> <span class="nx">A</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-1">
<h2>1015.可被K整除的最小整数(1)<a class="headerlink" href="#k-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。
返回 N 的长度。如果不存在这样的 N，就返回 -1。
示例 1：输入：1 输出：1
解释：最小的答案是 N = 1，其长度为 1。
示例 2：输入：2 输出：-1
解释：不存在可被 2 整除的正整数 N 。
示例 3：输入：3 输出：3
解释：最小的答案是 N = 111，其长度为 3。
提示：1 &lt;= K &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">smallestRepunitDivByK</span><span class="p">(</span><span class="nx">K</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">K</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">K</span><span class="o">%</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">num</span><span class="o">%</span><span class="nx">K</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">res</span>
		<span class="p">}</span>
		<span class="nx">num</span> <span class="p">=</span> <span class="nx">num</span> <span class="o">%</span> <span class="nx">K</span> <span class="c1">// (n*10+1)%K = ((n%K)*10+1)%K</span>
		<span class="nx">num</span> <span class="p">=</span> <span class="mi">10</span><span class="o">*</span><span class="nx">num</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">res</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>1019.链表中的下一个更大节点(2)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。
每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，
而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。
返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。
注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，
第二个节点值为 1，第三个节点值为 5 。
示例 1：输入：[2,1,5] 输出：[5,5,0]
示例 2：输入：[2,7,4,3,5] 输出：[7,0,5,5,0]
示例 3：输入：[1,7,5,1,9,2,5,1] 输出：[7,9,9,9,0,5,0,0]
提示：对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9
给定列表的长度在 [0, 10000] 范围内
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func nextLargerNodes(head *ListNode) []int {
	arr := make([]int, 0)
	if head == nil {
		return arr
	}
	for head != nil {
		arr = append(arr, head.Val)
		head = head.Next
	}
	res := make([]int, len(arr))
	for i := 0; i &lt; len(arr); i++ {
		for j := i + 1; j &lt; len(arr); j++ {
			if arr[i] &lt; arr[j] {
				res[i] = arr[j]
				break
			}
		}
	}
	return res
}

# 2
func nextLargerNodes(head *ListNode) []int {
	arr := make([]int, 0)
	if head == nil {
		return arr
	}
	for head != nil {
		arr = append(arr, head.Val)
		head = head.Next
	}
	res := make([]int, len(arr))
	stack := make([]int, 0)
	for i := 0; i &lt; len(arr); i++ {
		for len(stack) &gt; 0 &amp;&amp; arr[i] &gt; arr[stack[len(stack)-1]] {
			last := stack[len(stack)-1]
			res[last] = arr[i]
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, i)
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>1020.飞地的数量(2)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。
移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。
返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。
示例 1：输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3
解释： 有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
示例 2：输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0
解释：所有 1 都在边界上或可以到达边界。
提示：
    1 &lt;= A.length &lt;= 500
    1 &lt;= A[i].length &lt;= 500
    0 &lt;= A[i][j] &lt;= 1
    所有行的大小都相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numEnclaves(A [][]int) int {
	for i := 0; i &lt; len(A); i++ {
		dfs(A, i, 0)
		dfs(A, i, len(A[i])-1)
	}
	for i := 0; i &lt; len(A[0]); i++ {
		dfs(A, 0, i)
		dfs(A, len(A)-1, i)
	}
	res := 0
	for i := 0; i &lt; len(A); i++ {
		for j := 0; j &lt; len(A[i]); j++ {
			if A[i][j] == 1 {
				res++
			}
		}
	}
	return res
}

func dfs(A [][]int, i, j int) {
	if i &lt; 0 || i &gt;= len(A) || j &lt; 0 || j &gt;= len(A[i]) {
		return
	}
	if A[i][j] == 0 {
		return
	}
	A[i][j] = 0
	dfs(A, i, j+1)
	dfs(A, i, j-1)
	dfs(A, i+1, j)
	dfs(A, i-1, j)
}

# 2
var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func numEnclaves(A [][]int) int {
	queue := make([][2]int, 0)
	for i := 0; i &lt; len(A); i++ {
		if A[i][0] == 1 {
			A[i][0] = 0
			queue = append(queue, [2]int{i, 0})
		}
		if A[i][len(A[i])-1] == 1 {
			A[i][len(A[i])-1] = 0
			queue = append(queue, [2]int{i, len(A[i]) - 1})
		}
	}
	for i := 0; i &lt; len(A[0]); i++ {
		if A[0][i] == 1 {
			A[0][i] = 0
			queue = append(queue, [2]int{0, i})
		}
		if A[len(A)-1][i] == 1 {
			A[len(A)-1][i] = 0
			queue = append(queue, [2]int{len(A) - 1, i})
		}
	}
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		for k := 0; k &lt; 4; k++ {
			x := dx[k] + node[0]
			y := dy[k] + node[1]
			if x &lt; 0 || x &gt;= len(A) || y &lt; 0 || y &gt;= len(A[0]) {
				continue
			}
			if A[x][y] == 0 {
				continue
			}
			queue = append(queue, [2]int{x, y})
			A[x][y] = 0
		}
	}
	res := 0
	for i := 0; i &lt; len(A); i++ {
		for j := 0; j &lt; len(A[i]); j++ {
			if A[i][j] == 1 {
				res++
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>1023.驼峰式匹配(2)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。
（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）
给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。
只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。
示例 1：输入：queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,
&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;
输出：[true,false,true,true,false]
示例：&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。
&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.
&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.
示例 2：输入：queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], 
pattern = &quot;FoBa&quot; 输出：[true,false,true,false,false]
解释： &quot;FooBar&quot; 可以这样生成：&quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.
&quot;FootBall&quot; 可以这样生成：&quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.
示例 3：输出：queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;],
pattern = &quot;FoBaT&quot; 输入：[false,true,false,false,false]
解释：  &quot;FooBarTest&quot; 可以这样生成：&quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.
提示：1 &lt;= queries.length &lt;= 100
1 &lt;= queries[i].length &lt;= 100
1 &lt;= pattern.length &lt;= 100
所有字符串都仅由大写和小写英文字母组成。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>trie树</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func camelMatch(queries []string, pattern string) []bool {
	n := len(queries)
	res := make([]bool, n)
	for i := 0; i &lt; n; i++ {
		str := queries[i]
		count := 0
		flag := true
		for j := 0; j &lt; len(str); j++ {
			if count &lt; len(pattern) &amp;&amp; str[j] == pattern[count] {
				count++
				continue
			}
			if &#39;A&#39; &lt;= str[j] &amp;&amp; str[j] &lt;= &#39;Z&#39; {
				flag = false
				break
			}
		}
		if flag == true &amp;&amp; count == len(pattern) {
			res[i] = true
		}
	}
	return res
}

# 2
func camelMatch(queries []string, pattern string) []bool {
	node := Constructor()
	node.Insert(pattern)
	res := make([]bool, len(queries))
	for i := 0; i &lt; len(queries); i++ {
		res[i] = node.Match(queries[i])
	}
	return res
}

type Trie struct {
	next   map[int32]*Trie // 下一级指针，如不限于小写字母，[26]=&gt;[256]
	ending int             // 次数（可以改为bool）
}

func Constructor() *Trie {
	return &amp;Trie{
		next:   make(map[int32]*Trie),
		ending: 0,
	}
}

// 插入word
func (this *Trie) Insert(word string) {
	temp := this
	for _, v := range word {
		value := v
		if _, ok := temp.next[value]; ok == false {
			temp.next[value] = Constructor()
		}
		temp = temp.next[value]
	}
	temp.ending++
}

// 查找
func (this *Trie) Match(word string) bool {
	temp := this
	for _, v := range word {
		value := v
		if _, ok := temp.next[value]; ok == false {
			if value &lt; &#39;a&#39; {
				return false
			}
		} else {
			temp = temp.next[value]
		}
	}
	if temp.ending &gt; 0 {
		return true
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>1024.视频拼接(2)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。
这些片段可能有所重叠，也可能长度不一。
视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。
我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。
我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。
返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。
示例 1：输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10 输出：3
解释：我们选中 [0,2], [8,10], [1,9] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。
示例 2：输入：clips = [[0,1],[1,2]], T = 5 输出：-1
解释：我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。
示例 3：输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],
[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9 输出：3
解释： 我们选取片段 [0,4], [4,7] 和 [6,9] 。
示例 4：输入：clips = [[0,4],[2,8]], T = 5 输出：2
解释：注意，你可能录制超过比赛结束时间的视频。
提示：1 &lt;= clips.length &lt;= 100
0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100
0 &lt;= T &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func videoStitching(clips [][]int, T int) int {
	dp := make([]int, T+1) //dp[i]表示将区间[0,i)覆盖所需的最少子区间的数量
	for i := 0; i &lt;= T; i++ {
		dp[i] = math.MaxInt32 / 10
	}
	dp[0] = 0
	for i := 1; i &lt;= T; i++ {
		for j := 0; j &lt; len(clips); j++ {
			a, b := clips[j][0], clips[j][1]
			if a &lt; i &amp;&amp; i &lt;= b &amp;&amp; dp[a]+1 &lt; dp[i] {
				dp[i] = dp[a] + 1
			}
		}
	}
	if dp[T] == math.MaxInt32/10 {
		return -1
	}
	return dp[T]
}

# 2
func videoStitching(clips [][]int, T int) int {
	arr := make([]int, T)
	for i := 0; i &lt; len(clips); i++ {
		a, b := clips[i][0], clips[i][1]
		if a &lt; T &amp;&amp; arr[a] &lt; b {
			arr[a] = b // 更新当前位置能到达最远的位置
		}
	}
	last := 0
	prev := 0
	res := 0
	// 变成leetcode45.跳跃游戏II的变形
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] &gt; last {
			last = arr[i]
		}
		if i == last { // 无法达到目标
			return -1
		}
		if i == prev {
			res++
			prev = last
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>1026.节点与其祖先之间的最大差值(2)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，
其中 V = |A.val - B.val|，且 A 是 B 的祖先。
（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）
示例 1：输入：root = [8,3,10,1,6,null,14,null,null,4,7,13] 输出：7
解释：  我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。
示例 2：输入：root = [1,null,2,null,0,3] 输出：3
提示：树中的节点数在 2 到 5000 之间。
0 &lt;= Node.val &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res int

func maxAncestorDiff(root *TreeNode) int {
	res = 0
	if root == nil {
		return 0
	}
	dfs(root, root.Val, root.Val)
	return res
}

func dfs(root *TreeNode, minValue, maxValue int) {
	if root == nil {
		return
	}
	if root.Val &gt; maxValue {
		maxValue = root.Val
	}
	if root.Val &lt; minValue {
		minValue = root.Val
	}
	if maxValue-minValue &gt; res {
		res = maxValue - minValue
	}
	dfs(root.Left, minValue, maxValue)
	dfs(root.Right, minValue, maxValue)
}

# 2
var res int

func maxAncestorDiff(root *TreeNode) int {
	res = 0
	if root == nil {
		return 0
	}
	dfs(root, []int{})
	return res
}

func dfs(root *TreeNode, arr []int) {
	if root == nil {
		return
	}
	for i := 0; i &lt; len(arr); i++ {
		if abs(arr[i], root.Val) &gt; res {
			res = abs(arr[i], root.Val)
		}
	}
	arr = append(arr, root.Val)
	dfs(root.Left, arr)
	dfs(root.Right, arr)
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>1027.最长等差数列(2)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 A，返回 A 中最长等差子序列的长度。
回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 
其中 0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1。
并且如果 B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1) 的值都相同，那么序列 B 是等差的。
示例 1：输入：[3,6,9,12] 输出：4
解释： 整个数组是公差为 3 的等差数列。
示例 2：输入：[9,4,7,2,10] 输出：3
解释：最长的等差子序列是 [4,7,10]。
示例 3：输入：[20,1,15,3,10,5,8] 输出：4
解释：最长的等差子序列是 [20,15,10,5]。
提示：2 &lt;= A.length &lt;= 2000
0 &lt;= A[i] &lt;= 10000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestArithSeqLength(A []int) int {
	n := len(A)
	if n &lt; 3 {
		return 0
	}
	res := 0
	dp := make([]map[int]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make(map[int]int)
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; i; j++ {
			diff := A[i] - A[j]
			if _, ok := dp[j][diff]; ok {
				dp[i][diff] = dp[j][diff] + 1
			} else {
				dp[j][diff] = 1
				dp[i][diff] = dp[j][diff] + 1
			}
			if dp[i][diff] &gt; res {
				res = dp[i][diff]
			}
		}
	}
	return res
}

# 2
func longestArithSeqLength(A []int) int {
	n := len(A)
	if n &lt; 3 {
		return 0
	}
	res := 0
	dp := make([][20001]int, n)
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; i; j++ {
			diff := A[i] - A[j] + 10001
			if dp[j][diff] &gt; 0 {
				dp[i][diff] = dp[j][diff] + 1
			} else {
				dp[j][diff] = 1
				dp[i][diff] = dp[j][diff] + 1
			}
			if dp[i][diff] &gt; res {
				res = dp[i][diff]
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>1035.不相交的线(3)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。
现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，
且我们绘制的直线不与任何其他连线（非水平线）相交。
以这种方法绘制线条，并返回我们可以绘制的最大连线数。
示例 1：输入：A = [1,4,2], B = [1,2,4] 输出：2
解释：我们可以画出两条不交叉的线，如上图所示。
我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。
示例 2：输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2] 输出：3
示例 3：输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1] 输出：2
提示：1 &lt;= A.length &lt;= 500
    1 &lt;= B.length &lt;= 500
    1 &lt;= A[i], B[i] &lt;= 2000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划-二维</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划-一维</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划-一维</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxUncrossedLines(A []int, B []int) int {
	n, m := len(A), len(B)
	dp := make([][]int, n+1)
	for i := 0; i &lt; n+1; i++ {
		dp[i] = make([]int, m+1)
	}
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= m; j++ {
			if A[i-1] == B[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j])
			}
		}
	}
	return dp[n][m]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maxUncrossedLines(A []int, B []int) int {
	n, m := len(A), len(B)
	prev := make([]int, m+1)
	cur := make([]int, m+1)
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= m; j++ {
			if A[i-1] == B[j-1] {
				cur[j] = prev[j-1] + 1
			} else {
				cur[j] = max(prev[j], cur[j-1])
			}
		}
		copy(prev, cur)
	}
	return cur[m]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func maxUncrossedLines(A []int, B []int) int {
	n, m := len(A), len(B)
	cur := make([]int, m+1)
	for i := 1; i &lt;= n; i++ {
		pre := cur[0]
		for j := 1; j &lt;= m; j++ {
			temp := cur[j]
			if A[i-1] == B[j-1] {
				cur[j] = pre + 1
			} else {
				cur[j] = max(cur[j], cur[j-1])
			}
			pre = temp
		}
	}
	return cur[m]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>1038.把二叉搜索树转换为累加树(2)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
提醒一下，二叉搜索树满足下列约束条件：
节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
注意：该题目与 538:相同
示例 1：输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
示例 2：输入：root = [0,null,1] 输出：[1,null,1]
示例 3：输入：root = [1,0,2] 输出：[3,3,2]
示例 4：输入：root = [3,2,4,1] 输出：[7,9,4,10]
提示：树中的节点数介于 1 和 100 之间。
每个节点的值介于 0 和 100 之间。
树中的所有值 互不相同 。
给定的树为二叉搜索树。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func bstToGst(root *TreeNode) *TreeNode {
	sum := 0
	dfs(root, &amp;sum)
	return root
}

func dfs(root *TreeNode, sum *int) {
	if root == nil {
		return
	}
	dfs(root.Right, sum)
	*sum = *sum + root.Val
	root.Val = *sum
	dfs(root.Left, sum)
}

# 2
func bstToGst(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}
	stack := make([]*TreeNode, 0)
	temp := root
	sum := 0
	for {
		if temp != nil {
			stack = append(stack, temp)
			temp = temp.Right
		} else if len(stack) != 0 {
			temp = stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			temp.Val = temp.Val + sum
			sum = temp.Val
			temp = temp.Left
		} else {
			break
		}
	}
	return root
}
</pre></div>
</div>
</div>
<div class="section" id="ii">
<h2>1040.移动石子直到连续II<a class="headerlink" href="#ii" title="永久链接至标题">¶</a></h2>
<div class="section" id="id32">
<h3>题目<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个长度无限的数轴上，第 i 颗石子的位置为 stones[i]。
如果一颗石子的位置最小/最大，那么该石子被称作端点石子。
每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。
值得注意的是，如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5 的端点石子，
因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。
当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 
以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。
示例 1：输入：[7,4,9] 输出：[1,2]
解释：我们可以移动一次，4 -&gt; 8，游戏结束。
或者，我们可以移动两次 9 -&gt; 5，4 -&gt; 6，游戏结束。
示例 2：输入：[6,5,4,3,10] 输出：[2,3]
解释：我们可以移动 3 -&gt; 8，接着是 10 -&gt; 7，游戏结束。
或者，我们可以移动 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9，游戏结束。
注意，我们无法进行 10 -&gt; 2 这样的移动来结束游戏，因为这是不合要求的移动。
示例 3：输入：[100,101,104,102,103] 输出：[0,0]
提示：3 &lt;= stones.length &lt;= 10^4
1 &lt;= stones[i] &lt;= 10^9
stones[i] 的值各不相同。
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h3>解题思路<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id34">
<h2>1041.困于环中的机器人(1)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一：
&quot;G&quot;：直走 1 个单位
&quot;L&quot;：左转 90 度
&quot;R&quot;：右转 90 度
机器人按顺序执行指令 instructions，并一直重复它们。
只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。
示例 1：输入：&quot;GGLLGG&quot; 输出：true
解释：机器人从 (0,0) 移动到 (0,2)，转 180 度，然后回到 (0,0)。
重复这些指令，机器人将保持在以原点为中心，2 为半径的环中进行移动。
示例 2：输入：&quot;GG&quot; 输出：false
解释：机器人无限向北移动。
示例 3：输入：&quot;GL&quot; 输出：true
解释：机器人按 (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; ... 进行移动。
提示：1 &lt;= instructions.length &lt;= 100
instructions[i] 在 {&#39;G&#39;, &#39;L&#39;, &#39;R&#39;} 中
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">isRobotBounded</span><span class="p">(</span><span class="nx">instructions</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">dx</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">dy</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
	<span class="nx">dir</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">instructions</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">instructions</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;L&#39;</span> <span class="p">{</span>
			<span class="nx">dir</span> <span class="p">=</span> <span class="p">(</span><span class="nx">dir</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">instructions</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span> <span class="p">{</span>
			<span class="nx">dir</span> <span class="p">=</span> <span class="p">(</span><span class="nx">dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">[</span><span class="nx">dir</span><span class="p">]</span>
			<span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">[</span><span class="nx">dir</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="nx">dir</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>1043.分隔数组以得到最大和(3)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。
分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。
返回将数组分隔变换后能够得到的元素最大和。
注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。
示例 1：输入：arr = [1,15,7,9,2,5,10], k = 3 输出：84
解释：因为 k=3 可以分隔成 [1,15,7] [9] [2,5,10]，结果为 [15,15,15,9,10,10,10]，
和为 84，是该数组所有分隔变换后元素总和最大的。
若是分隔成 [1] [15,7,9] [2,5,10]，
结果就是 [1, 15, 15, 15, 10, 10, 10] 但这种分隔方式的元素总和（76）小于上一种。 
示例 2：输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4 输出：83
示例 3：输入：arr = [1], k = 1 输出：1
提示：1 &lt;= arr.length &lt;= 500
0 &lt;= arr[i] &lt;= 109
1 &lt;= k &lt;= arr.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxSumAfterPartitioning(arr []int, k int) int {
	n := len(arr)
	dp := make([]int, n+1)
	for i := 1; i &lt;= n; i++ {
		start := max(0, i-k)
		maxValue := math.MinInt32
		for j := i; j &gt; start; j-- {
			maxValue = max(maxValue, arr[j-1])
			dp[i] = max(dp[i], dp[j-1]+maxValue*(i-j+1))
		}
	}
	return dp[n]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maxSumAfterPartitioning(arr []int, k int) int {
	n := len(arr)
	dp := make([]int, n+1)
	for i := 1; i &lt;= n; i++ {
		start := max(0, i-k)
		maxValue := math.MinInt32
		for j := i - 1; j &gt;= start; j-- {
			maxValue = max(maxValue, arr[j])
			dp[i] = max(dp[i], dp[j]+maxValue*(i-j))
		}
	}
	return dp[n]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func maxSumAfterPartitioning(arr []int, k int) int {
	n := len(arr)
	dp := make([]int, n)
	for i := 0; i &lt; n; i++ {
		maxValue := arr[i]
		for j := i; j &gt;= 0 &amp;&amp; j &gt; i-k; j-- {
			maxValue = max(maxValue, arr[j])
			if j &gt; 0 {
				dp[i] = max(dp[i], dp[j-1]+maxValue*(i-j+1))
			} else {
				dp[i] = max(dp[i], maxValue*(i+1))
			}
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>1048.最长字符串链(2)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个单词列表，其中每个单词都由小写英文字母组成。
如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。
例如，&quot;abc&quot; 是 &quot;abac&quot; 的前身。
词链是单词 [word_1, word_2, ..., word_k] 组成的序列，
k &gt;= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。
从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。
示例：输入：[&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;] 输出：4
解释：最长单词链之一为 &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;。
提示：1 &lt;= words.length &lt;= 1000
1 &lt;= words[i].length &lt;= 16
words[i] 仅由小写英文字母组成。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestStrChain(words []string) int {
	sort.Slice(words, func(i, j int) bool {
		return len(words[i]) &lt; len(words[j])
	})
	res := 0
	dp := make(map[string]int)
	for i := 0; i &lt; len(words); i++ {
		str := words[i]
		for j := 0; j &lt; len(words[i]); j++ {
			target := words[i][:j] + words[i][j+1:]
			if dp[target]+1 &gt; dp[str] {
				dp[str] = dp[target] + 1
			}
		}
		if dp[str] &gt; res {
			res = dp[str]
		}
	}
	return res
}

# 2
func longestStrChain(words []string) int {
	sort.Slice(words, func(i, j int) bool {
		return len(words[i]) &lt; len(words[j])
	})
	res := 0
	dp := make([]int, len(words))
	for i := 0; i &lt; len(words); i++ {
		dp[i] = 1
		for j := 0; j &lt; i; j++ {
			if judge(words[i], words[j]) == true &amp;&amp; dp[j]+1 &gt; dp[i] {
				dp[i] = dp[j] + 1
			}
		}
		if dp[i] &gt; res {
			res = dp[i]
		}
	}
	return res
}

func judge(a, b string) bool {
	if len(a)-len(b) != 1 {
		return false
	}
	i, j := 0, 0
	for i &lt; len(a) &amp;&amp; j &lt; len(b) {
		if a[i] == b[j] {
			j++
		}
		i++
	}
	return j == len(b)
}
</pre></div>
</div>
</div>
<div class="section" id="ii-2">
<h2>1049.最后一块石头的重量II(2)<a class="headerlink" href="#ii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。
那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。
示例：输入：[2,7,4,1,8,1] 输出：1
解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
提示：1 &lt;= stones.length &lt;= 30
1 &lt;= stones[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func lastStoneWeightII(stones []int) int {
	sum := 0
	for i := 0; i &lt; len(stones); i++ {
		sum = sum + stones[i]
	}
    // 求最后1个最小，把石头分2堆，求差值
	// 题目转换为0-1背包问题，容量为sum/2，能装多大体积
	target := sum / 2
	dp := make([]int, sum/2+1)
	for i := 0; i &lt; len(stones); i++ {
		for j := target; j &gt;= 0; j-- {
			if j-stones[i] &gt;= 0 {
				dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
			}
		}
	}
	return sum - 2*dp[sum/2]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func lastStoneWeightII(stones []int) int {
	n := len(stones)
	sum := 0
	for i := 0; i &lt; n; i++ {
		sum = sum + stones[i]
	}
    // 求最后1个最小，把石头分2堆，求差值
	// 题目转换为0-1背包问题，容量为sum/2，能装多大体积
	target := sum / 2
	dp := make([][]int, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]int, target+1)
		dp[i][0] = 0
	}
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= target; j++ {
			if j-stones[i-1] &lt; 0 {
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i-1]]+stones[i-1])
			}
		}
	}
	return sum - 2*dp[n][sum/2]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>1052.爱生气的书店老板(1)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>今天，书店老板有一家店打算试营业 customers.length 分钟。
每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。
在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。
当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。
书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。
请你返回这一天营业下来，最多有多少客户能够感到满意的数量。
示例：输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 输出：16
解释： 书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
提示： 1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000
    0 &lt;= customers[i] &lt;= 1000
    0 &lt;= grumpy[i] &lt;= 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxSatisfied</span><span class="p">(</span><span class="nx">customers</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">grumpy</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">X</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">customers</span><span class="p">)</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">grumpy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">window</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">X</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">grumpy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">window</span> <span class="p">=</span> <span class="nx">window</span> <span class="o">+</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">total</span><span class="o">+</span><span class="nx">window</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">X</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">window</span> <span class="p">=</span> <span class="nx">window</span> <span class="o">+</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">*</span><span class="nx">grumpy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">X</span><span class="p">]</span><span class="o">*</span><span class="nx">grumpy</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">X</span><span class="p">]</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">total</span><span class="o">+</span><span class="nx">window</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>1053.交换一次的先前排列(2)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个正整数的数组 A（其中的元素不一定完全不同），
请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。
如果无法这么操作，就请返回原数组。
示例 1：输入：arr = [3,2,1] 输出：[3,1,2]
解释：交换 2 和 1
示例 2：输入：arr = [1,1,5] 输出：[1,1,5]
解释：已经是最小排列
示例 3：输入：arr = [1,9,4,6,7] 输出：[1,7,4,6,9]
解释：交换 9 和 7
示例 4：输入：arr = [3,1,1,3] 输出：[1,3,1,3]
解释：交换 1 和 3
提示：1 &lt;= arr.length &lt;= 104
1 &lt;= arr[i] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func prevPermOpt1(arr []int) []int {
	for i := len(arr) - 2; i &gt;= 0; i-- {
		if arr[i] &gt; arr[i+1] { // 找到第一个降序的位置a
			b := -1
			maxValue := -1
			for j := i + 1; j &lt; len(arr); j++ { // 往后找到小于a的最大数第1次出现位置b
				if arr[i] &gt; arr[j] {
					if arr[j] &gt; maxValue {
						maxValue = arr[j]
						b = j
					}
				}
			}
			if b != -1 {
				arr[i], arr[b] = arr[b], arr[i]
				return arr
			}
		}
	}
	return arr
}

# 2
func prevPermOpt1(arr []int) []int {
	a := -1
	b := -1
	var i int
	for i = len(arr) - 2; i &gt;= 0; i-- {
		if arr[i] &gt; arr[i+1] { // 找到第一个降序的位置a
			a = i
			break
		}
	}
	if a == -1 {
		return arr
	}
	maxValue := -1
	for j := i + 1; j &lt; len(arr); j++ { // 往后找到小于a的最大数第1次出现位置b
		if arr[a] &gt; arr[j] {
			if arr[j] &gt; maxValue {
				maxValue = arr[j]
				b = j
			}
		}
	}
	if a != -1 &amp;&amp; b != -1 {
		arr[a], arr[b] = arr[b], arr[a]
	}
	return arr
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>1054.距离相等的条形码(2)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。
请你重新排列这些条形码，使其中两个相邻的条形码 不能 相等。 
你可以返回任何满足该要求的答案，此题保证存在答案。
示例 1：输入：[1,1,1,2,2,2] 输出：[2,1,2,1,2,1]
示例 2：输入：[1,1,1,1,2,2,3,3] 输出：[1,3,1,3,2,1,2,1]
提示：1 &lt;= barcodes.length &lt;= 10000
1 &lt;= barcodes[i] &lt;= 10000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rearrangeBarcodes(barcodes []int) []int {
	m := make(map[int]int)
	for i := 0; i &lt; len(barcodes); i++ {
		m[barcodes[i]]++
	}
	arr := make([]Node, 0)
	for k, v := range m {
		arr = append(arr, Node{
			k,
			v,
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i].num &gt; arr[j].num
	})
	res := make([]int, len(barcodes))
	index := 0
	// 先偶后奇
	for i := 0; i &lt; 2; i++ {
		for j := i; j &lt; len(barcodes); j = j + 2 {
			if arr[index].num == 0 {
				index++
			}
			res[j] = arr[index].value
			arr[index].num--
		}
	}
	return res
}

# 2
func rearrangeBarcodes(barcodes []int) []int {
	n := len(barcodes)
	if n &lt;= 1 {
		return barcodes
	}
	res := make([]int, 0)
	m := make(map[int]int)
	for _, v := range barcodes {
		m[v]++
	}
	nodeHeap := &amp;Heap{}
	heap.Init(nodeHeap)
	for k, v := range m {
		heap.Push(nodeHeap, Node{
			value: k,
			num:   v,
		})
	}
	for nodeHeap.Len() &gt;= 2 {
		node1 := heap.Pop(nodeHeap).(Node)
		node2 := heap.Pop(nodeHeap).(Node)
		res = append(res, node1.value, node2.value)
		node1.num--
		node2.num--
		if node1.num &gt; 0 {
			heap.Push(nodeHeap, node1)
		}
		if node2.num &gt; 0 {
			heap.Push(nodeHeap, node2)
		}
	}
	if nodeHeap.Len() &gt; 0 {
		t := heap.Pop(nodeHeap).(Node)
		res = append(res, t.value)
	}
	return res
}

type Node struct {
	value int
	num   int
}

type Heap []Node

func (h Heap) Len() int {
	return len(h)
}

func (h Heap) Less(i, j int) bool {
	return h[i].num &gt; h[j].num
}

func (h Heap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *Heap) Push(x interface{}) {
	*h = append(*h, x.(Node))
}

func (h *Heap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>1079.活字印刷(1)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。
注意：本题中，每个活字字模只能使用一次。
示例 1：输入：&quot;AAB&quot; 输出：8
解释：可能的序列为 &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;。
示例 2：输入：&quot;AAABBC&quot; 输出：188
提示：1 &lt;= tiles.length &lt;= 7
tiles 由大写英文字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯-全排列</td>
<td>O(n!)</td>
<td>O(n!)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nx">numTilePossibilities</span><span class="p">(</span><span class="nx">tiles</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">tiles</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)),</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">visited</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">arr</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">temp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">dfs</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">visited</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
		<span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h2>1081.不同字符的最小子序列(2)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。
示例 1：输入：&quot;cdadabcc&quot; 输出：&quot;adbc&quot;
示例 2：输入：&quot;abcd&quot; 输出：&quot;abcd&quot;
示例 3：输入：&quot;ecbacba&quot; 输出：&quot;eacb&quot;
示例 4：输入：&quot;leetcode&quot; 输出：&quot;letcod&quot;
提示：
    1 &lt;= text.length &lt;= 1000
    text 由小写英文字母组成
注意：本题目与 316 https://leetcode-cn.com/problems/remove-duplicate-letters/ 相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func smallestSubsequence(text string) string {
	stack := make([]byte, 0)
	arr := [256]byte{}
	m := make(map[byte]bool)
	for i := 0; i &lt; len(text); i++ {
		arr[text[i]]++
	}
	for i := 0; i &lt; len(text); i++ {
		if m[text[i]] == true {
			arr[text[i]]--
			continue
		}
		// arr[栈顶]说明有重复元素
		// 栈顶&gt;s[i]:说明字典序不满足
		for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] &gt; text[i] &amp;&amp; arr[stack[len(stack)-1]] &gt; 0 {
			m[stack[len(stack)-1]] = false
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, text[i])
		arr[text[i]]--
		m[text[i]] = true
	}
	return string(stack)
}

# 2
func smallestSubsequence(text string) string {
	arr := [26]int{}
	pos := 0
	for i := 0; i &lt; len(text); i++ {
		arr[text[i]-&#39;a&#39;]++
	}
	for i := 0; i &lt; len(text); i++ {
		if text[i] &lt; text[pos] {
			pos = i
		}
		arr[text[i]-&#39;a&#39;]--
		if arr[text[i]-&#39;a&#39;] == 0 {
			break
		}
	}
	if len(text) == 0 {
		return &quot;&quot;
	}
	newStr := strings.ReplaceAll(text[pos+1:], string(text[pos]), &quot;&quot;)
	return string(text[pos]) + smallestSubsequence(newStr)
}
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h2>1090.受标签影响的最大值(1)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们有一个项的集合，其中第 i 项的值为 values[i]，标签为 labels[i]。
我们从这些项中选出一个子集 S，这样一来：
|S| &lt;= num_wanted
对于任意的标签 L，子集 S 中标签为 L 的项的数目总满足 &lt;= use_limit。
返回子集 S 的最大可能的 和。
示例 1：输入：values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1
输出：9
解释：选出的子集是第一项，第三项和第五项。
示例 2：输入：values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2
输出：12
解释：选出的子集是第一项，第二项和第三项。
示例 3：输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1
输出：16
解释：选出的子集是第一项和第四项。
示例 4：输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2
输出：24
解释：选出的子集是第一项，第二项和第四项。
提示：1 &lt;= values.length == labels.length &lt;= 20000
0 &lt;= values[i], labels[i] &lt;= 20000
1 &lt;= num_wanted, use_limit &lt;= values.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>自定义排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">largestValsFromLabels</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">labels</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">num_wanted</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">use_limit</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">i</span><span class="p">]})</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="p">&lt;</span> <span class="nx">use_limit</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">++</span>
			<span class="nx">num_wanted</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">num_wanted</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2>1091.二进制矩阵中的最短路径(2)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。
一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, ..., C_k 组成：
相邻单元格 C_i 和 C_{i+1} 在八个方向之一上连通（此时，C_i 和 C_{i+1} 不同且共享边或角）
C_1 位于 (0, 0)（即，值为 grid[0][0]）
C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]）
如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）
返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。
示例 1：输入：[[0,1],[1,0]] 输出：2
示例 2：输入：[[0,0,0],[1,1,0],[1,1,0]] 输出：4
提示：1 &lt;= grid.length == grid[0].length &lt;= 100
grid[i][j] 为 0 或 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var dx = []int{-1, -1, -1, 0, 0, 1, 1, 1}
var dy = []int{-1, 0, 1, -1, 1, -1, 0, 1}

func shortestPathBinaryMatrix(grid [][]int) int {
	if grid[0][0] == 1 {
		return -1
	}
	n, m := len(grid), len(grid[0])
	if grid[n-1][m-1] == 1 {
		return -1
	}
	if n == 1 &amp;&amp; m == 1 {
		return 1
	}
	visited := make(map[[2]int]bool)
	visited[[2]int{0, 0}] = true
	queue := make([][3]int, 0)
	queue = append(queue, [3]int{0, 0, 1})
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		x := node[0]
		y := node[1]
		v := node[2]
		for i := 0; i &lt; 8; i++ {
			newX := x + dx[i]
			newY := y + dy[i]
			if 0 &lt;= newX &amp;&amp; newX &lt; n &amp;&amp; 0 &lt;= newY &amp;&amp; newY &lt; m &amp;&amp;
				grid[newX][newY] == 0 &amp;&amp; visited[[2]int{newX, newY}] == false {
				queue = append(queue, [3]int{newX, newY, v + 1})
				visited[[2]int{newX, newY}] = true
				if newX == n-1 &amp;&amp; newY == m-1 {
					return v + 1
				}
			}
		}
	}
	return -1
}

# 2
var dx = []int{-1, -1, -1, 0, 0, 1, 1, 1}
var dy = []int{-1, 0, 1, -1, 1, -1, 0, 1}

func shortestPathBinaryMatrix(grid [][]int) int {
	if grid[0][0] == 1 {
		return -1
	}
	n, m := len(grid), len(grid[0])
	if grid[n-1][m-1] == 1 {
		return -1
	}
	if n == 1 &amp;&amp; m == 1 {
		return 1
	}
	queue := make([]int, 0)
	queue = append(queue, 0)
	grid[0][0] = 1
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		x := node / m
		y := node % m
		for i := 0; i &lt; 8; i++ {
			newX := x + dx[i]
			newY := y + dy[i]
			if 0 &lt;= newX &amp;&amp; newX &lt; n &amp;&amp; 0 &lt;= newY &amp;&amp; newY &lt; m &amp;&amp; grid[newX][newY] == 0 {
				queue = append(queue, newX*m+newY)
				grid[newX][newY] = grid[x][y] + 1
				if newX == n-1 &amp;&amp; newY == m-1 {
					return grid[n-1][m-1]
				}
			}
		}
	}
	return -1
}
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>1093.大样本统计(1)<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 的采样个数。
我们以 浮点数 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。
我们先来回顾一下中位数的知识：
如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。
示例 1：输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
示例 2：输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
提示：count.length == 256
1 &lt;= sum(count) &lt;= 10^9
计数表示的众数是唯一的
答案与真实值误差在 10^-5 以内就会被视为正确答案
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sampleStats</span><span class="p">(</span><span class="nx">count</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="nx">minValue</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
	<span class="nx">maxTime</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">maxTimeValue</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">minValue</span> <span class="p">=</span> <span class="nx">i</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">i</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">*</span><span class="nx">i</span>
		<span class="k">if</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">maxTime</span> <span class="p">{</span>
			<span class="nx">maxTime</span> <span class="p">=</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">maxTimeValue</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">temp</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nx">total</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">total</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="p">&lt;</span> <span class="nx">temp</span><span class="o">+</span><span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">a</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">temp</span> <span class="o">&lt;=</span> <span class="nx">total</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">total</span><span class="o">/</span><span class="mi">2</span> <span class="p">&lt;</span> <span class="nx">temp</span><span class="o">+</span><span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">i</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">temp</span> <span class="p">=</span> <span class="nx">temp</span> <span class="o">+</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span>
		<span class="nb">float64</span><span class="p">(</span><span class="nx">minValue</span><span class="p">),</span>
		<span class="nb">float64</span><span class="p">(</span><span class="nx">maxValue</span><span class="p">),</span>
		<span class="nb">float64</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">total</span><span class="p">),</span>
		<span class="nb">float64</span><span class="p">(</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
		<span class="nb">float64</span><span class="p">(</span><span class="nx">maxTimeValue</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h2>1094.拼车(1)<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，
车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。
这儿有一份乘客行程计划表 trips[][]，其中 trips[i] = 
[num_passengers, start_location, end_location] 包含了第 i 组乘客的行程信息：
    必须接送的乘客数量；
    乘客的上车地点；
    以及乘客的下车地点。
这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。
请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务
（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）。
示例 1：输入：trips = [[2,1,5],[3,3,7]], capacity = 4 输出：false
示例 2：输入：trips = [[2,1,5],[3,3,7]], capacity = 5 输出：true
示例 3：输入：trips = [[2,1,5],[3,5,7]], capacity = 3 输出：true
示例 4：输入：trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11 输出：true
提示：
    你可以假设乘客会自觉遵守 “先下后上” 的良好素质
    trips.length &lt;= 1000
    trips[i].length == 3
    1 &lt;= trips[i][0] &lt;= 100
    0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000
    1 &lt;= capacity &lt;= 100000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>差分数组</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">carPooling</span><span class="p">(</span><span class="nx">trips</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">trips</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">start</span> <span class="o">:=</span> <span class="nx">trips</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">end</span> <span class="o">:=</span> <span class="nx">trips</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
		<span class="nx">count</span> <span class="o">:=</span> <span class="nx">trips</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">+</span> <span class="nx">count</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">end</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">end</span><span class="p">]</span> <span class="o">-</span> <span class="nx">count</span>
	<span class="p">}</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">total</span> <span class="p">&gt;</span> <span class="nx">capacity</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>1001-1100-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="id46">
<h2>1028.从先序遍历还原二叉树<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<div class="section" id="id47">
<h3>题目<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们从二叉树的根节点 root 开始进行深度优先搜索。
在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。
（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。
如果节点只有一个子节点，那么保证该子节点为左子节点。
给出遍历输出 S，还原树并返回其根节点 root。
示例 1：输入：&quot;1-2--3--4-5--6--7&quot; 输出：[1,2,5,3,4,6,7]
示例 2：输入：&quot;1-2--3---4-5--6---7&quot; 输出：[1,2,5,3,null,6,null,4,null,7]
示例 3：输入：&quot;1-401--349---90--88&quot; 输出：[1,401,null,349,88,90]
提示：原始树中的节点数介于 1 和 1000 之间。
    每个节点的值介于 1 和 10 ^ 9 之间。
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h3>解题思路<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>差分数组</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="1101-1200.html" class="btn btn-neutral float-right" title="1101-1200-Easy" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="0901-1000.html" class="btn btn-neutral float-left" title="0901-1000-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>