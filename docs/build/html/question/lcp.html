

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>LCP &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="PAT (Basic Level) Practice 乙级" href="patB.html" />
    <link rel="prev" title="程序员面试金典" href="lcci.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">LCP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lcp01-2">LCP01.猜数字(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp02-2">LCP02.分式化简(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp03-1">LCP03.机器人大冒险(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp06-2">LCP06.拿硬币(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp07-5">LCP07.传递信息(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp08-2">LCP08.剧情触发时间(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp11-2">LCP11.期望个数统计(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp12-2">LCP12.小张刷题计划(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp17-2">LCP17.速算机器人(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp18-3">LCP18.早餐组合(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp19">LCP19.秋叶收藏集</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#lcp22-1">LCP22.黑白方格画(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp28-3">LCP28.采购方案(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp29-2">LCP29.乐团站位(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp30-2">LCP30.魔塔游戏(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp33-2">LCP33.蓄水(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lcp34">LCP34.二叉树染色</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">解题思路</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>LCP</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/lcp.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lcp">
<h1>LCP<a class="headerlink" href="#lcp" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#lcp">LCP</a><ul>
<li><a class="reference external" href="#lcp01%E7%8C%9C%E6%95%B0%E5%AD%972">LCP01.猜数字(2)</a></li>
<li><a class="reference external" href="#lcp02%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%802">LCP02.分式化简(2)</a></li>
<li><a class="reference external" href="#lcp06%E6%8B%BF%E7%A1%AC%E5%B8%812">LCP06.拿硬币(2)</a></li>
<li><a class="reference external" href="#lcp07%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF5">LCP07.传递信息(5)</a></li>
<li><a class="reference external" href="#lcp11%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A12">LCP11.期望个数统计(2)</a></li>
</ul>
</li>
</ul>
<div class="section" id="lcp01-2">
<h2>LCP01.猜数字(2)<a class="headerlink" href="#lcp01-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。
他们一共进行三次这个游戏，请返回 小A 猜对了几次？
输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。
guess和answer的长度都等于3。
示例 1：输入：guess = [1,2,3], answer = [1,2,3] 输出：3
解释：小A 每次都猜对了。
示例 2：输入：guess = [2,2,3], answer = [3,2,1] 输出：1
解释：小A 只猜对了第二次。
限制：
    guess的长度 = 3
    answer的长度 = 3
    guess的元素取值为 {1, 2, 3} 之一。
    answer的元素取值为 {1, 2, 3} 之一。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>位运算-异或</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func game(guess []int, answer []int) int {
	res := 0
	for i := 0; i &lt; len(guess); i++ {
		if guess[i] == answer[i] {
			res++
		}
	}
	return res
}

#
func game(guess []int, answer []int) int {
	res := 0
	for i := 0; i &lt; len(guess); i++ {
		if guess[i]^answer[i] == 0 {
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="lcp02-2">
<h2>LCP02.分式化简(2)<a class="headerlink" href="#lcp02-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？
连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。
输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。
返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。
示例 1：输入：cont = [3, 2, 0, 2] 输出：[13, 4]
解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。
示例 2：输入：cont = [0, 0, 3] 输出：[3, 1]
解释：如果答案是整数，令分母为1即可。
限制：
    cont[i] &gt;= 0
    1 &lt;= cont的长度 &lt;= 10
    cont最后一个元素不等于0
    答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func fraction(cont []int) []int {
	n, m := 1, cont[len(cont)-1]
	for i := len(cont) - 2; i &gt;= 0; i-- {
		n, m = m, cont[i]*m+n
	}
	return []int{m, n}
}

#
func fraction(cont []int) []int {
	if len(cont) == 1 {
		return []int{cont[0], 1}
	}
	n := fraction(cont[1:])
	m := cont[0]
	return []int{m*n[0] + n[1], n[0]}
}
</pre></div>
</div>
</div>
<div class="section" id="lcp03-1">
<h2>LCP03.机器人大冒险(1)<a class="headerlink" href="#lcp03-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。
小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：
    U: 向y轴正方向移动一格
    R: 向x轴正方向移动一格。
不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
示例 1：输入：command = &quot;URR&quot;, obstacles = [], x = 3, y = 2 输出：true
解释：U(0, 1) -&gt; R(1, 1) -&gt; R(2, 1) -&gt; U(2, 2) -&gt; R(3, 2)。
示例 2：输入：command = &quot;URR&quot;, obstacles = [[2, 2]], x = 3, y = 2 输出：false
解释：机器人在到达终点前会碰到(2, 2)的障碍物。
示例 3：输入：command = &quot;URR&quot;, obstacles = [[4, 2]], x = 3, y = 2 输出：true
解释：到达终点后，再碰到障碍物也不影响返回结果。
限制：
    2 &lt;= command的长度 &lt;= 1000
    command由U，R构成，且至少有一个U，至少有一个R
    0 &lt;= x &lt;= 1e9, 0 &lt;= y &lt;= 1e9
    0 &lt;= obstacles的长度 &lt;= 1000
    obstacles[i]不为原点或者终点
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数学计算</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">robot</span><span class="p">(</span><span class="nx">command</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">obstacles</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">obstacles</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="nx">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">command</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">u</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">)</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="s">&quot;R&quot;</span><span class="p">)</span>
	<span class="nx">times</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="nx">command</span><span class="p">[:(</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="nx">command</span><span class="p">)]</span>
	<span class="nx">uNum</span> <span class="o">:=</span> <span class="nx">u</span><span class="o">*</span><span class="nx">times</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="nx">last</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">)</span>
	<span class="nx">rNum</span> <span class="o">:=</span> <span class="nx">r</span><span class="o">*</span><span class="nx">times</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="nx">last</span><span class="p">,</span> <span class="s">&quot;R&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">uNum</span> <span class="o">==</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">rNum</span> <span class="o">==</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="lcp06-2">
<h2>LCP06.拿硬币(2)<a class="headerlink" href="#lcp06-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。
我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。
示例 1：输入：[4,2,1]输出：4
解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。
示例 2： 输入：[2,3,10]输出：8
限制：
    1 &lt;= n &lt;= 4
    1 &lt;= coins[i] &lt;= 10
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minCount(coins []int) int {
	res := 0
	for i := 0; i &lt; len(coins); i++ {
		res = res + coins[i]/2
		if coins[i]%2 == 1 {
			res = res + 1
		}
	}
	return res
}

#
func minCount(coins []int) int {
	res := 0
	for i := 0; i &lt; len(coins); i++ {
		res = res + int(math.Ceil(float64(coins[i])/2))
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="lcp07-5">
<h2>LCP07.传递信息(5)<a class="headerlink" href="#lcp07-5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
    有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
    每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。
    传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
    每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。
返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。

示例 1：
    输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
    输出：3
    解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。
    共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。
示例 2：
    输入：n = 3, relation = [[0,2],[2,1]], k = 2
    输出：0
    解释：信息不能从小 A 处经过 2 轮传递到编号 2
限制：
    2 &lt;= n &lt;= 10
    1 &lt;= k &lt;= 5
    1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2
    0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(n^k)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>深度优先搜索</td>
<td>O(n^k)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>广度优先搜索</td>
<td>O(n^k)</td>
<td>O(n^k)</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>05</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var ways [][]bool

func numWays(n int, relation [][]int, k int) int {
	ways = make([][]bool, n)
	for i := range ways {
		ways[i] = make([]bool, n)
	}
	sum := 0
	for i := 0; i &lt; len(relation); i++ {
		ways[relation[i][0]][relation[i][1]] = true
	}
	for i := 0; i &lt; n; i++ {
		if ways[0][i] == true {
			sum = sum + dfs(i, n, k-1)
		}
	}
	return sum
}

func dfs(i, n, k int) int {
	sum := 0
	if k &lt; 0 || i &lt; 0 || i &gt;= n {
		return 0
	}
	if k == 0 &amp;&amp; i == n-1 {
		return 1
	} else {
		for j := 0; j &lt; n; j++ {
			if ways[i][j] == true {
				sum += dfs(j, n, k-1)
			}
		}
	}
	return sum
}

#
var res, K, N int

func numWays(n int, relation [][]int, k int) int {
	res = 0
	K = k
	N = n
	dfs(0, relation, 0)
	return res
}

func dfs(n int, relation [][]int, k int) {
	if n == N-1 &amp;&amp; k == K {
		res++
	}
	if k &gt; K {
		return
	}
	for i := 0; i &lt; len(relation); i++ {
		if relation[i][0] == n {
			dfs(relation[i][1], relation, k+1)
		}
	}
}

# 3
func numWays(n int, relation [][]int, k int) int {
	m := make(map[int][]int)
	for i := 0; i &lt; len(relation); i++ {
		m[relation[i][0]] = append(m[relation[i][0]], relation[i][1])
	}
	start := []int{0}
	for i := 0; i &lt; k; i++ {
		arr := make([]int, 0)
		for j := 0; j &lt; len(start); j++ {
			for k := 0; k &lt; len(m[start[j]]); k++ {
				arr = append(arr, m[start[j]][k])
			}
		}
		start = arr
	}
	res := 0
	for i := 0; i &lt; len(start); i++ {
		if start[i] == n-1 {
			res++
		}
	}
	return res
}

# 4
func numWays(n int, relation [][]int, k int) int {
	dp := make([]int, n)
	dp[0] = 1
	for i := 0; i &lt; k; i++ {
		temp := make([]int, n)
		for _, v := range relation {
			temp[v[1]] = temp[v[1]] + dp[v[0]]
		}
		dp = temp
	}
	return dp[n-1]
}

# 5
func numWays(n int, relation [][]int, k int) int {
	dp := make([][]int, k+1)
	for i := 0; i &lt; k+1; i++ {
		dp[i] = make([]int, n)
	}
	dp[0][0] = 1
	for i := 0; i &lt; k; i++ {
		for _, v := range relation {
			dp[i+1][v[1]] = dp[i+1][v[1]] + dp[i][v[0]]
		}
	}
	return dp[k][n-1]
}
</pre></div>
</div>
</div>
<div class="section" id="lcp08-2">
<h2>LCP08.剧情触发时间(2)<a class="headerlink" href="#lcp08-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，
分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。
随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。
这个二维数组的每个元素是一个长度为 3 的一维数组，
例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。
所有剧情的触发条件也用一个二维数组 requirements 表示。
这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，
如果当前 C &gt;= c[i] 且 R &gt;= r[i] 且 H &gt;= h[i] ，则剧情会被触发。
根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。
如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。
示例 1：
    输入： increase = [[2,8,4],[2,5,0],[10,9,8]] 
    requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]
    输出: [2,-1,3,-1]
    解释：
    初始时，C = 0，R = 0，H = 0
    第 1 天，C = 2，R = 8，H = 4
    第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0
    第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2
    剧情 1 和 3 无法触发。
示例 2：
    输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] 
    requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]
    输出: [-1,4,3,3,3]
示例 3：输入： increase = [[1,1,1]] requirements = [[0,0,0]] 输出: [0]
限制：
    1 &lt;= increase.length &lt;= 10000
    1 &lt;= requirements.length &lt;= 100000
    0 &lt;= increase[i] &lt;= 10
    0 &lt;= requirements[i] &lt;= 100000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func getTriggerTime(increase [][]int, requirements [][]int) []int {
	for i := 1; i &lt; len(increase); i++ {
		increase[i][0] = increase[i][0] + increase[i-1][0]
		increase[i][1] = increase[i][1] + increase[i-1][1]
		increase[i][2] = increase[i][2] + increase[i-1][2]
	}
	res := make([]int, len(requirements))
	for i := 0; i &lt; len(requirements); i++ {
		C, R, H := requirements[i][0], requirements[i][1], requirements[i][2]
		if C == 0 &amp;&amp; R == 0 &amp;&amp; H == 0 {
			res[i] = 0
			continue
		}
		if C &gt; increase[len(increase)-1][0] ||
			R &gt; increase[len(increase)-1][1] ||
			H &gt; increase[len(increase)-1][2] {
			res[i] = -1
			continue
		}
		left, right := 0, len(increase)-1
		index := -1
		for left &lt;= right {
			mid := left + (right-left)/2
			if increase[mid][0] &gt;= C &amp;&amp; increase[mid][1] &gt;= R &amp;&amp; increase[mid][2] &gt;= H {
				index = mid + 1
				right = mid - 1
			} else {
				left = mid + 1
			}
		}
		res[i] = index
	}
	return res
}

#
func getTriggerTime(increase [][]int, requirements [][]int) []int {
	for i := 1; i &lt; len(increase); i++ {
		increase[i][0] = increase[i][0] + increase[i-1][0]
		increase[i][1] = increase[i][1] + increase[i-1][1]
		increase[i][2] = increase[i][2] + increase[i-1][2]
	}

	res := make([]int, len(requirements))
	for i := 0; i &lt; len(requirements); i++ {
		C, R, H := requirements[i][0], requirements[i][1], requirements[i][2]
		if C == 0 &amp;&amp; R == 0 &amp;&amp; H == 0 {
			res[i] = 0
			continue
		}
		if C &gt; increase[len(increase)-1][0] ||
			R &gt; increase[len(increase)-1][1] ||
			H &gt; increase[len(increase)-1][2] {
			res[i] = -1
			continue
		}
		index := sort.Search(len(increase), func(j int) bool {
			return increase[j][0] &gt;= requirements[i][0] &amp;&amp;
				increase[j][1] &gt;= requirements[i][1] &amp;&amp;
				increase[j][2] &gt;= requirements[i][2]
		})
		if index == len(increase) {
			index = -2
		}
		res[i] = index + 1
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="lcp11-2">
<h2>LCP11.期望个数统计(2)<a class="headerlink" href="#lcp11-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。
每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。
小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。
由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。
现在给定 n 名面试者的能力值 scores，
设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。
提示：离散的非负随机变量的期望计算公式为 1。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是 2。
示例 1： 输入：scores = [1,2,3] 输出：3
    解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。
示例 2：输入：scores = [1,1]  输出：1 解释：设两位面试者的编号为 0, 1。
    由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。
    如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。
    所以 X 的期望是 (2+0+2+0) * 1/4 = 1
示例 3：输入：scores = [1,1,2] 输出：2
限制：
    1 &lt;= scores.length &lt;= 10^5
    0 &lt;= scores[i] &lt;= 10^6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func expectNumber(scores []int) int {
	m := make(map[int]bool)
	for i := 0; i &lt; len(scores); i++{
		m[scores[i]] = true
	}
	return len(m)
}

#
func expectNumber(scores []int) int {
	sort.Ints(scores)
	count := 0
	for i := 1; i &lt; len(scores); i++ {
		if scores[i] == scores[i-1] {
			count++
		}
	}
	return len(scores) - count
}
</pre></div>
</div>
</div>
<div class="section" id="lcp12-2">
<h2>LCP12.小张刷题计划(2)<a class="headerlink" href="#lcp12-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，
编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。
在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，
通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，
小张每天最多使用一次求助。
我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。
请你帮小张求出最小的 T是多少。
示例 1：
    输入：time = [1,2,3,3], m = 2
    输出：3
    解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。
    这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。
示例 2：输入：time = [999,999,999], m = 4 输出：0
    解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。
限制：
    1 &lt;= time.length &lt;= 10^5
    1 &lt;= time[i] &lt;= 10000
    1 &lt;= m &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minTime(time []int, m int) int {
	left, right, mid := 0, 0, 0
	for i := 0; i &lt; len(time); i++ {
		right = right + time[i]
	}
	// 二分查找一个数mid，使time数组能分割成m个和不小于mid的子数组
	for left &lt;= right {
		mid = left + (right-left)/2
		if check(time, mid, m) {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return left
}

func check(arr []int, mid, m int) bool {
	maxValue := 0
	sum := 0
	count := 0
	for i := 0; i &lt; len(arr); i++ {
		sum = sum + arr[i]
		if arr[i] &gt; maxValue {
			maxValue = arr[i]
		}
		if sum-maxValue &gt; mid {
			count++
			if count &gt;= m {
				return false
			}
			sum = arr[i]
			maxValue = arr[i]
		}
	}
	return true
}

#
func minTime(time []int, m int) int {
	left, right, mid := 0, 0, 0
	for i := 0; i &lt; len(time); i++ {
		right = right + time[i]
	}
	// 二分查找一个数mid，使time数组能分割成m个和不小于mid的子数组
	res := math.MaxInt32
	for left &lt;= right {
		mid = left + (right-left)/2
		if check(time, mid) &lt;= m {
			if mid &lt; res {
				res = mid
			}
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return res
}

func check(arr []int, mid int) int {
	res := 1
	maxValue := 0
	sum := 0
	for i := 0; i &lt; len(arr); i++ {
		sum = sum + arr[i]
		if arr[i] &gt; maxValue {
			maxValue = arr[i]
		}
		if sum-maxValue &gt; mid {
			sum = arr[i]
			maxValue = arr[i]
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="lcp17-2">
<h2>LCP17.速算机器人(2)<a class="headerlink" href="#lcp17-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 x 和 y），请小扣说出计算指令：
    &quot;A&quot; 运算：使 x = 2 * x + y；
    &quot;B&quot; 运算：使 y = 2 * y + x。
在本次游戏中，店家说出的数字为 x = 1 和 y = 0，小扣说出的计算指令记作仅由大写字母 A、B 组成的字符串 s，
字符串中字符的顺序表示计算顺序，请返回最终 x 与 y 的和为多少。
示例 1： 输入：s = &quot;AB&quot; 输出：4
解释：经过一次 A 运算后，x = 2, y = 0。
    再经过一次 B 运算，x = 2, y = 2。
    最终 x 与 y 之和为 4。
提示：0 &lt;= s.length &lt;= 10
    s 由 &#39;A&#39; 和 &#39;B&#39; 组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func calculate(s string) int {
	x, y := 1, 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;A&#39; {
			x = 2*x + y
		} else if s[i] == &#39;B&#39; {
			y = 2*y + x
		}
	}
	return x + y
}

# 2
func calculate(s string) int {
	return 1 &lt;&lt; len(s)
}
</pre></div>
</div>
</div>
<div class="section" id="lcp18-3">
<h2>LCP18.早餐组合(3)<a class="headerlink" href="#lcp18-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小扣在秋日市集选择了一家早餐摊位，一维整型数组 staple 中记录了每种主食的价格，
一维整型数组 drinks 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 x 元。
请返回小扣共有多少种购买方案。
注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1
示例 1：输入：staple = [10,20,5], drinks = [5,5,2], x = 15 输出：6
    解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：
    第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15；
    第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15；
    第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12；
    第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10；
    第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10；
    第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。
示例 2： 输入：staple = [2,1,1], drinks = [8,9,5,1], x = 9 输出：8
    解释：小扣有 8 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：
    第 1 种方案：staple[0] + drinks[2] = 2 + 5 = 7；
    第 2 种方案：staple[0] + drinks[3] = 2 + 1 = 3；
    第 3 种方案：staple[1] + drinks[0] = 1 + 8 = 9；
    第 4 种方案：staple[1] + drinks[2] = 1 + 5 = 6；
    第 5 种方案：staple[1] + drinks[3] = 1 + 1 = 2；
    第 6 种方案：staple[2] + drinks[0] = 1 + 8 = 9；
    第 7 种方案：staple[2] + drinks[2] = 1 + 5 = 6；
    第 8 种方案：staple[2] + drinks[3] = 1 + 1 = 2；
提示：1 &lt;= staple.length &lt;= 10^5
    1 &lt;= drinks.length &lt;= 10^5
    1 &lt;= staple[i],drinks[i] &lt;= 10^5
    1 &lt;= x &lt;= 2*10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序双指针</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助+前缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>排序+二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func breakfastNumber(staple []int, drinks []int, x int) int {
	sort.Ints(staple)
	sort.Ints(drinks)
	res := 0
	j := len(drinks) - 1
	for i := 0; i &lt; len(staple); i++ {
		for j &gt;= 0 &amp;&amp; staple[i]+drinks[j] &gt; x {
			j--
		}
		res = (res + j + 1) % 1000000007
	}
	return res
}

# 2
func breakfastNumber(staple []int, drinks []int, x int) int {
	res := 0
	arr := make([]int, x+1)
	for i := 0; i &lt; len(staple); i++ {
		if staple[i] &lt; x {
			arr[staple[i]]++
		}
	}
	for i := 1; i &lt; len(arr); i++ {
		arr[i] = arr[i-1] + arr[i]
	}
	for i := 0; i &lt; len(drinks); i++ {
		target := x - drinks[i]
		if target &lt;= 0 {
			continue
		}
		res = (res + arr[target]) % 1000000007
	}
	return res
}

# 3
func breakfastNumber(staple []int, drinks []int, x int) int {
	sort.Ints(staple)
	sort.Ints(drinks)
	res := 0
	for i := 0; i &lt; len(staple); i++ {
		target := x - staple[i]
		if target &lt;= 0 {
			break
		}
		j := binarySearch(drinks, target)
		res = (res + j) % 1000000007
	}
	return res
}

func binarySearch(arr []int, target int) int {
	left, right := 0, len(arr)
	for left &lt; right {
		mid := left + (right-left)/2
		if arr[mid] &gt; target {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}
</pre></div>
</div>
</div>
<div class="section" id="lcp19">
<h2>LCP19.秋叶收藏集<a class="headerlink" href="#lcp19" title="永久链接至标题">¶</a></h2>
<div class="section" id="id1">
<h3>题目<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 
字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。
每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，
小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。
请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。
示例 1：输入：leaves = &quot;rrryyyrryyyrr&quot; 输出：2
解释：调整两次，将中间的两片红叶替换成黄叶，得到 &quot;rrryyyyyyyyrr&quot;
示例 2：输入：leaves = &quot;ryr&quot; 输出：0
解释：已符合要求，不需要额外操作
提示：3 &lt;= leaves.length &lt;= 10^5
    leaves 中只包含字符 &#39;r&#39; 和字符 &#39;y&#39;
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>解题思路<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划-二维</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划-一维</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minimumOperations</span><span class="p">(</span><span class="nx">leaves</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leaves</span><span class="p">)</span>
	<span class="c1">// 长度i+1</span>
	<span class="c1">// dp[i][0] 全部变成r的步数</span>
	<span class="c1">// dp[i][1] 变成r...ry...y的步数</span>
	<span class="c1">// dp[i][2] 变成r...ry...yr...r的步数</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;y&#39;</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 1个y变为r需要1步</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">leaves</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>     <span class="c1">// 不需要改变，同前一个</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// 全r+当前r，需要改变一个y，步数+1</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// 需要改变，步数+1</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>     <span class="c1">// 前一个全r+当前y,不需要改变</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="lcp22-1">
<h2>LCP22.黑白方格画(1)<a class="headerlink" href="#lcp22-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。
画板上有 n * n 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色，
所选行数、列数均可为 0。
小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。
注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。
示例 1：输入：n = 2, k = 2 输出：4
解释：一共有四种不同的方案：
第一种方案：涂第一列；
第二种方案：涂第二列；
第三种方案：涂第一行；
第四种方案：涂第二行。
示例 2：输入：n = 2, k = 1 输出：0
解释：不可行，因为第一次涂色至少会涂两个黑格。
示例 3：输入：n = 2, k = 4 输出：1
解释：共有 2*2=4 个格子，仅有一种涂色方案。
限制：1 &lt;= n &lt;= 6
0 &lt;= k &lt;= n * n
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法+组合</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">paintingPlan</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">n</span><span class="o">*</span><span class="nx">n</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 全部涂满或者不涂只有1种方案</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span> <span class="c1">// 最少大于等于n</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// 暴力枚举行和列</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">a</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">*</span> <span class="nx">n</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nx">j</span> <span class="o">*</span> <span class="nx">n</span>
			<span class="k">if</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">-</span><span class="nx">i</span><span class="o">*</span><span class="nx">j</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">C</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">C</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="c1">// 求组合数</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">C</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">*</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="lcp28-3">
<h2>LCP28.采购方案(3)<a class="headerlink" href="#lcp28-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，
要求购买零件的花费不超过预算，请问他有多少种采购方案。
注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1
示例 1：输入：nums = [2,5,3,5], target = 6 输出：1
解释：预算内仅能购买 nums[0] 与 nums[2]。
示例 2：输入：nums = [2,2,1,9], target = 10 输出：4
解释：符合预算的采购方案如下：
nums[0] + nums[1] = 4
nums[0] + nums[2] = 3
nums[1] + nums[2] = 3
nums[2] + nums[3] = 10
提示：2 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i], target &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序+双指针</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>排序+双指针</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>排序+二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func purchasePlans(nums []int, target int) int {
	sort.Ints(nums)
	j := len(nums) - 1
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		for i &lt; j {
			if nums[i]+nums[j] &lt;= target {
				break
			}
			j--
		}
		if i &lt; j {
			res = res + (j - i)
		}
	}
	return res % 1000000007
}

# 2
func purchasePlans(nums []int, target int) int {
	sort.Ints(nums)
	res := 0
	left, right := 0, len(nums)-1
	for left &lt; right {
		for left &lt; right &amp;&amp; nums[left]+nums[right] &gt; target {
			right--
		}
		res = res + right - left
		left++
	}
	return res % 1000000007
}

# 3
func purchasePlans(nums []int, target int) int {
	sort.Ints(nums)
	ln := len(nums)
	res := 0
	for i := 0; i &lt; ln; i++ {
		target := target - nums[i]
		index := search(nums[i+1:], target)
		res = res + index
	}
	return res % 1000000007
}

func search(nums []int, target int) int {
	left := 0
	right := len(nums) - 1
	for left &lt;= right {
		mid := left + (right-left)/2
		if nums[mid] &gt; target {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return left
}
</pre></div>
</div>
</div>
<div class="section" id="lcp29-2">
<h2>LCP29.乐团站位(2)<a class="headerlink" href="#lcp29-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。
乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。
为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，...，9 循环重复排列。
例如当 num = 5 时，站位如图所示
请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。
示例 1：输入：num = 3, Xpos = 0, Ypos = 2 输出：3
解释：
示例 2：输入：num = 4, Xpos = 1, Ypos = 2 输出：5
解释：
提示：1 &lt;= num &lt;= 10^9
0 &lt;= Xpos, Ypos &lt; num
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>找规律</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>找规律</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func orchestraLayout(num int, xPos int, yPos int) int {
	x := min(xPos, num-1-xPos)
	y := min(yPos, num-1-yPos)
	k := min(x, y) // 在第几圈（从0开始）
	// n*n - (n-2k)*(n-2k) = n*n-(n*n+4k*k-4nk)= 4nk-4k*k
	total := 4 * k * (num - k) % 9 // 第几圈外总共的个数
	if xPos == k {                 // 上边
		return (total+yPos-k)%9 + 1
	} else if yPos == num-1-k { // 右边
		before := num - 2*k - 1
		return (total+before+xPos-k)%9 + 1
	} else if xPos == num-1-k { // 下边
		before := (num - 2*k - 1) * 2
		return (total+before+num-k-1-yPos)%9 + 1
	} else if yPos == k { // 左边
		before := (num - 2*k - 1) * 3
		return (total+before+num-k-1-xPos)%9 + 1
	}
	return 0
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func orchestraLayout(num int, xPos int, yPos int) int {
	x := min(xPos, num-1-xPos)
	y := min(yPos, num-1-yPos)
	k := min(x, y) // 在第几圈（从0开始）
	// n*n - (n-2k)*(n-2k) = n*n-(n*n+4k*k-4nk)= 4nk-4k*k
	if xPos &lt;= yPos {
		total := num*num - (num-2*k)*(num-2*k)
		return (total+xPos-k+yPos-k)%9 + 1
	} else {
		total := num*num - (num-(2*k+2))*(num-(2*k+2))
		return (total-(xPos-k)-(yPos-k))%9 + 1
	}
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="lcp30-2">
<h2>LCP30.魔塔游戏(2)<a class="headerlink" href="#lcp30-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。
每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；
负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。
小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，
小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。
请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。
示例 1：输入：nums = [100,100,100,-250,-60,-140,-50,-50,100,150] 输出：1
解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。
示例 2：输入：nums = [-200,-300,400,0]输出：-1
解释：调整访问顺序也无法完成全部房间的访问。
提示：1 &lt;= nums.length &lt;= 10^5
-10^5 &lt;= nums[i] &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func magicTower(nums []int) int {
	intHeap := make(IntHeap, 0)
	heap.Init(&amp;intHeap)
	blood := 0
	sum := 0
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
		if nums[i] &lt; 0 {
			heap.Push(&amp;intHeap, nums[i])
			if blood+nums[i] &lt; 0 {
				res++
				minValue := heap.Pop(&amp;intHeap).(int)
				blood = blood - minValue 
			}
		}
		blood = blood + nums[i]
	}
	if sum &lt; 0 {
		return -1
	}
	return res
}

type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h IntHeap) Less(i, j int) bool {
	return h[i] &lt; h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
func magicTower(nums []int) int {
	sum := 0
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
	}
	if sum &lt; 0 {
		return -1
	}
	intHeap := make(IntHeap, 0)
	heap.Init(&amp;intHeap)
	blood := 0
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		heap.Push(&amp;intHeap, nums[i])
		blood = blood + nums[i]
		if blood &lt; 0 {
			minValue := heap.Pop(&amp;intHeap).(int)
			blood = blood - minValue
			res++
		}
	}
	return res
}

type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h IntHeap) Less(i, j int) bool {
	return h[i] &lt; h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}
</pre></div>
</div>
</div>
<div class="section" id="lcp33-2">
<h2>LCP33.蓄水(2)<a class="headerlink" href="#lcp33-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，
第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：
升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1
蓄水：将全部水桶接满水，倒入各自对应的水缸
每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。
注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。
示例 1：输入：bucket = [1,3], vat = [6,8] 输出：4
解释：第 1 次操作升级 bucket[0]；
第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。
示例 2：输入：bucket = [9,0,1], vat = [0,2,2] 输出：3
解释：第 1 次操作均选择升级 bucket[1]
第 2~3 次操作选择蓄水，即可完成蓄水要求。
提示：1 &lt;= bucket.length == vat.length &lt;= 100
0 &lt;= bucket[i], vat[i] &lt;= 10^4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>枚举</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func storeWater(bucket []int, vat []int) int {
	n := len(vat)
	maxValue := 0
	for i := 0; i &lt; n; i++ {
		maxValue = max(maxValue, vat[i])
	}
	if maxValue == 0 {
		return 0
	}
	res := math.MaxInt32
	for k := 1; k &lt;= maxValue; k++ { // 枚举蓄水的次数
		temp := k
		for i := 0; i &lt; n; i++ {
			begin := vat[i] / k // 需要升级到的目的容量
			if vat[i]%k &gt; 0 {
				begin++
			}
			if begin &gt; bucket[i] {
				temp = temp + begin - bucket[i] // 升级次数
			}
		}
		res = min(res, temp)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func storeWater(bucket []int, vat []int) int {
	n := len(vat)
	nodeHeap := make(IntHeap, 0)
	heap.Init(&amp;nodeHeap)
	count := 0 // 需要升级的次数
	for i := 0; i &lt; n; i++ {
		if bucket[i] == 0 &amp;&amp; vat[i] &gt; 0 {
			bucket[i] = 1
			count++
		}
		if vat[i] &gt; 0 {
			heap.Push(&amp;nodeHeap, Node{
				bucket: bucket[i],
				vat:    vat[i],
				count:  (vat[i]-1)/bucket[i] + 1,
			})
		}
	}
	res := math.MaxInt32 // 总次数
	for nodeHeap.Len() &gt; 0 {
		node := heap.Pop(&amp;nodeHeap).(Node)
		if count &gt;= res {
			break
		}
        res = min(res, node.count+count) // 堆里面最大的蓄水次数+升级的次数
		heap.Push(&amp;nodeHeap, Node{
			bucket: node.bucket + 1,
			vat:    node.vat,
			count:  (node.vat-1)/(node.bucket+1) + 1,
		})
		count++
	}
	if res == math.MaxInt32 {
		return 0
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

type Node struct {
	bucket int
	vat    int
	count  int
}

type IntHeap []Node

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h IntHeap) Less(i, j int) bool {
	return h[i].count &gt; h[j].count
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(Node))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}
</pre></div>
</div>
</div>
<div class="section" id="lcp34">
<h2>LCP34.二叉树染色<a class="headerlink" href="#lcp34" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>题目<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>小扣有一个根结点为 root 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，
模型的每个结点有一个 val 价值。
小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过 k 个，
求所有染成蓝色的结点价值总和最大是多少？
示例 1：输入：root = [5,2,3,4], k = 2输出：12
解释：结点 5、3、4 染成蓝色，获得最大的价值 5+3+4=12
示例 2：输入：root = [4,1,3,9,null,null,2], k = 2 输出：16
解释：结点 4、3、9 染成蓝色，获得最大的价值 4+3+9=16
提示：1 &lt;= k &lt;= 10
1 &lt;= val &lt;= 10000
1 &lt;= 结点数量 &lt;= 10000
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>解题思路<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>枚举</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="patB.html" class="btn btn-neutral float-right" title="PAT (Basic Level) Practice 乙级" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="lcci.html" class="btn btn-neutral float-left" title="程序员面试金典" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>