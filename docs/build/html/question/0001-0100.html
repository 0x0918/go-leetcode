

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>0001-0100-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="0101-0200-Easy" href="0101-0200.html" />
    <link rel="prev" title="Welcome to go-leetcode’s documentation!" href="../index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">0001-0100-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">1.两数之和(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">7.整数反转(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">9.回文数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">13.罗马数字转整数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">14.最长公共前缀(6)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">20.有效的括号(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">21.合并两个有序链表(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">26.删除排序数组中的重复项(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">27.移除元素(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#strstr-4">28.实现strStr()(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">35.搜索插入位置(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">38.报数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">53.最大子序和(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">58.最后一个单词的长度(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">66.加一(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">67.二进制求和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#x-5">69.x的平方根 (5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">70.爬楼梯(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">83.删除排序链表中的重复元素(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">88.合并两个有序数组(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19">100.相同的树(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">0001-0100-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id20">2.两数相加(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">3.无重复字符的最长子串(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">5.最长回文子串(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#z-2">6.Z字形变换(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#atoi-3">8.字符串转换整数 (atoi)(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">11.盛最多水的容器(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">12.整数转罗马数字(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">15.三数之和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">16.最接近的三数之和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">17.电话号码的字母组合(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">18.四数之和(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#n-3">19.删除链表的倒数第N个节点(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">22.括号生成(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">24.两两交换链表中的节点(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">29.两数相除(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">31.下一个排列(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">33.搜索旋转排序数组(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">34.在排序数组中查找元素的第一个和最后一个位置(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">36.有效的数独(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">39.组合总和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-2">40.组合总和II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">43.字符串相乘(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">46.全排列(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-3">47.全排列II(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">48.旋转图像(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">49.字母异位词分组(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pow-x-n-4">50.Pow(x,n)(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id41">54.螺旋矩阵(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id42">55.跳跃游戏(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43">56.合并区间(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">59.螺旋矩阵II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-1">60.第k个排列(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id45">61.旋转链表(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id46">62.不同路径(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id47">63.不同路径II(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id48">64.最小路径和(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id49">71.简化路径(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id50">73.矩阵置零(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id51">74.搜索二维矩阵(6)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id52">75.颜色分类(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id53">77.组合(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id54">78.子集(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id55">79.单词搜索(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id56">80.删除排序数组中的重复项II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id57">81.搜索旋转排序数组II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id58">82.删除排序链表中的重复元素II(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id59">86.分隔链表(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id60">89.格雷编码(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id61">90.子集II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id62">91.解码方法(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id63">92.反转链表II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ip-2">93.复原IP地址(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id64">94.二叉树的中序遍历(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id65">95.不同的二叉搜索树II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id66">96.不同的二叉搜索树(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id67">98.验证二叉搜索树(5)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">0001-1000-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id68">4.寻找两个正序数组的中位数(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id69">10.正则表达式匹配(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-4">23.合并K个排序链表(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id70">25.K个一组翻转链表(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id71">30.串联所有单词的子串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id72">32.最长有效括号(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id73">37.解数独(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id74">41.缺失的第一个正数(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id75">42.接雨水(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id76">44.通配符匹配(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-4">45.跳跃游戏II(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id77">51.N皇后(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nii-3">52.N皇后II(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id78">57.插入区间(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id79">65.有效数字(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id80">68.文本左右对齐(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id81">72.编辑距离(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id82">76.最小覆盖子串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id83">84.柱状图中最大的矩形(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id84">85.最大矩形(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id85">87.扰乱字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id86">97.交错字符串(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id87">99.恢复二叉搜索树(4)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html">Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#medium">Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#hard">Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>0001-0100-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/0001-0100.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>0001-0100-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#0001-0100-easy">0001-0100-Easy</a><ul>
<li><a class="reference external" href="#1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C3">1.两数之和(3)</a></li>
<li><a class="reference external" href="#7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC2">7.整数反转(2)</a></li>
<li><a class="reference external" href="#9%E5%9B%9E%E6%96%87%E6%95%B03">9.回文数(3)</a></li>
<li><a class="reference external" href="#13%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B02">13.罗马数字转整数(2)</a></li>
<li><a class="reference external" href="#14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%806">14.最长公共前缀(6)</a></li>
<li><a class="reference external" href="#20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B73">20.有效的括号(3)</a></li>
<li><a class="reference external" href="#21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A83">21.合并两个有序链表(3)</a></li>
<li><a class="reference external" href="#26%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B92">26.删除排序数组中的重复项(2)</a></li>
<li><a class="reference external" href="#27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A03">27.移除元素(3)</a></li>
<li><a class="reference external" href="#28%E5%AE%9E%E7%8E%B0strstr4">28.实现strStr()(4)</a></li>
<li><a class="reference external" href="#35%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE3">35.搜索插入位置(3)</a></li>
<li><a class="reference external" href="#38%E6%8A%A5%E6%95%B02">38.报数(2)</a></li>
<li><a class="reference external" href="#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C5">53.最大子序和(5)</a></li>
<li><a class="reference external" href="#58%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A62">58.最后一个单词的长度(2)</a></li>
<li><a class="reference external" href="#66%E5%8A%A0%E4%B8%802">66.加一(2)</a></li>
<li><a class="reference external" href="#67%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C2">67.二进制求和(2)</a></li>
<li><a class="reference external" href="#69x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-5">69.x的平方根 (5)</a></li>
<li><a class="reference external" href="#70%E7%88%AC%E6%A5%BC%E6%A2%AF3">70.爬楼梯(3)</a></li>
<li><a class="reference external" href="#83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A03">83.删除排序链表中的重复元素(3)</a></li>
<li><a class="reference external" href="#88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%843">88.合并两个有序数组(3)</a></li>
<li><a class="reference external" href="#100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%912">100.相同的树(2)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0001-0100-medium">0001-0100-Medium</a><ul>
<li><a class="reference external" href="#2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A02">2.两数相加(2)</a></li>
<li><a class="reference external" href="#3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B24">3.无重复字符的最长子串(4)</a></li>
<li><a class="reference external" href="#5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B25">5.最长回文子串(5)</a></li>
<li><a class="reference external" href="#6z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A22">6.Z字形变换(2)</a></li>
<li><a class="reference external" href="#8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi3">8.字符串转换整数 (atoi)(3)</a></li>
<li><a class="reference external" href="#11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A82">11.盛最多水的容器(2)</a></li>
<li><a class="reference external" href="#12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%972">12.整数转罗马数字(2)</a></li>
<li><a class="reference external" href="#15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C2">15.三数之和(2)</a></li>
<li><a class="reference external" href="#16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C2">16.最接近的三数之和(2)</a></li>
<li><a class="reference external" href="#17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%882">17.电话号码的字母组合(2)</a></li>
<li><a class="reference external" href="#18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C3">18.四数之和(3)</a></li>
<li><a class="reference external" href="#19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B93">19.删除链表的倒数第N个节点(3)</a></li>
<li><a class="reference external" href="#22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%903">22.括号生成(3)</a></li>
<li><a class="reference external" href="#24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92">24.两两交换链表中的节点(2)</a></li>
<li><a class="reference external" href="#29%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A42">29.两数相除(2)</a></li>
<li><a class="reference external" href="#31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%971">31.下一个排列(1)</a></li>
<li><a class="reference external" href="#33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842">33.搜索旋转排序数组(2)</a></li>
<li><a class="reference external" href="#34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE4">34.在排序数组中查找元素的第一个和最后一个位置(4)</a></li>
<li><a class="reference external" href="#36%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC1">36.有效的数独(1)</a></li>
<li><a class="reference external" href="#39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C2">39.组合总和(2)</a></li>
<li><a class="reference external" href="#40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii2">40.组合总和II(2)</a></li>
<li><a class="reference external" href="#43%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%981">43.字符串相乘(1)</a></li>
<li><a class="reference external" href="#46%E5%85%A8%E6%8E%92%E5%88%973">46.全排列(3)</a></li>
<li><a class="reference external" href="#47%E5%85%A8%E6%8E%92%E5%88%97ii3">47.全排列II(3)</a></li>
<li><a class="reference external" href="#48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F3">48.旋转图像(3)</a></li>
<li><a class="reference external" href="#49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%842">49.字母异位词分组(2)</a></li>
<li><a class="reference external" href="#50powxn4">50.Pow(x,n)(4)</a></li>
<li><a class="reference external" href="#54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52">54.螺旋矩阵(2)</a></li>
<li><a class="reference external" href="#55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F4">55.跳跃游戏(4)</a></li>
<li><a class="reference external" href="#56%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B42">56.合并区间(2)</a></li>
<li><a class="reference external" href="#59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii2">59.螺旋矩阵II(2)</a></li>
<li><a class="reference external" href="#60%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%971">60.第k个排列(1)</a></li>
<li><a class="reference external" href="#61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A82">61.旋转链表(2)</a></li>
<li><a class="reference external" href="#62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%844">62.不同路径(4)</a></li>
<li><a class="reference external" href="#63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84ii3">63.不同路径II(3)</a></li>
<li><a class="reference external" href="#64%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C4">64.最小路径和(4)</a></li>
<li><a class="reference external" href="#71%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%842">71.简化路径(2)</a></li>
<li><a class="reference external" href="#73%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B64">73.矩阵置零(4)</a></li>
<li><a class="reference external" href="#74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B56">74.搜索二维矩阵(6)</a></li>
<li><a class="reference external" href="#75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB3">75.颜色分类(3)</a></li>
<li><a class="reference external" href="#77%E7%BB%84%E5%90%884">77.组合(4)</a></li>
<li><a class="reference external" href="#78%E5%AD%90%E9%9B%863">78.子集(3)</a></li>
<li><a class="reference external" href="#79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A22">79.单词搜索(2)</a></li>
<li><a class="reference external" href="#80%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9ii2">80.删除排序数组中的重复项II(2)</a></li>
<li><a class="reference external" href="#81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii2">81.搜索旋转排序数组II(2)</a></li>
<li><a class="reference external" href="#82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii3">82.删除排序链表中的重复元素II(3)</a></li>
<li><a class="reference external" href="#86%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A82">86.分隔链表(2)</a></li>
<li><a class="reference external" href="#89%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%812">89.格雷编码(2)</a></li>
<li><a class="reference external" href="#90%E5%AD%90%E9%9B%86ii2">90.子集II(2)</a></li>
<li><a class="reference external" href="#91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%953">91.解码方法(3)</a></li>
<li><a class="reference external" href="#92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii2">92.反转链表II(2)</a></li>
<li><a class="reference external" href="#93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%802">93.复原IP地址(2)</a></li>
<li><a class="reference external" href="#94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%863">94.二叉树的中序遍历(3)</a></li>
<li><a class="reference external" href="#95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii2">95.不同的二叉搜索树II(2)</a></li>
<li><a class="reference external" href="#96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%913">96.不同的二叉搜索树(3)</a></li>
<li><a class="reference external" href="#98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%915">98.验证二叉搜索树(5)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0001-1000-hard">0001-1000-Hard</a><ul>
<li><a class="reference external" href="#4%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B04">4.寻找两个正序数组的中位数(4)</a></li>
<li><a class="reference external" href="#10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D3">10.正则表达式匹配(3)</a></li>
<li><a class="reference external" href="#23%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A84">23.合并K个排序链表(4)</a></li>
<li><a class="reference external" href="#25k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A84">25.K个一组翻转链表(4)</a></li>
<li><a class="reference external" href="#30%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B22">30.串联所有单词的子串(2)</a></li>
<li><a class="reference external" href="#32%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B74">32.最长有效括号(4)</a></li>
<li><a class="reference external" href="#37%E8%A7%A3%E6%95%B0%E7%8B%AC2">37.解数独(2)</a></li>
<li><a class="reference external" href="#41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B05">41.缺失的第一个正数(5)</a></li>
<li><a class="reference external" href="#42%E6%8E%A5%E9%9B%A8%E6%B0%B44">42.接雨水(4)</a></li>
<li><a class="reference external" href="#44%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D3">44.通配符匹配(3)</a></li>
<li><a class="reference external" href="#45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii4">45.跳跃游戏II(4)</a></li>
<li><a class="reference external" href="#51n%E7%9A%87%E5%90%8E3">51.N皇后(3)</a></li>
<li><a class="reference external" href="#52n%E7%9A%87%E5%90%8Eii3">52.N皇后II(3)</a></li>
<li><a class="reference external" href="#57%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B43">57.插入区间(3)</a></li>
<li><a class="reference external" href="#65%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%971">65.有效数字(1)</a></li>
<li><a class="reference external" href="#68%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%901">68.文本左右对齐(1)</a></li>
<li><a class="reference external" href="#72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB2">72.编辑距离(2)</a></li>
<li><a class="reference external" href="#76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B22">76.最小覆盖子串(2)</a></li>
<li><a class="reference external" href="#84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A25">84.柱状图中最大的矩形(5)</a></li>
<li><a class="reference external" href="#85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A22">85.最大矩形(2)</a></li>
<li><a class="reference external" href="#87%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B22">87.扰乱字符串(2)</a></li>
<li><a class="reference external" href="#97%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B23">97.交错字符串(3)</a></li>
<li><a class="reference external" href="#99%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%914">99.恢复二叉搜索树(4)</a></li>
</ul>
</li>
</ul>
<div class="section" id="id1">
<h2>1.两数之和(3)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 nums 和一个目标值 target，
请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</pre></div>
</div>
<ul class="simple">
<li>解答思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法: 2层循环遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>两遍哈希遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03(最优)</td>
<td>一遍哈希遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span># 暴力法: 2层循环遍历
func twoSum(nums []int, target int) []int {
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			if nums[i]+nums[j] == target {
				return []int{i, j}
			}
		}
	}
	return []int{}
}

# 两遍哈希遍历
func twoSum(nums []int, target int) []int {
	m := make(map[int]int,len(nums))
	for k, v := range nums{
		m[v] = k
	}

	for i := 0; i &lt; len(nums); i++{
		b := target - nums[i]
		if num, ok := m[b]; ok &amp;&amp; num != i{
			return []int{i,m[b]}
		}
	}
	return []int{}
}

# 一遍哈希遍历
func twoSum(nums []int, target int) []int {
	m := make(map[int]int, len(nums))
	for i, b := range nums {
		if j, ok := m[target-b]; ok {
			return []int{j, i}
		}
		m[b] = i
	}
	return nil
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>7.整数反转(2)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
示例 1:输入: 123 输出: 321
示例 2:输入: -123 输出: -321
示例 3:输入: 120 输出: 21
注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。
请根据这个假设，如果反转后整数溢出那么就返回 0。
</pre></div>
</div>
<ul class="simple">
<li>解答思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>使用符号标记，转成正数，循环得到%10的余数，再加上符号</td>
<td>O(log(x))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02(最优)</td>
<td>对x进行逐个%10取个位，一旦溢出，直接跳出循环</td>
<td>O(log(x))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用符号标记，转成正数，循环得到%10的余数，再加上符号</span>
<span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">flag</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">flag</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">x</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span>

		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">temp</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="p">=</span> <span class="nx">flag</span> <span class="o">*</span> <span class="nx">result</span>
	<span class="k">if</span> <span class="nx">result</span> <span class="p">&gt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span> <span class="o">||</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 对x进行逐个%10取个位，一旦溢出，直接跳出循环</span>
<span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">temp</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="p">&gt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span> <span class="o">||</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>9.回文数(3)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 1:	输入: 121	输出: true
示例 2:输入: -121	输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:输入: 10  	输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
进阶: 你能不将整数转为字符串来解决这个问题吗？
</pre></div>
</div>
<ul class="simple">
<li>解答思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>数学解法，取出后半段数字进行翻转，然后判断是否相等</td>
<td>O(log(x))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>转成字符串，依次判断</td>
<td>O(log(x))</td>
<td>O(log(x))</td>
</tr>
<tr>
<td>03</td>
<td>转成byte数组，依次判断，同2</td>
<td>O(log(x))</td>
<td>O(log(x))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 数学解法，取出后半段数字进行翻转，然后判断是否相等</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">revertedNumber</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="nx">revertedNumber</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">revertedNumber</span> <span class="p">=</span> <span class="nx">revertedNumber</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">temp</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span>
	<span class="p">}</span>
	<span class="c1">// for example:</span>
	<span class="c1">// x = 1221  =&gt; x = 12 revertedNumber = 12</span>
	<span class="c1">// x = 12321 =&gt; x = 12 revertedNumber = 123</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">revertedNumber</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">revertedNumber</span><span class="o">/</span><span class="mi">10</span>
<span class="p">}</span>

<span class="c1">// 转成字符串，依次判断</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// 转成byte数组，依次判断，同2</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">arrs</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
	<span class="nx">Len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arrs</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">Len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arrs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">arrs</span><span class="p">[</span><span class="nx">Len</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>13.罗马数字转整数(2)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 
27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。
但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
示例 1:输入: &quot;III&quot; 输出: 3
示例 2:	输入: &quot;IV&quot; 输出: 4
示例 3:	输入: &quot;IX&quot;	输出: 9
示例 4:	输入: &quot;LVIII&quot;	输出: 58 解释: L = 50, V= 5, III = 3.
示例 5: 输入: &quot;MCMXCIV&quot;	输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4.
</pre></div>
</div>
<ul class="simple">
<li>解答思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>本质上其实就是全部累加，然后遇到特殊的就做判断。使用一个字段记录递增</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02(最优)</td>
<td>从右到左遍历字符串，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 带标记位</span>
<span class="kd">func</span> <span class="nx">romanToInt</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="sc">&#39;I&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
		<span class="sc">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
		<span class="sc">&#39;L&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
		<span class="sc">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
		<span class="sc">&#39;D&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
		<span class="sc">&#39;M&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nx">current</span> <span class="p">&lt;</span> <span class="nx">last</span> <span class="p">{</span>
			<span class="nx">flag</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">flag</span><span class="o">*</span><span class="nx">current</span>
		<span class="nx">last</span> <span class="p">=</span> <span class="nx">current</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 不带标记位，小于则减去2倍数</span>
<span class="kd">func</span> <span class="nx">romanToInt</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="sc">&#39;I&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
		<span class="sc">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
		<span class="sc">&#39;L&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
		<span class="sc">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
		<span class="sc">&#39;D&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
		<span class="sc">&#39;M&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="k">if</span> <span class="nx">current</span> <span class="p">&lt;</span> <span class="nx">last</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">-</span> <span class="nx">current</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">current</span>
		<span class="p">}</span>
		<span class="nx">last</span> <span class="p">=</span> <span class="nx">current</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>14.最长公共前缀(6)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &quot;&quot;。
示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot;
示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot;
解释: 输入不存在公共前缀。
说明: 所有输入只包含小写字母 a-z 。
</pre></div>
</div>
<ul class="simple">
<li>解答思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串</td>
<td>O(n^2)/O(n*m)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>纵向扫描(暴力法):直接取第一个字符串作为最长公共前缀，将其每个字符遍历过一次</td>
<td>O(n^2)/O(n*m)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03(最优)</td>
<td>排序后，然后计算第一个，和最后一个字符串的最长前缀</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>trie树</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>05</td>
<td>水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后</td>
<td>O(n^2)/O(n*m)</td>
<td>O(1)</td>
</tr>
<tr>
<td>06</td>
<td>分治法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">short</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strs</span><span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">short</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span>
			<span class="nx">short</span> <span class="p">=</span> <span class="nx">s</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">short</span><span class="p">{</span>
		<span class="nx">shortest</span> <span class="o">:=</span> <span class="nx">short</span><span class="p">[:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">str</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strs</span><span class="p">{</span>
			<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span><span class="nx">shortest</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">{</span>
				<span class="k">return</span> <span class="nx">short</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">short</span>
<span class="p">}</span>

<span class="c1">// 暴力法:直接依次遍历</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">char</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="o">||</span> <span class="nx">char</span> <span class="o">!=</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="nx">length</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">length</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="nx">length</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 排序后，遍历比较第一个，和最后一个字符串</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">{</span>
		<span class="nx">length</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">first</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">last</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
			<span class="k">return</span> <span class="nx">first</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">first</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// trie树</span>
<span class="kd">var</span> <span class="nx">trie</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">index</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">trie</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">trie</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
		<span class="nx">trie</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="nx">insert</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

	<span class="nx">minValue</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">retValue</span> <span class="o">:=</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">minValue</span> <span class="p">&gt;</span> <span class="nx">retValue</span> <span class="p">{</span>
			<span class="nx">minValue</span> <span class="p">=</span> <span class="nx">retValue</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="nx">minValue</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
		<span class="c1">// fmt.Println(string(str[i]),p,ch,trie[p][ch])</span>
		<span class="k">if</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">trie</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">ch</span><span class="p">];</span> <span class="nx">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">index</span><span class="o">++</span>
			<span class="nx">trie</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">ch</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">trie</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">ch</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>

<span class="c1">// 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">commonStr</span> <span class="o">:=</span> <span class="nx">common</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">if</span> <span class="nx">commonStr</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">commonStr</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&quot;&quot;</span>
		<span class="p">}</span>
		<span class="nx">commonStr</span> <span class="p">=</span> <span class="nx">common</span><span class="p">(</span><span class="nx">commonStr</span><span class="p">,</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">commonStr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">common</span><span class="p">(</span><span class="nx">str1</span><span class="p">,</span> <span class="nx">str2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">char</span> <span class="o">:=</span> <span class="nx">str1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str2</span><span class="p">)</span> <span class="o">||</span> <span class="nx">char</span> <span class="o">!=</span> <span class="nx">str2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">str1</span><span class="p">[:</span><span class="nx">length</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">length</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">str1</span><span class="p">[:</span><span class="nx">length</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 分治法</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">middle</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">leftStr</span> <span class="o">:=</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">middle</span><span class="p">)</span>
	<span class="nx">rightStr</span> <span class="o">:=</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span><span class="p">,</span> <span class="nx">middle</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">commonPrefixWord</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">,</span> <span class="nx">rightStr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">commonPrefixWord</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">,</span> <span class="nx">rightStr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rightStr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">leftStr</span> <span class="p">=</span> <span class="nx">leftStr</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">rightStr</span><span class="p">)]</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">leftStr</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">leftStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">rightStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">leftStr</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">leftStr</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>20.有效的括号(3)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。
有效字符串需满足：
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
示例 1: 输入: &quot;()&quot; 输出: true
示例 2: 输入: &quot;()[]{}&quot; 输出: true
示例 3: 输入: &quot;(]&quot; 输出: false
示例 4: 输入: &quot;([)]&quot; 输出: false
示例 5: 输入: &quot;{[]}&quot; 输出: true
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>使用栈结构实现栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>借助数组实现栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>借助数组实现栈，使用数字表示来匹配</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用栈结构实现</span>
<span class="kd">func</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">st</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">char</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
			<span class="nx">st</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
		<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">:</span>
			<span class="nx">ret</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">ret</span> <span class="o">!=</span> <span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">st</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">match</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">rune</span><span class="p">{</span>
	<span class="sc">&#39;)&#39;</span><span class="p">:</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span>
	<span class="sc">&#39;]&#39;</span><span class="p">:</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span>
	<span class="sc">&#39;}&#39;</span><span class="p">:</span> <span class="sc">&#39;{&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">stack</span> <span class="p">[]</span><span class="kt">rune</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nx">push</span><span class="p">(</span><span class="nx">b</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nx">pop</span><span class="p">()</span> <span class="p">(</span><span class="kt">rune</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="o">*</span><span class="nx">s</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="nx">res</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// 借助数组实现栈</span>
<span class="kd">func</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">match</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">rune</span><span class="p">{</span>
		<span class="sc">&#39;)&#39;</span><span class="p">:</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span>
		<span class="sc">&#39;]&#39;</span><span class="p">:</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span>
		<span class="sc">&#39;}&#39;</span><span class="p">:</span> <span class="sc">&#39;{&#39;</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">char</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
			<span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="p">]</span> <span class="p">=</span> <span class="nx">char</span>
			<span class="nx">length</span><span class="o">++</span>
		<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">length</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// 借助数组实现栈，使用数字表示来匹配</span>
<span class="kd">func</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">match</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="sc">&#39;)&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;(&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;]&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="sc">&#39;[&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
		<span class="sc">&#39;}&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
		<span class="sc">&#39;{&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">char</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
			<span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="p">]</span> <span class="p">=</span> <span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span>
			<span class="nx">length</span><span class="o">++</span>
		<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">length</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>21.合并两个有序链表(3)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>迭代遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归实现</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>// 迭代遍历
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}

	var head, node *ListNode
	if l1.Val &lt; l2.Val {
		head = l1
		node = l1
		l1 = l1.Next
	} else {
		head = l2
		node = l2
		l2 = l2.Next
	}

	for l1 != nil &amp;&amp; l2 != nil {
		if l1.Val &lt; l2.Val {
			node.Next = l1
			l1 = l1.Next
		} else {
			node.Next = l2
			l2 = l2.Next
		}
		node = node.Next
	}
	if l1 != nil {
		node.Next = l1
	}
	if l2 != nil {
		node.Next = l2
	}
	return head
}

// 递归遍历
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}

	if l1.Val &lt; l2.Val{
		l1.Next = mergeTwoLists(l1.Next,l2)
		return l1
	}else {
		l2.Next = mergeTwoLists(l1,l2.Next)
		return l2
	}
}

#
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	res := &amp;ListNode{}
	temp := res
	for l1 != nil &amp;&amp; l2 != nil {
		if l1.Val &lt; l2.Val {
			temp.Next = l1
			l1 = l1.Next
		} else {
			temp.Next = l2
			l2 = l2.Next
		}
		temp = temp.Next
	}
	if l1 != nil {
		temp.Next = l1
	} else {
		temp.Next = l2
	}
	return res.Next
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>26.删除排序数组中的重复项(2)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1: 给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。
示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
说明: 为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02(最优)</td>
<td>计数法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">removeDuplicates</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="p">,</span> <span class="nx">j</span> <span class="p">,</span> <span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 计数法</span>
<span class="kd">func</span> <span class="nx">removeDuplicates</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">count</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>27.移除元素(3)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 1: 给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
说明: 为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>双指针，数字前移</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针，出现重复最后数字前移</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>首位指针法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 双指针，数字前移</span>
<span class="kd">func</span> <span class="nx">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">val</span><span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 双指针，出现重复最后数字前移</span>
<span class="kd">func</span> <span class="nx">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">val</span><span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 首位指针法</span>
<span class="kd">func</span> <span class="nx">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 从左向右找到等于 val 的位置</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 从右向左找到不等于 val 的位置</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">j</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// fmt.Println(i,j)</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="strstr-4">
<h2>28.实现strStr()(4)<a class="headerlink" href="#strstr-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，
在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。
如果不存在，则返回-1。
示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2
示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1
说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。
这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>Sunday算法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>直接匹配</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>系统函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>kmp算法</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sunday算法</span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">needle</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 计算模式串needle的偏移量</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">needle</span><span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span><span class="o">-</span><span class="nx">k</span>
	<span class="p">}</span>

	<span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
		<span class="c1">// 匹配字符串</span>
		<span class="nx">str</span> <span class="o">:=</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">index</span><span class="p">:</span><span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)]</span>
		<span class="k">if</span> <span class="nx">str</span> <span class="o">==</span> <span class="nx">needle</span><span class="p">{</span>
			<span class="k">return</span> <span class="nx">index</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
			<span class="c1">// 后一位字符串</span>
			<span class="nx">next</span> <span class="o">:=</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)]</span>
			<span class="k">if</span> <span class="nx">nextStep</span><span class="p">,</span><span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nb">int32</span><span class="p">(</span><span class="nx">next</span><span class="p">)];</span><span class="nx">ok</span><span class="p">{</span>
				<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span><span class="o">+</span><span class="nx">nextStep</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">index</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// </span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">hlen</span><span class="p">,</span> <span class="nx">nlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">hlen</span><span class="o">-</span><span class="nx">nlen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nlen</span><span class="p">]</span> <span class="o">==</span> <span class="nx">needle</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">haystack</span><span class="p">,</span> <span class="nx">needle</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">next</span> <span class="o">:=</span> <span class="nx">getNext</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span>

	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 求next数组</span>
<span class="kd">func</span> <span class="nx">getNext</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">next</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
	<span class="nx">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>

	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
			<span class="nx">j</span><span class="o">++</span>
			<span class="nx">next</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">j</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">next</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>35.搜索插入位置(3)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
示例 1: 输入: [1,3,5,6], 5 输出: 2
示例 2: 输入: [1,3,5,6], 2 输出: 1
示例 3: 输入: [1,3,5,6], 7 输出: 4
示例 4: 输入: [1,3,5,6], 0 输出: 0
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>顺序查找</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>顺序查找</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 二分查找</span>
<span class="kd">func</span> <span class="nx">searchInsert</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">low</span><span class="p">,</span> <span class="nx">high</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
	<span class="k">for</span> <span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">target</span><span class="p">:</span>
			<span class="nx">low</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">case</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">target</span><span class="p">:</span>
			<span class="nx">high</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">mid</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">low</span>
<span class="p">}</span>

<span class="c1">// 顺序查找</span>
<span class="kd">func</span> <span class="nx">searchInsert</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 顺序查找</span>
<span class="kd">func</span> <span class="nx">searchInsert</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>38.报数(2)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
注意：整数顺序将表示为一个字符串。
示例 1:输入: 1 输出: &quot;1&quot;
示例 2: 输入: 4 输出: &quot;1211&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01 (最优)</td>
<td>递推+双指针计数</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归+双指针计数</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递推+双指针计数</span>
<span class="kd">func</span> <span class="nx">countAndSay</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">strs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;1&#39;</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">strs</span> <span class="p">=</span> <span class="nx">say</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">say</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 几个几</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="sc">&#39;0&#39;</span><span class="p">))</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 递归+双指针计数</span>
<span class="kd">func</span> <span class="nx">countAndSay</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;1&quot;</span>
	<span class="p">}</span>
	<span class="nx">strs</span> <span class="o">:=</span> <span class="nx">countAndSay</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 几个几</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="sc">&#39;0&#39;</span><span class="p">))</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>53.最大子序和(5)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>贪心法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>分治</td>
<td>O(nlog(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 贪心法</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">sum</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 暴力法</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
				<span class="nx">result</span> <span class="p">=</span> <span class="nx">sum</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// </span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 动态规划</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">dp</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">dp</span> <span class="p">=</span> <span class="nx">dp</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">dp</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">dp</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">dp</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 分治法</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">leftSum</span> <span class="o">:=</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">)</span>        <span class="c1">// 最大子序在左边</span>
	<span class="nx">rightSum</span> <span class="o">:=</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>    <span class="c1">// 最大子序在右边</span>
	<span class="nx">midSum</span> <span class="o">:=</span> <span class="nx">findMaxArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="c1">// 跨中心</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftSum</span><span class="p">,</span> <span class="nx">rightSum</span><span class="p">)</span>
	<span class="nx">result</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">midSum</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">findMaxArr</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">leftSum</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// 从右到左</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">mid</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">left</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">leftSum</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftSum</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rightSum</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="nx">sum</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 从左到右</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">rightSum</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">rightSum</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">leftSum</span> <span class="o">+</span> <span class="nx">rightSum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>58.最后一个单词的长度(2)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。
如果不存在最后一个单词，请返回 0 。
说明：一个单词是指由字母组成，但不包含任何空格的字符串。
示例: 输入: &quot;Hello World&quot; 输出: 5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01(最优)</td>
<td>调用系统函数，切割为数组取最后一个值</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历统计</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 调用系统函数，切割为数组取最后一个值</span>
<span class="kd">func</span> <span class="nx">lengthOfLastWord</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Trim</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">),</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">// 遍历统计</span>
<span class="kd">func</span> <span class="nx">lengthOfLastWord</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">result</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">result</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">result</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>66.加一(2)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。
示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>直接模拟</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02(最优)</td>
<td>直接模拟</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 模拟进位</span>
<span class="kd">func</span> <span class="nx">plusOne</span><span class="p">(</span><span class="nx">digits</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">digits</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">digits</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
		<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">9</span> <span class="p">{</span>
		<span class="nx">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
		<span class="nx">digits</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="nx">digits</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">digits</span>
<span class="p">}</span>

<span class="c1">// 模拟进位</span>
<span class="kd">func</span> <span class="nx">plusOne</span><span class="p">(</span><span class="nx">digits</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">digits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">9</span> <span class="p">{</span>
			<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span>
			<span class="k">return</span> <span class="nx">digits</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="nx">digits</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>67.二进制求和(2)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个二进制字符串，返回他们的和（用二进制表示）。
输入为非空字符串且只包含数字 1 和 0。
示例 1: 输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot;
示例 2:输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>转换成数组模拟</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02(最优)</td>
<td>直接模拟</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 转换成数组模拟</span>
<span class="kd">func</span> <span class="nx">addBinary</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

	<span class="nx">A</span> <span class="o">:=</span> <span class="nx">transToInt</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
	<span class="nx">B</span> <span class="o">:=</span> <span class="nx">transToInt</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">makeString</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">transToInt</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">length</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
	<span class="nx">ls</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="nx">ls</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span> <span class="o">%</span> <span class="mi">2</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">makeString</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bytes</span> <span class="p">{</span>
		<span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 直接模拟</span>
<span class="kd">func</span> <span class="nx">addBinary</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="nx">flag</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">current</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">intA</span><span class="p">,</span> <span class="nx">intB</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">intA</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">intB</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">current</span> <span class="p">=</span> <span class="nx">intA</span> <span class="o">+</span> <span class="nx">intB</span> <span class="o">+</span> <span class="nx">flag</span>
		<span class="nx">flag</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">current</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">flag</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">current</span> <span class="p">=</span> <span class="nx">current</span> <span class="o">-</span> <span class="mi">2</span>
		<span class="p">}</span>
		<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">current</span><span class="p">)</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">result</span>
		<span class="nx">i</span><span class="o">--</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="s">&quot;1&quot;</span> <span class="o">+</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x-5">
<h2>69.x的平方根 (5)<a class="headerlink" href="#x-5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:输入: 4 输出: 2
示例 2:输入: 8 输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>系统函数</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>系统函数</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03(最优)</td>
<td>牛顿迭代法</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>二分查找法</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>暴力法:遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 系统函数</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 系统函数</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Floor</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 牛顿迭代法</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">x</span>
	<span class="k">for</span> <span class="nx">result</span><span class="o">*</span><span class="nx">result</span> <span class="p">&gt;</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="p">(</span><span class="nx">result</span> <span class="o">+</span> <span class="nx">x</span><span class="o">/</span><span class="nx">result</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 二分查找法</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nx">x</span>
	<span class="k">for</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="k">if</span> <span class="nx">mid</span> <span class="o">==</span> <span class="nx">x</span><span class="o">/</span><span class="nx">mid</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">mid</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">mid</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="o">/</span><span class="nx">mid</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">right</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">*</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">x</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">left</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">left</span><span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 暴力法:遍历</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">x</span><span class="o">/</span><span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">*</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>70.爬楼梯(3)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 
1.  1 阶 + 1 阶
2.  2 阶
示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03(最优)</td>
<td>斐波那契</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">climbStart</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">climbStart</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">climbStart</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="nx">climbStart</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 动态规划</span>
<span class="kd">func</span> <span class="nx">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">2</span>
	<span class="p">}</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 斐波那契</span>
<span class="kd">func</span> <span class="nx">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">second</span> <span class="o">:=</span> <span class="mi">2</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">third</span> <span class="o">:=</span> <span class="nx">first</span> <span class="o">+</span> <span class="nx">second</span>
		<span class="nx">first</span> <span class="p">=</span> <span class="nx">second</span>
		<span class="nx">second</span> <span class="p">=</span> <span class="nx">third</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">second</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>83.删除排序链表中的重复元素(3)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1:输入: 1-&gt;1-&gt;2 输出: 1-&gt;2
示例 2:输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01( 最优)</td>
<td>直接法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>双指针法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 直接法</span>
<span class="kd">func</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">head</span>
	<span class="k">for</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
			<span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">temp</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>

<span class="c1">// 递归法</span>
<span class="kd">func</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">head</span>
	<span class="p">}</span>
	<span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
		<span class="nx">head</span> <span class="p">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>

<span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">head</span>
	<span class="p">}</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">head</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="k">for</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Next</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
			<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span>
				<span class="nx">q</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Next</span>
			<span class="nx">q</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>88.合并两个有序数组(3)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
说明:
    初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
    你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
示例:输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>合并后排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02(最优)</td>
<td>双指针法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>拷贝后插入</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 合并后排序</span>
<span class="kd">func</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">nums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">nums1</span> <span class="p">=</span> <span class="nx">nums1</span><span class="p">[:</span><span class="nx">m</span><span class="p">]</span>
	<span class="nx">nums1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">nums1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">nums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">m</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">m</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 拷贝后插入</span>
<span class="kd">func</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">nums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">first</span><span class="p">,</span> <span class="nx">second</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">second</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span>
			<span class="nx">first</span><span class="o">++</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">first</span> <span class="o">&gt;=</span> <span class="nx">m</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">second</span><span class="p">]</span>
			<span class="nx">second</span><span class="o">++</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">second</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span>
			<span class="nx">first</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">second</span><span class="p">]</span>
			<span class="nx">second</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>100.相同的树(2)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个二叉树，编写一个函数来检验它们是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1:
输入:       1         1
          / \       / \
         2   3     2   3
        [1,2,3],   [1,2,3]
输出: true
示例 2:
输入:      1          1
          /           \
         2             2
        [1,2],     [1,null,2]
输出: false
示例 3:
输入:       1         1
          / \       / \
         2   1     1   2
        [1,2,1],   [1,1,2]
输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归(深度优先)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>层序遍历(宽度优先)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归(深度优先)</span>
<span class="kd">func</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Val</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 层序遍历(宽度优先)</span>
<span class="kd">func</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">queueP</span><span class="p">,</span> <span class="nx">queueQ</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">queueP</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueP</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="nx">queueQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queueP</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">tempP</span> <span class="o">:=</span> <span class="nx">queueP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">queueP</span> <span class="p">=</span> <span class="nx">queueP</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

		<span class="nx">tempQ</span> <span class="o">:=</span> <span class="nx">queueQ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">queueQ</span> <span class="p">=</span> <span class="nx">queueQ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

		<span class="k">if</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">queueP</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueP</span><span class="p">,</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="nx">queueQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">,</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">queueP</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueP</span><span class="p">,</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="nx">queueQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">,</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>0001-0100-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id20">
<h2>2.两数相加(2)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出两个 非空 的链表用来表示两个非负的整数。
其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	res := &amp;ListNode{}
	cur := res
	carry := 0
	for l1 != nil || l2 != nil || carry &gt; 0 {
		sum := carry
		if l1 != nil {
			sum += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			sum += l2.Val
			l2 = l2.Next
		}
		carry = sum / 10 // 进位
		cur.Next = &amp;ListNode{Val: sum % 10}
		cur = cur.Next
	}
	return res.Next
}

#
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil &amp;&amp; l2 == nil {
		return nil
	}
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	sum := l1.Val + l2.Val
	res := &amp;ListNode{Val: sum % 10}
	if sum &gt;= 10 {
		l1.Next = addTwoNumbers(l1.Next, &amp;ListNode{Val: 1})
	}
	res.Next = addTwoNumbers(l1.Next, l2.Next)
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>3.无重复字符的最长子串(4)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:输入: &quot;abcabcbb&quot;输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
示例 2:输入: &quot;bbbbb&quot; 输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
示例 3:输入: &quot;pwwkew&quot; 输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
同剑指offer面试题48.最长不含重复字符的子字符串
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组辅助-双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针-内置函数</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>哈希辅助-双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func lengthOfLongestSubstring(s string) int {
	arr := [256]int{}
	for i := range arr {
		arr[i] = -1
	}
	max, j := 0, 0
	for i := 0; i &lt; len(s); i++ {
		if arr[s[i]] &gt;= j {
			j = arr[s[i]] + 1
		} else if i+1-j &gt; max {
			max = i + 1 - j
		}
		arr[s[i]] = i
	}
	return max
}

#
func lengthOfLongestSubstring(s string) int {
	max, j := 0, 0
	for i := 0; i &lt; len(s); i++ {
		index := strings.Index(s[j:i], string(s[i]))
		if index == -1 {
			continue
		}
		if i-j &gt; max {
			max = i - j
		}
		j = j + index + 1
	}
	if len(s)-j &gt; max {
		max = len(s) - j
	}
	return max
}

#
func lengthOfLongestSubstring(s string) int {
	m := make(map[uint8]int)
	max, j := 0, 0
	for i := 0; i &lt; len(s); i++ {
		if v, ok := m[s[i]]; ok &amp;&amp; v &gt;= j {
			j = v + 1
		} else if i+1-j &gt; max {
			max = i + 1 - j
		}
		m[s[i]] = i
	}
	return max
}

#
func lengthOfLongestSubstring(s string) int {
	if len(s) &lt; 1 {
		return 0
	}
	dp := make([]int, len(s))
	dp[0] = 1
	res := 1
	m := make(map[byte]int)
	m[s[0]] = 0
	for i := 1; i &lt; len(s); i++ {
		index := -1
		if value, ok := m[s[i]]; ok {
			index = value
		}
		if i-index &gt; dp[i-1] {
			dp[i] = dp[i-1] + 1
		} else {
			dp[i] = i - index
		}
		m[s[i]] = i
		if dp[i] &gt; res {
			res = dp[i]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>5.最长回文子串(5)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。
示例 2：输入: &quot;cbbd&quot; 输出: &quot;bb&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>中心扩展</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^3)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>Manacher算法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>05</td>
<td>Manacher算法</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>// dp(l,r)=dp(l+1,r−1)&amp;&amp;(s[l]==s[r])
// dp[l,r]：字符串s从索引l到r的子串是否是回文串
func longestPalindrome(s string) string {
	if len(s) &lt;= 1 {
		return s
	}
	dp := make([][]bool, len(s))
	start := 0
	max := 1
	for r := 0; r &lt; len(s); r++ {
		dp[r] = make([]bool, len(s))
		dp[r][r] = true
		for l := 0; l &lt; r; l++ {
			if s[l] == s[r] &amp;&amp; (r-l &lt;= 2 || dp[l+1][r-1] == true) {
				dp[l][r] = true
			} else {
				dp[l][r] = false
			}
			if dp[l][r] == true {
				if r-l+1 &gt; max {
					max = r - l + 1
					start = l
				}
			}
		}
	}
	return s[start : start+max]
}

# 2
func longestPalindrome(s string) string {
	if len(s) &lt;= 1 {
		return s
	}
	start := 0
	end := 0
	for i := 0; i &lt; len(s); i++ {
		left1, right1 := find(s, i, i)
		left2, right2 := find(s, i, i+1)
		if right1-left1 &gt; end-start {
			start, end = left1, right1
		}
		if right2-left2 &gt; end-start {
			start, end = left2, right2
		}
	}
	return s[start : end+1]
}

func find(s string, left, right int) (int, int) {
	for ; 0 &lt;= left &amp;&amp; right &lt; len(s) &amp;&amp; s[left] == s[right]; left, right = left-1, right+1 {
	}
	return left + 1, right - 1
}

# 3
func longestPalindrome(s string) string {
	if len(s) &lt;= 1 {
		return s
	}
	res := &quot;&quot;
	for i := 0; i &lt; len(s); i++ {
		for j := i; j &lt; len(s); j++ {
			str := s[i : j+1]
			if len(str) &lt; len(res) &amp;&amp; res != &quot;&quot; {
				continue
			}
			if judge(str) == true &amp;&amp; len(res) &lt; len(str) {
				res = str
			}
		}
	}
	return res
}

func judge(s string) bool {
	for i := 0; i &lt; len(s)/2; i++ {
		if s[i] != s[len(s)-1-i] {
			return false
		}
	}
	return true
}

# 4
func longestPalindrome(s string) string {
	if len(s) &lt;= 1 {
		return s
	}
	str := add(s)
	length := len(str)
	max := 1
	begin := 0
	for i := 0; i &lt; length; i++ {
		curLength := search(str, i)
		if curLength &gt; max {
			max = curLength
			begin = (i - max) / 2
		}
	}
	return s[begin : begin+max]
}

func search(s string, center int) int {
	i := center - 1
	j := center + 1
	step := 0
	for ; i &gt;= 0 &amp;&amp; j &lt; len(s) &amp;&amp; s[i] == s[j]; i, j = i-1, j+1 {
		step++
	}
	return step
}

func add(s string) string {
	var res []rune
	for _, v := range s {
		res = append(res, &#39;#&#39;)
		res = append(res, v)
	}
	res = append(res, &#39;#&#39;)
	return string(res)
}

#
func longestPalindrome(s string) string {
	if len(s) &lt;= 1 {
		return s
	}
	str := add(s)
	length := len(str)
	temp := make([]int, length)
	maxRight := 0
	center := 0
	max := 1
	begin := 0
	for i := 0; i &lt; length; i++ {
		if i &lt; maxRight {
			mirror := 2*center - i
			temp[i] = min(maxRight-i, temp[mirror])
		}
		left := i - (1 + temp[i])
		right := i + (1 + temp[i])
		for left &gt;= 0 &amp;&amp; right &lt; len(str) &amp;&amp; str[left] == str[right] {
			temp[i]++
			left--
			right++
		}
		if i+temp[i] &gt; maxRight {
			maxRight = i + temp[i]
			center = i
		}
		if temp[i] &gt; max {
			max = temp[i]
			begin = (i - max) / 2
		}
	}
	return s[begin : begin+max]
}

func add(s string) string {
	var res []rune
	for _, v := range s {
		res = append(res, &#39;#&#39;)
		res = append(res, v)
	}
	res = append(res, &#39;#&#39;)
	return string(res)
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="z-2">
<h2>6.Z字形变换(2)<a class="headerlink" href="#z-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：
L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。
请你实现这个将字符串进行指定行数变换的函数：
string convert(string s, int numRows);
示例 1:输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3 输出: &quot;LCIRETOESIIGEDHN&quot;
示例 2:输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 输出: &quot;LDREOEIIECIHNTSG&quot;
解释:
L     D     R
E   O E   I I
E C   I H   N
T     S     G
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func convert(s string, numRows int) string {
	if numRows == 1 {
		return s
	}
	arr := []rune(s)
	total := numRows*2 - 2
	res := make([]string, numRows)
	for i := 0; i &lt; len(arr); i++ {
		index := i % total
		if index &lt; numRows {
			res[index] = res[index] + string(arr[i])
		} else {
			res[total-index] = res[total-index] + string(arr[i])
		}
	}
	return strings.Join(res, &quot;&quot;)
}

#
func convert(s string, numRows int) string {
	if numRows == 1 {
		return s
	}
	arr := []rune(s)
	res := make([]string, numRows)
	flag := -1
	index := 0
	for i := 0; i &lt; len(arr); i++ {
		res[index] = res[index] + string(arr[i])
		if index == 0 || index == numRows-1 {
			flag = -flag
		}
		index = index + flag
	}
	return strings.Join(res, &quot;&quot;)
}
</pre></div>
</div>
</div>
<div class="section" id="atoi-3">
<h2>8.字符串转换整数 (atoi)(3)<a class="headerlink" href="#atoi-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请你来实现一个 atoi 函数，使其能将字符串转换成整数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：
   如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
   假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
   该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，
则你的函数不需要进行转换，即无法进行有效转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0 。
提示：
    本题中的空白字符只包括空格字符 &#39; &#39; 。
    假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。
    如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。
示例 1:输入: &quot;42&quot; 输出: 42
示例 2:输入: &quot;   -42&quot; 输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:输入: &quot;4193 with words&quot; 输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
示例 4:输入: &quot;words and 987&quot; 输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:输入: &quot;-91283472332&quot; 输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>正则</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func myAtoi(str string) int {
	i := 0
	for i &lt; len(str) &amp;&amp; str[i] == &#39; &#39; {
		i++
	}
	str = str[i:]
	arr := make([]byte, 0)
	isFlag := byte(&#39; &#39;)
	for j := 0; j &lt; len(str); j++ {
		if str[j] &gt;= &#39;0&#39; &amp;&amp; str[j] &lt;= &#39;9&#39; {
			arr = append(arr, str[j])
		} else {
			if len(arr) &gt; 0 {
				break
			}
			if str[j] != &#39; &#39; &amp;&amp; str[j] != &#39;+&#39; &amp;&amp; str[j] != &#39;-&#39; {
				return 0
			}
			if isFlag != &#39; &#39; {
				return 0
			}
			isFlag = str[j]
		}
	}
	res := 0
	for i := 0; i &lt; len(arr); i++ {
		value := int(arr[i] - &#39;0&#39;)
		res = res*10 + value
		if isFlag == &#39;-&#39; {
			if -1*res &lt; math.MinInt32 {
				return math.MinInt32
			}
		} else if isFlag == &#39; &#39; || isFlag == &#39;+&#39; {
			if res &gt; math.MaxInt32 {
				return math.MaxInt32
			}
		}
	}
	if isFlag == &#39;-&#39; {
		return -1 * res
	}
	return res
}

#
func myAtoi(str string) int {
	re := regexp.MustCompile(`^[+-]?\d+`)
	arrS := re.FindAllString(strings.Trim(str, &quot; &quot;), -1)
	if len(arrS) == 0{
		return 0
	}
	arr := arrS[0]
	res := 0
	isFlag := byte(&#39; &#39;)
	if !(arr[0] &gt;= &#39;0&#39; &amp;&amp; arr[0] &lt;= &#39;9&#39;) {
		isFlag = arr[0]
		arr = arr[1:]
	}
	for i := 0; i &lt; len(arr); i++ {
		value := int(arr[i] - &#39;0&#39;)
		if isFlag == &#39;-&#39; {
			if res &gt; 214748364 || (res==214748364 &amp;&amp; value &gt;= 8) {
				return math.MinInt32
			}
		} else if isFlag == &#39; &#39; || isFlag == &#39;+&#39; {
			if res &gt; 214748364 || (res==214748364 &amp;&amp; value &gt;= 7) {
				return math.MaxInt32
			}
		}
		res = res*10 + value
	}
	if isFlag == &#39;-&#39; {
		return -1 * res
	}
	return res
}

#
func myAtoi(str string) int {
	str = strings.TrimSpace(str)
	result := 0
	flag := 1
	for i, v := range str {
		if v &gt;= &#39;0&#39; &amp;&amp; v &lt;= &#39;9&#39; {
			result = result*10 + int(v-&#39;0&#39;)
		} else if v == &#39;-&#39; &amp;&amp; i == 0 {
			flag = -1
		} else if v == &#39;+&#39; &amp;&amp; i == 0 {
			flag = 1
		} else {
			break
		}
		if result &gt; math.MaxInt32 {
			if flag == -1 {
				return math.MinInt32
			}
			return math.MaxInt32
		}
	}
	return flag * result
}
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>11.盛最多水的容器(2)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例：输入：[1,8,6,2,5,4,8,3,7] 输出：49
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历-双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历-暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxArea(height []int) int {
	i := 0
	j := len(height) - 1
	res := 0
	for i &lt; j {
		area := (j - i) * min(height[i], height[j])
		if area &gt; res {
			res = area
		}
		// 移动较小的指针，尝试获取更大的面积
		if height[i] &gt; height[j] {
			j--
		} else {
			i++
		}
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

#
func maxArea(height []int) int {
	res := 0
	for i := 0; i &lt; len(height); i++ {
		for j := i + 1; j &lt; len(height); j++ {
			area := (j - i) * min(height[i], height[j])
			if area &gt; res {
				res = area
			}
		}
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>12.整数转罗马数字(2)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 
27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
示例 1:输入: 3输出: &quot;III&quot;
示例 2:输入: 4 输出: &quot;IV&quot;
示例 3:输入: 9 输出: &quot;IX&quot;
示例 4:输入: 58 输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.
示例 5:输入: 1994 输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>枚举</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func intToRoman(num int) string {
	m := map[int]string{
		1:    &quot;I&quot;,
		4:    &quot;IV&quot;,
		5:    &quot;V&quot;,
		9:    &quot;IX&quot;,
		10:   &quot;X&quot;,
		40:   &quot;XL&quot;,
		50:   &quot;L&quot;,
		90:   &quot;XC&quot;,
		100:  &quot;C&quot;,
		400:  &quot;CD&quot;,
		500:  &quot;D&quot;,
		900:  &quot;CM&quot;,
		1000: &quot;M&quot;,
	}
	arr := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
	result := &quot;&quot;
	for i := 0; i &lt; len(arr); i++ {
		if num == 0 {
			break
		}
		value := num / arr[i]
		for j := 0; j &lt; value; j++ {
			result = result + m[arr[i]]
		}
		num = num - value*arr[i]
	}
	return result
}

#
func intToRoman(num int) string {
	res := &quot;&quot;
	arr1 := []string{&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;}
	arr2 := []string{&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;}
	arr3 := []string{&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;}
	arr4 := []string{&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;}
	res = arr4[num/1000] + arr3[num%1000/100] + arr2[num%100/10] + arr1[num%10]
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>15.三数之和(2)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func threeSum(nums []int) [][]int {
	res := make([][]int, 0)
	sort.Ints(nums)
	for i := 0; i &lt; len(nums)-1; i++ {
		target := 0 - nums[i]
		left := i + 1
		right := len(nums) - 1
		if nums[i] &gt; 0 || nums[i]+nums[left] &gt; 0 {
			break
		}
		if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {
			continue
		}
		for left &lt; right {
			if left &gt; i+1 &amp;&amp; nums[left] == nums[left-1] {
				left++
				continue
			}
			if right &lt; len(nums)-2 &amp;&amp; nums[right] == nums[right+1] {
				right--
				continue
			}
			if nums[left]+nums[right] &gt; target {
				right--
			} else if nums[left]+nums[right] &lt; target {
				left++
			} else {
				res = append(res, []int{nums[i], nums[left], nums[right]})
				left++
				right--
			}
		}
	}
	return res
}

#
func threeSum(nums []int) [][]int {
	res := make([][]int, 0)
	m := make(map[[2]int]int)
	p := make(map[int]int)
	sort.Ints(nums)
	for k, v := range nums {
		p[v] = k
	}
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			if j != i+1 &amp;&amp; nums[j] == nums[j-1] {
				continue
			}
			sum := nums[i] + nums[j]
			if sum &gt; 0 {
				break
			}
			if value, ok := p[-sum]; ok &amp;&amp; value &gt; j {
				if _, ok2 := m[[2]int{nums[i], nums[j]}]; !ok2 {
					res = append(res, []int{nums[i], nums[j], 0 - nums[i] - nums[j]})
					m[[2]int{nums[i], nums[j]}] = 1
				}
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>16.最接近的三数之和(2)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。
找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：输入：nums = [-1,2,1,-4], target = 1 输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
提示：
    3 &lt;= nums.length &lt;= 10^3
    -10^3 &lt;= nums[i] &lt;= 10^3
    -10^4 &lt;= target &lt;= 10^4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^3)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func threeSumClosest(nums []int, target int) int {
	sort.Ints(nums)
	res := nums[0] + nums[1] + nums[2]
	for i := 0; i &lt; len(nums); i++ {
		left := i + 1
		right := len(nums) - 1
		for left &lt; right {
			sum := nums[i] + nums[left] + nums[right]
			if sum &gt; target {
				right--
			} else if sum &lt; target {
				left++
			} else {
				return target
			}
			if abs(sum, target) &lt; abs(res, target) {
				res = sum
			}
		}
	}
	return res
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}

#
func threeSumClosest(nums []int, target int) int {
	res := nums[0] + nums[1] + nums[2]
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			for k := j + 1; k &lt; len(nums); k++ {
				sum := nums[i] + nums[j] + nums[k]
				if abs(sum, target) &lt; abs(res, target) {
					res = sum
				}
			}
		}
	}
	return res
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>17.电话号码的字母组合(2)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
示例:输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(4^n)</td>
<td>O(4^n)</td>
</tr>
<tr>
<td>02</td>
<td>递归-回溯</td>
<td>O(4^n)</td>
<td>O(4^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func letterCombinations(digits string) []string {
	if len(digits) == 0 {
		return nil
	}
	arr := []string{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}
	res := []string{&quot;&quot;}
	for i := 0; i &lt; len(digits); i++ {
		length := len(res)
		for j := 0; j &lt; length; j++ {
			for k := 0; k &lt; len(arr[digits[i]-&#39;0&#39;]); k++ {
				res = append(res, res[j]+string(arr[digits[i]-&#39;0&#39;][k]))
			}
		}
		res = res[length:]
	}
	return res
}

#
var res []string
var arr = []string{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}

func letterCombinations(digits string) []string {
	if len(digits) == 0 {
		return nil
	}
	res = make([]string, 0)
	dfs(digits, 0, &quot;&quot;)
	return res
}

func dfs(digits string, index int, str string) {
	if index == len(digits) {
		res = append(res, str)
		return
	}
	for i := 0; i &lt; len(arr[digits[index]-&#39;0&#39;]); i++ {
		dfs(digits, index+1, str+string(arr[digits[index]-&#39;0&#39;][i]))
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>18.四数之和(3)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，
使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
注意：答案中不可以包含重复的四元组。
示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。
满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n^3)</td>
<td>O(n^3)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n^3)</td>
<td>O(n^3)</td>
</tr>
<tr>
<td>03</td>
<td>全排列+递归</td>
<td>O(n^3)</td>
<td>O(n^3)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func fourSum(nums []int, target int) [][]int {
	sort.Ints(nums)
	res := make([][]int, 0)
	for i := 0; i &lt; len(nums); i++ {
		if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {
			continue
		}
		for j := i + 1; j &lt; len(nums); j++ {
			if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1] {
				continue
			}
			temp := target - nums[i] - nums[j]
			left := j + 1
			right := len(nums) - 1
			for left &lt; right {
				if left &gt; j+1 &amp;&amp; nums[left] == nums[left-1] {
					left++
					continue
				}
				if right &lt; len(nums)-2 &amp;&amp; nums[right] == nums[right+1] {
					right--
					continue
				}
				if nums[left]+nums[right] &gt; temp {
					right--
				} else if nums[left]+nums[right] &lt; temp {
					left++
				} else {
					res = append(res, []int{nums[i], nums[j], nums[left], nums[right]})
					left++
					right--
				}
			}
		}
	}
	return res
}

#
func fourSum(nums []int, target int) [][]int {
	m := make(map[[3]int]int)
	p := make(map[int]int)
	sort.Ints(nums)
	for k, v := range nums {
		p[v] = k
	}
	res := make([][]int, 0)
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			for k := j + 1; k &lt; len(nums); k++ {
				sum := nums[i] + nums[j] + nums[k]
				if value, ok := p[target-sum]; ok &amp;&amp; value &gt; k {
					if _, ok2 := m[[3]int{nums[i], nums[j], nums[k]}]; !ok2 {
						res = append(res, []int{nums[i], nums[j], nums[k], target - nums[i] - nums[j] - nums[k]})
						m[[3]int{nums[i], nums[j], nums[k]}] = 1
					}
				}
			}
		}
	}
	return res
}

#
var res [][]int

func fourSum(nums []int, target int) [][]int {
	sort.Ints(nums)
	res = make([][]int, 0)
	dfs(nums, target, []int{}, 0)
	return res
}

func dfs(nums []int, target int, arr []int, level int) {
	if len(arr) == 4 {
		sum := 0
		for i := 0; i &lt; len(arr); i++ {
			sum = sum + arr[i]
		}
		if sum == target {
			tempArr := make([]int, len(arr))
			copy(tempArr, arr)
			res = append(res, tempArr)
		}
		return
	}
	prev := math.MaxInt32
	for i := level; i &lt; len(nums); i++ {
		if nums[i] != prev {
			prev = nums[i]
			arr = append(arr, nums[i])
			dfs(nums, target, arr, i+1)
			arr = arr[:len(arr)-1]
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="n-3">
<h2>19.删除链表的倒数第N个节点(3)<a class="headerlink" href="#n-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
说明：给定的 n 保证是有效的。
进阶：你能尝试使用一趟扫描实现吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>快慢指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeNthFromEnd(head *ListNode, n int) *ListNode {
	temp := &amp;ListNode{Next: head}
	cur := temp
	total := 0
	for cur.Next != nil {
		cur = cur.Next
		total++
	}
	cur = temp
	count := 0
	for cur.Next != nil {
		if total-n == count {
			cur.Next = cur.Next.Next
			break
		}
		cur = cur.Next
		count++
	}
	return temp.Next
}

#
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	temp := &amp;ListNode{Next: head}
	fast, slow := temp, temp
	for i := 0; i &lt; n; i++ {
		fast = fast.Next
	}
	for fast.Next != nil {
		fast = fast.Next
		slow = slow.Next
	}
	slow.Next = slow.Next.Next
	return temp.Next
}

#
var count int

func removeNthFromEnd(head *ListNode, n int) *ListNode {
	if head == nil {
		count = 0
		return nil
	}
	head.Next = removeNthFromEnd(head.Next, n)
	count = count + 1
	if count == n {
		return head.Next
	}
	return head
}
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>22.括号生成(3)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：输入：n = 3
输出：[
       &quot;((()))&quot;,
       &quot;(()())&quot;,
       &quot;(())()&quot;,
       &quot;()(())&quot;,
       &quot;()()()&quot;
     ]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>全排列-递归</td>
<td>O(4^n/n^(1/2))</td>
<td>O(4^n/n^(1/2))</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(4^n/n^(1/2))</td>
<td>O(4^n/n^(1/2))</td>
</tr>
<tr>
<td>03</td>
<td>广度优先搜索</td>
<td>O(4^n/n^(1/2))</td>
<td>O(4^n/n^(1/2))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res []string

func generateParenthesis(n int) []string {
	res = make([]string, 0)
	dfs(0, 0, n, &quot;&quot;)
	return res
}

func dfs(left, right, max int, str string) {
	if left == right &amp;&amp; left == max {
		res = append(res, str)
		return
	}
	if left &lt; max {
		dfs(left+1, right, max, str+&quot;(&quot;)
	}
	if right &lt; left {
		dfs(left, right+1, max, str+&quot;)&quot;)
	}
}

#
/*
dp[i]表示n=i时括号的组合
dp[i]=&quot;(&quot; + dp[j] + &quot;)&quot;+dp[i-j-1] (j&lt;i)
dp[0] = &quot;&quot;
*/
func generateParenthesis(n int) []string {
	dp := make([][]string, n+1)
	dp[0] = make([]string, 0)
	if n == 0 {
		return dp[0]
	}
	dp[0] = append(dp[0], &quot;&quot;)
	for i := 1; i &lt;= n; i++ {
		dp[i] = make([]string, 0)
		for j := 0; j &lt; i; j++ {
			for _, a := range dp[j] {
				for _, b := range dp[i-j-1] {
					str := &quot;(&quot; + a + &quot;)&quot; + b
					dp[i] = append(dp[i], str)
				}
			}
		}
	}
	return dp[n]
}

#
type Node struct {
	str   string
	left  int
	right int
}

func generateParenthesis(n int) []string {
	res := make([]string, 0)
	if n == 0 {
		return res
	}
	queue := make([]*Node, 0)
	queue = append(queue, &amp;Node{
		str:   &quot;&quot;,
		left:  n,
		right: n,
	})
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		if node.left == 0 &amp;&amp; node.right == 0 {
			res = append(res, node.str)
		}
		if node.left &gt; 0 {
			queue = append(queue, &amp;Node{
				str:   node.str + &quot;(&quot;,
				left:  node.left - 1,
				right: node.right,
			})
		}
		if node.right &gt; 0 &amp;&amp; node.left &lt; node.right {
			queue = append(queue, &amp;Node{
				str:   node.str + &quot;)&quot;,
				left:  node.left,
				right: node.right - 1,
			})
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>24.两两交换链表中的节点(2)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例:给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func swapPairs(head *ListNode) *ListNode {
	temp := &amp;ListNode{Next: head}
	prev := temp
	for head != nil &amp;&amp; head.Next != nil {
		first, second := head, head.Next
		prev.Next = second
		first.Next, second.Next = second.Next, first
		prev, head = first, first.Next
	}
	return temp.Next
}

#
func swapPairs(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	first, second := head, head.Next
	first.Next, second.Next = swapPairs(second.Next), first
	return second
}
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>29.两数相除(2)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
整数除法的结果应当截去（truncate）其小数部分，
例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
示例 1:输入: dividend = 10, divisor = 3输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
示例 2:输入: dividend = 7, divisor = -3 输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2
提示：
    被除数和除数均为 32 位有符号整数。
    除数不为 0。
    假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。
    本题中，如果除法结果溢出，则返回 2^31 − 1。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>计算</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func divide(dividend int, divisor int) int {
	if divisor == 0 || dividend == 0 {
		return 0
	}
	if divisor == 1 {
		return dividend
	}
	flag, count := 1, 1
	if dividend &lt; 0 {
		flag = -flag
		dividend = -dividend
	}
	if divisor &lt; 0 {
		flag = -flag
		divisor = -divisor
	}
	a, b, c := dividend, divisor, 0
	temp := b
	for a-b &gt;= 0 {
		for a-b &gt;= 0 {
			a = a - b
			c = c + count
			b = b + b
			count = count + count
		}
		b = temp
		count = 1
	}
	if c &gt; math.MaxInt32 {
		return math.MaxInt32
	}
	if flag &lt; 0 {
		return -c
	}
	return c
}

#
func divide(dividend int, divisor int) int {
	res := dividend / divisor
	if res &gt; math.MaxInt32 {
		return math.MaxInt32
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>31.下一个排列(1)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nextPermutation</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
	<span class="k">for</span> <span class="nx">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">left</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">right</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">right</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
	<span class="c1">// sort.Ints(nums[left+1:])</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">count</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">count</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">count</span><span class="o">++</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>33.搜索旋转排序数组(2)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4
示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func search(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left &lt;= right {
		mid := left + (right-left)/2
		if nums[mid] == target {
			return mid
		}
		if nums[left] &lt;= nums[mid] {
			if nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] {
				right = mid - 1
			} else {
				left = mid + 1
			}
		} else {
			if nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}
	return -1
}

#
func search(nums []int, target int) int {
	for i := 0; i &lt; len(nums); i++{
		if nums[i] == target{
			return i
		}
	}
	return -1
}
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>34.在排序数组中查找元素的第一个和最后一个位置(4)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 [-1, -1]。
示例 1:输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4]
示例 2:输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func searchRange(nums []int, target int) []int {
	left := 0
	right := len(nums) - 1
	for left &lt;= right {
		if nums[left] != target {
			if target &gt; nums[left] {
				left++
			}
		}
		if nums[right] != target {
			if target &lt; nums[right] {
				right--
			}
		}
		if left &lt; len(nums) &amp;&amp; right &gt;= 0 &amp;&amp;
			nums[left] == nums[right] &amp;&amp; nums[left] == target {
			break
		}
	}
	if right &lt; left {
		return []int{-1, -1}
	}
	return []int{left, right}
}

#
func searchRange(nums []int, target int) []int {
	left := -1
	right := -1
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] == target {
			right = i
		} else if nums[i] &gt; target {
			break
		}
	}
	for i := len(nums) - 1; i &gt;= 0; i-- {
		if nums[i] == target {
			left = i
		} else if nums[i] &lt; target {
			break
		}
	}
	return []int{left, right}
}

# 3
func searchRange(nums []int, target int) []int {
	if len(nums) == 0 || nums[0] &gt; target || nums[len(nums)-1] &lt; target {
		return []int{-1, -1}
	}
	left := leftSearch(nums, target)
	right := rightSearch(nums, target)
	return []int{left, right}
}

func leftSearch(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left &lt;= right {
		mid := left + (right-left)/2
		if target &gt; nums[mid] {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	if left &lt; len(nums) &amp;&amp; nums[left] == target {
		return left
	}
	return -1
}

func rightSearch(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left &lt;= right {
		mid := left + (right-left)/2
		if target &lt; nums[mid] {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	if right &gt;= 0 &amp;&amp; nums[right] == target {
		return right
	}
	return -1
}

#
func searchRange(nums []int, target int) []int {
	left := -1
	right := -1
	for i, j := 0, len(nums)-1; i &lt;= j; {
		mid := i + (j-i)/2
		if nums[mid] &lt; target {
			i = mid + 1
		} else if nums[mid] &gt; target {
			j = mid - 1
		} else {
			for temp := mid; temp &gt;= 0; temp-- {
				if target == nums[temp] {
					left = temp
				} else {
					break
				}
			}
			for temp := mid; temp &lt; len(nums); temp++ {
				if target == nums[temp] {
					right = temp
				} else {
					break
				}
			}
			break
		}
	}
	return []int{left, right}
}
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>36.有效的数独(1)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
上图是一个部分填充的有效的数独。
数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。
示例 1:输入:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: true
示例 2:输入:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:
    一个有效的数独（部分已被填充）不一定是可解的。
    只需要根据以上规则，验证已经填入的数字是否有效即可。
    给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
    给定数独永远是 9x9 形式的。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">isValidSudoku</span><span class="p">(</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="mi">9</span><span class="p">]</span><span class="kt">int</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span> <span class="p">{</span>
				<span class="nx">num</span> <span class="o">:=</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;1&#39;</span>
				<span class="nx">index</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="nx">j</span><span class="o">/</span><span class="mi">3</span>
				<span class="k">if</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">num</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">col</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">num</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">][</span><span class="nx">num</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">false</span>
				<span class="p">}</span>
				<span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">num</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
				<span class="nx">col</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">num</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
				<span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">][</span><span class="nx">num</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>39.组合总和(2)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个无重复元素的数组 candidates 和一个目标数 target ，
找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
    所有数字（包括 target）都是正整数。
    解集不能包含重复的组合。 
示例 1:输入: candidates = [2,3,6,7], target = 7, 所求解集为:
[
  [7],
  [2,2,3]
]
示例 2:输入: candidates = [2,3,5], target = 8, 所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func combinationSum(candidates []int, target int) [][]int {
	res = make([][]int, 0)
	sort.Ints(candidates)
	dfs(candidates, target, []int{}, 0)
	return res
}

func dfs(candidates []int, target int, arr []int, index int) {
	if target == 0 {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	if target &lt; 0{
		return
	}
	for i := index; i &lt; len(candidates); i++ {
		arr = append(arr, candidates[i])
		dfs(candidates, target-candidates[i], arr, i)
		arr = arr[:len(arr)-1]
	}
}

#
var res [][]int

func combinationSum(candidates []int, target int) [][]int {
	res = make([][]int, 0)
	sort.Ints(candidates)
	dfs(candidates, target, []int{}, 0)
	return res
}

func dfs(candidates []int, target int, arr []int, index int) {
	if target == 0 {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := index; i &lt; len(candidates); i++ {
		if target &lt; candidates[i] {
			return
		}
		dfs(candidates, target-candidates[i], append(arr, candidates[i]), i)
	}
}
</pre></div>
</div>
</div>
<div class="section" id="ii-2">
<h2>40.组合总和II(2)<a class="headerlink" href="#ii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
说明：
    所有数字（包括目标数）都是正整数。
    解集不能包含重复的组合。 
示例 1:输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
示例 2:输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n!)</td>
<td>O(n!)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n!)</td>
<td>O(n!)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func combinationSum2(candidates []int, target int) [][]int {
	res = make([][]int, 0)
	sort.Ints(candidates)
	dfs(candidates, target, []int{}, 0)
	return res
}

func dfs(candidates []int, target int, arr []int, index int) {
	if target == 0 {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	if target &lt; 0 {
		return
	}
	for i := index; i &lt; len(candidates); i++ {
		origin := i
		for i &lt; len(candidates)-1 &amp;&amp; candidates[i] == candidates[i+1] {
			i++
		}
		arr = append(arr, candidates[i])
		dfs(candidates, target-candidates[i], arr, origin+1)
		arr = arr[:len(arr)-1]
	}
}

#
var res [][]int

func combinationSum2(candidates []int, target int) [][]int {
	res = make([][]int, 0)
	sort.Ints(candidates)
	dfs(candidates, target, []int{}, 0)
	return res
}

func dfs(candidates []int, target int, arr []int, index int) {
	if target == 0 {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := index; i &lt; len(candidates); i++ {
		if i != index &amp;&amp; candidates[i] == candidates[i-1] {
			continue
		}
		if target &lt; 0 {
			return
		}
		arr = append(arr, candidates[i])
		dfs(candidates, target-candidates[i], arr, i+1)
		arr = arr[:len(arr)-1]
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>43.字符串相乘(1)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，
它们的乘积也表示为字符串形式。
示例 1:输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;
示例 2:输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;
说明：
    num1 和 num2 的长度小于110。
    num1 和 num2 只包含数字 0-9。
    num1 和 num2 均不以零开头，除非是数字 0 本身。
    不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>模拟</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func multiply(num1 string, num2 string) string {
	if num1 == &quot;0&quot; || num2 == &quot;0&quot; {
		return &quot;0&quot;
	}
	arr := make([]int, len(num1)+len(num2))
	for i := len(num1) - 1; i &gt;= 0; i-- {
		a := int(num1[i] - &#39;0&#39;)
		for j := len(num2) - 1; j &gt;= 0; j-- {
			b := int(num2[j] - &#39;0&#39;)
			value := a*b + arr[i+j+1]
			arr[i+j+1] = value % 10
			arr[i+j] = value/10 + arr[i+j]
		}
	}
	res := &quot;&quot;
	for i := 0; i &lt; len(arr); i++ {
		if i == 0 &amp;&amp; arr[i] == 0 {
			continue
		}
		res = res + string(arr[i]+&#39;0&#39;)
	}
	return res
}

# 2
func multiply(num1 string, num2 string) string {
	a, b := new(big.Int), new(big.Int)
	a.SetString(num1, 10)
	b.SetString(num2, 10)
	a.Mul(a, b)
	return a.String()
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>46.全排列(3)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 没有重复 数字的序列，返回其所有可能的全排列。
示例:输入: [1,2,3]输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n*n!)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n!)</td>
<td>O(n*n!)</td>
</tr>
<tr>
<td>03</td>
<td>回溯</td>
<td>O(n!)</td>
<td>O(n*n!)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func permute(nums []int) [][]int {
	res = make([][]int, 0)
	arr := make([]int, 0)
	visited := make(map[int]bool)
	dfs(nums, 0, arr, visited)
	return res
}

func dfs(nums []int, index int, arr []int, visited map[int]bool) {
	if index == len(nums) {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := 0; i &lt; len(nums); i++ {
		if visited[i] == false {
			arr = append(arr, nums[i])
			visited[i] = true
			dfs(nums, index+1, arr, visited)
			arr = arr[:len(arr)-1]
			visited[i] = false
		}
	}
}

#
func permute(nums []int) [][]int {
	if len(nums) == 1 {
		return [][]int{nums}
	}
	res := make([][]int, 0)
	for i := 0; i &lt; len(nums); i++ {
		tempArr := make([]int, len(nums)-1)
		copy(tempArr[0:], nums[:i])
		copy(tempArr[i:], nums[i+1:])
		arr := permute(tempArr)
		for _, v := range arr {
			res = append(res, append(v, nums[i]))
		}
	}
	return res
}

#
var res [][]int

func permute(nums []int) [][]int {
	res = make([][]int, 0)
	arr := make([]int, len(nums))
	dfs(nums, 0, arr)
	return res
}

func dfs(nums []int, index int, arr []int) {
	if index == len(nums) {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := index; i &lt; len(nums); i++ {
		arr[index] = nums[i]
		nums[i], nums[index] = nums[index], nums[i]
		dfs(nums, index+1, arr)
		nums[i], nums[index] = nums[index], nums[i]
	}
}
</pre></div>
</div>
</div>
<div class="section" id="ii-3">
<h2>47.全排列II(3)<a class="headerlink" href="#ii-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个可包含重复数字的序列，返回所有不重复的全排列。
示例:输入: [1,1,2] 输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n!)</td>
<td>O(n!)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(n!)</td>
<td>O(n!)</td>
</tr>
<tr>
<td>03</td>
<td>回溯</td>
<td>O(n!)</td>
<td>O(n!)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func permuteUnique(nums []int) [][]int {
	res = make([][]int, 0)
	sort.Ints(nums)
	dfs(nums, 0, make([]int, len(nums)), make([]int, 0))
	return res
}

func dfs(nums []int, index int, visited []int, arr []int) {
	if len(nums) == index {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := 0; i &lt; len(nums); i++ {
		if visited[i] == 1 {
			continue
		}
		if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i-1] == 0{
			continue
		}
		arr = append(arr, nums[i])
		visited[i] = 1
		dfs(nums, index+1, visited, arr)
		visited[i] = 0
		arr = arr[:len(arr)-1]
	}
}

# 2
var res [][]int

func permuteUnique(nums []int) [][]int {
	res = make([][]int, 0)
	sort.Ints(nums)
	dfs(nums, 0)
	return res
}

func dfs(nums []int, index int) {
	if index == len(nums) {
		temp := make([]int, len(nums))
		copy(temp, nums)
		res = append(res, temp)
		return
	}
	m := make(map[int]int)
	for i := index; i &lt; len(nums); i++ {
		if _, ok := m[nums[i]]; ok {
			continue
		}
		m[nums[i]] = 1
		nums[i], nums[index] = nums[index], nums[i]
		dfs(nums, index+1)
		nums[i], nums[index] = nums[index], nums[i]
	}
}

# 3
var res [][]int

func permuteUnique(nums []int) [][]int {
	res = make([][]int, 0)
	sort.Ints(nums)
	dfs(nums, make([]int, 0))
	return res
}

func dfs(nums []int, arr []int) {
	if len(nums) == 0 {
		temp := make([]int, len(arr))
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := 0; i &lt; len(nums); i++ {
		if i != 0 &amp;&amp; nums[i] == nums[i-1] {
			continue
		}
		tempArr := make([]int, len(nums))
		copy(tempArr, nums)
		arr = append(arr, nums[i])
		dfs(append(tempArr[:i], tempArr[i+1:]...), arr)
		arr = arr[:len(arr)-1]
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>48.旋转图像(3)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
示例 1:给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 
原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数组辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rotate(matrix [][]int) {
	n := len(matrix)
	// 同行逆置
	// [[1 2 3] [4 5 6] [7 8 9]]
	// [[3 2 1] [6 5 4] [9 8 7]]
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; n/2; j++ {
			matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
		}
	}
	// 左下右上对角线对互换
	// [[3 2 1] [6 5 4] [9 8 7]]
	// [[7 4 1] [8 5 2] [9 6 3]]
	for i := 0; i &lt; n-1; i++ {
		for j := 0; j &lt; n-1-i; j++ {
			matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]
		}
	}
}

# 2
func rotate(matrix [][]int) {
	n := len(matrix)
	for start, end := 0, n-1; start &lt; end; {
		for s, e := start, end; s &lt; end; {
			matrix[start][s], matrix[e][start], matrix[end][e], matrix[s][end] =
				matrix[e][start], matrix[end][e], matrix[s][end], matrix[start][s]
			s++
			e--
		}
		start++
		end--
	}
}

# 3
func rotate(matrix [][]int) {
	n := len(matrix)
	arr := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]int, n)
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; n; j++ {
			arr[j][n-1-i] = matrix[i][j]
		}
	}
	copy(matrix, arr)
}
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>49.字母异位词分组(2)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
示例:输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
说明：
    所有输入均为小写字母。
    不考虑答案输出的顺序。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2log(n))</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func groupAnagrams(strs []string) [][]string {
	m := make(map[string]int)
	res := make([][]string, 0)
	for i := 0; i &lt; len(strs); i++ {
		arr := []byte(strs[i])
		sort.Slice(arr, func(i, j int) bool {
			return arr[i] &lt; arr[j]
		})
		newStr := string(arr)
		if _, ok := m[newStr]; ok {
			res[m[newStr]] = append(res[m[newStr]], strs[i])
		} else {
			m[newStr] = len(res)
			res = append(res, []string{strs[i]})
		}
	}
	return res
}

#
func groupAnagrams(strs []string) [][]string {
	m := make(map[[26]int]int)
	res := make([][]string, 0)
	for i := 0; i &lt; len(strs); i++ {
		arr := [26]int{}
		for j := 0; j &lt; len(strs[i]); j++{
			arr[strs[i][j]-&#39;a&#39;]++
		}
		if _, ok := m[arr]; ok {
			res[m[arr]] = append(res[m[arr]], strs[i])
		} else {
			m[arr] = len(res)
			res = append(res, []string{strs[i]})
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="pow-x-n-4">
<h2>50.Pow(x,n)(4)<a class="headerlink" href="#pow-x-n-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现 pow(x, n) ，即计算 x 的 n 次幂函数。
示例 1:输入: 2.00000, 10 输出: 1024.00000
示例 2:输入: 2.10000, 3 输出: 9.26100
示例 3:输入: 2.00000, -2 输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
说明:  -100.0 &lt; x &lt; 100.0
    n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>计算</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func myPow(x float64, n int) float64 {
	if n == 0 {
		return 1
	}
	if n &lt; 0 {
		return 1 / myPow(x, -n)
	}
	if n%2 == 1 {
		return x * myPow(x, n-1)
	}
	return myPow(x*x, n/2)
}

#
func myPow(x float64, n int) float64 {
	if n &lt; 0 {
		x = 1 / x
		n = -n
	}
	res := float64(1)
	for n &gt; 0 {
		if n%2 == 1 {
			res = res * x
		}
		x = x * x
		n = n / 2
	}
	return res
}

#
func myPow(x float64, n int) float64 {
	return math.Pow(x, float64(n))
}

#
func myPow(x float64, n int) float64 {
	if n == 0 {
		return 1
	}
	if n == 1 {
		return x
	}
	res := 1.0
	if n &gt; 0 {
		res = myPow(x, n/2)
		return res * res * myPow(x, n%2)
	} else {
		res = myPow(x, -n/2)
		res = res * res * myPow(x, -n%2)
		return 1 / res
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h2>54.螺旋矩阵(2)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
示例 1:输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
示例 2:输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res []int

func spiralOrder(matrix [][]int) []int {
	res = make([]int, 0)
	rows := len(matrix)
	if rows == 0 {
		return res
	}
	cols := len(matrix[0])
	if cols == 0 {
		return res
	}
	start := 0
	for cols &gt; start*2 &amp;&amp; rows &gt; start*2 {
		printCircle(matrix, cols, rows, start)
		start++
	}
	return res
}

func printCircle(matrix [][]int, cols, rows, start int) {
	x := cols - 1 - start
	y := rows - 1 - start
	// 左到右
	for i := start; i &lt;= x; i++ {
		res = append(res, matrix[start][i])
	}
	// 上到下
	if start &lt; y {
		for i := start + 1; i &lt;= y; i++ {
			res = append(res, matrix[i][x])
		}
	}
	// 右到左
	if start &lt; x &amp;&amp; start &lt; y {
		for i := x - 1; i &gt;= start; i-- {
			res = append(res, matrix[y][i])
		}
	}
	// 下到上
	if start &lt; x &amp;&amp; start &lt; y-1 {
		for i := y - 1; i &gt;= start+1; i-- {
			res = append(res, matrix[i][start])
		}
	}
}

#
func spiralOrder(matrix [][]int) []int {
	res := make([]int, 0)
	rows := len(matrix)
	if rows == 0 {
		return res
	}
	cols := len(matrix[0])
	if cols == 0 {
		return res
	}
	x1, x2, y1, y2 := 0, rows-1, 0, cols-1
	direct := 0
	for x1 &lt;= x2 &amp;&amp; y1 &lt;= y2 {
		direct = (direct + 4) % 4
		if direct == 0 {
			for i := y1; i &lt;= y2; i++ {
				res = append(res, matrix[x1][i])
			}
			x1++
		} else if direct == 1 {
			for i := x1; i &lt;= x2; i++ {
				res = append(res, matrix[i][y2])
			}
			y2--
		} else if direct == 2 {
			for i := y2; i &gt;= y1; i-- {
				res = append(res, matrix[x2][i])
			}
			x2--
		} else if direct == 3 {
			for i := x2; i &gt;= x1; i-- {
				res = append(res, matrix[i][y1])
			}
			y1++
		}
		direct++
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h2>55.跳跃游戏(4)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:输入: [2,3,1,1,4] 输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:输入: [3,2,1,0,4] 输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 
所以你永远不可能到达最后一个位置。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历-贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历-贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func canJump(nums []int) bool {
	j := len(nums) - 1
	for i := len(nums) - 2; i &gt;= 0; i-- {
		if nums[i]+i &gt;= j {
			j = i
		}
	}
	return j &lt;= 0
}

#
func canJump(nums []int) bool {
	if len(nums) &lt;= 1 {
		return true
	}
	dp := make([]bool, len(nums))
	dp[0] = true
	for i := 1; i &lt; len(nums); i++ {
		flag := false
		for j := 0; j &lt; i; j++ {
			if dp[j] &amp;&amp; nums[j]+j &gt;= i {
				flag = true
				break
			}
		}
		dp[i] = flag
	}
	return dp[len(nums)-1]
}

#
func canJump(nums []int) bool {
	max := 0
	for i := 0; i &lt; len(nums); i++ {
		if i &lt;= max {
			if i+nums[i] &gt; max {
				max = i + nums[i]
			}
			if max &gt;= len(nums)-1 {
				return true
			}
		}
	}
	return false
}

#
func canJump(nums []int) bool {
	zero := -1
	for i := len(nums) - 2; i &gt;= 0; i-- {
		if zero &gt; 0 {
			if i+nums[i] &gt; zero {
				zero = -1
			}
			continue
		}
		if nums[i] == 0 {
			zero = i
			continue
		}
	}
	return zero &lt; 0
}
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2>56.合并区间(2)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个区间的集合，请合并所有重叠的区间。
示例 1:输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:输入: [[1,4],[4,5]] 输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序-双指针</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func merge(intervals [][]int) [][]int {
	res := make([][]int, 0)
	if len(intervals) == 0 {
		return nil
	}
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] &lt; intervals[j][0]
	})
	res = append(res, intervals[0])
	for i := 1; i &lt; len(intervals); i++ {
		arr := res[len(res)-1]
		if intervals[i][0] &gt; arr[1] {
			res = append(res, intervals[i])
		} else if intervals[i][1] &gt; arr[1] {
			res[len(res)-1][1] = intervals[i][1]
		}
	}
	return res
}

#
func merge(intervals [][]int) [][]int {
	res := make([][]int, 0)
	if len(intervals) == 0 {
		return nil
	}
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] &lt; intervals[j][0]
	})
	for i := 0; i &lt; len(intervals); {
		end := intervals[i][1]
		j := i + 1
		for j &lt; len(intervals) &amp;&amp; intervals[j][0] &lt;= end {
			if intervals[j][1] &gt; end {
				end = intervals[j][1]
			}
			j++
		}
		res = append(res, []int{intervals[i][0], end})
		i = j
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>59.螺旋矩阵II(2)<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
示例:输入: 3 输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>遍历模拟</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func generateMatrix(n int) [][]int {
	res := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		res[i] = make([]int, n)
	}
	count := 1
	level := 1
	for count &lt;= n*n {
		top, bottom, left, right := level-1, n-level, level-1, n-level
		// 左到右
		for i := left; i &lt;= right &amp;&amp; left &lt;= right; i++ {
			res[top][i] = count
			count++
		}
		// 上到下
		for i := top + 1; i &lt;= bottom &amp;&amp; top &lt;= bottom; i++ {
			res[i][right] = count
			count++
		}
		// 右到左
		for i := right - 1; i &gt;= left &amp;&amp; left &lt;= right; i-- {
			res[bottom][i] = count
			count++
		}
		// 下到上
		for i := bottom - 1; i &gt;= top+1 &amp;&amp; top &lt;= bottom; i-- {
			res[i][left] = count
			count++
		}
		level++
	}
	return res
}

#
func generateMatrix(n int) [][]int {
	res := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		res[i] = make([]int, n)
	}
	count := 1
	top, bottom, left, right := 0, n-1, 0, n-1
	for count &lt;= n*n {
		for i := left; i &lt;= right; i++ {
			res[top][i] = count
			count++
		}
		top++
		for i := top; i &lt;= bottom; i++ {
			res[i][right] = count
			count++
		}
		right--
		for i := right; i &gt;= left; i-- {
			res[bottom][i] = count
			count++
		}
		bottom--
		for i := bottom; i &gt;= top; i-- {
			res[i][left] = count
			count++
		}
		left++
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="k-1">
<h2>60.第k个排列(1)<a class="headerlink" href="#k-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
    &quot;123&quot;
    &quot;132&quot;
    &quot;213&quot;
    &quot;231&quot;
    &quot;312&quot;
    &quot;321&quot;
给定 n 和 k，返回第 k 个排列。
说明：
    给定 n 的范围是 [1, 9]。
    给定 k 的范围是[1,  n!]。
示例 1:输入: n = 3, k = 3 输出: &quot;213&quot;
示例 2:输入: n = 4, k = 9 输出: &quot;2314&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历计算</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">getPermutation</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">,</span> <span class="s">&quot;6&quot;</span><span class="p">,</span> <span class="s">&quot;7&quot;</span><span class="p">,</span> <span class="s">&quot;8&quot;</span><span class="p">,</span> <span class="s">&quot;9&quot;</span><span class="p">}</span>
	<span class="nx">times</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">times</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">times</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">times</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">times</span><span class="p">,</span> <span class="nx">value</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">value</span> <span class="p">=</span> <span class="nx">value</span> <span class="o">*</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="nx">k</span><span class="o">--</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="nx">k</span> <span class="o">/</span> <span class="nx">times</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="nx">times</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">n</span><span class="o">--</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h2>61.旋转链表(2)<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
示例 1:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
示例 2:
输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>统计遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rotateRight(head *ListNode, k int) *ListNode {
	if head == nil || k == 0 {
		return head
	}
	temp := head
	count := 1
	for temp.Next != nil {
		temp = temp.Next
		count++
	}
	temp.Next = head
	k = k % count
	for i := 0; i &lt; count-k; i++ {
		temp = temp.Next
	}
	head, temp.Next = temp.Next, nil
	return head
}

#
func rotateRight(head *ListNode, k int) *ListNode {
	if head == nil || k == 0 {
		return head
	}
	temp := head
	count := 0
	arr := make([]*ListNode, 0)
	for temp != nil {
		arr = append(arr, temp)
		temp = temp.Next
		count++
	}
	k = k % count
	if k == 0 {
		return head
	}
	arr[count-1].Next = head
	temp = arr[count-1-k]
	head, temp.Next = temp.Next, nil
	return head
}
</pre></div>
</div>
</div>
<div class="section" id="id46">
<h2>62.不同路径(4)<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？
例如，上图是一个7 x 3 的网格。有多少可能的路径？
示例 1:输入: m = 3, n = 2 输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
示例 2:输入: m = 7, n = 3 输出: 28
提示：
    1 &lt;= m, n &lt;= 100
    题目数据保证答案小于等于 2 * 10 ^ 9
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>数学</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>// dp[i][j] = dp[i-1][j] + dp[i][j-1]
func uniquePaths(m int, n int) int {
	if m &lt;= 0 || n &lt;= 0 {
		return 0
	}
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
		dp[i][0] = 1
	}
	for i := 0; i &lt; m; i++ {
		dp[0][i] = 1
	}
	for i := 1; i &lt; n; i++ {
		for j := 1; j &lt; m; j++ {
			dp[i][j] = dp[i-1][j] + dp[i][j-1]
		}
	}
	return dp[n-1][m-1]
}

#
// dp[i]= dp[i-1] + dp[i]
func uniquePaths(m int, n int) int {
	if m &lt;= 0 || n &lt;= 0 {
		return 0
	}
	dp := make([]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = 1
	}
	for i := 1; i &lt; m; i++ {
		for j := 1; j &lt; n; j++ {
			dp[j] = dp[j] + dp[j-1]
		}
	}
	return dp[n-1]
}

# 3
func uniquePaths(m int, n int) int {
	if m == 1 || n == 1 {
		return 1
	}
	if m &gt; n {
		m, n = n, m
	}
	a := 1
	for i := 1; i &lt;= m-1; i++ {
		a = a * i
	}
	b := 1
	for i := n; i &lt;= m+n-2; i++ {
		b = b * i
	}
	return b / a
}

# 4
var arr [][]int

func uniquePaths(m int, n int) int {
	arr = make([][]int, n+1)
	for i := 0; i &lt;= n; i++ {
		arr[i] = make([]int, m+1)
	}
	return dfs(m, n)
}

func dfs(m, n int) int {
	if m &lt;= 0 || n &lt;= 0 {
		return 0
	}
	if m == 1 || n == 1 {
		return 1
	}
	if arr[n][m] &gt; 0 {
		return arr[n][m]
	}
	arr[n][m] = dfs(m, n-1) + dfs(m-1, n)
	return arr[n][m]
}
</pre></div>
</div>
</div>
<div class="section" id="id47">
<h2>63.不同路径II(3)<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
说明：m 和 n 的值均不超过 100。
示例 1:
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	n := len(obstacleGrid)
	if n &lt; 1 {
		return 0
	}
	m := len(obstacleGrid[0])
	if m &lt; 1 {
		return 0
	}
	if obstacleGrid[0][0] == 1 {
		return 0
	}
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
		for j := 0; j &lt; m; j++ {
			if i == 0 &amp;&amp; j == 0 {
				dp[i][j] = 1
			} else if i == 0 &amp;&amp; j != 0 {
				if obstacleGrid[i][j] == 0 {
					dp[i][j] = dp[i][j-1]
				}
			} else if i != 0 &amp;&amp; j == 0 {
				if obstacleGrid[i][j] == 0 {
					dp[i][j] = dp[i-1][j]
				}
			} else {
				if obstacleGrid[i][j] == 0 {
					dp[i][j] = dp[i-1][j] + dp[i][j-1]
				}
			}
		}
	}
	return dp[n-1][m-1]
}

# 2
// dp[j] = dp[j] + dp[j-1]
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	n := len(obstacleGrid)
	if n &lt; 1 {
		return 0
	}
	m := len(obstacleGrid[0])
	if m &lt; 1 {
		return 0
	}
	if obstacleGrid[0][0] == 1 {
		return 0
	}
	dp := make([]int, m)
	dp[0] = 1
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if obstacleGrid[i][j] == 1 {
				dp[j] = 0
				continue
			}
			if j &gt;= 1 &amp;&amp; obstacleGrid[i][j-1] == 0 {
				dp[j] = dp[j] + dp[j-1]
			}
		}
	}
	return dp[m-1]
}

# 3
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	n := len(obstacleGrid)
	if n &lt; 1 {
		return 0
	}
	m := len(obstacleGrid[0])
	if m &lt; 1 {
		return 0
	}
	if obstacleGrid[0][0] == 1 {
		return 0
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if obstacleGrid[i][j] == 1 {
				obstacleGrid[i][j] = 0
				continue
			}
			if i == 0 {
				if j == 0 {
					obstacleGrid[i][j] = 1
				} else {
					obstacleGrid[i][j] += obstacleGrid[i][j-1]
				}
			} else {
				if j == 0 {
					obstacleGrid[i][j] += obstacleGrid[i-1][j]
				} else {
					obstacleGrid[i][j] += obstacleGrid[i][j-1] + obstacleGrid[i-1][j]
				}
			}
		}
	}
	return obstacleGrid[n-1][m-1]
}
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h2>64.最小路径和(4)<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例:
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minPathSum(grid [][]int) int {
	n := len(grid)
	if n == 0 {
		return 0
	}
	m := len(grid[0])
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
	}
	dp[0][0] = grid[0][0]
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if i == 0 &amp;&amp; j != 0 {
				dp[i][j] = dp[i][j-1] + grid[i][j]
			} else if i != 0 &amp;&amp; j == 0 {
				dp[i][j] = dp[i-1][j] + grid[i][j]
			} else if i != 0 &amp;&amp; j != 0 {
				dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
			}
		}
	}
	return dp[n-1][m-1]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

#
func minPathSum(grid [][]int) int {
	n := len(grid)
	if n == 0 {
		return 0
	}
	m := len(grid[0])
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if i == 0 &amp;&amp; j != 0 {
				grid[i][j] = grid[i][j-1] + grid[i][j]
			} else if i != 0 &amp;&amp; j == 0 {
				grid[i][j] = grid[i-1][j] + grid[i][j]
			} else if i != 0 &amp;&amp; j != 0 {
				grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
			}
		}
	}
	return grid[n-1][m-1]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
func minPathSum(grid [][]int) int {
	n := len(grid)
	if n == 0 {
		return 0
	}
	m := len(grid[0])
	dp := make([]int, m)
	dp[0] = grid[0][0]

	for i := 1; i &lt; m; i++ {
		dp[i] = dp[i-1] + grid[0][i]
	}
	for i := 1; i &lt; n; i++ {
		dp[0] = dp[0] + grid[i][0]
		for j := 1; j &lt; m; j++ {
			dp[j] = min(dp[j-1], dp[j]) + grid[i][j]
		}
	}
	return dp[m-1]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 4
var arr [][]int

func minPathSum(grid [][]int) int {
	n := len(grid)
	if n == 0 {
		return 0
	}
	m := len(grid[0])
	arr = make([][]int, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]int, m)
	}
	return dfs(grid, n-1, m-1)
}

func dfs(grid [][]int, n, m int) int {
	if m == 0 &amp;&amp; n == 0 {
		arr[0][0] = grid[0][0]
		return grid[0][0]
	}
	if n == 0 {
		return grid[0][m] + dfs(grid, 0, m-1)
	}
	if m == 0 {
		return grid[n][0] + dfs(grid, n-1, 0)
	}
	if arr[n][m] &gt; 0 {
		return arr[n][m]
	}
	arr[n][m] = min(dfs(grid, n-1, m), dfs(grid, n, m-1)) + grid[n][m]
	return arr[n][m]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id49">
<h2>71.简化路径(2)<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。
在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；
此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。
更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径
请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。
最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。
示例 1：输入：&quot;/home/&quot; 输出：&quot;/home&quot;
解释：注意，最后一个目录名后面没有斜杠。
示例 2：输入：&quot;/../&quot; 输出：&quot;/&quot;
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
示例 3：输入：&quot;/home//foo/&quot; 输出：&quot;/home/foo&quot;
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
示例 4：输入：&quot;/a/./b/../../c/&quot; 输出：&quot;/c&quot;
示例 5：输入：&quot;/a/../../b/../c//.//&quot; 输出：&quot;/c&quot;
示例 6：输入：&quot;/a//b////c/d//././/..&quot; 输出：&quot;/a/b/c&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func simplifyPath(path string) string {
	stack := make([]string, 0)
	arr := strings.Split(path, &quot;/&quot;)
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == &quot;.&quot; || arr[i] == &quot;&quot; {
			continue
		}
		if arr[i] == &quot;..&quot; {
			if len(stack) &gt; 0 {
				stack = stack[:len(stack)-1]
			}
		} else {
			stack = append(stack, arr[i])
		}
	}
	return &quot;/&quot; + strings.Join(stack, &quot;/&quot;)
}

#
func simplifyPath(path string) string {
	return filepath.Clean(path)
}
</pre></div>
</div>
</div>
<div class="section" id="id50">
<h2>73.矩阵置零(4)<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。
示例 1:
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
示例 2:
输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
进阶:
    一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
    一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
    你能想出一个常数空间的解决方案吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^4)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func setZeroes(matrix [][]int) {
	x := make(map[int]int)
	y := make(map[int]int)
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == 0 {
				x[i] = 1
				y[j] = 1
			}
		}
	}
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if x[i] == 1 || y[j] == 1 {
				matrix[i][j] = 0
			}
		}
	}
}

#
func setZeroes(matrix [][]int) {
	m := make(map[[2]int]bool)
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == math.MinInt32 {
				m[[2]int{i, j}] = true
			}
		}
	}
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == 0 {
				for k := 0; k &lt; len(matrix); k++ {
					for l := 0; l &lt; len(matrix[k]); l++ {
						if (k == i || l == j) &amp;&amp; matrix[k][l] != 0 {
							delete(m, [2]int{k, l})
							matrix[k][l] = math.MinInt32
						}
					}
				}
			}
		}
	}
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == math.MinInt32 &amp;&amp; m[[2]int{i, j}] == false {
				matrix[i][j] = 0
			}
		}
	}
}

# 3
func setZeroes(matrix [][]int) {
	flag := false
	for i := 0; i &lt; len(matrix); i++ {
		if matrix[i][0] == 0 {
			flag = true
		}
		for j := 1; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == 0 {
				matrix[i][0] = 0
				matrix[0][j] = 0
			}
		}
	}
	for i := 1; i &lt; len(matrix); i++ {
		for j := 1; j &lt; len(matrix[i]); j++ {
			if matrix[i][0] == 0 || matrix[0][j] == 0 {
				matrix[i][j] = 0
			}
		}
	}
	// 第一行处理
	if matrix[0][0] == 0 {
		for j := 0; j &lt; len(matrix[0]); j++ {
			matrix[0][j] = 0
		}
	}
	// 第一列处理
	if flag == true {
		for i := 0; i &lt; len(matrix); i++ {
			matrix[i][0] = 0
		}
	}
}

# 4
func setZeroes(matrix [][]int) {
	flag := false
	for i := 0; i &lt; len(matrix); i++ {
		if matrix[i][0] == 0 {
			flag = true
		}
		for j := 1; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == 0 {
				matrix[i][0] = 0
				matrix[0][j] = 0
			}
		}
	}
	for i := len(matrix) - 1; i &gt;= 0; i-- {
		for j := len(matrix[i]) - 1; j &gt;= 1; j-- {
			if matrix[i][0] == 0 || matrix[0][j] == 0 {
				matrix[i][j] = 0
			}
		}
	}
	// 第一列处理
	if flag == true {
		for i := 0; i &lt; len(matrix); i++ {
			matrix[i][0] = 0
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h2>74.搜索二维矩阵(6)<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
    每行中的整数从左到右按升序排列。
    每行的第一个整数大于前一行的最后一个整数。
示例 1:输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true
示例 2:输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法-优化</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>左下角查找</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>右上角查找</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>06</td>
<td>内置函数</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == target {
				return true
			}
		}
	}
	return false
}

# 2
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		if matrix[i][0] &lt;= target &amp;&amp; matrix[i][len(matrix[i])-1] &gt;= target {
			for j := 0; j &lt; len(matrix[i]); j++ {
				if matrix[i][j] == target {
					return true
				}
			}
		}
	}
	return false
}

# 3
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		if matrix[i][0] &lt;= target &amp;&amp; matrix[i][len(matrix[i])-1] &gt;= target {
			res := binarySearch(matrix[i], target)
			if res == true {
				return true
			}
		}
	}
	return false
}

func binarySearch(arr []int, target int) bool {
	left := 0
	right := len(arr) - 1
	for left &lt;= right {
		mid := left + (right-left)/2
		if arr[mid] == target {
			return true
		} else if arr[mid] &gt; target {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return false
}

# 4
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	i := len(matrix) - 1
	j := 0
	for i &gt;= 0 &amp;&amp; j &lt; len(matrix[0]) {
		if matrix[i][j] == target {
			return true
		} else if matrix[i][j] &gt; target {
			i--
		} else {
			j++
		}
	}
	return false
}

# 5
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	i := 0
	j := len(matrix[0]) - 1
	for j &gt;= 0 &amp;&amp; i &lt; len(matrix) {
		if matrix[i][j] == target {
			return true
		} else if matrix[i][j] &gt; target {
			j--
		} else {
			i++
		}
	}
	return false
}

# 6
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		index := sort.SearchInts(matrix[i], target)
		if index &lt; len(matrix[i]) &amp;&amp; target == matrix[i][index] {
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id52">
<h2>75.颜色分类(3)<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，
使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意:
不能使用代码库中的排序函数来解决这道题。
示例:输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2]
进阶：
    一个直观的解决方案是使用计数排序的两趟扫描算法。
    首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
    你能想出一个仅使用常数空间的一趟扫描算法吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func sortColors(nums []int) {
	sort.Ints(nums)
}

# 2
func sortColors(nums []int) {
	left := 0
	right := len(nums) - 1
	for i := 0; i &lt;= right; i++ {
		if nums[i] == 0 {
			nums[left], nums[i] = nums[i], nums[left]
			left++
		} else if nums[i] == 2 {
			nums[right], nums[i] = nums[i], nums[right]
			right--
			i--
		}
	}
}

# 3
func sortColors(nums []int) {
	arr := make([]int, 3)
	for i := 0; i &lt; len(nums); i++ {
		arr[nums[i]]++
	}
	count := 0
	for i := 0; i &lt; len(arr); i++ {
		for j := 0; j &lt; arr[i]; j++ {
			nums[count] = i
			count++
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id53">
<h2>77.组合(4)<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
示例:输入: n = 4, k = 2 输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯-递归</td>
<td>O(kC(n,k))</td>
<td>O(C(n,k))</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(kC(n,k))</td>
<td>O(C(n,k))</td>
</tr>
<tr>
<td>03</td>
<td>回溯</td>
<td>O(kC(n,k))</td>
<td>O(C(n,k))</td>
</tr>
<tr>
<td>04</td>
<td>迭代</td>
<td>O(kC(n,k))</td>
<td>O(C(n,k))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func combine(n int, k int) [][]int {
	res = make([][]int, 0)
	nums := make([]int, 0)
	for i := 1; i &lt;= n; i++ {
		nums = append(nums, i)
	}
	dfs(nums, 0, k)
	return res
}

func dfs(nums []int, index, k int) {
	if index == k {
		temp := make([]int, k)
		copy(temp, nums[:k])
		res = append(res, temp)
		return
	}
	for i := index; i &lt; len(nums); i++ {
		if index == 0 || nums[i] &gt; nums[index-1] {
			nums[i], nums[index] = nums[index], nums[i]
			dfs(nums, index+1, k)
			nums[i], nums[index] = nums[index], nums[i]
		}
	}
}

# 2
var res [][]int

func combine(n int, k int) [][]int {
	res = make([][]int, 0)
	dfs(n, k, 1, make([]int, 0))
	return res
}

func dfs(n, k, index int, arr []int) {
	if len(arr) == k {
		temp := make([]int, k)
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := index; i &lt;= n; i++ {
		arr = append(arr, i)
		dfs(n, k, i+1, arr)
		arr = arr[:len(arr)-1]
	}
}

# 3
var res [][]int

func combine(n int, k int) [][]int {
	res = make([][]int, 0)
	nums := make([]int, 0)
	for i := 1; i &lt;= n; i++ {
		nums = append(nums, i)
	}
	dfs(nums, 0, k, make([]int, 0))
	return res
}

func dfs(nums []int, index, k int, arr []int) {
	if len(arr) == k {
		temp := make([]int, k)
		copy(temp, arr)
		res = append(res, temp)
		return
	}
	for i := index; i &lt; len(nums); i++ {
		arr = append(arr, nums[i])
		dfs(nums, i+1, k, arr)
		arr = arr[:len(arr)-1]
	}
}

# 4
func combine(n int, k int) [][]int {
	res := make([][]int, 0)
	arr := make([]int, 0)
	for i := 1; i &lt;= k; i++ {
		arr = append(arr, 0)
	}
	i := 0
	for i &gt;= 0 {
		arr[i]++
		if arr[i] &gt; n {
			i--
		} else if i == k-1 {
			temp := make([]int, k)
			copy(temp, arr)
			res = append(res, temp)
		} else {
			i++
			arr[i] = arr[i-1]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id54">
<h2>78.子集(3)<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:输入: nums = [1,2,3] 输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>03</td>
<td>位运算</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func subsets(nums []int) [][]int {
	res = make([][]int, 0)
	dfs(nums, make([]int, 0), 0)
	return res
}

func dfs(nums []int, arr []int, level int) {
	temp := make([]int, len(arr))
	copy(temp, arr)
	res = append(res, temp)
	for i := level; i &lt; len(nums); i++ {
		dfs(nums, append(arr, nums[i]), i+1)
	}
}

# 2
func subsets(nums []int) [][]int {
	res := make([][]int, 0)
	res = append(res, []int{})
	for i := 0; i &lt; len(nums); i++ {
		temp := make([][]int, len(res))
		for key, value := range res {
			value = append(value, nums[i])
			temp[key] = append(temp[key], value...)
		}
		for _, v := range temp {
			res = append(res, v)
		}
	}
	return res
}

# 3
func subsets(nums []int) [][]int {
	res := make([][]int, 0)
	n := len(nums)
	left := 1 &lt;&lt; n
	right := 1 &lt;&lt; (n + 1)
	for i := left; i &lt; right; i++ {
		temp := make([]int, 0)
		for j := 0; j &lt; n; j++ {
			if i&amp;(1&lt;&lt;j) != 0 {
				temp = append(temp, nums[j])
			}
		}
		res = append(res, temp)
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id55">
<h2>79.单词搜索(2)<a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二维网格和一个单词，找出该单词是否存在于网格中。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。
同一个单元格内的字母不允许被重复使用。
示例:board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]
给定 word = &quot;ABCCED&quot;, 返回 true
给定 word = &quot;SEE&quot;, 返回 true
给定 word = &quot;ABCB&quot;, 返回 false
提示：
    board 和 word 中只包含大写和小写英文字母。
    1 &lt;= board.length &lt;= 200
    1 &lt;= board[i].length &lt;= 200
    1 &lt;= word.length &lt;= 10^3
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索+回溯</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>深度优先搜索+回溯+数组辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func exist(board [][]byte, word string) bool {
	for i := 0; i &lt; len(board); i++ {
		for j := 0; j &lt; len(board[0]); j++ {
			if dfs(board, i, j, word, 0) {
				return true
			}
		}
	}
	return false
}

func dfs(board [][]byte, i, j int, word string, level int) bool {
	if i &lt; 0 || i &gt;= len(board) || j &lt; 0 || j &gt;= len(board[0]) ||
		board[i][j] != word[level] {
		return false
	}
	if level == len(word)-1 {
		return true
	}
	temp := board[i][j]
	board[i][j] = &#39; &#39;
	res := dfs(board, i+1, j, word, level+1) ||
		dfs(board, i-1, j, word, level+1) ||
		dfs(board, i, j+1, word, level+1) ||
		dfs(board, i, j-1, word, level+1)
	board[i][j] = temp
	return res
}

#
func exist(board [][]byte, word string) bool {
	visited := make([][]bool, len(board))
	for i := 0; i &lt; len(board); i++ {
		visited[i] = make([]bool, len(board[0]))
	}
	for i := 0; i &lt; len(board); i++ {
		for j := 0; j &lt; len(board[0]); j++ {
			if dfs(board, i, j, word, 0, visited) {
				return true
			}
		}
	}
	return false
}

func dfs(board [][]byte, i, j int, word string, level int, visited [][]bool) bool {
	res := false
	if i &gt;= 0 &amp;&amp; i &lt; len(board) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(board[0]) &amp;&amp;
		visited[i][j] == false &amp;&amp; board[i][j] == word[level] {
		if level == len(word)-1 {
			return true
		}
		visited[i][j] = true
		level = level + 1
		res = dfs(board, i+1, j, word, level, visited) ||
			dfs(board, i-1, j, word, level, visited) ||
			dfs(board, i, j+1, word, level, visited) ||
			dfs(board, i, j-1, word, level, visited)
		if !res {
			visited[i][j] = false
			level = level - 1
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id56">
<h2>80.删除排序数组中的重复项II(2)<a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:给定 nums = [1,1,1,2,2,3],
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。
你不需要考虑数组中超出新长度后面的元素。
示例 2:给定 nums = [0,0,1,1,1,1,2,3,3],
函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。
你不需要考虑数组中超出新长度后面的元素。
说明:为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	if len(nums) == 1 {
		return 1
	}
	n := 2
	i := n
	for j := n; j &lt; len(nums); j++ {
		if nums[i-n] != nums[j] {
			nums[i] = nums[j]
			i++
		}
	}
	return i
}

#
func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	prev := nums[0]
	count := 1
	j := 1
	for i := 1; i &lt; len(nums); i++ {
		if nums[i] == prev {
			count = count + 1
		} else {
			count = 1
			prev = nums[i]
		}
		if count &lt;= 2 {
			nums[j] = nums[i]
			j++
		}
	}
	return j
}
</pre></div>
</div>
</div>
<div class="section" id="id57">
<h2>81.搜索旋转排序数组II(2)<a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。
编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。
示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true
示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false
进阶:
    这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。
    这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func search(nums []int, target int) bool {
	for i := 0; i &lt; len(nums); i++ {
		if target == nums[i] {
			return true
		}
	}
	return false
}

#
func search(nums []int, target int) bool {
	left, right := 0, len(nums)-1
	for left &lt;= right {
		for left &lt; right &amp;&amp; nums[left] == nums[left+1] {
			left++
		}
		for left &lt; right &amp;&amp; nums[right] == nums[right-1] {
			right--
		}
		mid := left + (right-left)/2
		if nums[mid] == target {
			return true
		}
		if nums[left] &lt;= nums[mid] {
			if nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] {
				right = mid - 1
			} else {
				left = mid + 1
			}
		} else {
			if nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id58">
<h2>82.删除排序链表中的重复元素II(3)<a class="headerlink" href="#id58" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。
示例 1:输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 输出: 1-&gt;2-&gt;5
示例 2:输入: 1-&gt;1-&gt;1-&gt;2-&gt;3 输出: 2-&gt;3
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	temp := &amp;ListNode{Next: head}
	cur := temp
	value := 0
	for cur.Next != nil &amp;&amp; cur.Next.Next != nil {
		if cur.Next.Val == cur.Next.Next.Val {
			value = cur.Next.Val
			for cur.Next != nil &amp;&amp; cur.Next.Val == value {
				cur.Next = cur.Next.Next
			}
		} else {
			cur = cur.Next
		}
	}
	return temp.Next
}

#
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	flag := false
	for head.Next != nil &amp;&amp; head.Val == head.Next.Val{
		head = head.Next
		flag = true
	}
	head.Next = deleteDuplicates(head.Next)
	if flag{
		return head.Next
	}
	return head
}

#
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	flag := false
	for head.Next != nil &amp;&amp; head.Val == head.Next.Val{
		head = head.Next
		flag = true
	}
	head.Next = deleteDuplicates(head.Next)
	if flag{
		return head.Next
	}
	return head
}
</pre></div>
</div>
</div>
<div class="section" id="id59">
<h2>86.分隔链表(2)<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。
你应当保留两个分区中每个节点的初始相对位置。
示例:
输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func partition(head *ListNode, x int) *ListNode {
	first := &amp;ListNode{}
	second := &amp;ListNode{}
	a := first
	b := second
	for head != nil {
		if head.Val &lt; x {
			a.Next = head
			a = head
		} else {
			b.Next = head
			b = head
		}
		head = head.Next
	}
	b.Next = nil
	a.Next = second.Next
	return first.Next
}

#
func partition(head *ListNode, x int) *ListNode {
	a := make([]*ListNode, 0)
	b := make([]*ListNode, 0)

	for head != nil {
		if head.Val &lt; x {
			a = append(a, head)
		} else {
			b = append(b, head)
		}
		head = head.Next
	}
	temp := &amp;ListNode{}
	node := temp
	for i := 0; i &lt; len(a); i++ {
		node.Next = a[i]
		node = node.Next
	}
	for i := 0; i &lt; len(b); i++ {
		node.Next = b[i]
		node = node.Next
	}
	node.Next = nil
	return temp.Next
}
</pre></div>
</div>
</div>
<div class="section" id="id60">
<h2>89.格雷编码(3)<a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。
格雷编码序列必须以 0 开头。
示例 1:输入: 2 输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2
对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。
00 - 0
10 - 2
11 - 3
01 - 1
示例 2:输入: 0 输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历-推导</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
<tr>
<td>02</td>
<td>公式</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func grayCode(n int) []int {
	if n == 0 {
		return []int{0}
	}
	res := []int{0, 1}
	for i := 1; i &lt; n; i++ {
		temp := make([]int, 0)
		value := 1 &lt;&lt; i
		for j := len(res) - 1; j &gt;= 0; j-- {
			// 10 1 11
			// 10 0 10
			// 100 10 110
			// 100 11 111
			// 100 1 101
			// 100 0 100
			// fmt.Printf(&quot;%b %b %b\n&quot;, value, res[j], res[j]^value)

			// temp = append(temp, res[j]|value)
			// temp = append(temp, res[j]^value)
			temp = append(temp, res[j]+value)
		}
		res = append(res, temp...)
	}
	return res
}

# 2
func grayCode(n int) []int {
	total := 1 &lt;&lt; n
	res := make([]int, 0)
	for i := 0; i &lt; total; i++ {
		res = append(res, i^(i&gt;&gt;1))
	}
	return res
}

# 3
func grayCode(n int) []int {
	if n == 0 {
		return []int{0}
	}
	res := []int{0, 1}
	for i := 1; i &lt; n; i++ {
		value := 1 &lt;&lt; i
		for j := len(res) - 1; j &gt;= 0; j-- {
			res= append(res, res[j]+value)
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id61">
<h2>90.子集II(2)<a class="headerlink" href="#id61" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:输入: [1,2,2] 输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]int

func subsetsWithDup(nums []int) [][]int {
	sort.Ints(nums)
	res = make([][]int, 0)
	dfs(nums, make([]int, 0), 0)
	return res
}

func dfs(nums []int, arr []int, level int) {
	temp := make([]int, len(arr))
	copy(temp, arr)
	res = append(res, temp)
	for i := level; i &lt; len(nums); i++ {
		if i &gt; level &amp;&amp; nums[i] == nums[i-1] {
			continue
		}
		arr = append(arr, nums[i])
		dfs(nums, arr, i+1)
		arr = arr[:len(arr)-1]
	}
}

# 2
var res [][]int

func subsetsWithDup(nums []int) [][]int {
	sort.Ints(nums)
	res = make([][]int, 0)
	dfs(nums, make([]int, 0))
	return res
}

func dfs(nums []int, arr []int) {
	temp := make([]int, len(arr))
	copy(temp, arr)
	res = append(res, temp)
	for i := 0; i &lt; len(nums); i++ {
		if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {
			continue
		}
		arr = append(arr, nums[i])
		dfs(nums[i+1:], arr)
		arr = arr[:len(arr)-1]
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id62">
<h2>91.解码方法(3)<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一条包含字母 A-Z 的消息通过以下方式进行了编码：
&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。
示例 1:输入: &quot;12&quot; 输出: 2
解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。
示例 2:输入: &quot;226&quot; 输出: 3
解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numDecodings(s string) int {
	if s[0] == &#39;0&#39; {
		return 0
	}
	pre := 1
	cur := 1
	for i := 1; i &lt; len(s); i++ {
		temp := cur
		if s[i] == &#39;0&#39; {
			if s[i-1] == &#39;1&#39; || s[i-1] == &#39;2&#39; {
				cur = pre
			} else {
				return 0
			}
		} else if s[i-1] == &#39;1&#39; || 
			(s[i-1] == &#39;2&#39; &amp;&amp; s[i] &gt;= &#39;1&#39; &amp;&amp; s[i] &lt;= &#39;6&#39;) {
			cur = cur + pre
		}
		pre = temp
	}
	return cur
}

# 2
func numDecodings(s string) int {
	if s[0] == &#39;0&#39; {
		return 0
	}
	dp := make([]int, len(s)+1)
	dp[0] = 1
	for i := 0; i &lt; len(s); i++{
		if s[i] == &#39;0&#39; {
			if i == 0 || s[i-1] == &#39;1&#39; || s[i-1] == &#39;2&#39; {
				return 0
			}
			dp[i+1] = dp[i-1]
		} else{
			if  i &gt; 0 &amp;&amp; (s[i-1] == &#39;2&#39; &amp;&amp; s[i] &gt;= &#39;1&#39; &amp;&amp; s[i] &lt;= &#39;6&#39;) {
				dp[i+1] = dp[i-1]+dp[i]
			}else {
				dp[i+1] = dp[i]
			}
		}
	}
	return dp[len(s)]
}

# 3
var m map[string]int

func numDecodings(s string) int {
	m = make(map[string]int)
	return dfs(s)
}

func dfs(s string) int {
	if m[s] &gt; 0 {
		return m[s]
	}
	if len(s) == 0 {
		return 1
	}
	if s[0] == &#39;0&#39; {
		return 0
	}
	if len(s) == 1 {
		return 1
	}
	if (s[0]-&#39;0&#39;)*10+s[1]-&#39;0&#39; &gt; 26 {
		return dfs(s[1:])
	}
	m[s] = dfs(s[1:]) + dfs(s[2:])
	return m[s]
}
</pre></div>
</div>
</div>
<div class="section" id="id63">
<h2>92.反转链表II(2)<a class="headerlink" href="#id63" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
说明: 1 ≤ m ≤ n ≤ 链表长度。
示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func reverseBetween(head *ListNode, m int, n int) *ListNode {
	if m == n || head == nil {
		return head
	}
	temp := &amp;ListNode{Next: head}
	prev := temp
	for i := 1; i &lt; m; i++ {
		prev = prev.Next
	}
	head = prev.Next
	for i := m; i &lt; n; i++ {
		next := head.Next
		head.Next = next.Next
		next.Next = prev.Next
		prev.Next = next
	}
	return temp.Next
}

#
func reverseBetween(head *ListNode, m int, n int) *ListNode {
	if m == 1 {
		return reverseN(head, n)
	}
	head.Next = reverseBetween(head.Next, m-1, n-1)
	return head
}

var next *ListNode

func reverseN(head *ListNode, n int) *ListNode {
	if n == 1 {
		next = head.Next
		return head
	}
	prev := reverseN(head.Next, n-1)
	head.Next.Next = head
	head.Next = next
	return prev
}
</pre></div>
</div>
</div>
<div class="section" id="ip-2">
<h2>93.复原IP地址(2)<a class="headerlink" href="#ip-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 &#39;.&#39; 分隔。
示例:输入: &quot;25525511135&quot; 输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func dfs(s string, arr []string, level int) {
	if level == 4 {
		if len(s) == 0 {
			str := strings.Join(arr, &quot;.&quot;)
			res = append(res, str)
		}
		return
	}
	for i := 1; i &lt;= 3; i++ {
		if i &lt;= len(s) {
			value, _ := strconv.Atoi(s[:i])
			if value &lt;= 255 {
				str := s[i:]
				dfs(str, append(arr, s[:i]), level+1)
			}
			if value == 0 {
				// 避免出现001,01这种情况
				break
			}
		}
	}
}

#
func restoreIpAddresses(s string) []string {
	res := make([]string, 0)
	if len(s) &lt; 4 || len(s) &gt; 12 {
		return nil
	}
	for i := 1; i &lt;= 3 &amp;&amp; i &lt; len(s)-2; i++ {
		for j := i + 1; j &lt;= i+3 &amp;&amp; j &lt; len(s)-1; j++ {
			for k := j + 1; k &lt;= j+3 &amp;&amp; k &lt; len(s); k++ {
				if judge(s[:i]) &amp;&amp; judge(s[i:j]) &amp;&amp;
					judge(s[j:k]) &amp;&amp; judge(s[k:]) {
					res = append(res, s[:i]+&quot;.&quot;+s[i:j]+&quot;.&quot;+s[j:k]+&quot;.&quot;+s[k:])
				}
			}
		}
	}
	return res
}

func judge(s string) bool {
	if len(s) &gt; 1 &amp;&amp; s[0] == &#39;0&#39; {
		return false
	}
	value, _ := strconv.Atoi(s)
	if value &gt; 255 {
		return false
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id64">
<h2>94.二叉树的中序遍历(3)<a class="headerlink" href="#id64" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，返回它的中序 遍历。
示例:输入: [1,null,2,3]
   1
    \
     2
    /
   3
输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func inorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	left := inorderTraversal(root.Left)
	right := inorderTraversal(root.Right)
	res := left
	res = append(res, root.Val)
	res = append(res, right...)
	return res
}

# 2
func inorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	stack := make([]*TreeNode, 0)
	res := make([]int, 0)
	for len(stack) &gt; 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		last := len(stack) - 1
		res = append(res, stack[last].Val)
		root = stack[last].Right
		stack = stack[:last]
	}
	return res
}

# 3
var res []int

func inorderTraversal(root *TreeNode) []int {
	res = make([]int, 0)
	dfs(root)
	return res
}

func dfs(root *TreeNode) {
	if root != nil {
		dfs(root.Left)
		res = append(res, root.Val)
		dfs(root.Right)
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id65">
<h2>95.不同的二叉搜索树II(2)<a class="headerlink" href="#id65" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
示例：输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：以上的输出对应以下 5 种不同结构的二叉搜索树：
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
提示：
    0 &lt;= n &lt;= 8
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(C(2n,n)/(n+1))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(C(2n,n)/(n+1))</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func generateTrees(n int) []*TreeNode {
	if n == 0 {
		return nil
	}
	return dfs(1, n)
}

func dfs(left, right int) []*TreeNode {
	if left &gt; right {
		return []*TreeNode{nil}
	}
	if left == right {
		return []*TreeNode{
			&amp;TreeNode{Val: left},
		}
	}
	arr := make([]*TreeNode, 0)
	for i := left; i &lt;= right; i++ {
		leftTree := dfs(left, i-1)
		rightTree := dfs(i+1, right)
		for j := 0; j &lt; len(leftTree); j++ {
			for k := 0; k &lt; len(rightTree); k++ {
				node := &amp;TreeNode{Val: i}
				node.Left = leftTree[j]
				node.Right = rightTree[k]
				arr = append(arr, node)
			}
		}
	}
	return arr
}

# 2
func generateTrees(n int) []*TreeNode {
	if n == 0 {
		return nil
	}
	dp := make([][]*TreeNode, n+1)
	dp[1] = append(dp[1], &amp;TreeNode{Val: 1})
	for i := 2; i &lt;= n; i++ {
		for _, node := range dp[i-1]{
			root := &amp;TreeNode{Val:i}
			root.Left = node
			dp[i] = append(dp[i], copyTree(root))
			root = node
			temp := root
			newNode := &amp;TreeNode{Val:i}
			for temp != nil{
				newNode.Left = temp.Right
				temp.Right = newNode
				dp[i] = append(dp[i], copyTree(root))
				temp.Right = newNode.Left
				newNode.Left = nil
				temp = temp.Right
			}
		}
	}
	return dp[n]
}

func copyTree(node *TreeNode) *TreeNode {
	if node == nil {
		return nil
	}
	newNode := &amp;TreeNode{Val: node.Val}
	newNode.Left = copyTree(node.Left)
	newNode.Right = copyTree(node.Right)
	return newNode
}
</pre></div>
</div>
</div>
<div class="section" id="id66">
<h2>96.不同的二叉搜索树(3)<a class="headerlink" href="#id66" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
示例:输入: 3 输出: 5
解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>公式</td>
<td>)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>公式</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numTrees(n int) int {
	dp := make([]int, n+1)
	dp[0] =1
	dp[1] =1
	for i := 2; i &lt;= n;i++{
		for j := 1; j &lt;= i; j++{
			dp[i] = dp[i] + dp[j-1]*dp[i-j]
		}
	}
	return dp[n]
}

#
/*
C0 = 1
Cn+1 = 2(2n+1)/(n+2) * Cn
*/
func numTrees(n int) int {
	c := 1
	for i := 1; i &lt; n;i++{
		c = c * 2 * (2*i+1)/(i+2)
	}
	return c
}

#
func numTrees(n int) int {
	c := 1
	for i := 1; i &lt;= n;i++{
		c = c * (n+i)/i
	}
	return c/(n+1)
}
</pre></div>
</div>
</div>
<div class="section" id="id67">
<h2>98.验证二叉搜索树(5)<a class="headerlink" href="#id67" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
    节点的左子树只包含小于当前节点的数。
    节点的右子树只包含大于当前节点的数。
    所有左子树和右子树自身必须也是二叉搜索树。
示例 1:输入:
    2
   / \
  1   3
输出: true
示例 2:输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>05</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isValidBST(root *TreeNode) bool {
	return dfs(root, math.MinInt64, math.MaxInt64)
}

func dfs(root *TreeNode, left, right int) bool {
	if root == nil {
		return true
	}
	if left &gt;= root.Val || right &lt;= root.Val {
		return false
	}
	return dfs(root.Left, left, root.Val) &amp;&amp; dfs(root.Right, root.Val, right)
}

# 2
var res []int

func isValidBST(root *TreeNode) bool {
	res = make([]int, 0)
	dfs(root)
	for i := 0; i &lt; len(res)-1; i++ {
		if res[i] &gt;= res[i+1] {
			return false
		}
	}
	return true
}

func dfs(root *TreeNode) {
	if root != nil {
		dfs(root.Left)
		res = append(res, root.Val)
		dfs(root.Right)
	}
}

# 3
func isValidBST(root *TreeNode) bool {
	if root == nil {
		return true
	}
	stack := make([]*TreeNode, 0)
	res := make([]int, 0)
	for len(stack) &gt; 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		last := len(stack) - 1
		res = append(res, stack[last].Val)
		root = stack[last].Right
		stack = stack[:last]
	}
	for i := 0; i &lt; len(res)-1; i++ {
		if res[i] &gt;= res[i+1] {
			return false
		}
	}
	return true
}

# 4
func isValidBST(root *TreeNode) bool {
	if root == nil {
		return true
	}
	stack := make([]*TreeNode, 0)
	pre := math.MinInt64
	for len(stack) &gt; 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		last := len(stack) - 1
		if stack[last].Val &lt;= pre {
			return false
		}
		pre = stack[last].Val
		root = stack[last].Right
		stack = stack[:last]
	}
	return true
}

# 5
var pre int

func isValidBST(root *TreeNode) bool {
	pre = math.MinInt64
	return dfs(root)
}

func dfs(root *TreeNode) bool {
	if root == nil {
		return true
	}
	if dfs(root.Left) == false {
		return false
	}
	if root.Val &lt;= pre {
		return false
	}
	pre = root.Val
	return dfs(root.Right)
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>0001-1000-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="id68">
<h2>4.寻找两个正序数组的中位数(4)<a class="headerlink" href="#id68" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:nums1 = [1, 3] nums2 = [2]
则中位数是 2.0
示例 2:nums1 = [1, 2] nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	nums1 = append(nums1, nums2...)
	sort.Ints(nums1)
	if len(nums1)%2 == 1 {
		return float64(nums1[len(nums1)/2])
	}
	return float64(nums1[len(nums1)/2]+nums1[len(nums1)/2-1]) / 2
}

# 2
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	total := len(nums1) + len(nums2)
	if total%2 == 1 {
		mid := total / 2
		return float64(getKth(nums1, nums2, mid+1))
	}
	mid1, mid2 := total/2-1, total/2
	return float64(getKth(nums1, nums2, mid1+1)+getKth(nums1, nums2, mid2+1)) / 2.0
}

func getKth(nums1 []int, nums2 []int, k int) int {
	a, b := 0, 0
	for {
		if a == len(nums1) {
			return nums2[b+k-1]
		}
		if b == len(nums2) {
			return nums1[a+k-1]
		}
		if k == 1 {
			return min(nums1[a], nums2[b])
		}
		mid := k / 2
		newA := min(a+mid, len(nums1)) - 1
		newB := min(b+mid, len(nums2)) - 1
		valueA, valueB := nums1[newA], nums2[newB]
		if valueA &lt; valueB {
			k = k - (newA - a + 1)
			a = newA + 1
		} else {
			k = k - (newB - b + 1)
			b = newB + 1
		}
	}
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	total := len(nums1) + len(nums2)
	a, b := total/2, (total-1)/2
	count := 0
	res := 0
	for i, j := 0, 0; i &lt; len(nums1) || j &lt; len(nums2); count++ {
		if i &lt; len(nums1) &amp;&amp; (j == len(nums2) || nums1[i] &lt; nums2[j]) {
			if count == a {
				res = res + nums1[i]
			}
			if count == b {
				res = res + nums1[i]
			}
			i++
		} else {
			if count == a {
				res = res + nums2[j]
			}
			if count == b {
				res = res + nums2[j]
			}
			j++
		}
	}
	return float64(res) / 2
}

# 4
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	n, m := len(nums1), len(nums2)
	if n &gt; m {
		return findMedianSortedArrays(nums2, nums1)
	}
	left, right := 0, n
	a, b := 0, 0
	for left &lt;= right {
		// 左半部分最大的值小于等于右半部分最小的值: max(A[i-1],B[j-1])) &lt;= min(A[i],B[j]))
		i := left + (right-left)/2 // i,j分别对num1,num2的划分
		j := (n+m+1)/2 - i         // i+j == (n+m+1)/2
		// 偶数求a=&gt;max(A[i-1],B[j-1])) b=&gt;min(A[i],B[j]))
		// 奇数求a=&gt;max(A[i-1],B[j-1]))
		if j != 0 &amp;&amp; i != n &amp;&amp; nums1[i] &lt; nums2[j-1] {
			left = i + 1
		} else if i != 0 &amp;&amp; j != m &amp;&amp; nums1[i-1] &gt; nums2[j] {
			right = i - 1
		} else {
			if i == 0 {
				a = nums2[j-1]
			} else if j == 0 {
				a = nums1[i-1]
			} else {
				a = max(nums1[i-1], nums2[j-1])
			}
			if (n+m)%2 == 1 {
				return float64(a)
			}
			if i == n {
				b = nums2[j]
			} else if j == m {
				b = nums1[i]
			} else {
				b = min(nums1[i], nums2[j])
			}
			return float64(a+b) / 2.0
		}
	}
	return 0.0
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id69">
<h2>10.正则表达式匹配(3)<a class="headerlink" href="#id69" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。
&#39;.&#39; 匹配任意单个字符
&#39;*&#39; 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
说明:
    s 可能为空，且只包含从 a-z 的小写字母。
    p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:输入:s = &quot;aa&quot; p = &quot;a&quot; 输出: false
解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。
示例 2:输入: s = &quot;aa&quot; p = &quot;a*&quot; 输出: true
解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。
因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。
示例 3:输入: s = &quot;ab&quot; p = &quot;.*&quot; 输出: true
解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。
示例 4:输入:s = &quot;aab&quot;p = &quot;c*a*b&quot; 输出: true
解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。
示例 5:输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot; 输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isMatch(s string, p string) bool {
	return dfs(s, p, 0, 0)
}

func dfs(s string, p string, i, j int) bool {
	if i &gt;= len(s) &amp;&amp; j &gt;= len(p) {
		return true
	}
	if i &lt;= len(s) &amp;&amp; j &gt;= len(p) {
		return false
	}
	if j+1 &lt; len(p) &amp;&amp; p[j+1] == &#39;*&#39; {
		if (i &lt; len(s) &amp;&amp; p[j] == s[i]) || (p[j] == &#39;.&#39; &amp;&amp; i &lt; len(s)) {
			return dfs(s, p, i+1, j+2) ||
				dfs(s, p, i+1, j) ||
				dfs(s, p, i, j+2)
		} else {
			return dfs(s, p, i, j+2)
		}
	}
	if (i &lt; len(s) &amp;&amp; s[i] == p[j]) || (p[j] == &#39;.&#39; &amp;&amp; i &lt; len(s)) {
		return dfs(s, p, i+1, j+1)
	}
	return false
}

# 2
func isMatch(s string, p string) bool {
	// dp[i][j]表示p[:i]能否正则匹配s[:j]
	dp := make([][]bool, len(p)+1)
	for i := 0; i &lt; len(p)+1; i++ {
		dp[i] = make([]bool, len(s)+1)
	}
	// 1.初始化
	dp[0][0] = true
	for i := 2; i &lt; len(p)+1; i++ {
		if i%2 == 0 &amp;&amp; p[i-1] == &#39;*&#39; {
			dp[i][0] = dp[i-2][0]
		}
	}
	// 2.dp状态转移
	for i := 1; i &lt; len(p)+1; i++ {
		for j := 1; j &lt; len(s)+1; j++ {
			// 2.1 相同或者 .
			if p[i-1] == s[j-1] || p[i-1] == &#39;.&#39; {
				dp[i][j] = dp[i-1][j-1]
			} else if p[i-1] == &#39;*&#39; {
				if i &gt; 1 {
					if p[i-2] == s[j-1] || p[i-2] == &#39;.&#39; {
						dp[i][j] = dp[i][j-1] || dp[i-2][j-1] || dp[i-2][j]
					} else {
						dp[i][j] = dp[i-2][j]
					}
				}
			}
		}
	}
	return dp[len(p)][len(s)]
}

# 3
func isMatch(s string, p string) bool {
	if len(s) == 0 &amp;&amp; len(p) == 0 {
		return true
	} else if len(p) == 0 {
		return false
	}
	match := false
	// 正常匹配条件=&gt;相等，或者 p[0]等于.就不用管s[0]
	if len(s) &gt; 0 &amp;&amp; (s[0] == p[0] || p[0] == &#39;.&#39;) {
		match = true
	}
	// 匹配多个 就把 s 往后移1位，注意p不移动
	// 匹配0个 就把 p 往后移2位，相当于p的*当前作废
	if len(p) &gt; 1 &amp;&amp; p[1] == &#39;*&#39; {
		return (match &amp;&amp; isMatch(s[1:], p)) || isMatch(s, p[2:])
	}
	// 匹配当前成功，同时往后移
	return match &amp;&amp; isMatch(s[1:], p[1:])
}
</pre></div>
</div>
</div>
<div class="section" id="k-4">
<h2>23.合并K个排序链表(4)<a class="headerlink" href="#k-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
示例:输入:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>顺序合并</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>归并(分治)合并</td>
<td>O(nlog(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>03</td>
<td>堆辅助</td>
<td>O(nlog(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>04</td>
<td>自定义排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func mergeKLists(lists []*ListNode) *ListNode {
	if len(lists) == 0 {
		return nil
	}
	temp := &amp;ListNode{}
	for i := 0; i &lt; len(lists); i++ {
		temp.Next = mergeTwoLists(temp.Next, lists[i])
	}
	return temp.Next
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	res := &amp;ListNode{}
	temp := res
	for l1 != nil &amp;&amp; l2 != nil {
		if l1.Val &lt; l2.Val {
			temp.Next = l1
			l1 = l1.Next
		} else {
			temp.Next = l2
			l2 = l2.Next
		}
		temp = temp.Next
	}
	if l1 != nil {
		temp.Next = l1
	} else {
		temp.Next = l2
	}
	return res.Next
}

# 2
func mergeKLists(lists []*ListNode) *ListNode {
	if len(lists) == 0 {
		return nil
	}
	if len(lists) == 1 {
		return lists[0]
	}
	first := mergeKLists(lists[:len(lists)/2])
	second := mergeKLists(lists[len(lists)/2:])
	return mergeTwoLists(first, second)
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	res := &amp;ListNode{}
	temp := res
	for l1 != nil &amp;&amp; l2 != nil {
		if l1.Val &lt; l2.Val {
			temp.Next = l1
			l1 = l1.Next
		} else {
			temp.Next = l2
			l2 = l2.Next
		}
		temp = temp.Next
	}
	if l1 != nil {
		temp.Next = l1
	} else {
		temp.Next = l2
	}
	return res.Next
}

# 3
func mergeKLists(lists []*ListNode) *ListNode {
	if len(lists) == 0 {
		return nil
	}
	var h IntHeap
	heap.Init(&amp;h)
	for i := 0; i &lt; len(lists); i++ {
		if lists[i] != nil {
			heap.Push(&amp;h, lists[i])
		}
	}
	res := &amp;ListNode{}
	temp := res
	for h.Len() &gt; 0 {
		minItem := heap.Pop(&amp;h).(*ListNode)
		temp.Next = minItem
		temp = temp.Next
		if minItem.Next != nil {
			heap.Push(&amp;h, minItem.Next)
		}
	}
	return res.Next
}

type IntHeap []*ListNode

func (h IntHeap) Len() int            { return len(h) }
func (h IntHeap) Less(i, j int) bool  { return h[i].Val &lt; h[j].Val }
func (h IntHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) }
func (h *IntHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

# 4
func mergeKLists(lists []*ListNode) *ListNode {
	if len(lists) == 0 {
		return nil
	}
	arr := make([]*ListNode, 0)
	for i := 0; i &lt; len(lists); i++ {
		temp := lists[i]
		for temp != nil {
			arr = append(arr, temp)
			temp = temp.Next
		}
	}
	if len(arr) == 0 {
		return nil
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i].Val &lt; arr[j].Val
	})
	for i := 0; i &lt; len(arr)-1; i++ {
		arr[i].Next = arr[i+1]
	}
	arr[len(arr)-1].Next = nil
	return arr[0]
}
</pre></div>
</div>
</div>
<div class="section" id="id70">
<h2>25.K个一组翻转链表(4)<a class="headerlink" href="#id70" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例：
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5
说明：
    你的算法只能使用常数的额外空间。
    你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func reverseKGroup(head *ListNode, k int) *ListNode {
	length := getLength(head)
	if length &lt; k || k &lt;= 1 {
		return head
	}
	pre := &amp;ListNode{}
	cur := head
	for i := 0; i &lt; k; i++ {
		temp := cur
		cur = cur.Next
		temp.Next = pre
		pre = temp
	}
	head.Next = reverseKGroup(cur, k)
	return pre
}

func getLength(head *ListNode) int {
	if head == nil {
		return 0
	}
	temp := head
	res := 0
	for temp != nil {
		res++
		temp = temp.Next
	}
	return res
}

# 2
func reverseKGroup(head *ListNode, k int) *ListNode {
	res := 0
	temp := head
	for temp != nil {
		res++
		temp = temp.Next
	}
	if res &lt; k || k &lt;= 1 {
		return head
	}
	pre := &amp;ListNode{}
	cur := head
	for i := 0; i &lt; k; i++ {
		next := cur.Next
		cur.Next = pre
		pre = cur
		cur = next
	}
	head.Next = reverseKGroup(cur, k)
	return pre
}

# 3
func reverseKGroup(head *ListNode, k int) *ListNode {
	res := &amp;ListNode{Next: head}
	prev := res
	for head != nil {
		tail := prev
		for i := 0; i &lt; k; i++ {
			tail = tail.Next
			if tail == nil {
				return res.Next
			}
		}
		next := tail.Next
		head, tail = reverse(head, tail)
		prev.Next = head
		tail.Next = next
		prev = tail
		head = tail.Next
	}
	return res.Next
}

func reverse(head, tail *ListNode) (*ListNode, *ListNode) {
	prev := tail.Next
	temp := head
	for prev != tail {
		next := temp.Next
		temp.Next = prev
		prev = temp
		temp = next
	}
	return tail, head
}

# 4
func reverseKGroup(head *ListNode, k int) *ListNode {
	res := &amp;ListNode{Next: head}
	prev, end := res, res
	for end.Next != nil {
		for i := 0; i &lt; k &amp;&amp; end != nil; i++ {
			end = end.Next
		}
		if end == nil {
			break
		}
		start := prev.Next         // 开始的位置
		next := end.Next           // 结束的下一个位置
		end.Next = nil             // 断开尾部连接
		prev.Next = reverse(start) // 反转后接到prev.Next
		start.Next = next          // start的指针指向下一个开头（此时start已经是反转的最后一个节点）
		prev = start               // 已经处理后的最后一个节点
		end = prev                 // end也移动到prev
	}
	return res.Next
}

func reverse(head *ListNode) *ListNode {
	var result *ListNode
	for head != nil {
		temp := head.Next
		head.Next = result
		result = head
		head = temp
	}
	return result
}
</pre></div>
</div>
</div>
<div class="section" id="id71">
<h2>30.串联所有单词的子串(2)<a class="headerlink" href="#id71" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串 s 和一些长度相同的单词 words。
找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
示例 1：输入：s = &quot;barfoothefoobarman&quot;,words = [&quot;foo&quot;,&quot;bar&quot;] 输出：[0,9]
解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。
输出的顺序不重要, [9,0] 也是有效答案。
示例 2：输入：s = &quot;wordgoodgoodgoodbestword&quot;,words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>滑动窗口</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findSubstring(s string, words []string) []int {
	res := make([]int, 0)
	length,n := len(s),len(words)
	if length == 0 || n == 0 || len(words[0]) == 0 {
		return res
	}
	single := len(words[0])
	m := make(map[string]int)
	for i := 0; i &lt; len(words); i++ {
		m[words[i]]++
	}
	for i := 0; i &lt;= length-n*single; i++ {
		temp := make(map[string]int)
		for j := 0; j &lt; n; j++ {
			l := i + j*single
			str := s[l : l+single]
			if _, ok := m[str]; !ok {
				break
			}
			temp[str]++
			if temp[str] &gt; m[str] {
				break
			}
			if compare(m, temp) == true {
				res = append(res, i)
				break
			}
		}
	}
	return res
}

func compare(m1, m2 map[string]int) bool {
	if len(m1) != len(m2) {
		return false
	}
	for k, v := range m1 {
		if m2[k] != v {
			return false
		}
	}
	return true
}

# 2
func findSubstring(s string, words []string) []int {
	res := make([]int, 0)
	length := len(s)
	n := len(words)
	if length == 0 || n == 0 || len(words[0]) == 0 {
		return res
	}
	single := len(words[0])
	m := make(map[string]int)
	for i := 0; i &lt; len(words); i++ {
		m[words[i]]++
	}
	for i := 0; i &lt; single; i++ {
		left, right, count := i, i, 0
		temp := make(map[string]int)
		for right+single &lt;= length {
			str := s[right : right+single]
			right = right + single
			if m[str] &gt; 0 {
				temp[str]++
				if temp[str] == m[str] {
					count++
				}
			}
			if right-left == n*single {
				if count == len(m) {
					res = append(res, left)
				}
				leftStr := s[left : left+single]
				left = left + single
				if m[leftStr] &gt; 0 {
					if temp[leftStr] == m[leftStr] {
						count--
					}
					temp[leftStr]--
				}
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id72">
<h2>32.最长有效括号(4)<a class="headerlink" href="#id72" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。
示例 1:输入: &quot;(()&quot;输出: 2
解释: 最长有效括号子串为 &quot;()&quot;
示例 2:输入: &quot;)()())&quot; 输出: 4
解释: 最长有效括号子串为 &quot;()()&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestValidParentheses(s string) int {
	res := 0
	stack := make([]int, 0)
	stack = append(stack, -1)
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;(&#39; {
			stack = append(stack, i)
		} else {
			stack = stack[:len(stack)-1] // 弹出栈顶元素表示匹配了当前右括号
			if len(stack) == 0 {         // 没有匹配到左括号，存入最后一个没有被匹配到的右括号下标
				stack = append(stack, i)
			} else {
				res = max(res, i-stack[len(stack)-1])
			}
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func longestValidParentheses(s string) int {
	res := 0
	dp := make([]int, len(s))
	for i := 1; i &lt; len(s); i++ {
		if s[i] == &#39;)&#39; {
			// &#39;()&#39; 匹配到
			if s[i-1] == &#39;(&#39; {
				if i &lt; 2 {
					dp[i] = 2
				} else {
					dp[i] = dp[i-2] + 2
				}
			} else {
				// &#39;))&#39;情况
				if i-dp[i-1] &gt; 0 &amp;&amp; s[i-dp[i-1]-1] == &#39;(&#39; {
					if i-dp[i-1] &lt; 2 {
						dp[i] = dp[i-1] + 2
					} else {
						dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
					}
				}
			}
		}
		res = max(res, dp[i])
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func longestValidParentheses(s string) int {
	res := 0
	left, right := 0, 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;(&#39; {
			left++
		} else {
			right++
		}
		if left == right {
			res = max(res, 2*left)
		} else if right &gt; left {
			left, right = 0, 0
		}
	}
	left, right = 0, 0
	for i := len(s) - 1; i &gt;= 0; i-- {
		if s[i] == &#39;(&#39; {
			left++
		} else {
			right++
		}
		if left == right {
			res = max(res, 2*left)
		} else if left &gt; right {
			left, right = 0, 0
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 4
func longestValidParentheses(s string) int {
	res := 0
	for i := 0; i &lt; len(s); i++ {
		count := 0
		for j := i; j &lt; len(s); j++ {
			if s[j] == &#39;(&#39; {
				count++
			} else {
				count--
			}
			if count &lt; 0 {
				break
			}
			if count == 0 {
				res = max(res, j+1-i)
			}
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id73">
<h2>37.解数独(2)<a class="headerlink" href="#id73" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个程序，通过已填充的空格来解决数独问题。
一个数独的解法需遵循如下规则：
    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
空白格用 &#39;.&#39; 表示。
一个数独。
答案被标成红色。
Note:给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
    你可以假设给定的数独只有唯一解。
    给定数独永远是 9x9 形式的。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O((9!)^9)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O((9!)^9)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var rows, cols, arrs [9][9]int

func solveSudoku(board [][]byte) {
	rows = [9][9]int{}
	cols = [9][9]int{}
	arrs = [9][9]int{}
	for i := 0; i &lt; 9; i++ {
		for j := 0; j &lt; 9; j++ {
			if board[i][j] != &#39;.&#39; {
				num := board[i][j] - &#39;1&#39;
				index := (i/3)*3 + j/3
				rows[i][num] = 1
				cols[j][num] = 1
				arrs[index][num] = 1
			}
		}
	}
	dfs(board, 0)
}

func dfs(board [][]byte, index int) bool {
	if index == 81 {
		return true
	}
	row := index / 9
	col := index % 9
	c := (row/3)*3 + col/3
	if board[row][col] != &#39;.&#39; {
		return dfs(board, index+1)
	}
	for i := 0; i &lt; 9; i++ {
		if rows[row][i] == 1 || cols[col][i] == 1 || arrs[c][i] == 1 {
			continue
		}
		board[row][col] = byte(i + &#39;1&#39;)
		rows[row][i], cols[col][i], arrs[c][i] = 1, 1, 1
		if dfs(board, index+1) == true {
			return true
		}
		rows[row][i], cols[col][i], arrs[c][i] = 0, 0, 0
		board[row][col] = &#39;.&#39;
	}
	return false
}

# 2
func solveSudoku(board [][]byte) {
	dfs(board, 0)
}

func dfs(board [][]byte, index int) bool {
	if index == 81 {
		return true
	}
	row := index / 9
	col := index % 9
	if board[row][col] != &#39;.&#39; {
		return dfs(board, index+1)
	}
	for i := 0; i &lt; 9; i++ {
		board[row][col] = byte(i + &#39;1&#39;)
		if isValidSudoku(board) == false {
			board[row][col] = &#39;.&#39;
			continue
		}
		if dfs(board, index+1) == true {
			return true
		}
		board[row][col] = &#39;.&#39;
	}
	return false
}

func isValidSudoku(board [][]byte) bool {
	var row, col, arr [9][9]int
	for i := 0; i &lt; 9; i++ {
		for j := 0; j &lt; 9; j++ {
			if board[i][j] != &#39;.&#39; {
				num := board[i][j] - &#39;1&#39;
				index := (i/3)*3 + j/3
				if row[i][num] == 1 || col[j][num] == 1 || arr[index][num] == 1 {
					return false
				}
				row[i][num] = 1
				col[j][num] = 1
				arr[index][num] = 1
			}
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id74">
<h2>41.缺失的第一个正数(5)<a class="headerlink" href="#id74" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
示例 1:输入: [1,2,0] 输出: 3
示例 2:输入: [3,4,-1,1]输出: 2
示例 3:输入: [7,8,9,11,12]输出: 1
提示：你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>标负</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>置换</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>桶</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func firstMissingPositive(nums []int) int {
	n := len(nums)
	for i := 0; i &lt; n; i++ {
		// 非正数处理
		if nums[i] &lt;= 0 {
			nums[i] = n + 1
		}
	}
	for i := 0; i &lt; n; i++ {
		value := abs(nums[i])
		// 标负
		if value &lt;= n {
			nums[value-1] = -abs(abs(nums[value-1]))
		}
	}
	for i := 0; i &lt; n; i++ {
		if nums[i] &gt; 0 {
			return i + 1
		}
	}
	return n + 1
}

func abs(a int) int {
	if a &gt;= 0 {
		return a
	}
	return -a
}

# 2
func firstMissingPositive(nums []int) int {
	n := len(nums)
	for i := 0; i &lt; n; i++ {
		for nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]-1] != nums[i] {
			nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]
		}
	}
	for i := 0; i &lt; n; i++ {
		if nums[i] != i+1 {
			return i + 1
		}
	}
	return n + 1
}

# 3
func firstMissingPositive(nums []int) int {
	n := len(nums)
	m := make(map[int]int)
	for i := 0; i &lt; n; i++ {
		m[nums[i]] = 1
	}
	for i := 1; i &lt;= n; i++ {
		if m[i] == 0 {
			return i
		}
	}
	return n + 1
}

# 4
func firstMissingPositive(nums []int) int {
	n := len(nums)
	for i := 1; i &lt;= n; i++ {
		flag := false
		for j := 0; j &lt; n; j++ {
			if i == nums[j] {
				flag = true
				break
			}
		}
		if flag == false {
			return i
		}
	}
	return n + 1
}

# 5
func firstMissingPositive(nums []int) int {
	n := len(nums)
	arr := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		if 1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n {
			arr[nums[i]] = 1
		}
	}
	for i := 1; i &lt;= n; i++ {
		if arr[i] == 0 {
			return i
		}
	}
	return n + 1
}
</pre></div>
</div>
</div>
<div class="section" id="id75">
<h2>42.接雨水(4)<a class="headerlink" href="#id75" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，
在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
示例:输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func trap(height []int) int {
	res := 0
	for i := 0; i &lt; len(height); i++ {
		left, right := 0, 0
		for j := i; j &gt;= 0; j-- {
			left = max(left, height[j])
		}
		for j := i; j &lt; len(height); j++ {
			right = max(right, height[j])
		}
		// 当前坐标形成的面积=(min(左边最高，右边最高)-当前高度) * 宽度(1,可省略)
		area := min(left, right) - height[i]
		res = res + area
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func trap(height []int) int {
	res := 0
	if len(height) == 0{
		return 0
	}
	left := make([]int, len(height))
	right := make([]int, len(height))
	left[0] = height[0]
	right[len(right)-1] = height[len(height)-1]
	for i := 1; i &lt; len(height); i++ {
		left[i] = max(height[i], left[i-1])
	}
	for i := len(height) - 2; i &gt;= 0; i-- {
		right[i] = max(height[i], right[i+1])
	}
	for i := 0; i &lt; len(height); i++ {
		// 当前坐标形成的面积=(min(左边最高，右边最高)-当前高度) * 宽度(1,可省略)
		area := min(left[i], right[i]) - height[i]
		res = res + area
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
func trap(height []int) int {
	res := 0
	stack := make([]int, 0)
	for i := 0; i &lt; len(height); i++ {
		for len(stack) &gt; 0 &amp;&amp; height[i] &gt; height[stack[len(stack)-1]] {
			bottom := height[stack[len(stack)-1]]
			stack = stack[:len(stack)-1]
			if len(stack) &gt; 0 {
				prev := stack[len(stack)-1]
				// 横着的面积=长(min(height[i], height[prev])-bottom)*宽(i-prev-1)
				h := min(height[i], height[prev]) - bottom
				w := i - prev - 1
				area := h * w
				res = res + area
			}
		}
		stack = append(stack, i)
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 4
func trap(height []int) int {
	res := 0
	if len(height) == 0 {
		return 0
	}
	left := 0
	right := len(height) - 1
	leftMax := 0  // 左边的最大值
	rightMax := 0 // 右边的最大值
	for left &lt; right {
		// 当前坐标形成的面积=(min(左边最高，右边最高)-当前高度) * 宽度(1,可省略)
		// 选择高度低的一边处理并求最大值, 说明当前侧最大值小于另一侧
		if height[left] &lt; height[right] {
			// 也可以写成这样
			// leftMax = max(leftMax, height[left])
			// res = res + leftMax - height[left]
			if height[left] &gt;= leftMax { // 递增无法蓄水
				leftMax = height[left]
			} else {
				res = res + leftMax - height[left]
			}
			left++
		} else {
			// 也可以写成这样
			// rightMax = max(rightMax, height[right])
			// res = res + rightMax - height[right]
			if height[right] &gt;= rightMax { // 递减无法蓄水
				rightMax = height[right]
			} else {
				res = res + rightMax - height[right]
			}
			right--
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id76">
<h2>44.通配符匹配(3)<a class="headerlink" href="#id76" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。
&#39;?&#39; 可以匹配任何单个字符。
&#39;*&#39; 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
说明:s 可能为空，且只包含从 a-z 的小写字母。
    p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
示例 1: 输入:s = &quot;aa&quot; p = &quot;a&quot; 输出: false
解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。
示例 2: 输入: s = &quot;aa&quot; p = &quot;*&quot; 输出: true
解释: &#39;*&#39; 可以匹配任意字符串。
示例 3:输入: s = &quot;cb&quot; p = &quot;?a&quot; 输出: false
解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。
示例 4:输入:s = &quot;adceb&quot; p = &quot;*a*b&quot; 输出: true
解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.
示例 5:输入:s = &quot;acdcb&quot; p = &quot;a*c?b&quot; 输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>贪心</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isMatch(s string, p string) bool {
	n, m := len(s), len(p)
	dp := make([][]bool, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]bool, m+1)
	}
	dp[0][0] = true
	for i := 1; i &lt;= m; i++ {
		if p[i-1] == &#39;*&#39; { // 可以匹配任意字符串（包括空字符串）
			dp[0][i] = true
		} else {
			break
		}
	}
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= m; j++ {
			if p[j-1] == &#39;*&#39; {
				// dp[i][j-1]=&gt;不使用这个*，dp[i-1][j]=&gt;使用这个*
				dp[i][j] = dp[i][j-1] || dp[i-1][j]
			} else if p[j-1] == &#39;?&#39; || s[i-1] == p[j-1] {
				dp[i][j] = dp[i-1][j-1]
			}
		}
	}
	return dp[n][m]
}

# 2
var dp [][]int

func isMatch(s string, p string) bool {
	n, m := len(s), len(p)
	dp = make([][]int, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]int, m+1)
	}
	return dfs(s, p, 0, 0)
}

func dfs(s, p string, i, j int) bool {
	if i == len(s) &amp;&amp; j == len(p) {
		return true
	}
	if dp[i][j] &gt; 0 {
		if dp[i][j] == 1 {
			return false
		} else {
			return true
		}
	}
	if i &gt;= len(s) {
		return p[j] == &#39;*&#39; &amp;&amp; dfs(s, p, i, j+1)
	}
	if j &gt;= len(p) {
		return false
	}
	res := false
	if p[j] == &#39;*&#39; {
		res = dfs(s, p, i+1, j) || dfs(s, p, i, j+1)
	} else {
		res = (s[i] == p[j] || p[j] == &#39;?&#39;) &amp;&amp; dfs(s, p, i+1, j+1)
	}
	if res == true {
		dp[i][j] = 2
	} else {
		dp[i][j] = 1
	}
	return res
}

# 3
func isMatch(s string, p string) bool {
	i, j := 0, 0
	start, last := 0, 0
	for i = 0; i &lt; len(s); {
		if j &lt; len(p) &amp;&amp; (s[i] == p[j] || p[j] == &#39;?&#39;) {
			i++
			j++
		} else if j &lt; len(p) &amp;&amp; p[j] == &#39;*&#39; {
			last = i  // 记录s的位置
            j++
			start = j // 记录*的位置
		} else if start != 0 {
			last++
			i = last // 更新到记录位置的下一个
			j = start
		} else {
			return false
		}
	}
	for ; j &lt; len(p) &amp;&amp; p[j] == &#39;*&#39;; j++ {
	}
	return j == len(p)
}
</pre></div>
</div>
</div>
<div class="section" id="ii-4">
<h2>45.跳跃游戏II(4)<a class="headerlink" href="#ii-4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
示例:输入: [2,3,1,1,4] 输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
说明:假设你总是可以到达数组的最后一个位置。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>迭代</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func jump(nums []int) int {
	last := len(nums) - 1
	res := 0
	for last &gt; 0 {
		// 从前往后，找到第一个一步能走到终点的，更新终点的位置
		for i := 0; i &lt; last; i++ {
			if i+nums[i] &gt;= last {
				last = i
				res++
				break
			}
		}
	}
	return res
}

# 2
func jump(nums []int) int {
	res := 0
	end := 0
	maxValue := 0
	for i := 0; i &lt; len(nums)-1; i++ {
		maxValue = max(maxValue, i+nums[i])
		if i == end {
			end = maxValue
			res++
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func jump(nums []int) int {
	dp := make([]int, len(nums))
	dp[0] = 0
	for i := 1; i &lt; len(nums); i++ {
		dp[i] = i
		for j := 0; j &lt; i; j++ {
			if nums[j]+j &gt;= i {
				dp[i] = min(dp[i], dp[j]+1)
			}
		}
	}
	return dp[len(nums)-1]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 4
func jump(nums []int) int {
	if len(nums) &lt;= 1 {
		return 0
	}
	dp := make([]int, len(nums))
	for i := 1; i &lt; len(nums); i++ {
		dp[i] = math.MaxInt32
	}
	dp[0] = 0
	for i := 0; i &lt; len(nums)-1; i++ {
		if i+nums[i] &gt;= len(nums)-1 {
			return dp[i] + 1
		}
		for j := i + 1; j &lt;= i+nums[i]; j++ {
			if j &lt; len(nums) {
				dp[j] = min(dp[j], dp[i]+1)
			} else {
				break
			}
		}
	}
	return dp[len(nums)-1]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 4
func jump(nums []int) int {
	if len(nums) &lt;= 1 {
		return 0
	}
	arr := make([]int, len(nums))
	for i := 1; i &lt; len(nums); i++ {
		arr[i] = math.MaxInt32
	}
	arr[0] = 0
	for i := 0; i &lt; len(nums)-1; i++ {
		if i+nums[i] &gt;= len(nums)-1 {
			return arr[i] + 1
		}
		for j := i + 1; j &lt;= i+nums[i]; j++ {
			if j &lt; len(nums) {
				arr[j] = min(arr[j], arr[i]+1)
			} else {
				break
			}
		}
	}
	return arr[len(nums)-1]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id77">
<h2>51.N皇后(3)<a class="headerlink" href="#id77" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
上图为 8 皇后问题的一种解法。
给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。
示例:
输入: 4
输出: [
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
解释: 4皇后问题存在两个不同的解法。
提示：
    皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。
    当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res [][]string

func solveNQueens(n int) [][]string {
	res = make([][]string, 0)
	// 初始化棋盘
	arr := make([][]string, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]string, n)
		for j := 0; j &lt; n; j++ {
			arr[i][j] = &quot;.&quot;
		}
	}
	// 从第1行开始,上层是满足条件
	dfs(arr, 0)
	return res
}

func dfs(arr [][]string, row int) {
	if len(arr) == row {
		temp := make([]string, 0)
		for i := 0; i &lt; len(arr); i++ {
			str := &quot;&quot;
			for j := 0; j &lt; len(arr[i]); j++ {
				str = str + arr[i][j]
			}
			temp = append(temp, str)
		}
		res = append(res, temp)
		return
	}
	// 每列尝试
	for col := 0; col &lt; len(arr[0]); col++ {
		if valid(arr, row, col) == false {
			continue
		}
		arr[row][col] = &quot;Q&quot;
		dfs(arr, row+1)
		arr[row][col] = &quot;.&quot;
	}
}

func valid(arr [][]string, row, col int) bool {
	n := len(arr)
	// 当前列判断(竖着)
	for row := 0; row &lt; n; row++ {
		if arr[row][col] == &quot;Q&quot; {
			return false
		}
	}
	// 左上角
	for row, col := row-1, col-1; row &gt;= 0 &amp;&amp; col &gt;= 0; row, col = row-1, col-1 {
		if arr[row][col] == &quot;Q&quot; {
			return false
		}
	}
	// 右上角
	for row, col := row-1, col+1; row &gt;= 0 &amp;&amp; col &lt; n; row, col = row-1, col+1 {
		if arr[row][col] == &quot;Q&quot; {
			return false
		}
	}
	return true
}

# 2
var res [][]string
var rows, left, right []bool

func solveNQueens(n int) [][]string {
	res = make([][]string, 0)
	rows, left, right = make([]bool, n), make([]bool, 2*n-1), make([]bool, 2*n-1)
	// 初始化棋盘
	arr := make([][]string, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]string, n)
		for j := 0; j &lt; n; j++ {
			arr[i][j] = &quot;.&quot;
		}
	}
	// 从第1行开始,上层是满足条件
	dfs(arr, 0)
	return res
}

func dfs(arr [][]string, row int) {
	n := len(arr)
	if len(arr) == row {
		temp := make([]string, 0)
		for i := 0; i &lt; n; i++ {
			str := &quot;&quot;
			for j := 0; j &lt; n; j++ {
				str = str + arr[i][j]
			}
			temp = append(temp, str)
		}
		res = append(res, temp)
		return
	}
	// 每列尝试
	for col := 0; col &lt; n; col++ {
		if rows[col] == true || left[row-col+n-1] == true || right[row+col] == true {
			continue
		}
		rows[col], left[row-col+n-1], right[row+col] = true, true, true
		arr[row][col] = &quot;Q&quot;
		dfs(arr, row+1)
		arr[row][col] = &quot;.&quot;
		rows[col], left[row-col+n-1], right[row+col] = false, false, false
	}
}

# 3
var res [][]string

func solveNQueens(n int) [][]string {
	res = make([][]string, 0)
	// 初始化棋盘
	arr := make([][]string, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]string, n)
		for j := 0; j &lt; n; j++ {
			arr[i][j] = &quot;.&quot;
		}
	}
	// 从第1行开始,上层是满足条件
	dfs(arr, 0, 0, 0, 0)
	return res
}

func dfs(arr [][]string, row int, rows, left, right int) {
	n := len(arr)
	if len(arr) == row {
		temp := make([]string, 0)
		for i := 0; i &lt; n; i++ {
			str := &quot;&quot;
			for j := 0; j &lt; n; j++ {
				str = str + arr[i][j]
			}
			temp = append(temp, str)
		}
		res = append(res, temp)
		return
	}
	// 每列尝试
	for col := 0; col &lt; n; col++ {
		a := uint(col)
		b := uint(row - col + n - 1)
		c := uint(row + col)
		if ((rows&gt;&gt;a)&amp;1) != 0 || ((left&gt;&gt;b)&amp;1) != 0 || ((right&gt;&gt;c)&amp;1) != 0 {
			continue
		}
		arr[row][col] = &quot;Q&quot;
		dfs(arr, row+1, rows^(1&lt;&lt;a), left^(1&lt;&lt;b), right^(1&lt;&lt;c))
		arr[row][col] = &quot;.&quot;
	}
}
</pre></div>
</div>
</div>
<div class="section" id="nii-3">
<h2>52.N皇后II(3)<a class="headerlink" href="#nii-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
上图为 8 皇后问题的一种解法。
给定一个整数 n，返回 n 皇后不同的解决方案的数量。
示例:输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。
[
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
提示：皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。
    当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(n^n)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>回溯-位运算</td>
<td>O(n^n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res int
var rows, left, right []bool

func totalNQueens(n int) int {
	res = 0
	rows, left, right = make([]bool, n), make([]bool, 2*n-1), make([]bool, 2*n-1)
	// 初始化棋盘
	arr := make([][]string, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]string, n)
		for j := 0; j &lt; n; j++ {
			arr[i][j] = &quot;.&quot;
		}
	}
	// 从第1行开始,上层是满足条件
	dfs(arr, 0)
	return res
}

func dfs(arr [][]string, row int) {
	n := len(arr)
	if len(arr) == row {
		res++
		return
	}
	// 每列尝试
	for col := 0; col &lt; n; col++ {
		if rows[col] == true || left[row-col+n-1] == true || right[row+col] == true {
			continue
		}
		rows[col], left[row-col+n-1], right[row+col] = true, true, true
		arr[row][col] = &quot;Q&quot;
		dfs(arr, row+1)
		arr[row][col] = &quot;.&quot;
		rows[col], left[row-col+n-1], right[row+col] = false, false, false
	}
}

# 2
var res int

func totalNQueens(n int) int {
	res = 0
	// 初始化棋盘
	arr := make([][]string, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]string, n)
		for j := 0; j &lt; n; j++ {
			arr[i][j] = &quot;.&quot;
		}
	}
	// 从第1行开始,上层是满足条件
	dfs(arr, 0)
	return res
}

func dfs(arr [][]string, row int) {
	if len(arr) == row {
		res++
		return
	}
	// 每列尝试
	for col := 0; col &lt; len(arr[0]); col++ {
		if valid(arr, row, col) == false {
			continue
		}
		arr[row][col] = &quot;Q&quot;
		dfs(arr, row+1)
		arr[row][col] = &quot;.&quot;
	}
}

func valid(arr [][]string, row, col int) bool {
	n := len(arr)
	// 当前列判断(竖着)
	for row := 0; row &lt; n; row++ {
		if arr[row][col] == &quot;Q&quot; {
			return false
		}
	}
	// 左上角
	for row, col := row-1, col-1; row &gt;= 0 &amp;&amp; col &gt;= 0; row, col = row-1, col-1 {
		if arr[row][col] == &quot;Q&quot; {
			return false
		}
	}
	// 右上角
	for row, col := row-1, col+1; row &gt;= 0 &amp;&amp; col &lt; n; row, col = row-1, col+1 {
		if arr[row][col] == &quot;Q&quot; {
			return false
		}
	}
	return true
}

# 3
var res int

func totalNQueens(n int) int {
	res = 0
	// 从第1行开始,上层是满足条件
	dfs(0, n, 0, 0, 0)
	return res
}

func dfs(row, n int, rows, left, right int) {
	if n == row {
		res++
		return
	}
	// 每列尝试
	for col := 0; col &lt; n; col++ {
		a := uint(col)
		b := uint(row - col + n - 1)
		c := uint(row + col)
		if ((rows&gt;&gt;a)&amp;1) != 0 || ((left&gt;&gt;b)&amp;1) != 0 || ((right&gt;&gt;c)&amp;1) != 0 {
			continue
		}
		dfs(row+1, n, rows^(1&lt;&lt;a), left^(1&lt;&lt;b), right^(1&lt;&lt;c))
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id78">
<h2>57.插入区间(3)<a class="headerlink" href="#id78" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]]
示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
注意：输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func insert(intervals [][]int, newInterval []int) [][]int {
	res := make([][]int, 0)
	if len(intervals) == 0 {
		res = append(res, newInterval)
		return res
	}
	i := 0
	for ; i &lt; len(intervals) &amp;&amp; intervals[i][1] &lt; newInterval[0]; i++ {
		res = append(res, intervals[i])
	}
	for ; i &lt; len(intervals) &amp;&amp; intervals[i][0] &lt;= newInterval[1]; i++ {
		newInterval[0] = min(newInterval[0], intervals[i][0])
		newInterval[1] = max(newInterval[1], intervals[i][1])
	}
	res = append(res, newInterval)
	for ; i &lt; len(intervals); i++ {
		res = append(res, intervals[i])
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func insert(intervals [][]int, newInterval []int) [][]int {
	if len(intervals) == 0 {
		return [][]int{newInterval}
	}
	i := 0
	for ; i &lt; len(intervals) &amp;&amp; intervals[i][1] &lt; newInterval[0]; i++ {
	}
	left := i
	i = len(intervals) - 1
	for ; i &gt;= 0 &amp;&amp; intervals[i][0] &gt; newInterval[1]; i-- {
	}
	right := i
	if left &gt; right {
		return append(intervals[:left], append([][]int{newInterval}, intervals[left:]...)...)
	}
	newInterval[0] = min(newInterval[0], intervals[left][0])
	newInterval[1] = max(newInterval[1], intervals[right][1])
	return append(intervals[:left], append([][]int{newInterval}, intervals[right+1:]...)...)
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func insert(intervals [][]int, newInterval []int) [][]int {
	res := make([][]int, 0)
	intervals = append(intervals, newInterval)
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] &lt; intervals[j][0]
	})
	res = append(res, intervals[0])
	for i := 1; i &lt; len(intervals); i++ {
		arr := res[len(res)-1]
		if intervals[i][0] &gt; arr[1] {
			res = append(res, intervals[i])
		} else if intervals[i][1] &gt; arr[1] {
			res[len(res)-1][1] = intervals[i][1]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id79">
<h2>65.有效数字(1)<a class="headerlink" href="#id79" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>验证给定的字符串是否可以解释为十进制数字。
例如:
&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
&quot; -90e3   &quot; =&gt; true
&quot; 1e&quot; =&gt; false
&quot;e3&quot; =&gt; false
&quot; 6e-1&quot; =&gt; true
&quot; 99e2.5 &quot; =&gt; false
&quot;53.5e93&quot; =&gt; true
&quot; --6 &quot; =&gt; false
&quot;-+3&quot; =&gt; false
&quot;95a54e53&quot; =&gt; false
说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。
这里给出一份可能存在于有效十进制数字中的字符列表：
    数字 0-9
    指数 - &quot;e&quot;
    正/负号 - &quot;+&quot;/&quot;-&quot;
    小数点 - &quot;.&quot;
当然，在输入中，这些字符的上下文也很重要。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Trim</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">numeric</span> <span class="o">:=</span> <span class="nx">scanInteger</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">numeric</span> <span class="p">=</span> <span class="nx">scanUnsignedInteger</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span> <span class="o">||</span> <span class="nx">numeric</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">numeric</span> <span class="p">=</span> <span class="nx">numeric</span> <span class="o">&amp;&amp;</span> <span class="nx">scanInteger</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">numeric</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">==</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">scanInteger</span><span class="p">(</span><span class="nx">arr</span> <span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">index</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="nx">index</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">arr</span><span class="p">)[</span><span class="o">*</span><span class="nx">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="nx">arr</span><span class="p">)[</span><span class="o">*</span><span class="nx">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="p">{</span>
		<span class="o">*</span><span class="nx">index</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">scanUnsignedInteger</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">scanUnsignedInteger</span><span class="p">(</span><span class="nx">arr</span> <span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">index</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">index</span>
	<span class="k">for</span> <span class="o">*</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">arr</span><span class="p">)[</span><span class="o">*</span><span class="nx">index</span><span class="p">]</span> <span class="p">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="nx">arr</span><span class="p">)[</span><span class="o">*</span><span class="nx">index</span><span class="p">]</span> <span class="p">&gt;</span> <span class="sc">&#39;9&#39;</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="nx">index</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="o">*</span><span class="nx">index</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id80">
<h2>68.文本左右对齐(1)<a class="headerlink" href="#id80" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，
且左右两端对齐的文本。
你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。
必要时可用空格 &#39; &#39; 填充，使得每行恰好有 maxWidth 个字符。
要求尽可能均匀分配单词间的空格数量。
如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
文本的最后一行应为左对齐，且单词之间不插入额外的空格。
说明:单词是指由非空格字符组成的字符序列。
    每个单词的长度大于 0，小于等于 maxWidth。
    输入单词数组 words 至少包含一个单词。
示例:输入: words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]
maxWidth = 16
输出:
[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
示例 2:输入: words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;] maxWidth = 16
输出:
[
  &quot;What   must   be&quot;,
  &quot;acknowledgment  &quot;,
  &quot;shall be        &quot;
]
解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
示例 3:
输入:words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,
         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]
maxWidth = 20
输出:
[
  &quot;Science  is  what we&quot;,
  &quot;understand      well&quot;,
  &quot;enough to explain to&quot;,
  &quot;a  computer.  Art is&quot;,
  &quot;everything  else  we&quot;,
  &quot;do                  &quot;
]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历模拟</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">fullJustify</span><span class="p">(</span><span class="nx">words</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">maxWidth</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">start</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">count</span> <span class="p">=</span> <span class="nx">count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">maxWidth</span> <span class="p">{</span>
			<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">justify</span><span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">maxWidth</span><span class="p">)</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">temp</span><span class="p">)</span>
			<span class="nx">start</span> <span class="p">=</span> <span class="nx">i</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
				<span class="nx">count</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nx">i</span><span class="o">--</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">count</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">justify</span><span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">maxWidth</span><span class="p">)</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">temp</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">justify</span><span class="p">(</span><span class="nx">words</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maxWidth</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">maxWidth</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">byte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// 文本的最后一行应为左对齐，且单词之间不插入额外的空格。</span>
	<span class="k">if</span> <span class="nx">start</span> <span class="o">==</span> <span class="nx">end</span> <span class="o">||</span> <span class="nx">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span> <span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 要求尽可能均匀分配单词间的空格数量。</span>
		<span class="c1">// 如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</span>
		<span class="nx">count</span> <span class="o">:=</span> <span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">left</span> <span class="o">:=</span> <span class="nx">maxWidth</span> <span class="o">-</span> <span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="p">=</span> <span class="nx">left</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">space</span> <span class="o">:=</span> <span class="nx">left</span> <span class="o">/</span> <span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 均分</span>
		<span class="nx">mod</span> <span class="o">:=</span> <span class="nx">left</span> <span class="o">%</span> <span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">// 多的放左边</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span> <span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">space</span>
			<span class="k">if</span> <span class="nx">mod</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">index</span><span class="o">++</span>
				<span class="nx">mod</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id81">
<h2>72.编辑距离(2)<a class="headerlink" href="#id81" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
    插入一个字符
    删除一个字符
    替换一个字符
示例 1：输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot; 输出：3
解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)
rorse -&gt; rose (删除 &#39;r&#39;)
rose -&gt; ros (删除 &#39;e&#39;)
示例 2：输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot; 输出：5
解释： intention -&gt; inention (删除 &#39;t&#39;)
inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)
enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)
exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)
exection -&gt; execution (插入 &#39;u&#39;)
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minDistance(word1 string, word2 string) int {
	n1 := len(word1)
	n2 := len(word2)
	// dp[i][j]代表 word1的i位置转换成word2的j位置需要最少步数
	dp := make([][]int, n1+1)
	for i := 0; i &lt; n1+1; i++ {
		dp[i] = make([]int, n2+1)
	}
	dp[0][0] = 0
	// 到word2[0]需要全部删除，有多少删除多少
	for i := 1; i &lt;= n1; i++ {
		dp[i][0] = i
	}
	// 到word2[i]需要添加，有多少添加多少
	for i := 1; i &lt;= n2; i++ {
		dp[0][i] = i
	}
	for i := 1; i &lt;= n1; i++ {
		for j := 1; j &lt;= n2; j++ {
			if word1[i-1] == word2[j-1] {
				dp[i][j] = dp[i-1][j-1] // 相同不需要操作
			} else {
				dp[i][j] = dp[i-1][j-1] + 1            // 替换
				dp[i][j] = min(dp[i][j], dp[i][j-1]+1) // 插入
				dp[i][j] = min(dp[i][j], dp[i-1][j]+1) // 删除
			}
		}
	}
	return dp[n1][n2]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
var dp [][]int

func minDistance(word1 string, word2 string) int {
	dp = make([][]int, len(word1)+1)
	for i := 0; i &lt; len(word1)+1; i++ {
		dp[i] = make([]int, len(word2)+1)
	}
	return helper(word1, word2, 0, 0)
}

func helper(word1, word2 string, i, j int) int {
	if dp[i][j] &gt; 0 {
		return dp[i][j]
	}
	if i == len(word1) || j == len(word2) {
		return len(word1) - i + len(word2) - j
	}
	if word1[i] == word2[j] {
		return helper(word1, word2, i+1, j+1)
	}
	inserted := helper(word1, word2, i, j+1)
	deleted := helper(word1, word2, i+1, j)
	replaced := helper(word1, word2, i+1, j+1)
	dp[i][j] = min(inserted, min(deleted, replaced)) + 1
	return dp[i][j]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id82">
<h2>76.最小覆盖子串(2)<a class="headerlink" href="#id82" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 S、一个字符串 T 。
请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。
示例：输入：S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; 输出：&quot;BANC&quot;
提示：如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。
    如果 S 中存在这样的子串，我们保证它是唯一的答案。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>滑动窗口</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minWindow(s string, t string) string {
	if len(s) &lt; len(t) {
		return &quot;&quot;
	}
	window := make(map[byte]int)
	need := make(map[byte]int)
	for i := 0; i &lt; len(t); i++ {
		need[t[i]]++
	}
	left, right := -1, -1
	minLength := math.MaxInt32
	for l, r := 0, 0; r &lt; len(s); r++ {
		if r &lt; len(s) &amp;&amp; need[s[r]] &gt; 0 {
			window[s[r]]++
		}
		// 找到，然后left往右移
		for check(need, window) == true &amp;&amp; l &lt;= r {
			if r-l+1 &lt; minLength {
				minLength = r - l + 1
				left, right = l, r+1
			}
			if _, ok := need[s[l]]; ok {
				window[s[l]]--
			}
			l++
		}
	}
	if left == -1 {
		return &quot;&quot;
	}
	return s[left:right]
}

func check(need, window map[byte]int) bool {
	for k, v := range need {
		if window[k] &lt; v {
			return false
		}
	}
	return true
}

# 2
func minWindow(s string, t string) string {
	if len(s) &lt; len(t) {
		return &quot;&quot;
	}
	arr := make(map[byte]int)
	for i := 0; i &lt; len(t); i++ {
		arr[t[i]]++
	}
	l, count := 0, 0
	res := &quot;&quot;
	minLength := math.MaxInt32
	for r := 0; r &lt; len(s); r++ {
		arr[s[r]]--
		if arr[s[r]] &gt;= 0 {
			count++
		}
		// left往右边移动
		for count == len(t) {
			if minLength &gt; r-l+1 {
				minLength = r - l + 1
				res = s[l : r+1]
			}
			arr[s[l]]++
			if arr[s[l]] &gt; 0 {
				count--
			}
			l++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id83">
<h2>84.柱状图中最大的矩形(5)<a class="headerlink" href="#id83" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。
图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。
示例:输入: [2,1,5,6,2,3]输出: 10
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>05</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func largestRectangleArea(heights []int) int {
	n := len(heights)
	res := 0
	for i := 0; i &lt; n; i++ {
		height := heights[i]
		for j := i; j &lt; n; j++ {
			width := j - i + 1
			height = min(height, heights[j])
			res = max(res, width*height)
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func largestRectangleArea(heights []int) int {
	n := len(heights)
	res := 0
	for i := 0; i &lt; n; i++ {
		height := heights[i]
		left, right := i, i
		for left &gt; 0 &amp;&amp; heights[left-1] &gt;= height {
			left--
		}
		for right &lt; n-1 &amp;&amp; heights[right+1] &gt;= height {
			right++
		}
		width := right - left + 1
		res = max(res, width*height)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func largestRectangleArea(heights []int) int {
	n := len(heights)
	res := 0
	left := make([]int, n)
	right := make([]int, n)
	stack := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		for len(stack) &gt; 0 &amp;&amp; heights[stack[len(stack)-1]] &gt;= heights[i] {
			stack = stack[:len(stack)-1]
		}
		if len(stack) == 0 {
			left[i] = -1
		} else {
			left[i] = stack[len(stack)-1]
		}
		stack = append(stack, i)
	}
	stack = make([]int, 0)
	for i := n - 1; i &gt;= 0; i-- {
		for len(stack) &gt; 0 &amp;&amp; heights[stack[len(stack)-1]] &gt;= heights[i] {
			stack = stack[:len(stack)-1]
		}
		if len(stack) == 0 {
			right[i] = n
		} else {
			right[i] = stack[len(stack)-1]
		}
		stack = append(stack, i)
	}
	for i := 0; i &lt; n; i++ {
		res = max(res, heights[i]*(right[i]-left[i]-1))
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 4
func largestRectangleArea(heights []int) int {
	n := len(heights)
	res := 0
	left := make([]int, n)
	right := make([]int, n)
	stack := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		right[i] = n
	}
	for i := 0; i &lt; n; i++ {
		for len(stack) &gt; 0 &amp;&amp; heights[stack[len(stack)-1]] &gt;= heights[i] {
			right[stack[len(stack)-1]] = i
			stack = stack[:len(stack)-1]
		}
		if len(stack) == 0 {
			left[i] = -1
		} else {
			left[i] = stack[len(stack)-1]
		}
		stack = append(stack, i)
	}

	for i := 0; i &lt; n; i++ {
		res = max(res, heights[i]*(right[i]-left[i]-1))
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 5
func largestRectangleArea(heights []int) int {
	heights = append([]int{0}, heights...)
	heights = append(heights, 0)
	n := len(heights)
	res := 0
	stack := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		// 递增栈
		for len(stack) &gt; 0 &amp;&amp; heights[stack[len(stack)-1]] &gt; heights[i] {
			height := heights[stack[len(stack)-1]]
			stack = stack[:len(stack)-1]
			width := i - stack[len(stack)-1] - 1
			res = max(res, height*width)
		}
		stack = append(stack, i)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id84">
<h2>85.最大矩形(2)<a class="headerlink" href="#id84" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
示例:输入:
[
  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],
  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]
]
输出: 6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>单调栈</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximalRectangle(matrix [][]byte) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}
	res := 0
	n, m := len(matrix), len(matrix[0])
	height := make([]int, m) // 高度
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == &#39;0&#39; {
				height[j] = 0
			} else {
				height[j] = height[j] + 1
			}
		}
		res = max(res, getMaxArea(height))
	}
	return res
}

func getMaxArea(heights []int) int {
	heights = append([]int{0}, heights...)
	heights = append(heights, 0)
	n := len(heights)
	res := 0
	stack := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		// 递增栈
		for len(stack) &gt; 0 &amp;&amp; heights[stack[len(stack)-1]] &gt; heights[i] {
			height := heights[stack[len(stack)-1]]
			stack = stack[:len(stack)-1]
			width := i - stack[len(stack)-1] - 1
			res = max(res, height*width)
		}
		stack = append(stack, i)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maximalRectangle(matrix [][]byte) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}
	res := 0
	n, m := len(matrix), len(matrix[0])
	left, right, height := make([]int, m), make([]int, m), make([]int, m)
	for i := 0; i &lt; m; i++ {
		right[i] = m
	}
	for i := 0; i &lt; n; i++ {
		curLeft, curRight := 0, m
		// 高度
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == &#39;1&#39; {
				height[j]++
			} else {
				height[j] = 0
			}
		}
		// 左边
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == &#39;1&#39; {
				left[j] = max(left[j], curLeft)
			} else {
				left[j] = 0
				curLeft = j + 1
			}
		}
		// 右边
		for j := m - 1; j &gt;= 0; j-- {
			if matrix[i][j] == &#39;1&#39; {
				right[j] = min(right[j], curRight)
			} else {
				right[j] = m
				curRight = j
			}
		}
		for j := 0; j &lt; m; j++ {
			res = max(res, height[j]*(right[j]-left[j]))
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id85">
<h2>87.扰乱字符串(2)<a class="headerlink" href="#id85" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。
下图是字符串 s1 = &quot;great&quot; 的一种可能的表示形式。
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。
例如，如果我们挑选非叶节点 &quot;gr&quot; ，交换它的两个子节点，将会产生扰乱字符串 &quot;rgeat&quot; 。
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
我们将 &quot;rgeat” 称作 &quot;great&quot; 的一个扰乱字符串。
同样地，如果我们继续交换节点 &quot;eat&quot; 和 &quot;at&quot; 的子节点，将会产生另一个新的扰乱字符串 &quot;rgtae&quot; 。
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
我们将 &quot;rgtae” 称作 &quot;great&quot; 的一个扰乱字符串。
给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。
示例 1:输入: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot; 输出: true
示例 2:输入: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot; 输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^4)</td>
<td>O(n^3)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(5^n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isScramble(s1 string, s2 string) bool {
	n, m := len(s1), len(s2)
	if n != m {
		return false
	}
	// dp[i][j][l]:表示s1从i开始，s2从j开始长度为l的两个子字符串是扰乱
	dp := make([][][]bool, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([][]bool, n+1)
		for j := 0; j &lt;= n; j++ {
			dp[i][j] = make([]bool, n+1)
		}
	}
	// 单个字符
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; n; j++ {
			dp[i][j][1] = s1[i] == s2[j]
		}
	}
	for k := 2; k &lt;= n; k++ { // 枚举长度: 2-n
		for i := 0; i &lt;= n-k; i++ { // s1起点
			for j := 0; j &lt;= n-k; j++ { // s2起点
				dp[i][j][k] = false
				// 长度为w，分为两部分，其中最少是1
				for w := 1; w &lt;= k-1; w++ {
					// 划分不交换：S1-&gt;T1, S2-&gt;T2
					// 划分交换： S1-&gt;T2, S2-&gt;T1
					if (dp[i][j][w] == true &amp;&amp; dp[i+w][j+w][k-w] == true) ||
						(dp[i][j+k-w][w] == true &amp;&amp; dp[i+w][j][k-w] == true) {
						dp[i][j][k] = true
					}
				}
			}
		}
	}
	return dp[0][0][n]
}

# 2
func isScramble(s1 string, s2 string) bool {
	return dfs([]byte(s1), []byte(s2))
}

func dfs(arr1, arr2 []byte) bool {
	if compare(arr1, arr2) == false {
		return false
	}
	if len(arr1) &lt;= 2 {
		return (len(arr1) == 2 &amp;&amp; ((arr1[0] == arr2[0] &amp;&amp; arr1[1] == arr2[1]) ||
			(arr1[0] == arr2[1] &amp;&amp; arr1[1] == arr2[0]))) ||
			(len(arr1) == 1 &amp;&amp; arr1[0] == arr2[0])
	}
	for i := 1; i &lt; len(arr1); i++ {
		leftA, rightA := arr1[:i], arr1[i:]
		leftB, rightB := arr2[:i], arr2[i:]
		LB, RB := arr2[len(arr1)-i:], arr2[:len(arr1)-i]
		if (dfs(leftA, leftB) &amp;&amp; dfs(rightA, rightB)) || (dfs(leftA, LB) &amp;&amp; dfs(rightA, RB)) {
			return true
		}
	}
	return false
}

func compare(arr1, arr2 []byte) bool {
	if len(arr1) != len(arr2) {
		return false
	}
	arrA := make([]byte, 26)
	arrB := make([]byte, 26)
	for i := 0; i &lt; len(arr1); i++ {
		arrA[arr1[i]-&#39;a&#39;]++
		arrB[arr2[i]-&#39;a&#39;]++
	}
	for i := 0; i &lt; len(arrA); i++ {
		if arrA[i] != arrB[i] {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id86">
<h2>97.交错字符串(3)<a class="headerlink" href="#id86" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。
示例 1：输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot; 输出：true
示例 2：输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot; 输出：false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划-一维</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isInterleave(s1 string, s2 string, s3 string) bool {
	n, m, t := len(s1), len(s2), len(s3)
	if n+m != t {
		return false
	}
	// dp[i][j]表示s1的前i个元素和s2的前j个元素是否能交错组成s3的前i+j个元素
	dp := make([][]bool, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]bool, m+1)
	}
	dp[0][0] = true
	for i := 0; i &lt;= n; i++ {
		for j := 0; j &lt;= m; j++ {
			total := i + j - 1
			if i &gt; 0 &amp;&amp; dp[i-1][j] == true &amp;&amp; s1[i-1] == s3[total] {
				dp[i][j] = true
			}
			if j &gt; 0 &amp;&amp; dp[i][j-1] == true &amp;&amp; s2[j-1] == s3[total] {
				dp[i][j] = true
			}
		}
	}
	return dp[n][m]
}

# 2
func isInterleave(s1 string, s2 string, s3 string) bool {
	n, m, t := len(s1), len(s2), len(s3)
	if n+m != t {
		return false
	}
	// dp[j]表示s1的前i个元素和s2的前j个元素是否能交错组成s3的前i+j个元素
	dp := make([]bool, m+1)
	dp[0] = true
	for i := 0; i &lt;= n; i++ {
		for j := 0; j &lt;= m; j++ {
			total := i + j - 1
			if i &gt; 0 {
				if dp[j] == true &amp;&amp; s1[i-1] == s3[total] {
					dp[j] = true
				} else {
					dp[j] = false
				}
			}
			if j &gt; 0 {
				if dp[j] == true || (dp[j-1] == true &amp;&amp; s2[j-1] == s3[total]) {
					dp[j] = true
				} else {
					dp[j] = false
				}
			}
		}
	}
	return dp[m]
}

# 3
func isInterleave(s1 string, s2 string, s3 string) bool {
	if len(s1)+len(s2) != len(s3) {
		return false
	}
	return dfs(s1, s2, s3, 0, 0, 0)
}

func dfs(s1, s2, s3 string, i, j, k int) bool {
	if k == len(s3) &amp;&amp; i == len(s1) &amp;&amp; j == len(s2) {
		return true
	}
	if k &gt;= len(s3) {
		return false
	}
	if i &lt; len(s1) {
		if s1[i] == s3[k] {
			if dfs(s1, s2, s3, i+1, j, k+1) {
				return true
			}
		}
	}
	if j &lt; len(s2) {
		if s2[j] == s3[k] {
			if dfs(s1, s2, s3, i, j+1, k+1) {
				return true
			}
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id87">
<h2>99.恢复二叉搜索树(4)<a class="headerlink" href="#id87" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>二叉搜索树中的两个节点被错误地交换。
请在不改变其结构的情况下，恢复这棵树。
示例 1:输入: [1,3,null,null,2]
   1
  /
 3
  \
   2
输出: [3,1,null,null,2]
   3
  /
 1
  \
   2
示例 2:输入: [3,1,4,null,null,2]
  3
 / \
1   4
   /
  2
输出: [2,1,4,null,null,3]
  2
 / \
1   4
   /
  3
进阶:使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>03</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var arr []*TreeNode

func recoverTree(root *TreeNode) {
	arr = make([]*TreeNode, 0)
	dfs(root)
	a, b := -1, -1
	for i := 0; i &lt; len(arr)-1; i++ {
		if arr[i].Val &gt; arr[i+1].Val {
			b = i + 1
			if a == -1 {
				a = i
			}
		}
	}
	arr[a].Val, arr[b].Val = arr[b].Val, arr[a].Val
}

func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)
	arr = append(arr, root)
	dfs(root.Right)
}

# 2
var prev, first, second *TreeNode

func recoverTree(root *TreeNode) {
	prev, first, second = nil, nil, nil
	dfs(root)
	first.Val, second.Val = second.Val, first.Val
}

func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)
	if prev != nil &amp;&amp; prev.Val &gt; root.Val {
		second = root
		if first == nil {
			first = prev
		} else {
			return
		}
	}
	prev = root
	dfs(root.Right)
}

# 3
func recoverTree(root *TreeNode) {
	var prev, first, second *TreeNode
	stack := make([]*TreeNode, 0)
	for len(stack) &gt; 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if prev != nil &amp;&amp; root.Val &lt; prev.Val {
			second = root
			if first == nil {
				first = prev
			} else {
				break
			}
		}
		prev = root
		root = root.Right
	}
	first.Val, second.Val = second.Val, first.Val
}

# 4
func recoverTree(root *TreeNode) {
	var prev, temp, first, second *TreeNode
	for root != nil {
		temp = root.Left
		if temp != nil {
            // 当前root节点向左走一步，然后一直向右走至无法走为止
			for temp.Right != nil &amp;&amp; temp.Right != root {
				temp = temp.Right
			}
			if temp.Right == nil {
				temp.Right = root
				root = root.Left
				continue
			} else {
				temp.Right = nil
			}
		}
		if prev != nil &amp;&amp; prev.Val &gt; root.Val {
			second = root
			if first == nil {
				first = prev
			}
		}
		prev = root
		root = root.Right
	}
	first.Val, second.Val = second.Val, first.Val
}
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="0101-0200.html" class="btn btn-neutral float-right" title="0101-0200-Easy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../index.html" class="btn btn-neutral float-left" title="Welcome to go-leetcode’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>