

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1201-1300-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="1301-1400-Easy" href="1301-1400.html" />
    <link rel="prev" title="1101-1200-Easy" href="1101-1200.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">1201-1300-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">1207.独一无二的出现次数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">1217.玩筹码(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">1221.分割平衡字符串(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">1232.缀点成线(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1237.找出给定方程的正整数解(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">1252.奇数值单元格的数目(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">1260.二维网格迁移(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">1266.访问所有点的最小时间(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">1275.找出井字棋的获胜者(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">1281.整数的各位积和之差(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">1287.有序数组中出现次数超过25%的元素(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">1290.二进制链表转整数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">1295.统计位数为偶数的数字(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">1299.将每个元素替换为右侧最大元素(3)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">1201-1300-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id15">1202.交换字符串中的元素(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">1208.尽可能使字符串相等(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-2">1209.删除字符串中的所有相邻重复项II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">1218.最长定差子序列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">1219.黄金矿工(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19">1222.可以攻击国王的皇后(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">1223.掷骰子模拟(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">1227.飞机座位分配概率(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">1233.删除子文件夹(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">1234.替换子串得到平衡字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">1238.循环码排列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">1239.串联字符串的最大长度(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">1247.交换字符使得字符串相同(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">1248.统计「优美子数组」(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">1249.移除无效的括号(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">1253.重构2行二进制矩阵(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">1254.统计封闭岛屿的数目(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">1261.在受污染的二叉树中查找元素(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">1262.可被三整除的最大和(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">1267.统计参与通信的服务器(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">1276.不浪费原料的汉堡制作方案(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">1282.用户分组(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">1288.删除被覆盖区间(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">1291.顺次数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">1296.划分数组为连续数字的集合(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">1297.子串的最大出现次数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">1300.转变数组后最接近目标值的数组和(3)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">1201-1300-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id41">1235.规划兼职工作(4)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html">Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#medium">Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#hard">Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>1201-1300-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/1201-1300.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>1201-1300-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#1201-1300-easy">1201-1300-Easy</a><ul>
<li><a class="reference external" href="#1207%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B02">1207.独一无二的出现次数(2)</a></li>
<li><a class="reference external" href="#1217%E7%8E%A9%E7%AD%B9%E7%A0%811">1217.玩筹码(1)</a></li>
<li><a class="reference external" href="#1221%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B23">1221.分割平衡字符串(3)</a></li>
<li><a class="reference external" href="#1232%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF3">1232.缀点成线(3)</a></li>
<li><a class="reference external" href="#1237%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%96%B9%E7%A8%8B%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A33">1237.找出给定方程的正整数解(3)</a></li>
<li><a class="reference external" href="#1252%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE3">1252.奇数值单元格的数目(3)</a></li>
<li><a class="reference external" href="#1260%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB2">1260.二维网格迁移(2)</a></li>
<li><a class="reference external" href="#1266%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B41">1266.访问所有点的最小时间(1)</a></li>
<li><a class="reference external" href="#1275%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%852">1275.找出井字棋的获胜者(2)</a></li>
<li><a class="reference external" href="#1281%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE2">1281.整数的各位积和之差(2)</a></li>
<li><a class="reference external" href="#1287%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%8725%E7%9A%84%E5%85%83%E7%B4%A04">1287.有序数组中出现次数超过25%的元素(4)</a></li>
<li><a class="reference external" href="#1290%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B03">1290.二进制链表转整数(3)</a></li>
<li><a class="reference external" href="#1295%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%972">1295.统计位数为偶数的数字(2)</a></li>
<li><a class="reference external" href="#1299%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A03">1299.将每个元素替换为右侧最大元素(3)</a></li>
</ul>
</li>
<li><a class="reference external" href="#1201-1300-medium">1201-1300-Medium</a><ul>
<li><a class="reference external" href="#1248%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%844">1248.统计「优美子数组」(4)</a></li>
</ul>
</li>
</ul>
<div class="section" id="id1">
<h2>1207.独一无二的出现次数(2)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。
如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。
示例 1：输入：arr = [1,2,2,1,1,3] 输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
示例 2：输入：arr = [1,2] 输出：false
示例 3：输入：arr = [-3,0,1,-3,1,1,1,-3,10,0] 输出：true
提示：
    1 &lt;= arr.length &lt;= 1000
    -1000 &lt;= arr[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func uniqueOccurrences(arr []int) bool {
	m := make(map[int]int)
	for _, v := range arr {
		m[v]++
	}
	temp := make(map[int]bool)
	for _, v := range m {
		if temp[v] == true {
			return false
		}
		temp[v] = true
	}
	return true
}

#
func uniqueOccurrences(arr []int) bool {
	tempArr := make([]int,2001)
	for _, v := range arr {
		tempArr[v+1000]++
	}
	temp := make(map[int]bool)
	for _, v := range tempArr {
		if v == 0{
			continue
		}
		if temp[v] == true {
			return false
		}
		temp[v] = true
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>1217.玩筹码(1)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。
你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：
    将第 i 个筹码向左或者右移动 2 个单位，代价为 0。
    将第 i 个筹码向左或者右移动 1 个单位，代价为 1。
最开始的时候，同一位置上也可能放着两个或者更多的筹码。
返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。
示例 1：输入：chips = [1,2,3] 输出：1
解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。
示例 2：输入：chips = [2,2,2,3,3] 输出：2
解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。
提示：
    1 &lt;= chips.length &lt;= 100
    1 &lt;= chips[i] &lt;= 10^9
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>奇偶计数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">1、所有偶数移动到同一偶数位置，花费0</span>
<span class="cm">2、所有奇数移动到同一奇数位置，花费0</span>
<span class="cm">3、将较小移动到较多的位置。</span>
<span class="cm">*/</span>
<span class="kd">func</span> <span class="nx">minCostToMoveChips</span><span class="p">(</span><span class="nx">chips</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">odd</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">even</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">chips</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">chips</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">odd</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">even</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">odd</span> <span class="p">&gt;</span> <span class="nx">even</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">even</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">odd</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>1221.分割平衡字符串(3)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个「平衡字符串」中，&#39;L&#39; 和 &#39;R&#39; 字符的数量是相同的。
给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
返回可以通过分割得到的平衡字符串的最大数量。
示例 1：输入：s = &quot;RLRRLLRLRL&quot; 输出：4
解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。
示例 2：输入：s = &quot;RLLLLRRRLR&quot; 输出：3
解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。
示例 3：输入：s = &quot;LLLLRRRR&quot; 输出：1
解释：s 只能保持原样 &quot;LLLLRRRR&quot;.
提示：
    1 &lt;= s.length &lt;= 1000
    s[i] = &#39;L&#39; 或 &#39;R&#39;
    分割得到的每个字符串都必须是平衡字符串。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func balancedStringSplit(s string) int {
	res := 0
	if len(s) == 0 {
		return res
	}
	stack := make([]byte, 0)
	stack = append(stack, s[0])
	for i := 1; i &lt; len(s); i++ {
		if len(stack) &gt; 0 &amp;&amp;
			((s[i] == &#39;L&#39; &amp;&amp; stack[len(stack)-1] == &#39;R&#39;) ||
				(s[i] == &#39;R&#39; &amp;&amp; stack[len(stack)-1] == &#39;L&#39;)) {
			stack = stack[:len(stack)-1]
			if len(stack) == 0 {
				res++
			}
		} else {
			stack = append(stack, s[i])
		}
	}
	return res
}

#
func balancedStringSplit(s string) int {
	res := 0
	if len(s) == 0 {
		return res
	}
	count := 0
	if s[0] == &#39;L&#39; {
		count++
	} else {
		count--
	}
	for i := 1; i &lt; len(s); i++ {
		if s[i] == &#39;L&#39; {
			count++
		} else {
			count--
		}
		if count == 0 {
			res++
		}
	}
	return res
}

#
func balancedStringSplit(s string) int {
	res := 0
	if len(s) == 0 {
		return res
	}
	left := 0
	right := 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;L&#39; {
			left++
		} else {
			right++
		}
		if left == right {
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>1232.缀点成线(3)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，
其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。
请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。
示例 1：输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] 输出：true
示例 2：输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] 输出：false
提示：
    2 &lt;= coordinates.length &lt;= 1000
    coordinates[i].length == 2
    -10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4
    coordinates 中不含重复的点
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>斜率公式</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>鞋带公式</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>判断三边长</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>// k=y/x k1=y1/x1 =&gt; xy1=x1y
func checkStraightLine(coordinates [][]int) bool {
	x, y := coordinates[1][0]-coordinates[0][0], coordinates[1][1]-coordinates[0][1]
	for i := 2; i &lt; len(coordinates); i++ {
		x1, y1 := coordinates[i][0]-coordinates[i-1][0], coordinates[i][1]-coordinates[i-1][1]
		if x*y1 != x1*y {
			return false
		}
	}
	return true
}

#
// 鞋带公式
// S=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2
// S==0组成一条直线
func checkStraightLine(coordinates [][]int) bool {
	for i := 2; i &lt; len(coordinates); i++ {
		x1 := coordinates[i-2][0]*coordinates[i-1][1] +
			coordinates[i-1][0]*coordinates[i][1] + coordinates[i][0]*coordinates[i-2][1]
		x2 := coordinates[i-2][1]*coordinates[i-1][0] +
			coordinates[i-1][1]*coordinates[i][0] + coordinates[i][1]*coordinates[i-2][0]
		if x1 != x2 {
			return false
		}
	}
	return true
}

#
func checkStraightLine(coordinates [][]int) bool {
	for i := 2; i &lt; len(coordinates); i++ {
		side1 := side(coordinates[i], coordinates[i-1])
		side2 := side(coordinates[i-1], coordinates[i-2])
		side3 := side(coordinates[i], coordinates[i-2])
		arr := []float64{side1, side2, side3}
		sort.Float64s(arr)
		if arr[2]-arr[1]-arr[0] &gt; 0.00000005 || arr[2]-arr[1]-arr[0] &lt; -0.00000005 {
			return false
		}
	}
	return true
}

func side(arr1, arr2 []int) float64 {
	res := (arr1[0]-arr2[0])*(arr1[0]-arr2[0]) +
		(arr1[1]-arr2[1])*(arr1[1]-arr2[1])
	return math.Sqrt(float64(res))
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>1237.找出给定方程的正整数解(3)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个函数  f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。
给定函数是严格单调的，也就是说：
    f(x, y) &lt; f(x + 1, y)
    f(x, y) &lt; f(x, y + 1)
函数接口定义如下：
interface CustomFunction {
public:
  // Returns positive integer f(x, y) for any given positive integer x and y.
  int f(int x, int y);
};
如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，
其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。  
你可以将满足条件的 结果数对 按任意顺序返回。
示例 1：
输入：function_id = 1, z = 5
输出：[[1,4],[2,3],[3,2],[4,1]]
解释：function_id = 1 表示 f(x, y) = x + y
示例 2：
输入：function_id = 2, z = 5
输出：[[1,5],[5,1]]
解释：function_id = 2 表示 f(x, y) = x * y
提示：
    1 &lt;= function_id &lt;= 9
    1 &lt;= z &lt;= 100
    题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。
    在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findSolution(customFunction func(int, int) int, z int) [][]int {
	res := make([][]int, 0)
	for i := 1; i &lt;= 1000; i++ {
		left := 1
		right := 1000
		v1, v2 := customFunction(i, left), customFunction(i, right)
		if z &lt; v1 || z &gt; v2 {
			continue
		}
		for left &lt;= right {
			mid := left + (right-left)/2
			v := customFunction(i, mid)
			if z == v {
				res = append(res, []int{i, mid})
				break
			} else if z &gt; v {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}
	return res
}

#
func findSolution(customFunction func(int, int) int, z int) [][]int {
	res := make([][]int, 0)
	i := 1
	j := 1000
	for i &lt;= 1000 &amp;&amp; j &gt;= 1 {
		if customFunction(i, j) == z {
			res = append(res, []int{i, j})
			i++
			j--
		} else if customFunction(i, j) &gt; z {
			j--
		} else {
			i++
		}
	}
	return res
}

#
func findSolution(customFunction func(int, int) int, z int) [][]int {
	res := make([][]int, 0)
	for i := 1; i &lt;= 1000; i++ {
		for j := 1; j &lt; 1000; j++ {
			if customFunction(i, j) == z {
				res = append(res, []int{i, j})
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>1252.奇数值单元格的数目(3)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。
另有一个索引数组 indices，indices[i] = [ri, ci] 中的 
ri 和 ci 分别表示指定的行和列（从 0 开始编号）。
你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。
请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。
示例 1：输入：n = 2, m = 3, indices = [[0,1],[1,1]] 输出：6
解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。
示例 2：输入：n = 2, m = 2, indices = [[1,1],[0,0]] 输出：0
解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。
提示：
    1 &lt;= n &lt;= 50
    1 &lt;= m &lt;= 50
    1 &lt;= indices.length &lt;= 100
    0 &lt;= indices[i][0] &lt; n
    0 &lt;= indices[i][1] &lt; m
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历模拟</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>统计行列</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>统计行列-遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func oddCells(n int, m int, indices [][]int) int {
	arr := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		arr[i] = make([]int, m)
	}
	for i := 0; i &lt; len(indices); i++ {
		r := indices[i][0]
		c := indices[i][1]
		for j := 0; j &lt; m; j++ {
			arr[r][j]++
		}
		for j := 0; j &lt; n; j++ {
			arr[j][c]++
		}
	}
	res := 0
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if arr[i][j]%2 == 1 {
				res++
			}
		}
	}
	return res
}

#
func oddCells(n int, m int, indices [][]int) int {
	rows := make([]int, n)
	cols := make([]int, m)
	for i := 0; i &lt; len(indices); i++ {
		rows[indices[i][0]]++
		cols[indices[i][1]]++
	}
	numRows := 0
	for i := 0; i &lt; n; i++ {
		if rows[i]%2 == 0 {
			numRows++
		}
	}
	res := 0
	for i := 0; i &lt; m; i++ {
		if cols[i]%2 == 0 {
			res = res + n - numRows
		} else {
			res = res + numRows
		}
	}
	return res
}

#
func oddCells(n int, m int, indices [][]int) int {
	rows := make([]int, n)
	cols := make([]int, m)
	for i := 0; i &lt; len(indices); i++ {
		rows[indices[i][0]]++
		cols[indices[i][1]]++
	}
	res := 0
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if (rows[i]+cols[j])%2 == 1 {
				res++
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>1260.二维网格迁移(2)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。
每次「迁移」操作将会引发下述活动：
    位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
    位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。
    位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。
请你返回 k 次迁移操作后最终得到的 二维网格。
示例 1：输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]]
示例 2：输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
示例 3：输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 输出：[[1,2,3],[4,5,6],[7,8,9]]
提示：
    1 &lt;= grid.length &lt;= 50
    1 &lt;= grid[i].length &lt;= 50
    -1000 &lt;= grid[i][j] &lt;= 1000
    0 &lt;= k &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历模拟</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>计算下标</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func shiftGrid(grid [][]int, k int) [][]int {
	for i := 0; i &lt; k; i++ {
		temp := make([][]int, len(grid))
		for i := 0; i &lt; len(temp); i++ {
			temp[i] = make([]int, len(grid[i]))
		}
		for i := 0; i &lt; len(grid); i++ {
			for j := 0; j &lt; len(grid[i])-1; j++ {
				temp[i][j+1] = grid[i][j]
			}
		}
		for i := 0; i &lt; len(grid)-1; i++ {
			temp[i+1][0] = grid[i][len(grid[0])-1]
		}
		temp[0][0] = grid[len(grid)-1][len(grid[0])-1]
		grid = temp
	}
	return grid
}

#
func shiftGrid(grid [][]int, k int) [][]int {
	n := len(grid)
	m := len(grid[0])
	res := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		res[i] = make([]int, m)
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			x := ((i*m + j) + k) % (n * m) / m
			y := ((i*m + j) + k) % (n * m) % m
			// x := (i + (j+k)/m) % n
			// y := (j + k) % m
			res[x][y] = grid[i][j]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>1266.访问所有点的最小时间(1)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。
请你计算访问所有这些点需要的最小时间（以秒为单位）。
你可以按照下面的规则在平面上移动：
    每一秒沿水平或者竖直方向移动一个单位长度，
    或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。
    必须按照数组中出现的顺序来访问这些点。
示例 1：输入：points = [[1,1],[3,4],[-1,0]] 输出：7
解释：一条最佳的访问路径是： 
[1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]   
从 [1,1] 到 [3,4] 需要 3 秒 
从 [3,4] 到 [-1,0] 需要 4 秒
一共需要 7 秒
示例 2：输入：points = [[3,2],[-2,2]] 输出：5
提示：
    points.length == n
    1 &lt;= n &lt;= 100
    points[i].length == 2
    -1000 &lt;= points[i][0], points[i][1] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minTimeToVisitAllPoints</span><span class="p">(</span><span class="nx">points</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nx">length</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
		<span class="nx">y</span> <span class="o">:=</span> <span class="nx">length</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="nx">y</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">x</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">y</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">length</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>1275.找出井字棋的获胜者(2)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>A 和 B 在一个 3 x 3 的网格上玩井字棋。
井字棋游戏的规则如下：
    玩家轮流将棋子放在空方格 (&quot; &quot;) 上。
    第一个玩家 A 总是用 &quot;X&quot; 作为棋子，而第二个玩家 B 总是用 &quot;O&quot; 作为棋子。
    &quot;X&quot; 和 &quot;O&quot; 只能放在空方格中，而不能放在已经被占用的方格上。
    只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
    如果所有方块都放满棋子（不为空），游戏也会结束。
    游戏结束后，棋子无法再进行任何移动。
给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），
它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。

如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；
如果游戏以平局结束，则返回 &quot;Draw&quot;；如果仍会有行动（游戏未结束），则返回 &quot;Pending&quot;。
你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。
示例 1：输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] 输出：&quot;A&quot;
解释：&quot;A&quot; 获胜，他总是先走。
&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;
&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;
&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;
示例 2：输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] 输出：&quot;B&quot;
解释：&quot;B&quot; 获胜。
&quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XXO&quot;
&quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;XO &quot; 
&quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;O  &quot;
示例 3：输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] 输出：&quot;Draw&quot;
输出：由于没有办法再行动，游戏以平局结束。
&quot;XXO&quot;
&quot;OOX&quot;
&quot;XOX&quot;
示例 4：输入：moves = [[0,0],[1,1]] 输出：&quot;Pending&quot;
解释：游戏还没有结束。
&quot;X  &quot;
&quot; O &quot;
&quot;   &quot;
提示：
    1 &lt;= moves.length &lt;= 9
    moves[i].length == 2
    0 &lt;= moves[i][j] &lt;= 2
    moves 里没有重复的元素。
    moves 遵循井字棋的规则。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历模拟</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历模拟</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func tictactoe(moves [][]int) string {
	arrA := make([]int, 0)
	arrB := make([]int, 0)
	for i := 0; i &lt; len(moves); i++ {
		value := moves[i][0]*3 + moves[i][1] + 1
		if i%2 == 0 {
			arrA = append(arrA, value)
			if check(arrA) {
				return &quot;A&quot;
			}
		} else {
			arrB = append(arrB, value)
			if check(arrB) {
				return &quot;B&quot;
			}
		}
	}
	if len(moves) == 9 {
		return &quot;Draw&quot;
	}
	return &quot;Pending&quot;
}

var state = [][]int{
	{1, 2, 3},
	{4, 5, 6},
	{7, 8, 9},
	{1, 4, 7},
	{2, 5, 8},
	{3, 6, 9},
	{1, 5, 9},
	{3, 5, 7},
}

func check(arr []int) bool {
	if len(arr) &lt; 3 {
		return false
	}
	for i := 0; i &lt; len(arr); i++ {
		for j := i + 1; j &lt; len(arr); j++ {
			for k := j + 1; k &lt; len(arr); k++ {
				temp := []int{arr[i], arr[j], arr[k]}
				sort.Ints(temp)
				for n := 0; n &lt; len(state); n++ {
					if temp[0] == state[n][0] &amp;&amp;
						temp[1] == state[n][1] &amp;&amp;
						temp[2] == state[n][2] {
						return true
					}
				}
			}
		}
	}
	return false
}

#
func tictactoe(moves [][]int) string {
	arr := make([][]int, 4)
	for i := 0; i &lt; len(arr); i++ {
		arr[i] = make([]int, 4)
	}
	for i := 0; i &lt; len(moves); i++ {
		x := moves[i][0] + 1
		y := moves[i][1] + 1
		if i%2 == 0 {
			arr[x][y]++
		} else {
			arr[x][y]--
		}
	}
	sum1 := arr[1][1] + arr[2][2] + arr[3][3]
	sum2 := arr[1][3] + arr[2][2] + arr[3][1]
	if sum1 == 3 || sum2 == 3 {
		return &quot;A&quot;
	} else if sum1 == -3 || sum2 == -3 {
		return &quot;B&quot;
	}
	for i := 1; i &lt;= 3; i++ {
		sum1 := arr[i][1] + arr[i][2] + arr[i][3]
		sum2 := arr[1][i] + arr[2][i] + arr[3][i]
		if sum1 == 3 || sum2 == 3 {
			return &quot;A&quot;
		} else if sum1 == -3 || sum2 == -3 {
			return &quot;B&quot;
		}
	}
	if len(moves) == 9 {
		return &quot;Draw&quot;
	}
	return &quot;Pending&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>1281.整数的各位积和之差(2)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。
示例 1：输入：n = 234 输出：15 
解释：
各位数之积 = 2 * 3 * 4 = 24 
各位数之和 = 2 + 3 + 4 = 9 
结果 = 24 - 9 = 15
示例 2：输入：n = 4421 输出：21
解释： 
各位数之积 = 4 * 4 * 2 * 1 = 32 
各位数之和 = 4 + 4 + 2 + 1 = 11 
结果 = 32 - 11 = 21
提示：
    1 &lt;= n &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>转字符串遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">subtractProductAndSum</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">mul</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">10</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">value</span>
		<span class="nx">mul</span> <span class="p">=</span> <span class="nx">mul</span> <span class="o">*</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">mul</span> <span class="o">-</span> <span class="nx">sum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">subtractProductAndSum</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">mul</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">value</span>
		<span class="nx">mul</span> <span class="p">=</span> <span class="nx">mul</span> <span class="o">*</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">mul</span> <span class="o">-</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>1287.有序数组中出现次数超过25%的元素(4)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。
请你找到并返回这个整数
示例：输入：arr = [1,2,2,6,6,6,6,7,10] 输出：6
提示：
    1 &lt;= arr.length &lt;= 10^4
    0 &lt;= arr[i] &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历统计</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findSpecialInteger(arr []int) int {
	count := 1
	res := arr[0]
	for i := 1; i &lt; len(arr); i++ {
		if arr[i] == arr[i-1] {
			count++
			if count &gt; len(arr)/4 {
				return arr[i]
			}
		} else {
			res = arr[i]
			count = 1
		}
	}
	return res
}

#
func findSpecialInteger(arr []int) int {
	step := len(arr) / 4
	for i := 0; i &lt; len(arr)-step; i++ {
		if arr[i] == arr[i+step] {
			return arr[i]
		}
	}
	return -1
}

#
func findSpecialInteger(arr []int) int {
	length := len(arr) / 4
	for i := 1; i &lt;= 2; i++ {
		value := arr[length*i]
		left := leftSearch(arr, value)
		right := rightSearch(arr, value)
		if right-left+1 &gt; length {
			return value
		}
	}
	return arr[3*length]
}

func leftSearch(arr []int, value int) int {
	left := 0
	right := len(arr)
	for left &lt; right {
		mid := left + (right-left)/2
		if arr[mid] &gt;= value {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func rightSearch(arr []int, value int) int {
	left := 0
	right := len(arr)
	for left &lt; right {
		mid := left + (right-left)/2
		if arr[mid] &gt; value {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return right - 1
}

#
func findSpecialInteger(arr []int) int {
	length := len(arr) / 4
	for i := 1; i &lt;= 2; i++ {
		value := arr[length*i]
		left := length * i
		for left &gt; 0 {
			if arr[left] == arr[left-1] {
				left--
			} else {
				break
			}
		}
		right := length * i
		for right &lt; len(arr)-1 {
			if arr[right] == arr[right+1] {
				right++
			} else {
				break
			}
		}
		if right-left+1 &gt; length {
			return value
		}
	}
	return arr[3*length]
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>1290.二进制链表转整数(3)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。
已知此链表是一个整数数字的二进制表示形式。
请你返回该链表所表示数字的 十进制值 。
示例 1：输入：head = [1,0,1] 输出：5
解释：二进制数 (101) 转化为十进制数 (5)
示例 2：输入：head = [0] 输出：0
示例 3：输入：head = [1] 输出：1
示例 4：输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0] 输出：18880
示例 5：输入：head = [0,0] 输出：0
提示：
    链表不为空。
    链表的结点总数不超过 30。
    每个结点的值不是 0 就是 1。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func getDecimalValue(head *ListNode) int {
	arr := make([]int, 0)
	for head != nil {
		arr = append(arr, head.Val)
		head = head.Next
	}
	res := 0
	for i := 0; i &lt; len(arr); i++ {
		res = res * 2
		res = res + arr[i]
	}
	return res
}

#
func getDecimalValue(head *ListNode) int {
	res := 0
	for head != nil {
		res = res*2 + head.Val
		head = head.Next
	}
	return res
}

#
var count = 0

func getDecimalValue(head *ListNode) int {
	if head == nil {
		count = 0
		return 0
	}
	value := getDecimalValue(head.Next)
	res := head.Val*int(math.Pow(2, float64(count))) + value
	count++
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>1295.统计位数为偶数的数字(2)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。
示例 1：输入：nums = [12,345,2,6,7896] 输出：2
解释： 12 是 2 位数字（位数为偶数） 
345 是 3 位数字（位数为奇数）  
2 是 1 位数字（位数为奇数） 
6 是 1 位数字 位数为奇数） 
7896 是 4 位数字（位数为偶数）  
因此只有 12 和 7896 是位数为偶数的数字
示例 2：输入：nums = [555,901,482,1771]输出：1 
解释：  只有 1771 是位数为偶数的数字。
提示：
    1 &lt;= nums.length &lt;= 500
    1 &lt;= nums[i] &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>转字符串</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findNumbers(nums []int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		count := 0
		value := nums[i]
		for value &gt; 0 {
			value = value / 10
			count++
		}
		if count%2 == 0 {
			res++
		}
	}
	return res
}

#
func findNumbers(nums []int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		value := strconv.Itoa(nums[i])
		if len(value)%2 == 0 {
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>1299.将每个元素替换为右侧最大元素(3)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。
完成所有替换操作后，请你返回这个数组。
示例：输入：arr = [17,18,5,4,6,1] 输出：[18,6,6,6,1,-1]
提示：
    1 &lt;= arr.length &lt;= 10^4
    1 &lt;= arr[i] &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历-数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func replaceElements(arr []int) []int {
	max := -1
	for i := len(arr) - 1; i &gt;= 0; i-- {
		if arr[i] &gt; max {
			arr[i], max = max, arr[i]
		} else {
			arr[i] = max
		}
	}
	return arr
}

#
func replaceElements(arr []int) []int {
	for i := 0; i &lt; len(arr); i++ {
		max := -1
		for j := i + 1; j &lt; len(arr); j++ {
			if arr[j] &gt; max {
				max = arr[j]
			}
		}
		arr[i] = max
	}
	return arr
}

#
func replaceElements(arr []int) []int {
	res := make([]int, len(arr))
	res[len(res)-1] = -1
	for i := len(arr) - 2; i &gt;= 0; i-- {
		if arr[i+1] &gt; res[i+1] {
			res[i] = arr[i+1]
		} else {
			res[i] = res[i+1]
		}
	}
	return res
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>1201-1300-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id15">
<h2>1202.交换字符串中的元素(1)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，
其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。
你可以 任意多次交换 在 pairs 中任意一对索引处的字符。
返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。
示例 1:输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]] 输出：&quot;bacd&quot;
解释： 交换 s[0] 和 s[3], s = &quot;bcad&quot;
交换 s[1] 和 s[2], s = &quot;bacd&quot;
示例 2：输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]] 输出：&quot;abcd&quot;
解释：交换 s[0] 和 s[3], s = &quot;bcad&quot;
交换 s[0] 和 s[2], s = &quot;acbd&quot;
交换 s[1] 和 s[2], s = &quot;abcd&quot;
示例 3：输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]] 输出：&quot;abc&quot;
解释：交换 s[0] 和 s[1], s = &quot;bca&quot;
交换 s[1] 和 s[2], s = &quot;bac&quot;
交换 s[0] 和 s[1], s = &quot;abc&quot;
提示：1 &lt;= s.length &lt;= 10^5
0 &lt;= pairs.length &lt;= 10^5
0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length
s 中只含有小写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>并查集+排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">smallestStringWithSwaps</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pairs</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">fa</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fa</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pairs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">pairs</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">pairs</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">union</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">target</span> <span class="o">:=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">target</span><span class="p">],</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]]))</span>
		<span class="p">}</span>
		<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">union</span><span class="p">(</span><span class="nx">fa</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fa</span><span class="p">[</span><span class="nx">find</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">a</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">find</span><span class="p">(</span><span class="nx">fa</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">a</span> <span class="p">{</span>
		<span class="nx">fa</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">fa</span><span class="p">[</span><span class="nx">a</span><span class="p">]]</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>1208.尽可能使字符串相等(4)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个长度相同的字符串，s 和 t。
将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），
也就是两个字符的 ASCII 码值的差的绝对值。
用于变更字符串的最大预算是 maxCost。
在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。
如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。
如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。
示例 1：输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3 输出：3
解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。
示例 2：输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3 输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
示例 3：输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0 输出：1
解释：你无法作出任何改动，所以最大长度为 1。
提示：1 &lt;= s.length, t.length &lt;= 10^5
0 &lt;= maxCost &lt;= 10^6
s 和 t 都只含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>前缀和+二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func equalSubstring(s string, t string, maxCost int) int {
	arr := make([]int, len(s))
	for i := 0; i &lt; len(s); i++ {
		arr[i] = getValue(s[i], t[i])
	}
	left, right := 0, 0
	total := 0
	res := 0
	for right &lt; len(s) {
		for total+arr[right] &gt; maxCost {
			total = total - arr[left]
			left++
		}
		total = total + arr[right]
		if right-left+1 &gt; res {
			res = right - left + 1
		}
		right++
	}
	return res
}

func getValue(a, b byte) int {
	res := int(a) - int(b)
	if res &lt; 0 {
		return -res
	}
	return res
}

# 2
func equalSubstring(s string, t string, maxCost int) int {
	left := 0
	total := 0
	for right := 0; right &lt; len(s); right++ {
		total = total + getValue(s[right], t[right])
		if total &gt; maxCost {
			total = total - getValue(s[left], t[left])
			left++
		}
	}
	return len(s) - left
}

func getValue(a, b byte) int {
	res := int(a) - int(b)
	if res &lt; 0 {
		return -res
	}
	return res
}

# 3
func equalSubstring(s string, t string, maxCost int) int {
	res := 0
	for i := 0; i &lt; len(s); i++ {
		total := 0
		count := 0
		for j := i; j &lt; len(s); j++ {
			total = total + getValue(s[j], t[j])
			if total &gt; maxCost {
				break
			}
			count++
		}
		if count &gt; res {
			res = count
		}
	}
	return res
}

func getValue(a, b byte) int {
	res := int(a) - int(b)
	if res &lt; 0 {
		return -res
	}
	return res
}

# 4
func equalSubstring(s string, t string, maxCost int) int {
	res := 0
	arr := make([]int, len(s)+1)
	for i := 0; i &lt; len(s); i++ {
		arr[i+1] = arr[i] + getValue(s[i], t[i])
	}
	for i := 1; i &lt;= len(s); i++ {
		index := sort.SearchInts(arr[:i], arr[i]-maxCost)
		if i-index &gt; res {
			res = i - index
		}
	}
	return res
}

func getValue(a, b byte) int {
	res := int(a) - int(b)
	if res &lt; 0 {
		return -res
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="ii-2">
<h2>1209.删除字符串中的所有相邻重复项II(2)<a class="headerlink" href="#ii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，
并删除它们，使被删去的字符串的左侧和右侧连在一起。
你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。
在执行完所有删除操作后，返回最终得到的字符串。
本题答案保证唯一。
示例 1：输入：s = &quot;abcd&quot;, k = 2 输出：&quot;abcd&quot;
解释：没有要删除的内容。
示例 2：输入：s = &quot;deeedbbcccbdaa&quot;, k = 3 输出：&quot;aa&quot;
解释： 先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot;
再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot;
最后删除 &quot;ddd&quot;，得到 &quot;aa&quot;
示例 3：输入：s = &quot;pbbcggttciiippooaais&quot;, k = 2 输出：&quot;ps&quot;
提示：1 &lt;= s.length &lt;= 10^5
2 &lt;= k &lt;= 10^4
s 中只含有小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>栈</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeDuplicates(s string, k int) string {
	if len(s) &lt; k {
		return s
	}
	res := &quot;&quot;
	for i := 0; i &lt; len(s); i++ {
		res = res + string(s[i])
		if len(res) &gt;= k &amp;&amp; res[len(res)-k:] == strings.Repeat(string(s[i]), k) {
			res = res[:len(res)-k]
		}
	}
	return res
}

# 2
func removeDuplicates(s string, k int) string {
	if len(s) &lt; k {
		return s
	}
	stack := make([]byte, 0)
	for i := 0; i &lt; len(s); i++ {
		stack = append(stack, s[i])
		if len(stack) &gt;= k {
			a := string(stack[len(stack)-k:])
			b := strings.Repeat(string(s[i]), k)
			if a == b {
				stack = stack[:len(stack)-k]
			}
		}
	}
	return string(stack)
}
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>1218.最长定差子序列(2)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，
该子序列中相邻元素之间的差等于 difference 。
子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。
示例 1：输入：arr = [1,2,3,4], difference = 1 输出：4
解释：最长的等差子序列是 [1,2,3,4]。
示例 2：输入：arr = [1,3,5,7], difference = 1 输出：1
解释：最长的等差子序列是任意单个元素。
示例 3：输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2 输出：4
解释：最长的等差子序列是 [7,5,3,1]。
提示：1 &lt;= arr.length &lt;= 105
-104 &lt;= arr[i], difference &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestSubsequence(arr []int, difference int) int {
	res := 0
	dp := make(map[int]int)
	for i := 0; i &lt; len(arr); i++ {
		dp[arr[i]] = dp[arr[i]-difference] + 1
		if dp[arr[i]] &gt; res {
			res = dp[arr[i]]
		}
	}
	return res
}

# 2
func longestSubsequence(arr []int, difference int) int {
	res := 0
	dp := make([]int, 40001)
	for i := 0; i &lt; len(arr); i++ {
		index := arr[i] + 20000
		dp[index] = dp[index-difference] + 1
		if dp[index] &gt; res {
			res = dp[index]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>1219.黄金矿工(1)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。
每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。
为了使收益最大化，矿工需要按以下规则来开采黄金：
每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。
示例 1：输入：grid = [[0,6,0],[5,8,7],[0,9,0]] 输出：24
解释：[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。
示例 2：

输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
输出：28
解释：
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。
提示：1 &lt;= grid.length, grid[i].length &lt;= 15
0 &lt;= grid[i][j] &lt;= 100
最多 25 个单元格中有黄金。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n^4)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">res</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">getMaximumGold</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">visited</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">visited</span> <span class="p">[][]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="o">||</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span>
		<span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">sum</span>
	<span class="p">}</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
	<span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>1222.可以攻击国王的皇后(1)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。
「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。
「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。
请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。
示例 1：输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
输出：[[0,1],[1,0],[3,3]]
解释： [0,1] 的皇后可以攻击到国王，因为他们在同一行上。 
[1,0] 的皇后可以攻击到国王，因为他们在同一列上。 
[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。 
[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。 
[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。 
[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。
示例 2：输入：queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
输出：[[2,2],[3,4],[4,4]]
示例 3：输入：queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],
[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],
[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
输出：[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]
提示：1 &lt;= queens.length &lt;= 63
queens[i].length == 2
0 &lt;= queens[i][j] &lt; 8
king.length == 2
0 &lt;= king[0], king[1] &lt; 8
一个棋盘格上最多只能放置一枚棋子。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">dir</span> <span class="p">=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}}</span>

<span class="kd">func</span> <span class="nx">queensAttacktheKing</span><span class="p">(</span><span class="nx">queens</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">king</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queens</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">queens</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">queens</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">][</span><span class="nx">b</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dir</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nx">dir</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">king</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">y</span> <span class="o">:=</span> <span class="nx">dir</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">king</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">for</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">})</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dir</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dir</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>1223.掷骰子模拟(2)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。
不过我们在使用它时有个约束，就是使得投掷骰子时，
连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。
现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。
由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。
示例 1：输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34
解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。
但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。
因此，最终答案是 36-2 = 34。
示例 2：输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30
示例 3：输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181
提示：1 &lt;= n &lt;= 5000
rollMax.length == 6
1 &lt;= rollMax[i] &lt;= 15
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func dieSimulator(n int, rollMax []int) int {
	dp := make([][7][16]int, n+1) // 第i轮,以j结尾,出现k次
	for j := 1; j &lt;= 6; j++ {
		dp[1][j][1] = 1
	}
	for i := 2; i &lt;= n; i++ {
		for j := 1; j &lt;= 6; j++ {
			for k := 1; k &lt;= rollMax[j-1] &amp;&amp; k &lt;= i; k++ {
				if k == 1 { // 不同情况
					for a := 1; a &lt;= 6; a++ {
						if a != j { // 考虑不同的情况
							for b := 1; b &lt;= rollMax[a-1] &amp;&amp; b &lt;= i-1; b++ {
								dp[i][j][k] = (dp[i][j][k] + dp[i-1][a][b]) % 1000000007
							}
						}
					}
				} else { // 直接同上一个
					dp[i][j][k] = dp[i-1][j][k-1]
				}
			}
		}
	}
	res := 0
	for j := 1; j &lt;= 6; j++ {
		for k := 1; k &lt;= 15; k++ {
			res = (res + dp[n][j][k]) % 1000000007
		}
	}
	return res
}

# 2
func dieSimulator(n int, rollMax []int) int {
	dp := [7][16]int{} // 以j结尾,出现k次
	for j := 1; j &lt;= 6; j++ {
		dp[j][1] = 1
	}
	for i := 2; i &lt;= n; i++ {
		temp := [7][16]int{}
		for j := 1; j &lt;= 6; j++ {
			for k := 1; k &lt;= rollMax[j-1] &amp;&amp; k &lt;= i; k++ {
				if k == 1 { // 不同情况
					for a := 1; a &lt;= 6; a++ {
						if a != j { // 考虑不同的情况
							for b := 1; b &lt;= rollMax[a-1] &amp;&amp; b &lt;= i-1; b++ {
								temp[j][k] = (temp[j][k] + dp[a][b]) % 1000000007
							}
						}
					}
				} else { // 直接同上一个
					temp[j][k] = dp[j][k-1]
				}
			}
		}
		dp = temp
	}
	res := 0
	for j := 1; j &lt;= 6; j++ {
		for k := 1; k &lt;= 15; k++ {
			res = (res + dp[j][k]) % 1000000007
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>1227.飞机座位分配概率(2)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
剩下的乘客将会：如果他们自己的座位还空着，就坐到自己的座位上，
    当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？
示例 1：输入：n = 1 输出：1.00000
解释：第一个人只会坐在自己的位置上。
示例 2：输入: n = 2 输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
提示：1 &lt;= n &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>找规律/数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递推</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func nthPersonGetsNthSeat(n int) float64 {
	if n == 1 {
		return 1
	}
	return 0.5
}

# 2
func nthPersonGetsNthSeat(n int) float64 {
	res := 1.0
	sum := 1.0
	// f(n) = 1/n * (f(n-1)+f(n-2)+f(n-3)+...+f(2)+1)
	for i := 2; i &lt;= n; i++ {
		nth := 1.0 / float64(i)
		res = nth * sum
		sum += res
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>1233.删除子文件夹(2)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，
并以 任意顺序 返回剩下的文件夹。
我们这样定义「子文件夹」：
如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的子文件夹。
文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：
/ 后跟一个或者多个小写英文字母。
例如，/leetcode 和 /leetcode/problems 都是有效的路径，而空字符串和 / 不是。
示例 1：输入：folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]
输出：[&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]
解释：&quot;/a/b/&quot; 是 &quot;/a&quot; 的子文件夹，而 &quot;/c/d/e&quot; 是 &quot;/c/d&quot; 的子文件夹。
示例 2：输入：folder = [&quot;/a&quot;,&quot;/a/b/c&quot;,&quot;/a/b/d&quot;] 输出：[&quot;/a&quot;]
解释：文件夹 &quot;/a/b/c&quot; 和 &quot;/a/b/d/&quot; 都会被删除，因为它们都是 &quot;/a&quot; 的子文件夹。
示例 3：输入：folder = [&quot;/a/b/c&quot;,&quot;/a/b/d&quot;,&quot;/a/b/ca&quot;]
输出：[&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]
提示：1 &lt;= folder.length &lt;= 4 * 10^4
2 &lt;= folder[i].length &lt;= 100
folder[i] 只包含小写字母和 /
folder[i] 总是以字符 / 起始
每个文件夹名都是唯一的
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeSubfolders(folder []string) []string {
	sort.Strings(folder)
	res := make([]string, 0)
	res = append(res, folder[0])
	prev := folder[0]
	for i := 1; i &lt; len(folder); i++ {
		// 加&#39;/&#39;避免/a/b =&gt; /a/bb的情况
		if strings.HasPrefix(folder[i], prev+&quot;/&quot;) == false {
			res = append(res, folder[i])
			prev = folder[i]
		}
	}
	return res
}

# 2
func removeSubfolders(folder []string) []string {
	res := make([]string, 0)
	m := make(map[string]bool)
	for i := 0; i &lt; len(folder); i++ {
		m[folder[i]] = true
	}
	arr := make([]int, len(folder))
	for i := 0; i &lt; len(folder); i++ {
		for j := 0; j &lt; len(folder[i]); j++ {
			if folder[i][j] == &#39;/&#39; &amp;&amp; j &gt; 0 &amp;&amp; m[folder[i][:j]] == true {
				arr[i] = 1
				break
			}
		}
	}
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == 0 {
			res = append(res, folder[i])
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>1234.替换子串得到平衡字符串(2)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个只含有 &#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39; 四种字符，且长度为 n 的字符串。
假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。
给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。
你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。
请返回待替换子串的最小可能长度。
如果原字符串自身就是一个平衡字符串，则返回 0。
示例 1：输入：s = &quot;QWER&quot; 输出：0
解释：s 已经是平衡的了。
示例 2：输入：s = &quot;QQWE&quot; 输出：1
解释：我们需要把一个 &#39;Q&#39; 替换成 &#39;R&#39;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。
示例 3：输入：s = &quot;QQQW&quot; 输出：2
解释：我们可以把前面的 &quot;QQ&quot; 替换成 &quot;ER&quot;。 
示例 4：输入：s = &quot;QQQQ&quot; 输出：3
解释：我们可以替换后 3 个 &#39;Q&#39;，使 s = &quot;QWER&quot;。
提示：1 &lt;= s.length &lt;= 10^5
s.length 是 4 的倍数
s 中只含有 &#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39; 四种字符
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func balancedString(s string) int {
	n := len(s)
	target := n / 4
	m := make(map[byte]int)
	for i := 0; i &lt; len(s); i++ {
		m[s[i]]++
	}
	if m[&#39;Q&#39;] == target &amp;&amp; m[&#39;W&#39;] == target &amp;&amp; m[&#39;E&#39;] == target &amp;&amp; m[&#39;R&#39;] == target {
		return 0
	}
	res := n
	left := 0
	for right := 0; right &lt; n; right++ {
		m[s[right]]--
		for left &lt; n &amp;&amp; left &lt;= right &amp;&amp; // [left,right]之间子串都是需要替换的（减去），使得m[x]&lt;=target
			m[&#39;Q&#39;] &lt;= target &amp;&amp; m[&#39;W&#39;] &lt;= target &amp;&amp;
			m[&#39;E&#39;] &lt;= target &amp;&amp; m[&#39;R&#39;] &lt;= target {
			res = min(res, right-left+1)
			m[s[left]]++
			left++
		}
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func balancedString(s string) int {
	n := len(s)
	target := n / 4
	m := make(map[byte]int)
	for i := 0; i &lt; len(s); i++ {
		m[s[i]]++
	}
	if m[&#39;Q&#39;] == target &amp;&amp; m[&#39;W&#39;] == target &amp;&amp; m[&#39;E&#39;] == target &amp;&amp; m[&#39;R&#39;] == target {
		return 0
	}
	res := n
	left := 0
	right := 0
	for left &lt; n {
		if m[&#39;Q&#39;] &gt; target || m[&#39;W&#39;] &gt; target || m[&#39;E&#39;] &gt; target || m[&#39;R&#39;] &gt; target {
			if right &lt; n {
				m[s[right]]--
				right++
			} else {
				break
			}
		} else {
			res = min(res, right-left)
			m[s[left]]++
			left++
		}
	}
	return res
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>1238.循环码排列(2)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p，并且满足：
p[0] = start
p[i] 和 p[i+1] 的二进制表示形式只有一位不同
p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同
示例 1：输入：n = 2, start = 3 输出：[3,2,0,1]
解释：这个排列的二进制表示是 (11,10,00,01)
     所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2]
示例 2：输出：n = 3, start = 2 输出：[2,6,7,5,4,0,1,3]
解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011)
提示：1 &lt;= n &lt;= 16
0 &lt;= start &lt; 2^n
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>格雷码+位运算</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
<tr>
<td>02</td>
<td>格雷码+位移</td>
<td>O(2^n)</td>
<td>O(2^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func circularPermutation(n int, start int) []int {
	total := 1 &lt;&lt; n
	res := make([]int, total)
	for i := 0; i &lt; total; i++ {
		// 计算格雷码：leetcode89.格雷编码
		res[i] = i ^ (i &gt;&gt; 1) ^ start // 在计算格雷码的基础上，再与start异或
	}
	return res
}

# 2
func circularPermutation(n int, start int) []int {
	total := 1 &lt;&lt; n
	res := []int{0, 1}
	for i := 2; i &lt;= n; i++ {
		// 计算格雷码：leetcode89.格雷编码
		for j := len(res) - 1; j &gt;= 0; j-- {
			res = append(res, res[j]+(1&lt;&lt;(i-1)))
		}
	}
	index := 0
	for i := 0; i &lt; total; i++ {
		if res[i] == start {
			index = i
			break
		}
	}
	return append(res[index:], res[:index]...)
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>1239.串联字符串的最大长度(3)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，
如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。
请返回所有可行解 s 中最长长度。
示例 1：输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;] 输出：4
解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。
示例 2：输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;] 输出：6
解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。
示例 3：输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;] 输出：26
提示：1 &lt;= arr.length &lt;= 16
1 &lt;= arr[i].length &lt;= 26
arr[i] 中只含有小写英文字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯-子集</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>02</td>
<td>回溯</td>
<td>O(n*2^n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>回溯</td>
<td>O(n*2^n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res []string

func maxLength(arr []string) int {
	res = make([]string, 0)
	dfs(arr, &quot;&quot;, 0)
	maxValue := 0
	for i := 0; i &lt; len(res); i++ {
		if check(res[i]) == true &amp;&amp; len(res[i]) &gt; maxValue {
			maxValue = len(res[i])
		}
	}
	return maxValue
}

func dfs(arr []string, path string, index int) {
	res = append(res, path)
	for i := index; i &lt; len(arr); i++ {
		dfs(arr, path+arr[i], i+1)
	}
}

func check(s string) bool {
	arr := [26]int{}
	for i := 0; i &lt; len(s); i++ {
		value := int(s[i] - &#39;a&#39;)
		arr[value]++
		if arr[value] &gt; 1 {
			return false
		}
	}
	return true
}

# 2
var res int

func maxLength(arr []string) int {
	res = 0
	dfs(arr, &quot;&quot;, 0)
	return res
}

func dfs(arr []string, path string, index int) {
	if check(path) == true &amp;&amp; len(path) &gt; res {
		res = len(path)
	}
	for i := index; i &lt; len(arr); i++ {
		dfs(arr, path+arr[i], i+1)
	}
}

func check(s string) bool {
	arr := [26]int{}
	for i := 0; i &lt; len(s); i++ {
		value := int(s[i] - &#39;a&#39;)
		arr[value]++
		if arr[value] &gt; 1 {
			return false
		}
	}
	return true
}

# 3
var res int

func maxLength(arr []string) int {
	res = 0
	dfs(arr, &quot;&quot;, 0)
	return res
}

func dfs(arr []string, path string, index int) {
	for i := index; i &lt; len(arr); i++ {
		newStr := path + arr[i]
		if check(newStr) == true {
			if len(newStr) &gt; res {
				res = len(newStr)
			}
			dfs(arr, path+arr[i], i+1)
		}
	}
}

func check(s string) bool {
	arr := [26]int{}
	for i := 0; i &lt; len(s); i++ {
		value := int(s[i] - &#39;a&#39;)
		arr[value]++
		if arr[value] &gt; 1 {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>1247.交换字符使得字符串相同(1)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 &quot;x&quot; 和 &quot;y&quot;，
你需要通过「交换字符」的方式使这两个字符串相同。
每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。
交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。
也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。
最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。
示例 1：输入：s1 = &quot;xx&quot;, s2 = &quot;yy&quot; 输出：1
解释：交换 s1[0] 和 s2[1]，得到 s1 = &quot;yx&quot;，s2 = &quot;yx&quot;。
示例 2：输入：s1 = &quot;xy&quot;, s2 = &quot;yx&quot; 输出：2
解释：交换 s1[0] 和 s2[0]，得到 s1 = &quot;yy&quot;，s2 = &quot;xx&quot; 。
交换 s1[0] 和 s2[1]，得到 s1 = &quot;xy&quot;，s2 = &quot;xy&quot; 。
注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &quot;yx&quot;，因为我们只能交换属于两个不同字符串的字符。
示例 3：输入：s1 = &quot;xx&quot;, s2 = &quot;xy&quot; 输出：-1
示例 4：输入：s1 = &quot;xxyyxyxyxx&quot;, s2 = &quot;xyyxyxxxyx&quot; 输出：4
提示：1 &lt;= s1.length, s2.length &lt;= 1000
s1, s2 只包含 &#39;x&#39; 或 &#39;y&#39;。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minimumSwap</span><span class="p">(</span><span class="nx">s1</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">s2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">s2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// 相同不需要交换</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="p">{</span>
			<span class="nx">a</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">b</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// a =&gt; x y</span>
	<span class="c1">// b =&gt; y x</span>
	<span class="k">if</span> <span class="nx">a</span><span class="o">%</span><span class="mi">2</span><span class="o">+</span><span class="nx">b</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">b</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="nx">a</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>1248.统计「优美子数组」(4)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 和一个整数 k。
如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。
请返回这个数组中「优美子数组」的数目。
示例 1：输入：nums = [1,1,2,1,1], k = 3 输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
示例 2：输入：nums = [2,4,6], k = 1 输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。
示例 3：输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16
提示：1 &lt;= nums.length &lt;= 50000
    1 &lt;= nums[i] &lt;= 10^5
    1 &lt;= k &lt;= nums.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>统计奇数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numberOfSubarrays(nums []int, k int) int {
	res := 0
	arr := make([]int, 0)
	arr = append(arr, -1)
	for i := 0; i &lt; len(nums); i++ {
		if nums[i]%2 == 1 {
			arr = append(arr, i)
		}
	}
	arr = append(arr, len(nums))
	for i := 1; i+k &lt; len(arr); i++ {
		res = res + (arr[i]-arr[i-1])*(arr[i+k]-arr[i+k-1])
	}
	return res
}

# 2
func numberOfSubarrays(nums []int, k int) int {
	res := 0
	arr := make([]int, len(nums)+1)
	arr[0] = 1
	sum := 0
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]%2
		arr[sum]++
		if sum &gt;= k {
			res = res + arr[sum-k]
		}
	}
	return res
}

# 3
func numberOfSubarrays(nums []int, k int) int {
	res := 0
	left, right := 0, 0
	count := 0
	for right &lt; len(nums) {
		if nums[right]%2 == 1 {
			count++
		}
		right++
		if count == k {
			temp := right
			for right &lt; len(nums) &amp;&amp; nums[right]%2 == 0 {
				right++
			}
			totalRight := right - temp + 1
			totalLeft := 1
			for nums[left]%2 == 0 {
				left++
				totalLeft++
			}
			res = res + totalLeft*totalRight
			count--
			left++
		}
	}
	return res
}

# 4
func numberOfSubarrays(nums []int, k int) int {
	res := 0
	dp := make([]int, 0)
	count := 0
	for i := 0; i &lt; len(nums); i++ {
		count++
		if nums[i]%2 == 1 {
			dp = append(dp, count)
			count = 0
		}
		if len(dp) &gt;= k {
			res = res + dp[len(dp)-k]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>1249.移除无效的括号(2)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个由 &#39;(&#39;、&#39;)&#39; 和小写字母组成的字符串 s。
你需要从字符串中删除最少数目的 &#39;(&#39; 或者 &#39;)&#39; （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。
请返回任意一个合法字符串。
有效「括号字符串」应当符合以下 任意一条 要求：
    空字符串或只包含小写字母的字符串
    可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
    可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
示例 1：输入：s = &quot;lee(t(c)o)de)&quot; 输出：&quot;lee(t(c)o)de&quot;
解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。
示例 2：输入：s = &quot;a)b(c)d&quot; 输出：&quot;ab(c)d&quot;
示例 3：输入：s = &quot;))((&quot; 输出：&quot;&quot;
解释：空字符串也是有效的
示例 4：输入：s = &quot;(a(b(c)d)&quot; 输出：&quot;a(b(c)d)&quot;
提示：1 &lt;= s.length &lt;= 10^5
    s[i] 可能是 &#39;(&#39;、&#39;)&#39; 或英文小写字母
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minRemoveToMakeValid(s string) string {
	arr := []byte(s)
	sum := 0
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == &#39;(&#39; {
			sum++
		} else if arr[i] == &#39;)&#39; {
			sum--
			if sum &lt; 0 {
				arr[i] = &#39; &#39;
				sum = 0
			}
		}
	}
	sum = 0
	for i := len(arr) - 1; i &gt;= 0; i-- {
		if arr[i] == &#39;)&#39; {
			sum++
		} else if arr[i] == &#39;(&#39; {
			sum--
			if sum &lt; 0 {
				arr[i] = &#39; &#39;
				sum = 0
			}
		}
	}
	return strings.ReplaceAll(string(arr), &quot; &quot;, &quot;&quot;)
}

# 2
func minRemoveToMakeValid(s string) string {
	arr := []byte(s)
	stack := make([]int, 0)
	for i := 0; i &lt; len(arr); i++ {
		if arr[i] == &#39;(&#39; {
			stack = append(stack, i)
		} else if arr[i] == &#39;)&#39; {
			if len(stack) == 0 {
				arr[i] = &#39; &#39;
			} else {
				stack = stack[:len(stack)-1]
			}
		}
	}
	for i := 0; i &lt; len(stack); i++ {
		arr[stack[i]] = &#39; &#39;
	}
	return strings.ReplaceAll(string(arr), &quot; &quot;, &quot;&quot;)
}
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>1253.重构2行二进制矩阵(2)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个 2 行 n 列的二进制数组：
矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。
第 0 行的元素之和为 upper。
第 1 行的元素之和为 lower。
第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。
你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。
如果有多个不同的答案，那么任意一个都可以通过本题。
如果不存在符合要求的答案，就请返回一个空的二维数组。
示例 1：输入：upper = 2, lower = 1, colsum = [1,1,1] 输出：[[1,1,0],[0,0,1]]
解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。
示例 2：输入：upper = 2, lower = 3, colsum = [2,2,1,1] 输出：[]
示例 3：输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]
提示：1 &lt;= colsum.length &lt;= 10^5
0 &lt;= upper, lower &lt;= colsum.length
0 &lt;= colsum[i] &lt;= 2
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func reconstructMatrix(upper int, lower int, colsum []int) [][]int {
	res := make([][]int, 0)
	total := 0
	two := 0
	for i := 0; i &lt; len(colsum); i++ {
		total = total + colsum[i]
		if colsum[i] == 2 {
			two++
		}
	}
	if total != upper+lower || two &gt; upper || two &gt; lower {
		return nil
	}
	up := make([]int, len(colsum))
	down := make([]int, len(colsum))
	upper = upper - two // 上面数组单独1的个数
	for i := 0; i &lt; len(colsum); i++ {
		if colsum[i] == 2 { // 2=&gt;各填充1
			up[i] = 1
			down[i] = 1
			lower--
		} else if colsum[i] == 1 {
			if upper &gt; 0 { // 先填充上面数组
				up[i] = 1
				upper--
			} else {
				down[i] = 1
			}
		}
	}
	res = append(res, up, down)
	return res
}

# 2
func reconstructMatrix(upper int, lower int, colsum []int) [][]int {
	res := make([][]int, 0)
	up := make([]int, len(colsum))
	down := make([]int, len(colsum))
	upSum := 0
	lowSum := 0
	total := 0
	for i := 0; i &lt; len(colsum); i++ {
		total = total + colsum[i]
		if colsum[i] == 2 { // 2=&gt;各填充1
			up[i] = 1
			down[i] = 1
			upSum++
			lowSum++
		}
	}
	if upSum &gt; upper || lowSum &gt; lower || total != upper+lower {
		return nil
	}
	for i := 0; i &lt; len(colsum); i++ {
		if colsum[i] == 1 {
			if upSum &lt; upper {
				up[i] = 1
				upSum++
			} else {
				down[i] = 1
			}
		}
	}
	res = append(res, up, down)
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>1254.统计封闭岛屿的数目(2)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。
我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。
如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。
请返回封闭岛屿的数目。
示例 1：输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],
[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 输出：2
解释：灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
示例 2：输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] 输出：1
示例 3：输入：grid = [[1,1,1,1,1,1,1],
             [1,0,0,0,0,0,1],
             [1,0,1,1,1,0,1],
             [1,0,1,0,1,0,1],
             [1,0,1,1,1,0,1],
             [1,0,0,0,0,0,1],
             [1,1,1,1,1,1,1]]
输出：2
提示： 1 &lt;= grid.length, grid[0].length &lt;= 100
    0 &lt;= grid[i][j] &lt;=1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func closedIsland(grid [][]int) int {
	res := 0
	for i := 0; i &lt; len(grid); i++ {
		for j := 0; j &lt; len(grid[i]); j++ {
			if grid[i][j] == 0 &amp;&amp; dfs(grid, i, j) == true {
				res++
			}
		}
	}
	return res
}

func dfs(grid [][]int, i, j int) bool {
	if i &lt; 0 || i &gt;= len(grid) || j &lt; 0 || j &gt;= len(grid[0]) {
		return false
	}
	if grid[i][j] == 1 {
		return true
	}
	grid[i][j] = 1
	up := dfs(grid, i, j+1)
	down := dfs(grid, i, j-1)
	left := dfs(grid, i-1, j)
	right := dfs(grid, i+1, j)
	return up &amp;&amp; down &amp;&amp; left &amp;&amp; right
}

# 2
var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func closedIsland(grid [][]int) int {
	res := 0
	for i := 0; i &lt; len(grid); i++ {
		for j := 0; j &lt; len(grid[i]); j++ {
			if grid[i][j] == 0 {
				flag := true
				queue := make([][2]int, 0)
				queue = append(queue, [2]int{i, j})
				if i == 0 || j == 0 || i == len(grid)-1 || j == len(grid[i])-1 {
					flag = false
				}
				for len(queue) &gt; 0 {
					node := queue[0]
					queue = queue[1:]
					for k := 0; k &lt; 4; k++ {
						x := dx[k] + node[0]
						y := dy[k] + node[1]
						if x &lt; 0 || x &gt;= len(grid) || y &lt; 0 || y &gt;= len(grid[i]) {
							continue
						}
						if grid[x][y] == 1 {
							continue
						}
						if x == 0 || y == 0 || x == len(grid)-1 || y == len(grid[i])-1 {
							flag = false
						}
						queue = append(queue, [2]int{x, y})
						grid[x][y] = 1
					}
				}
				if flag == true {
					res++
				}
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>1261.在受污染的二叉树中查找元素(2)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个满足下述规则的二叉树：
root.val == 0
如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1
如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2
现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。
请你先还原二叉树，然后实现 FindElements 类：
FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。
bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。
示例 1：输入： [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,null,-1]],[1],[2]]
输出：[null,false,true]
解释：FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 
示例 2：输入： [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
输出：[null,true,true,false]
解释：FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
示例 3：输入： [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
输出：[null,true,false,false,true]
解释：FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
提示：TreeNode.val == -1
二叉树的高度不超过 20
节点的总数在 [1, 10^4] 之间
调用 find() 的总次数在 [1, 10^4] 之间
0 &lt;= target &lt;= 10^6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type FindElements struct {
	m map[int]bool
}

type Node struct {
	root  *TreeNode
	index int
}

func Constructor(root *TreeNode) FindElements {
	if root == nil {
		return FindElements{m: map[int]bool{}}
	}
	m := make(map[int]bool)
	m[0] = true
	queue := make([]Node, 0)
	queue = append(queue, Node{root: root, index: 0})
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		var temp Node
		if node.root.Left != nil {
			temp = Node{
				root:  node.root.Left,
				index: node.index*2 + 1,
			}
			m[node.index*2+1] = true
		}
		if node.root.Right != nil {
			temp = Node{
				root:  node.root.Right,
				index: node.index*2 + 2,
			}
			m[node.index*2+2] = true
		}
		queue = append(queue, temp)
	}
	return FindElements{m: m}
}

func (this *FindElements) Find(target int) bool {
	return this.m[target]
}

# 2
type FindElements struct {
	num []int
}

type Node struct {
	root  *TreeNode
	index int
}

func Constructor(root *TreeNode) FindElements {
	if root == nil {
		return FindElements{num: []int{}}
	}
	num := make([]int, 0)
	num = append(num, 0)
	queue := make([]Node, 0)
	queue = append(queue, Node{
		root:  root,
		index: 0,
	})
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		if node.root.Left != nil {
			temp := Node{
				root:  node.root.Left,
				index: node.index*2 + 1,
			}
			num = append(num, node.index*2+1)
			queue = append(queue, temp)
		}
		if node.root.Right != nil {
			temp := Node{
				root:  node.root.Right,
				index: node.index*2 + 2,
			}
			num = append(num, node.index*2+2)
			queue = append(queue, temp)
		}
	}
	return FindElements{num: num}
}

func (this *FindElements) Find(target int) bool {
	for i := 0; i &lt; len(this.num); i++ {
		if this.num[i] == target {
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>1262.可被三整除的最大和(1)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。
示例 1：输入：nums = [3,6,5,1,8] 输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
示例 2：输入：nums = [4] 输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
示例 3：输入：nums = [1,2,3,4,4] 输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
提示：1 &lt;= nums.length &lt;= 4 * 10^4
1 &lt;= nums[i] &lt;= 10^4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxSumDivThree</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
			<span class="nx">value</span> <span class="o">:=</span> <span class="nx">v</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">%</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">%</span><span class="mi">3</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>1267.统计参与通信的服务器(1)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，
1 表示单元格上有服务器，0 表示没有。
如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。
请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。
示例 1：输入：grid = [[1,0],[0,1]] 输出：0
解释：没有一台服务器能与其他服务器进行通信。
示例 2：输入：grid = [[1,0],[1,1]] 输出：3
解释：所有这些服务器都至少可以与一台别的服务器进行通信。
示例 3：输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]] 输出：4
解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。
提示：m == grid.length
n == grid[i].length
1 &lt;= m &lt;= 250
1 &lt;= n &lt;= 250
grid[i][j] == 0 or 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countServers</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// 行</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// 列</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span>
				<span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">res</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>1276.不浪费原料的汉堡制作方案(1)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。
给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：
巨无霸汉堡：4 片番茄和 1 片奶酪
小皇堡：2 片番茄和 1 片奶酪
请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，
使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。
如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。
示例 1：输入：tomatoSlices = 16, cheeseSlices = 7 输出：[1,6]
解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。
示例 2：输入：tomatoSlices = 17, cheeseSlices = 4 输出：[]
解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。
示例 3：输入：tomatoSlices = 4, cheeseSlices = 17 输出：[]
解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。
示例 4：输入：tomatoSlices = 0, cheeseSlices = 0 输出：[0,0]
示例 5：输入：tomatoSlices = 2, cheeseSlices = 1 输出：[0,1]
提示：0 &lt;= tomatoSlices &lt;= 10^7
0 &lt;= cheeseSlices &lt;= 10^7
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">numOfBurgers</span><span class="p">(</span><span class="nx">tomatoSlices</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">cheeseSlices</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tomatoSlices</span><span class="p">,</span> <span class="nx">cheeseSlices</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="nx">b</span>
	<span class="k">if</span> <span class="nx">c</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">c</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">c</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>1282.用户分组(2)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。
给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，
请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。
你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。
示例 1：输入：groupSizes = [3,3,3,3,3,1,3] 输出：[[5],[0,1,2],[3,4,6]]
解释： 其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。
示例 2：输入：groupSizes = [2,1,3,3,3,2] 输出：[[1],[0,5],[2,3,4]]
提示：groupSizes.length == n
1 &lt;= n &lt;= 500
1 &lt;= groupSizes[i] &lt;= n
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func groupThePeople(groupSizes []int) [][]int {
	res := make([][]int, 0)
	m := make(map[int][]int)
	for i := 0; i &lt; len(groupSizes); i++ {
		m[groupSizes[i]] = append(m[groupSizes[i]], i)
	}
	for k, v := range m {
		for i := 0; i &lt; len(v); i = i + k {
			res = append(res, v[i:i+k])
		}
	}
	return res
}

# 2
func groupThePeople(groupSizes []int) [][]int {
	res := make([][]int, 0)
	m := make(map[int][]int)
	for i := 0; i &lt; len(groupSizes); i++ {
		m[groupSizes[i]] = append(m[groupSizes[i]], i)
		if groupSizes[i] == len(m[groupSizes[i]]) {
			res = append(res, m[groupSizes[i]])
			m[groupSizes[i]] = []int{}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>1288.删除被覆盖区间(4)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。
只有当 c &lt;= a 且 b &lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。
在完成所有删除操作后，请你返回列表中剩余区间的数目。
示例：输入：intervals = [[1,4],[3,6],[2,8]] 输出：2
解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。
提示：1 &lt;= intervals.length &lt;= 1000
0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5
对于所有的 i != j：intervals[i] != intervals[j]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeCoveredIntervals(intervals [][]int) int {
	sort.Slice(intervals, func(i, j int) bool {
		if intervals[i][0] == intervals[j][0] {
			return intervals[i][1] &gt; intervals[j][1]
		}
		return intervals[i][0] &lt; intervals[j][0]
	})
	res := 0
	maxValue := intervals[0][1]
	for i := 1; i &lt; len(intervals); i++ {
		if intervals[i][0] == intervals[i-1][0] { // 合并
			res++
			continue
		}
		if intervals[i][1] &gt; maxValue {
			maxValue = intervals[i][1] // 更新
		} else {
			res++ // 合并
		}
	}
	return len(intervals) - res
}

# 2
func removeCoveredIntervals(intervals [][]int) int {
	sort.Slice(intervals, func(i, j int) bool {
		if intervals[i][0] == intervals[j][0] {
			return intervals[i][1] &gt; intervals[j][1]
		}
		return intervals[i][0] &lt; intervals[j][0]
	})
	res := 0
	left := intervals[0][0]
	right := intervals[0][1]
	for i := 1; i &lt; len(intervals); i++ {
		l, r := intervals[i][0], intervals[i][1]
		if left &lt;= l &amp;&amp; r &lt;= right { // 合并
			res++
		}
		if right &lt; r { // 更新
			left = l
			right = r
		}
	}
	return len(intervals) - res
}

# 3
func removeCoveredIntervals(intervals [][]int) int {
	sort.Slice(intervals, func(i, j int) bool {
		if intervals[i][0] == intervals[j][0] {
			return intervals[i][1] &gt; intervals[j][1]
		}
		return intervals[i][0] &lt; intervals[j][0]
	})
	res := 0
	maxValue := 0
	for i := 0; i &lt; len(intervals); i++ {
		if maxValue &lt; intervals[i][1] {
			res++
			maxValue = intervals[i][1]
		}
	}
	return res
}

# 4
func removeCoveredIntervals(intervals [][]int) int {
	res := len(intervals)
	for i := 0; i &lt; len(intervals); i++ {
		for j := 0; j &lt; len(intervals); j++ {
			if i != j &amp;&amp; intervals[j][0] &lt;= intervals[i][0] &amp;&amp;
				intervals[i][1] &lt;= intervals[j][1] {
				res--
				break
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>1291.顺次数(2)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。
请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。
示例 1：输出：low = 100, high = 300输出：[123,234]
示例 2：输出：low = 1000, high = 13000 输出：[1234,2345,3456,4567,5678,6789,12345]
提示： 10 &lt;= low &lt;= high &lt;= 10^9
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>枚举</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>枚举</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func sequentialDigits(low int, high int) []int {
	res := make([]int, 0)
	for i := 1; i &lt;= 9; i++ {
		num := i
		for j := i + 1; j &lt;= 9; j++ {
			num = num*10 + j
			if num &gt;= low &amp;&amp; num &lt;= high {
				res = append(res, num)
			}
		}
	}
	sort.Ints(res)
	return res
}

# 2
func sequentialDigits(low int, high int) []int {
	res := make([]int, 0)
	str := &quot;123456789&quot;
	for i := 0; i &lt;= 9; i++ {
		for j := i + 1; j &lt;= 9; j++ {
			num, _ := strconv.Atoi(str[i:j])
			if num &gt;= low &amp;&amp; num &lt;= high {
				res = append(res, num)
			}
		}
	}
	sort.Ints(res)
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>1296.划分数组为连续数字的集合(3)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。
如果可以，请返回 True；否则，返回 False。
注意：此题目与 846 重复
示例 1：输入：nums = [1,2,3,3,4,4,5,6], k = 4 输出：true
解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。
示例 2：输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3 输出：true
解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。
示例 3：输入：nums = [3,3,2,2,1,1], k = 3 输出：true
示例 4：输入：nums = [1,2,3,4], k = 3 输出：false
解释：数组不能分成几个大小为 3 的子数组。
提示：1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i] &lt;= 10^9
1 &lt;= k &lt;= nums.length。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>哈希辅助</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isPossibleDivide(nums []int, k int) bool {
	n := len(nums)
	if n%k != 0 {
		return false
	}
	if k == 1 {
		return true
	}
	sort.Ints(nums)
	for i := 0; i &lt; n; i++ {
		if nums[i] &gt;= 0 {
			count := 1
			for j := i + 1; j &lt; n; j++ {
				if nums[j] &gt; nums[i]+count {
					break
				}
				if nums[j] &gt;= 0 &amp;&amp; nums[j] == nums[i]+count {
					nums[j] = -1
					count++
					if count == k {
						break
					}
				}
			}
			if count != k {
				return false
			}
			nums[i] = -1
		}
	}
	return true
}

# 2
func isPossibleDivide(nums []int, k int) bool {
	n := len(nums)
	if n%k != 0 {
		return false
	}
	if k == 1 {
		return true
	}
	arr := make([]int, 0)
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		if m[nums[i]] == 0 {
			arr = append(arr,nums[i])
		}
		m[nums[i]]++
	}
	sort.Ints(arr)
	for i := 0; i &lt; len(arr); i++ {
		if m[arr[i]] &gt; 0 {
			for j := 1; j &lt; k; j++ {
				value := arr[i] + j
				m[value] = m[value] - m[arr[i]]
				if m[value] &lt; 0 {
					return false
				}
			}
		}
	}
	return true
}

# 3
func isPossibleDivide(nums []int, k int) bool {
	n := len(nums)
	if n%k != 0 {
		return false
	}
	if k == 1 {
		return true
	}
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		m[nums[i]]++
	}
	sort.Ints(nums)
	for i := 0; i &lt; len(nums); i++ {
		value := m[nums[i]]
		if value &gt; 0 {
			for j := 0; j &lt; k; j++ {
				if m[nums[i]+j] &lt; value {
					return false
				}
				m[nums[i]+j] = m[nums[i]+j] - value
			}
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>1297.子串的最大出现次数(2)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：
子串中不同字母的数目必须小于等于 maxLetters 。
子串的长度必须大于等于 minSize 且小于等于 maxSize 。
示例 1：输入：s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4 输出：2
解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。
它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。
示例 2：输入：s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3 输出：2
解释：子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。
示例 3：输入：s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3 输出：3
示例 4：输入：s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3 输出：0
提示：1 &lt;= s.length &lt;= 10^5
1 &lt;= maxLetters &lt;= 26
1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)
s 只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>滑动窗口</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>固定窗口</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxFreq(s string, maxLetters int, minSize int, maxSize int) int {
	res := 0
	m := make(map[string]int)
	window := make(map[byte]int)
	count := 0
	left := 0
	for i := 0; i &lt; len(s); i++ {
		window[s[i]]++
		if window[s[i]] == 1 {
			count++
		}
		length := i - left + 1
		if length &lt; minSize {
			continue
		}
		if length &gt; minSize { // 滑动窗口左边=&gt;右移
			window[s[left]]--
			if window[s[left]] == 0 {
				count--
			}
			left++
			length--
		}
		// 只考虑最小值minSize，例如：minSize=2, maxSize=3
		// 如果abc出现3次，那么代表ab至少出现&gt;=3次
		if count &lt;= maxLetters {
			m[s[left:i+1]]++
		}
	}
	for _, v := range m {
		res = max(res, v)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maxFreq(s string, maxLetters int, minSize int, maxSize int) int {
	res := 0
	m := make(map[string]int)
	for i := 0; i &lt;= len(s)-minSize; i++ {
		str := s[i : i+minSize]
		count := getCount(str)
		// 只考虑最小值minSize，例如：minSize=2, maxSize=3
		// 如果abc出现3次，那么代表ab至少出现&gt;=3次
		if count &lt;= maxLetters {
			m[str]++
		}
	}
	for _, v := range m {
		res = max(res, v)
	}
	return res
}

func getCount(str string) int {
	m := make(map[byte]int)
	for i := 0; i &lt; len(str); i++ {
		m[str[i]]++
	}
	return len(m)
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>1300.转变数组后最接近目标值的数组和(3)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，
使得将数组中所有大于 value 的值变成 value 后，
数组的和最接近  target （最接近表示两者之差的绝对值最小）。
如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。
请注意，答案不一定是 arr 中的数字。
示例 1：输入：arr = [4,9,3], target = 10 输出：3
解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。
示例 2：输入：arr = [2,3,5], target = 10 输出：5
示例 3：输入：arr = [60864,25176,27249,21296,20204], target = 56803 输出：11361
提示：
    1 &lt;= arr.length &lt;= 10^4
    1 &lt;= arr[i], target &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findBestValue(arr []int, target int) int {
	sort.Ints(arr)
	n := len(arr)
	temp := make([]int, n+1)
	for i := 1; i &lt;= n; i++ {
		temp[i] = temp[i-1] + arr[i-1]
	}
	right := arr[n-1]
	res := 0
	diff := target
	for i := 1; i &lt;= right; i++ {
		index := sort.SearchInts(arr, i)
		if index &lt; 0 {
			index = abs(index) - 1
		}
		total := temp[index] + (n-index)*i
		if abs(total-target) &lt; diff {
			diff = abs(total - target)
			res = i
		}
	}
	return res
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}

# 2
func findBestValue(arr []int, target int) int {
	sort.Ints(arr)
	n := len(arr)
	temp := make([]int, n+1)
	for i := 1; i &lt;= n; i++ {
		temp[i] = temp[i-1] + arr[i-1]
	}
	left, right := 0, arr[n-1]
	res := 0
	for left &lt;= right {
		mid := left + (right-left)/2
		index := sort.SearchInts(arr, mid)
		if index &lt; 0 {
			index = abs(index) - 1
		}
		total := temp[index] + (n-index)*mid
		if total &lt;= target {
			res = mid
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	a := getSum(arr, res)
	b := getSum(arr, res+1)
	if abs(a-target) &gt; abs(b-target) {
		return res + 1
	}
	return res
}

func getSum(nums []int, target int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] &lt;= target {
			res = res + nums[i]
		} else {
			res = res + target
		}
	}
	return res
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}

# 3
func findBestValue(arr []int, target int) int {
	sort.Ints(arr)
	n := len(arr)
	res := target / n
	diff := target + 1
	for {
		a := getSum(arr, res)
		if diff &lt;= abs(target-a) {
			return res - 1
		}
		diff = abs(target - a)
		res = res + 1
	}
	return res
}

func getSum(nums []int, target int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] &lt;= target {
			res = res + nums[i]
		} else {
			res = res + target
		}
	}
	return res
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>1201-1300-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="id41">
<h2>1235.规划兼职工作(4)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你打算利用空闲时间来做兼职工作赚些零花钱。
这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。
给你一份兼职工作表，包含开始时间 startTime，
结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。
注意，时间上出现重叠的 2 份工作不能同时进行。
如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。
示例 1：输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] 输出：120
解释：我们选出第 1 份和第 4 份工作， 
时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。
示例 2：输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
输出：150
解释：我们选择第 1，4，5 份工作。 
共获得报酬 150 = 20 + 70 + 60。
示例 3：输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] 输出：6
提示：1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10^4
1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9
1 &lt;= profit[i] &lt;= 10^4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type Node struct {
	startTime int
	endTime   int
	profit    int
}

func jobScheduling(startTime []int, endTime []int, profit []int) int {
	n := len(startTime)
	arr := make([]Node, 0)
	for i := 0; i &lt; n; i++ {
		arr = append(arr, Node{
			startTime: startTime[i],
			endTime:   endTime[i],
			profit:    profit[i],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		if arr[i].endTime == arr[j].endTime {
			return arr[i].startTime &lt; arr[j].startTime
		}
		return arr[i].endTime &lt; arr[j].endTime
	})
	dp := make([]int, n)
	maxValue := 0
	for i := 0; i &lt; n; i++ {
		dp[i] = arr[i].profit
		for j := i - 1; j &gt;= 0; j-- {
			if arr[j].endTime &lt;= arr[i].startTime {
				dp[i] = max(dp[i], dp[j]+arr[i].profit)
				break
			}
		}
		dp[i] = max(dp[i], maxValue)
		maxValue = max(maxValue, dp[i])
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
type Node struct {
	startTime int
	endTime   int
	profit    int
}

func jobScheduling(startTime []int, endTime []int, profit []int) int {
	n := len(startTime)
	arr := make([]Node, 0)
	for i := 0; i &lt; n; i++ {
		arr = append(arr, Node{
			startTime: startTime[i],
			endTime:   endTime[i],
			profit:    profit[i],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		if arr[i].endTime == arr[j].endTime {
			return arr[i].startTime &lt; arr[j].startTime
		}
		return arr[i].endTime &lt; arr[j].endTime
	})
	for i := 1; i &lt; n; i++ {
		target := sort.Search(i, func(j int) bool {
			return arr[j].endTime &gt; arr[i].startTime
		})
		if target == 0 {
			arr[i].profit = max(arr[i].profit, arr[i-1].profit)
		} else {
			arr[i].profit = max(arr[i].profit+arr[target-1].profit, arr[i-1].profit)
		}
	}
	return arr[n-1].profit
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
type Node struct {
	startTime int
	endTime   int
	profit    int
}

func jobScheduling(startTime []int, endTime []int, profit []int) int {
	n := len(startTime)
	arr := make([]Node, 0)
	for i := 0; i &lt; n; i++ {
		arr = append(arr, Node{
			startTime: startTime[i],
			endTime:   endTime[i],
			profit:    profit[i],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		if arr[i].endTime == arr[j].endTime {
			return arr[i].startTime &lt; arr[j].startTime
		}
		return arr[i].endTime &lt; arr[j].endTime
	})
	dp := make([]int, n)
	dp[0] = arr[0].profit
	for i := 1; i &lt; n; i++ {
		dp[i] = dp[i-1] 
		dp[i] = max(dp[i], arr[i].profit)
		for j := i - 1; j &gt;= 0; j-- {
			if arr[j].endTime &lt;= arr[i].startTime {
				dp[i] = max(dp[i], dp[j]+arr[i].profit) 
				break
			}
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 4
type Node struct {
	startTime int
	endTime   int
	profit    int
}

func jobScheduling(startTime []int, endTime []int, profit []int) int {
	n := len(startTime)
	arr := make([]Node, 0)
	for i := 0; i &lt; n; i++ {
		arr = append(arr, Node{
			startTime: startTime[i],
			endTime:   endTime[i],
			profit:    profit[i],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		if arr[i].endTime == arr[j].endTime {
			return arr[i].startTime &lt; arr[j].startTime
		}
		return arr[i].endTime &lt; arr[j].endTime
	})
	dp := make([]int, n)
	dp[0] = arr[0].profit
	for i := 1; i &lt; n; i++ {
		left, right := 0, i-1
		for left &lt; right {
			mid := left + (right-left)/2
			if arr[mid+1].endTime &lt;= arr[i].startTime {
				left = mid + 1
			} else {
				right = mid
			}
		}
		if arr[left].endTime &lt;= arr[i].startTime {
			dp[i] = max(dp[i-1], dp[left]+arr[i].profit)
		} else {
			dp[i] = max(dp[i-1], arr[i].profit)
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="1301-1400.html" class="btn btn-neutral float-right" title="1301-1400-Easy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="1101-1200.html" class="btn btn-neutral float-left" title="1101-1200-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>