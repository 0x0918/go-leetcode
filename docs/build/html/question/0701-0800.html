

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>0701-0800-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="0801-0900-Easy" href="0801-0900.html" />
    <link rel="prev" title="0601-0700-Easy" href="0601-0700.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">0701-0800-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#k-2">703.数据流中的第K大元素(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">704.二分查找(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">705.设计哈希集合(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">706.设计哈希映射(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">709.转换成小写字母(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">717.1比特与2比特字符(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">720.词典中最长的单词(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">724.寻找数组的中心索引(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">728.自除数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">733.图像渲染(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">744.寻找比目标字母大的最小字母(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">746.使用最小花费爬楼梯(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">747.至少是其他数字两倍的最大数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">748.最短完整词(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">762.二进制表示中质数个计算置位(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">766.托普利茨矩阵(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">771.宝石与石头(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">783.二叉搜索树节点最小距离(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">784.字母大小写全排列(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19">788.旋转数字(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">796.旋转字符串(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">0701-0800-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id21">701.二叉搜索树中的插入操作(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ascii-3">712.两个字符串的最小ASCII删除和(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-1">713.乘积小于K的子数组(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">714.买卖股票的最佳时机含手续费(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">718.最长重复子数组(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">721.账户合并(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">722.删除注释(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">725.分隔链表(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">735.行星碰撞(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">738.单调递增的数字(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">739.每日温度(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">740.删除与获得点数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">752.打开转盘锁(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">763.划分字母区间(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">767.重构字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">769.最多能完成排序的块(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">775.全局倒置与局部倒置(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lr-1">777.在LR字符串中交换相邻字符(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-3">779.第K个语法符号(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">781.森林中的兔子(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">790.多米诺和托米诺平铺(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">791.自定义字符串排序(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">792.匹配子序列的单词数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">797. 所有可能的路径(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id41">799.香槟塔(1)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">0701-0800-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id42">710.黑名单中的随机数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43">765.情侣牵手(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>0701-0800-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/0701-0800.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>0701-0800-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#0701-0800-easy">0701-0800-Easy</a><ul>
<li><a class="reference external" href="#703%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A02">703.数据流中的第K大元素(2)</a></li>
<li><a class="reference external" href="#704%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE3">704.二分查找(3)</a></li>
<li><a class="reference external" href="#705%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%882">705.设计哈希集合(2)</a></li>
<li><a class="reference external" href="#706%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%842">706.设计哈希映射(2)</a></li>
<li><a class="reference external" href="#709%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D2">709.转换成小写字母(2)</a></li>
<li><a class="reference external" href="#7171%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A63">717.1比特与2比特字符(3)</a></li>
<li><a class="reference external" href="#720%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D2">720.词典中最长的单词(2)</a></li>
<li><a class="reference external" href="#724%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%952">724.寻找数组的中心索引(2)</a></li>
<li><a class="reference external" href="#728%E8%87%AA%E9%99%A4%E6%95%B02">728.自除数(2)</a></li>
<li><a class="reference external" href="#733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%932">733.图像渲染(2)</a></li>
<li><a class="reference external" href="#744%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D3">744.寻找比目标字母大的最小字母(3)</a></li>
<li><a class="reference external" href="#746%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF3">746.使用最小花费爬楼梯(3)</a></li>
<li><a class="reference external" href="#747%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B03">747.至少是其他数字两倍的最大数(3)</a></li>
<li><a class="reference external" href="#748%E6%9C%80%E7%9F%AD%E5%AE%8C%E6%95%B4%E8%AF%8D3">748.最短完整词(3)</a></li>
<li><a class="reference external" href="#762%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D2">762.二进制表示中质数个计算置位(2)</a></li>
<li><a class="reference external" href="#766%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B52">766.托普利茨矩阵(2)</a></li>
<li><a class="reference external" href="#771%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B43">771.宝石与石头(3)</a></li>
<li><a class="reference external" href="#783%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB3">783.二叉搜索树节点最小距离(3)</a></li>
<li><a class="reference external" href="#784%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%974">784.字母大小写全排列(4)</a></li>
<li><a class="reference external" href="#788%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%974">788.旋转数字(4)</a></li>
<li><a class="reference external" href="#796%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22">796.旋转字符串(2)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0701-0800-medium">0701-0800-Medium</a><ul>
<li><a class="reference external" href="#714%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B92">714.买卖股票的最佳时机含手续费(2)</a></li>
<li><a class="reference external" href="#718%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%843">718.最长重复子数组(3)</a></li>
<li><a class="reference external" href="#739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A63">739.每日温度(3)</a></li>
<li><a class="reference external" href="#752%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%811">752.打开转盘锁(1)</a></li>
<li><a class="reference external" href="#779%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B73">779.第K个语法符号(3)</a></li>
</ul>
</li>
</ul>
<div class="section" id="k-2">
<h2>703.数据流中的第K大元素(2)<a class="headerlink" href="#k-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。
你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。
每次调用 KthLargest.add，返回当前数据流中第K大的元素。

示例:
int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8
说明:
你可以假设 nums 的长度≥ k-1 且k ≥ 1。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>最小堆+内置heap</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>小根堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type KthLargest struct {
	k    int
	heap intHeap
}

func Constructor(k int, nums []int) KthLargest {
	h := intHeap(nums)
	heap.Init(&amp;h)

	for len(h) &gt; k {
		heap.Pop(&amp;h)
	}
	return KthLargest{
		k:    k,
		heap: h,
	}
}

func (k *KthLargest) Add(val int) int {
	heap.Push(&amp;k.heap, val)
	if len(k.heap) &gt; k.k {
		heap.Pop(&amp;k.heap)
	}
	return k.heap[0]
}

// 内置heap，实现接口
/*
type Interface interface {
	sort.Interface
	Push(x interface{}) // add x as element Len()
	Pop() interface{}   // remove and return element Len() - 1.
}
*/
type intHeap []int

func (h intHeap) Len() int {
	return len(h)
}

func (h intHeap) Less(i, j int) bool {
	return h[i] &lt; h[j]
}

func (h intHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *intHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *intHeap) Pop() interface{} {
	res := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return res
}

#
type KthLargest struct {
	nums []int
	k    int
}

func Constructor(k int, nums []int) KthLargest {
	if k &lt; len(nums) {
		sort.Ints(nums)
		nums = nums[len(nums)-k:]
	}
	// 向上调整
	Up(nums)
	return KthLargest{
		nums: nums,
		k:    k,
	}
}

func (k *KthLargest) Add(val int) int {
	if k.k &gt; len(k.nums) {
		k.nums = append(k.nums, val)
		Up(k.nums)
	} else {
		if val &gt; k.nums[0] {
			// 在堆顶，向下调整
			k.nums[0] = val
			Down(k.nums, 0)
		}
	}
	return k.nums[0]
}

func Down(nums []int, index int) {
	length := len(nums)
	minIndex := index
	for {
		left := 2*index + 1
		right := 2*index + 2
		if left &lt; length &amp;&amp; nums[left] &lt; nums[minIndex] {
			minIndex = left
		}
		if right &lt; length &amp;&amp; nums[right] &lt; nums[minIndex] {
			minIndex = right
		}
		if minIndex == index {
			break
		}
		swap(nums, index, minIndex)
		index = minIndex
	}
}

func Up(nums []int) {
	length := len(nums)
	for i := length/2 - 1; i &gt;= 0; i-- {
		minIndex := i
		left := 2*i + 1
		right := 2*i + 2
		if left &lt; length &amp;&amp; nums[left] &lt; nums[minIndex] {
			minIndex = left
		}
		if right &lt; length &amp;&amp; nums[right] &lt; nums[minIndex] {
			minIndex = right
		}
		if i != minIndex {
			swap(nums, i, minIndex)
		}
	}
}

func swap(nums []int, i, j int) {
	nums[i], nums[j] = nums[j], nums[i]
}
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h2>704.二分查找(3)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，
写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例 1:输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1
解释: 2 不存在 nums 中因此返回 -1
提示：
    你可以假设 nums 中的所有元素是不重复的。
    n 将在 [1, 10000]之间。
    nums 的每个元素都将在 [-9999, 9999]之间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
func search(nums []int, target int) int {
	left, right:= 0, len(nums)-1
	for left &lt;= right {
		mid := left + (right-left) / 2
		switch {
		case nums[mid] &lt; target:
			left = mid + 1
		case nums[mid] &gt; target:
			right = mid - 1
		default:
			return mid
		}
	}
	return -1
}

#
func search(nums []int, target int) int {
	if nums[0] &gt; target || nums[len(nums)-1] &lt; target {
		return -1
	}
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] == target {
			return i
		}
		if nums[i] &gt; target {
			return -1
		}
	}
	return -1
}

#
func search(nums []int, target int) int {
	if len(nums) == 0 {
		return -1
	}
	mid := len(nums) / 2
	if nums[mid] == target {
		return mid
	} else if nums[mid] &gt; target {
		return search(nums[:mid], target)
	} else {
		result := search(nums[mid+1:], target)
		if result == -1 {
			return result
		}
		return mid + 1 + result
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>705.设计哈希集合(2)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>不使用任何内建的哈希表库设计一个哈希集合
具体地说，你的设计应该包含以下的功能
    add(value)：向哈希集合中插入一个值。
    contains(value) ：返回哈希集合中是否存在这个值。
    remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。
示例:
MyHashSet hashSet = new MyHashSet();
hashSet.add(1);         
hashSet.add(2);         
hashSet.contains(1);    // 返回 true
hashSet.contains(3);    // 返回 false (未找到)
hashSet.add(2);          
hashSet.contains(2);    // 返回 true
hashSet.remove(2);          
hashSet.contains(2);    // 返回  false (已经被删除)
注意：
    所有的值都在 [0, 1000000]的范围内。
    操作的总数目在[1, 10000]范围内。
    不要使用内建的哈希集合库。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组实现</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>数组实现</td>
<td>O(n^1/2)</td>
<td>)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type MyHashSet struct {
	table []bool
}

func Constructor() MyHashSet {
	return MyHashSet{
		table: make([]bool, 1000001),
	}
}

func (m *MyHashSet) Add(key int) {
	m.table[key] = true
}

func (m *MyHashSet) Remove(key int) {
	m.table[key] = false
}

func (m *MyHashSet) Contains(key int) bool {
	return m.table[key]
}

#
type MyHashSet struct {
	table [10000][]int
}

func Constructor() MyHashSet {
	return MyHashSet{
		table: [10000][]int{},
	}
}

func (m *MyHashSet) Add(key int) {
	for _, v := range m.table[key%10000] {
		if v == key {
			return
		}
	}
	m.table[key%10000] = append(m.table[key%10000], key)
}

func (m *MyHashSet) Remove(key int) {
	for k, v := range m.table[key%10000] {
		if v == key {
			m.table[key%10000] = append(m.table[key%10000][:k], m.table[key%10000][k+1:]...)
		}
	}
}

func (m *MyHashSet) Contains(key int) bool {
	for _, v := range m.table[key%10000] {
		if v == key {
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>706.设计哈希映射(2)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>具体地说，你的设计应该包含以下的功能
    put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。
    get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。
    remove(key)：如果映射中存在这个键，删除这个数值对。
示例：
MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // 返回 1
hashMap.get(3);            // 返回 -1 (未找到)
hashMap.put(2, 1);         // 更新已有的值
hashMap.get(2);            // 返回 1 
hashMap.remove(2);         // 删除键为2的数据
hashMap.get(2);            // 返回 -1 (未找到) 
注意：
    所有的值都在 [0, 1000000]的范围内。
    操作的总数目在[1, 10000]范围内。
    不要使用内建的哈希库。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组实现</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>数组实现</td>
<td>O(n^1/2)</td>
<td>O(n^1/2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type MyHashMap struct {
	table []int
}

func Constructor() MyHashMap {
	return MyHashMap{
		table: make([]int, 1000001),
	}
}

func (this *MyHashMap) Put(key int, value int) {
	this.table[key] = value + 1
}

func (this *MyHashMap) Get(key int) int {
	return this.table[key] - 1
}

func (this *MyHashMap) Remove(key int) {
	this.table[key] = 0
}

#
type MyHashMap struct {
	keys  [10000][]int
	value [10000][]int
}

func Constructor() MyHashMap {
	return MyHashMap{
		keys:  [10000][]int{},
		value: [10000][]int{},
	}
}

func (m *MyHashMap) Put(key int, value int) {
	for k, v := range m.keys[key%10000] {
		if v == key {
			m.value[key%10000][k] = value
			return
		}
	}
	m.keys[key%10000] = append(m.keys[key%10000], key)
	m.value[key%10000] = append(m.value[key%10000], value)
}

func (m *MyHashMap) Get(key int) int {
	for k, v := range m.keys[key%10000] {
		if v == key {
			return m.value[key%10000][k]
		}
	}
	return -1
}

func (m *MyHashMap) Remove(key int) {
	for k, v := range m.keys[key%10000] {
		if v == key {
			m.keys[key%10000] = append(m.keys[key%10000][:k], m.keys[key%10000][k+1:]...)
			m.value[key%10000] = append(m.value[key%10000][:k], m.value[key%10000][k+1:]...)
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>709.转换成小写字母(2)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，
并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。

示例 1：输入: &quot;Hello&quot; 输出: &quot;hello&quot;
示例 2：输入: &quot;here&quot; 输出: &quot;here&quot;
示例 3：输入: &quot;LOVELY&quot; 输出: &quot;lovely&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func toLowerCase(str string) string {
	return strings.ToLower(str)
}

#
func toLowerCase(str string) string {
	arr := []byte(str)
	for i := 0; i &lt; len(arr); i++{
		if arr[i] &gt;=&#39;A&#39; &amp;&amp; arr[i] &lt;= &#39;Z&#39;{
			arr[i] = arr[i] - &#39;A&#39; + &#39;a&#39;
		}
	}
	return string(arr)
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>717.1比特与2比特字符(3)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。
示例 1:输入: bits = [1, 0, 0] 输出: True
解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
示例 2:输入: bits = [1, 1, 1, 0] 输出: False
解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。
注意:
    1 &lt;= len(bits) &lt;= 1000.
    bits[i] 总是0 或 1.
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isOneBitCharacter(bits []int) bool {
	n := len(bits)
	i := 0
	for i &lt; n-1 {
		// 逢1加2,0加1位
		if bits[i] == 1 {
			i = i + 2
		} else {
			i++
		}
	}
	return i == n-1
}

#
func isOneBitCharacter(bits []int) bool {
	n := len(bits)
	count := 0
	// 统计末尾1的个数，偶数正确，奇数错误
	for i := n - 2; i &gt;= 0; i-- {
		if bits[i] == 0 {
			break
		} else {
			count++
		}
	}
	// return count &amp; 1 == 0
	return count%2 == 0
}

#
func isOneBitCharacter(bits []int) bool {
	return helper(bits, 0)
}

func helper(bits []int, left int) bool {
	if left == len(bits)-1 {
		return bits[left] == 0
	}
	if left &lt; len(bits)-1 {
		if bits[left] == 0 {
			return helper(bits, left+1)
		}
		if bits[left] == 1 {
			return helper(bits, left+2)
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>720.词典中最长的单词(2)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个字符串数组words组成的一本英语词典。
从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。
若其中有多个可行的答案，则返回答案中字典序最小的单词。
若无答案，则返回空字符串。

示例 1:输入: words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;] 输出: &quot;world&quot;
解释: 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。
示例 2:输入: words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;] 输出: &quot;apple&quot;
解释:  &quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;得字典序小于&quot;apply&quot;。
注意:
    所有输入的字符串都只包含小写字母。
    words数组长度范围为[1,1000]。
    words[i]的长度范围为[1,30]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序+遍历</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>trie树</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestWord(words []string) string {
	if len(words) == 0 {
		return &quot;&quot;
	} else if len(words) == 1 &amp;&amp; len(words[0]) &gt; 1 {
		return &quot;&quot;
	}
	sort.Strings(words)
	m := make(map[string]bool)
	res := words[0]
	for _, w := range words {
		n := len(w)
		if n == 1 {
			m[w] = true
		} else if m[w[:n-1]] {
			m[w] = true
			if len(res) &lt; len(w) {
				res = w
			}
		}
	}
	return res
}

#
type Trie struct {
	children [26]*Trie
	index    int
}

func Constructor(str string) Trie {
	return Trie{}
}

func (t *Trie) insert(str string, index int) {
	cur := t
	for i := 0; i &lt; len(str); i++ {
		j := str[i] - &#39;a&#39;
		if cur.children[j] == nil {
			cur.children[j] = &amp;Trie{}
		}
		cur = cur.children[j]
	}
	cur.index = index
}

func (t *Trie) bfs(words []string) string {
	res := &quot;&quot;
	stack := make([]*Trie, 0)
	stack = append(stack, t)
	for len(stack) &gt; 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]

		if node.index &gt; 0 || node == t {
			if node != t {
				word := words[node.index-1]
				if len(word) &gt; len(res) || (len(word) == len(res) &amp;&amp; word &lt; res) {
					res = word
				}
			}
			for i := 0; i &lt; len(node.children); i++ {
				if node.children[i] != nil {
					stack = append(stack, node.children[i])
				}
			}
		}
	}
	return res
}

func longestWord(words []string) string {
	t := Trie{}
	for i := 0; i &lt; len(words); i++ {
		t.insert(words[i], i+1)
	}
	return t.bfs(words)
}
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>724.寻找数组的中心索引(2)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。
我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。
如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

示例 1:输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3
解释:  索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。
同时, 3 也是第一个符合要求的中心索引。
示例 2:输入: nums = [1, 2, 3] 输出: -1
解释: 数组中不存在满足此条件的中心索引。
说明:
    nums 的长度范围为 [0, 10000]。
    任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func pivotIndex(nums []int) int {
	sum := 0
	for i := range nums {
		sum = sum + nums[i]
	}
	left := 0
	for i := range nums {
		if left*2+nums[i] == sum {
			return i
		}
		left = left + nums[i]
	}
	return -1
}

#
func pivotIndex(nums []int) int {
	if len(nums) == 0 {
		return -1
	}
	arr := make([]int, len(nums))
	arr[0] = nums[0]
	for i := 1; i &lt; len(nums); i++ {
		arr[i] = arr[i-1] + nums[i]
	}
	for i := 0; i &lt; len(nums); i++ {
		var left, right int
		if i == 0 {
			left = 0
		} else {
			left = arr[i-1]
		}
		r := i + 1
		if r &gt; len(nums)-1 {
			right = 0
		} else {
			right = arr[len(nums)-1] - arr[i]
		}
		if left == right {
			return i
		}
	}
	return -1
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>728.自除数(2)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>自除数 是指可以被它包含的每一位数除尽的数。
例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
还有，自除数不允许包含 0 。
给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。
示例 1：输入： 上边界left = 1, 下边界right = 22
输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
注意：
    每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func selfDividingNumbers(left int, right int) []int {
	res := make([]int, 0)
	for i := left; i &lt;= right; i++ {
		if isSelfDividing(i) {
			res = append(res, i)
		}
	}
	return res
}

func isSelfDividing(n int) bool {
	temp := n
	for temp &gt; 0 {
		d := temp % 10
		temp = temp / 10
		if d == 0 || n%d != 0 {
			return false
		}
	}
	return true
}

#
func selfDividingNumbers(left int, right int) []int {
	res := make([]int, 0)
	for i := left; i &lt;= right; i++ {
		if isSelfDividing(i) {
			res = append(res, i)
		}
	}
	return res
}

func isSelfDividing(n int) bool {
	str := strconv.Itoa(n)
	for _, v := range str{
		if v == &#39;0&#39; || int32(n) % (v-&#39;0&#39;) != 0{
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>733.图像渲染(2)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，
接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。
将所有有记录的像素点的颜色值改为新的颜色值。
最后返回经过上色渲染后的图像。

示例 1:输入:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析:  在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。

注意:
    image 和 image[0] 的长度在范围 [1, 50] 内。
    给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。
    image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>深度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func floodFill(image [][]int, sr int, sc int, newColor int) [][]int {
	oldColor := image[sr][sc]
	if oldColor == newColor {
		return image
	}
	m, n := len(image), len(image[0])
	list := make([][]int, 1)
	list[0] = []int{sr, sc}

	for len(list) &gt; 0 {
		node := list[0]
		list = list[1:]
		image[node[0]][node[1]] = newColor
		for i := 0; i &lt; 4; i++ {
			x := node[0] + dx[i]
			y := node[1] + dy[i]
			if 0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp;
				image[x][y] == oldColor {
				list = append(list, []int{x, y})
			}
		}
	}
	return image
}

#
var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func floodFill(image [][]int, sr int, sc int, newColor int) [][]int {
	if sr &lt; 0 || sc &lt; 0 || sr &gt;= len(image) || 
		sc &gt;= len(image[sr]) || image[sr][sc] == newColor {
		return image
	}
	oldColor := image[sr][sc]
	image[sr][sc] = newColor
	for i := 0; i &lt; 4; i++ {
		x := sr + dx[i]
		y := sc + dy[i]
		if 0 &lt;= x &amp;&amp; x &lt; len(image) &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; len(image[x]) &amp;&amp;
			image[x][y] == oldColor {
			floodFill(image, x, y, newColor)
		}
	}
	return image
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>744.寻找比目标字母大的最小字母(3)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。
另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
在比较时，字母是依序循环出现的。举个例子：
    如果目标字母 target = &#39;z&#39; 并且字符列表为 letters = [&#39;a&#39;, &#39;b&#39;]，则答案返回 &#39;a&#39;
示例：
输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;a&quot; 输出: &quot;c&quot;
输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;c&quot; 输出: &quot;f&quot;
输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; 输出: &quot;f&quot;
输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;g&quot; 输出: &quot;j&quot;
输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;j&quot; 输出: &quot;c&quot;
输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; 输出: &quot;c&quot;
提示：
    letters长度范围在[2, 10000]区间内。
    letters 仅由小写字母组成，最少包含两个不同的字母。
    目标字母target 是一个小写字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func nextGreatestLetter(letters []byte, target byte) byte {
	for i := 0; i &lt; len(letters); i++ {
		if letters[i] &gt; target {
			return letters[i]
		}
	}
	return letters[0]
}

#
func nextGreatestLetter(letters []byte, target byte) byte {
	n := len(letters)
	i := sort.Search(n, func(i int) bool {
		return target &lt; letters[i]
	})
	return letters[i%n]
}

#
func nextGreatestLetter(letters []byte, target byte) byte {
	left := 0
	right := len(letters) - 1
	for left &lt;= right {
		mid := left + (right-left)/2
		if letters[mid] &lt;= target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return letters[left%len(letters)]
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>746.使用最小花费爬楼梯(3)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
示例 1:输入: cost = [10, 15, 20] 输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
示例 2:输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：
    cost 的长度将会在 [2, 1000]。
    每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划-一维数组</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>/*
用dp[i]表示爬i个台阶所需要的成本，所以dp[0]=0，dp[1]=0
每次爬i个楼梯，计算的都是从倒数第一个结束，还是从倒数第二个结束
动态转移方程为:
dp[i] = min{dp[i-2]+cost[i-2] , dp[i-1]+cost[i-1]};
*/
func minCostClimbingStairs(cost []int) int {
	n := len(cost)
	dp := make([]int, n+1)
	dp[0] = 0
	dp[1] = 0
	for i := 2; i &lt;= n; i++ {
		dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
	}
	return dp[n]
}

func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}

#
func minCostClimbingStairs(cost []int) int {
	a := 0
	b := 0
	for i := 2; i &lt;= len(cost); i++ {
		a, b = b, min(b+cost[i-1], a+cost[i-2])
	}
	return b
}

func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}

#
var arr []int

func minCostClimbingStairs(cost []int) int {
	arr = make([]int, len(cost)+1)
	return ClimbingStais(cost, len(cost))
}

func ClimbingStais(cost []int, i int) int {
	if i == 0 || i == 1 {
		return 0
	}
	if arr[i] == 0 {
		arr[i] = min(ClimbingStais(cost, i-1)+cost[i-1], 
			ClimbingStais(cost, i-2)+cost[i-2])
	}
	return arr[i]
}

func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>747.至少是其他数字两倍的最大数(3)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个给定的数组nums中，总是存在一个最大元素 。
查找数组中的最大元素是否至少是数组中每个其他数字的两倍。
如果是，则返回最大元素的索引，否则返回-1。

示例 1:输入: nums = [3, 6, 1, 0] 输出: 1
解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。
6的索引是1, 所以我们返回1.
示例 2:输入: nums = [1, 2, 3, 4] 输出: -1
解释: 4没有超过3的两倍大, 所以我们返回 -1.
提示:
    nums 的长度范围在[1, 50].
    每个 nums[i] 的整数范围在 [0, 100].
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>P</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func dominantIndex(nums []int) int {
	n := len(nums)
	if n == 1 {
		return 0
	}
	maxIndex, secondMaxIndex := 0, 1
	if nums[maxIndex] &lt; nums[secondMaxIndex] {
		maxIndex, secondMaxIndex = secondMaxIndex, maxIndex
	}

	for i := 2; i &lt; n; i++ {
		if nums[maxIndex] &lt; nums[i] {
			maxIndex, secondMaxIndex = i, maxIndex
		} else if nums[secondMaxIndex] &lt; nums[i] {
			secondMaxIndex = i
		}
	}
	if nums[maxIndex] &gt;= 2*nums[secondMaxIndex] {
		return maxIndex
	}
	return -1
}

#
func dominantIndex(nums []int) int {
	n := len(nums)
	if n == 1 {
		return 0
	}
	maxValue := nums[0]
	index := 0

	for i := 1; i &lt; n; i++ {
		if nums[i] &gt; maxValue {
			maxValue = nums[i]
			index = i
		}
	}
	for i := 0; i &lt; n; i++ {
		if i == index {
			continue
		}
		if nums[i]*2 &gt; maxValue {
			return -1
		}
	}
	return index
}

#
func dominantIndex(nums []int) int {
	n := len(nums)
	if n == 1 {
		return 0
	}
	temp := make([]int, len(nums))
	copy(temp, nums)
	sort.Ints(temp)
	maxValue := temp[len(temp)-1]
	if maxValue &lt; 2*temp[len(temp)-2] {
		return -1
	}
	for i := 0; i &lt; n; i++ {
		if nums[i] == maxValue {
			return i
		}
	}
	return -1
}
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>748.最短完整词(3)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。
在所有完整词中，最短的单词我们称之为最短完整词。
单词在匹配牌照中的字母时不区分大小写，比如牌照中的 &quot;P&quot; 依然可以匹配单词中的 &quot;p&quot; 字母。
我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。
牌照中可能包含多个相同的字符，比如说：对于牌照 &quot;PP&quot;，单词 &quot;pair&quot; 无法匹配，但是 &quot;supper&quot; 可以匹配。

示例 1：输入：licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]
输出：&quot;steps&quot;
说明：最短完整词应该包括 &quot;s&quot;、&quot;p&quot;、&quot;s&quot; 以及 &quot;t&quot;。
对于 &quot;step&quot; 它只包含一个 &quot;s&quot; 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。
示例 2：输入：licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]
输出：&quot;pest&quot;
说明：存在 3 个包含字母 &quot;s&quot; 且有着最短长度的完整词，但我们返回最先出现的完整词。
注意:
    牌照（licensePlate）的长度在区域[1, 7]中。
    牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。
    单词列表（words）长度在区间 [10, 1000] 中。
    每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双哈希遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双数组遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>排序+遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func shortestCompletingWord(licensePlate string, words []string) string {
	m := make(map[byte]int)
	licensePlate = strings.ToLower(licensePlate)
	for i := 0; i &lt; len(licensePlate); i++ {
		if licensePlate[i] &gt;= &#39;a&#39; &amp;&amp; licensePlate[i] &lt;= &#39;z&#39; {
			m[licensePlate[i]]++
		}
	}
	res := &quot;&quot;
	for i := 0; i &lt; len(words); i++ {
		if len(words[i]) &gt;= len(res) &amp;&amp; res != &quot;&quot; {
			continue
		}
		tempM := make(map[byte]int)
		for j := 0; j &lt; len(words[i]); j++ {
			tempM[words[i][j]]++
		}
		flag := true
		for k := range m {
			if tempM[k] &lt; m[k] {
				flag = false
				break
			}
		}
		if flag == true {
			res = words[i]
		}
	}
	return res
}

#
func shortestCompletingWord(licensePlate string, words []string) string {
	m := make([]int, 26)
	licensePlate = strings.ToLower(licensePlate)
	for i := 0; i &lt; len(licensePlate); i++ {
		if licensePlate[i] &gt;= &#39;a&#39; &amp;&amp; licensePlate[i] &lt;= &#39;z&#39; {
			m[licensePlate[i]-&#39;a&#39;]++
		}
	}
	res := &quot;&quot;
	for i := 0; i &lt; len(words); i++ {
		if len(words[i]) &gt;= len(res) &amp;&amp; res != &quot;&quot; {
			continue
		}
		tempM := make([]int, 26)
		for j := 0; j &lt; len(words[i]); j++ {
			tempM[words[i][j]-&#39;a&#39;]++
		}
		flag := true
		for k := range m {
			if tempM[k] &lt; m[k] {
				flag = false
				break
			}
		}
		if flag == true {
			res = words[i]
		}
	}
	return res
}

#
func shortestCompletingWord(licensePlate string, words []string) string {
	m := make([]int, 26)
	licensePlate = strings.ToLower(licensePlate)
	for i := 0; i &lt; len(licensePlate); i++ {
		if licensePlate[i] &gt;= &#39;a&#39; &amp;&amp; licensePlate[i] &lt;= &#39;z&#39; {
			m[licensePlate[i]-&#39;a&#39;]++
		}
	}
	var lists [16][]string
	for _, word := range words {
		lists[len(word)] = append(lists[len(word)], word)
	}
	for _, list := range lists {
		for _, word := range list {
			tempM := make([]int, 26)
			for i := 0; i &lt; len(word); i++ {
				tempM[word[i]-&#39;a&#39;]++
			}
			flag := true
			for k := range m {
				if tempM[k] &lt; m[k] {
					flag = false
					break
				}
			}
			if flag == true {
				return word
			}
		}
	}
	return &quot;&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>762.二进制表示中质数个计算置位(2)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。
（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）
示例 1: 输入: L = 6, R = 10 输出: 4
解释:
6 -&gt; 110 (2 个计算置位，2 是质数)
7 -&gt; 111 (3 个计算置位，3 是质数)
9 -&gt; 1001 (2 个计算置位，2 是质数)
10-&gt; 1010 (2 个计算置位，2 是质数)

示例 2: 输入: L = 10, R = 15 输出: 5
解释:
10 -&gt; 1010 (2 个计算置位, 2 是质数)
11 -&gt; 1011 (3 个计算置位, 3 是质数)
12 -&gt; 1100 (2 个计算置位, 2 是质数)
13 -&gt; 1101 (3 个计算置位, 3 是质数)
14 -&gt; 1110 (3 个计算置位, 3 是质数)
15 -&gt; 1111 (4 个计算置位, 4 不是质数)

注意:
    L, R 是 L &lt;= R 且在 [1, 10^6] 中的整数。
    R - L 的最大值为 10000。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历+内置函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countPrimeSetBits</span><span class="p">(</span><span class="nx">L</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">R</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="mi">2</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
		<span class="mi">3</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
		<span class="mi">5</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
		<span class="mi">7</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
		<span class="mi">11</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">13</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">17</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">19</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">23</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">29</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">31</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">L</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">R</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">bits</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// bits = bits + n &amp; 1</span>
			<span class="nx">bits</span> <span class="p">=</span> <span class="nx">bits</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">primes</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>766.托普利茨矩阵(2)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。
给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。
示例 1:输入: 
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
输出: True
解释:
在上述矩阵中, 其对角线为:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。
各条对角线上的所有元素均相同, 因此答案是True。
示例 2:输入:
matrix = [
  [1,2],
  [2,2]
]
输出: False
解释: 对角线&quot;[1, 2]&quot;上的元素不同。
说明:
    matrix 是一个包含整数的二维数组。
    matrix 的行数和列数均在 [1, 20]范围内。
    matrix[i][j] 包含的整数在 [0, 99]范围内。
进阶:
    如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？
    如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isToeplitzMatrix(matrix [][]int) bool {
	m, n := len(matrix), len(matrix[0])
	for i := 0; i &lt; m-1; i++ {
		for j := 0; j &lt; n-1; j++ {
			if matrix[i][j] != matrix[i+1][j+1] {
				return false
			}
		}
	}
	return true
}

#
func isToeplitzMatrix(matrix [][]int) bool {
	m := make(map[int]int)
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[0]); j++ {
			if value, ok := m[i-j]; ok {
				if matrix[i][j] != value {
					return false
				}
			} else {
				m[i-j] = matrix[i][j]
			}
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>771.宝石与石头(3)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 
S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。
示例 1:输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3
示例 2:输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0

注意:
    S 和 J 最多含有50个字母。
     J 中的字符不重复。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数+遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助+遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numJewelsInStones(J string, S string) int {
	res := 0
	for _, v := range J {
		res = res + strings.Count(S, string(v))
	}
	return res
}


#
func numJewelsInStones(J string, S string) int {
	m := make(map[byte]bool)
	for i := range J {
		m[J[i]] = true
	}
	res := 0
	for i := range S {
		if m[S[i]] {
			res++
		}
	}
	return res
}

#
func numJewelsInStones(J string, S string) int {
	res := 0
	for _, v := range J {
		for _, s := range S {
			if v == s {
				res++
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>783.二叉搜索树节点最小距离(3)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。
示例：输入: root = [4,2,6,1,3,null,null] 输出: 1
解释:注意，root是树节点对象(TreeNode object)，而不是数组。
给定的树 [4,2,6,1,3,null,null] 可表示为下图:
          4
        /   \
      2      6
     / \    
    1   3  
最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。
注意：
    二叉树的大小范围在 2 到 100。
    二叉树总是有效的，每个节点的值都是整数，且不重复。
    本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归+中序遍历</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归+遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var minDiff, previous int

func minDiffInBST(root *TreeNode) int {
	minDiff, previous = math.MaxInt32, math.MaxInt32
	dfs(root)
	return minDiff
}

func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)
	newDiff := diff(previous, root.Val)
	if minDiff &gt; newDiff {
		minDiff = newDiff
	}
	previous = root.Val
	dfs(root.Right)
}

func diff(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}

#
func minDiffInBST(root *TreeNode) int {
	arr := make([]int, 0)
	dfs(root, &amp;arr)
	min := arr[1] - arr[0]
	for i := 2; i &lt; len(arr); i++ {
		if min &gt; arr[i]-arr[i-1] {
			min = arr[i] - arr[i-1]
		}
	}
	return min
}

func dfs(root *TreeNode, arr *[]int) {
	if root == nil {
		return
	}
	dfs(root.Left, arr)
	*arr = append(*arr, root.Val)
	dfs(root.Right, arr)
}

#
func minDiffInBST(root *TreeNode) int {
	arr := make([]int, 0)
	stack := make([]*TreeNode, 0)
	min := math.MaxInt32
	for root != nil || len(stack) &gt; 0 {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		arr = append(arr, node.Val)
		if len(arr) &gt; 1 {
			temp := node.Val - arr[len(arr)-2]
			if min &gt; temp {
				min = temp
			}
		}
		root = node.Right
	}
	return min
}
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>784.字母大小写全排列(4)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。
返回所有可能得到的字符串集合。

示例:
输入: S = &quot;a1b2&quot; 输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]
输入: S = &quot;3z4&quot; 输出: [&quot;3z4&quot;, &quot;3Z4&quot;]
输入: S = &quot;12345&quot; 输出: [&quot;12345&quot;]
注意：
    S 的长度不超过12。
    S 仅由数字和字母组成。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历-逐位添加</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历-遇字母翻倍</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
<tr>
<td>04</td>
<td>回溯-递归</td>
<td>O(n*2^n)</td>
<td>O(n*2^n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func letterCasePermutation(S string) []string {
	res := make([]string, 1)
	for i := 0; i &lt; len(S); i++ {
		if string(S[i]) &gt;= &quot;0&quot; &amp;&amp; string(S[i]) &lt;= &quot;9&quot; {
			newRes := make([]string, 0)
			for _, v := range res {
				newRes = append(newRes, v+string(S[i]))
			}
			res = newRes
		} else if b, ok := check(S[i]); ok {
			first := string(b[0])
			second := string(b[1])
			newRes := make([]string, 0)
			for _, v := range res {
				newRes = append(newRes, v+first)
				newRes = append(newRes, v+second)
			}
			res = newRes
		}
	}
	return res
}

func check(b byte) ([]byte, bool) {
	if &#39;a&#39; &lt;= b &amp;&amp; b &lt;= &#39;z&#39; {
		return []byte{b - &#39;a&#39; + &#39;A&#39;, b}, true
	}
	if &#39;A&#39; &lt;= b &amp;&amp; b &lt;= &#39;Z&#39; {
		return []byte{b, b - &#39;A&#39; + &#39;a&#39;}, true
	}
	return []byte{b}, false
}

#
func letterCasePermutation(S string) []string {
	size := len(S)
	if size == 0 {
		return []string{&quot;&quot;}
	}
	postfixs := make([]string, 1)
	lastByte := S[size-1]
	postfixs[0] = string(lastByte)
	if b, ok := check(lastByte); ok {
		postfixs = append(postfixs, string(b))
	}
	prefixs := letterCasePermutation(S[:size-1])
	res := make([]string, 0)
	for _, pre := range prefixs {
		for _, post := range postfixs {
			res = append(res, pre+post)
		}
	}
	return res
}

func check(b byte) (byte, bool) {
	if &#39;a&#39; &lt;= b &amp;&amp; b &lt;= &#39;z&#39; {
		return b - &#39;a&#39; + &#39;A&#39;, true
	}
	if &#39;A&#39; &lt;= b &amp;&amp; b &lt;= &#39;Z&#39; {
		return b - &#39;A&#39; + &#39;a&#39;, true
	}
	return 0, false
}

#
func letterCasePermutation(S string) []string {
	S = strings.ToLower(S)
	res := []string{S}
	for i := range S {
		if S[i] &gt;= &#39;a&#39; {
			n := len(res)
			for j := 0; j &lt; n; j++ {
				temp := []byte(res[j])
				temp[i] = S[i] - &#39;a&#39; + &#39;A&#39;
				res = append(res, string(temp))
			}
		}
	}
	return res
}

#
var res []string

func letterCasePermutation(S string) []string {
	res = make([]string, 0)
	dfs([]byte(S), 0)
	return res
}

func dfs(arr []byte, level int) {
	if level == len(arr) {
		res = append(res, string(arr))
		return
	}
	if arr[level] &gt;= &#39;a&#39; &amp;&amp; arr[level] &lt;= &#39;z&#39; {
		dfs(arr, level+1)
		arr[level] = arr[level] - &#39;a&#39; + &#39;A&#39; // 大写
		dfs(arr, level+1)
		arr[level] = arr[level] - &#39;A&#39; + &#39;a&#39; // 小写
	} else if arr[level] &gt;= &#39;A&#39; &amp;&amp; arr[level] &lt;= &#39;Z&#39; {
		dfs(arr, level+1)
		arr[level] = arr[level] - &#39;A&#39; + &#39;a&#39; // 小写
		dfs(arr, level+1)
		arr[level] = arr[level] - &#39;a&#39; + &#39;A&#39; // 大写
	} else {
		dfs(arr, level+1)
	}
	return
}
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>788.旋转数字(4)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，
我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。
如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；
2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；
6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？
示例：输入: 10 输出: 4
解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。注意 1 和 10 不是好数, 因为他们在旋转之后不变。
提示：N 的取值范围是 [1, 10000]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历+递归</td>
<td>O(nlog(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>03</td>
<td>遍历+转字符串</td>
<td>O(nlog(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>04</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rotatedDigits(N int) int {
	count := 0
	for i := 2; i &lt;= N; i++ {
		if isValid(i) {
			count++
		}
	}
	return count
}

func isValid(n int) bool {
	valid := false
	for n &gt; 0 {
		switch n % 10 {
		case 2, 5, 6, 9:
			valid = true
		case 3, 4, 7:
			return false
		}
		n = n / 10
	}
	return valid
}

#
func rotatedDigits(N int) int {
	count := 0
	for i := 2; i &lt;= N; i++ {
		if isValid(i, false) {
			count++
		}
	}
	return count
}

func isValid(n int, flag bool) bool {
	if n == 0 {
		return flag
	}
	switch n % 10 {
	case 3, 4, 7:
		return false
	case 0, 1, 8:
		return isValid(n/10, flag)
	case 2, 5, 6, 9:
		return isValid(n/10, true)
	}
	return false
}

# 
// 每个数字由(i/10)和(i%10)组成
// dp[i]={dp[i/10],dp[i%10]}
func rotatedDigits(N int) int {
	dp := []int{0, 0, 1, -1, -1, 1, 1, -1, 0, 1}
	if N &gt;= 10 {
		dp = append(dp, make([]int, N-9)...)
	}
	res := 0
	for i := 0; i &lt;= N; i++ {
		if dp[i/10] == -1 || dp[i%10] == -1 {
			dp[i] = -1
		} else if dp[i] = dp[i/10] | dp[i%10]; dp[i] == 1 {
			// arr[i/10] = 1/0 arr[i%10] == 1/0
			// 异或操作，确保把0，1，8组成的数字剔除
			// 0|0 == 0
			// 0|1 == 1
			// 1|0 == 1
			// 1|1 == 1
			res++
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>796.旋转字符串(2)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个字符串, A 和 B。
A 的旋转操作就是将 A 最左边的字符移动到最右边。
例如, 若 A = &#39;abcde&#39;，在移动一次之后结果就是&#39;bcdea&#39; 。
如果在若干次旋转操作之后，A 能变成B，那么返回True。

示例 1: 输入: A = &#39;abcde&#39;, B = &#39;cdeab&#39; 输出: true
示例 2:输入: A = &#39;abcde&#39;, B = &#39;abced&#39; 输出: false
注意：A 和 B 长度不超过 100。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rotateString(A string, B string) bool {
	return len(A) == len(B) &amp;&amp; strings.Contains(A+A, B)
}

#
func rotateString(A string, B string) bool {
	if A == B {
		return true
	}
	if len(A) != len(B) {
		return false
	}
	for i := 0; i &lt; len(A); i++ {
		A = A[1:] + string(A[0])
		if A == B {
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>0701-0800-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id21">
<h2>701.二叉搜索树中的插入操作(2)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。
输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。
示例 1：输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
示例 2：输入：root = [40,20,60,10,30,50,70], val = 25 
输出：[40,20,60,10,30,50,70,null,null,25]
示例 3：输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
提示：给定的树上的节点数介于 0 和 10^4 之间
每个节点都有一个唯一整数值，取值范围从 0 到 10^8
-10^8 &lt;= val &lt;= 10^8
新值和原始二叉搜索树中的任意节点值都不同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>迭代</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func insertIntoBST(root *TreeNode, val int) *TreeNode {
	if root == nil {
		return &amp;TreeNode{
			Val: val,
		}
	}
	temp := root
	for temp != nil {
		if temp.Val &gt; val {
			if temp.Left == nil {
				temp.Left = &amp;TreeNode{
					Val: val,
				}
				break
			}
			temp = temp.Left
		} else {
			if temp.Right == nil {
				temp.Right = &amp;TreeNode{
					Val: val,
				}
				break
			}
			temp = temp.Right
		}
	}
	return root
}

# 2
func insertIntoBST(root *TreeNode, val int) *TreeNode {
	if root == nil {
		return &amp;TreeNode{
			Val: val,
		}
	}
	if root.Val &gt; val {
		root.Left = insertIntoBST(root.Left, val)
	} else {
		root.Right = insertIntoBST(root.Right, val)
	}
	return root
}
</pre></div>
</div>
</div>
<div class="section" id="ascii-3">
<h2>712.两个字符串的最小ASCII删除和(3)<a class="headerlink" href="#ascii-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。
示例 1:输入: s1 = &quot;sea&quot;, s2 = &quot;eat&quot; 输出: 231
解释: 在 &quot;sea&quot; 中删除 &quot;s&quot; 并将 &quot;s&quot; 的值(115)加入总和。
在 &quot;eat&quot; 中删除 &quot;t&quot; 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
示例 2:输入: s1 = &quot;delete&quot;, s2 = &quot;leet&quot; 输出: 403
解释: 在 &quot;delete&quot; 中删除 &quot;dee&quot; 字符串变成 &quot;let&quot;，
将 100[d]+101[e]+101[e] 加入总和。在 &quot;leet&quot; 中删除 &quot;e&quot; 将 101[e] 加入总和。
结束时，两个字符串都等于 &quot;let&quot;，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 &quot;lee&quot; 或 &quot;eet&quot;，我们会得到 433 或 417 的结果，比答案更大。
注意:0 &lt; s1.length, s2.length &lt;= 1000。
所有字符串中的字符ASCII值在[97, 122]之间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minimumDeleteSum(s1 string, s2 string) int {
	a, b := len(s1), len(s2)
	// 最长公共子序列
	dp := make([][]int, a+1)
	for i := 0; i &lt;= a; i++ {
		dp[i] = make([]int, b+1)
	}
	for i := 1; i &lt;= a; i++ {
		for j := 1; j &lt;= b; j++ {
			if s1[i-1] == s2[j-1] {
				dp[i][j] = dp[i-1][j-1] + int(s1[i-1])
			} else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j])
			}
		}
	}
	return sumAscii(s1) + sumAscii(s2) - 2*dp[a][b]
}

func sumAscii(s string) int {
	res := 0
	for i := 0; i &lt; len(s); i++ {
		res = res + int(s[i])
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func minimumDeleteSum(s1 string, s2 string) int {
	a, b := len(s1), len(s2)
	dp := make([][]int, a+1)
	for i := 0; i &lt;= a; i++ {
		dp[i] = make([]int, b+1)
		if i &gt; 0 {
			dp[i][0] = dp[i-1][0] + int(s1[i-1])
		}
	}
	for i := 1; i &lt;= b; i++ {
		dp[0][i] = dp[0][i-1] + int(s2[i-1])
	}

	for i := 1; i &lt;= a; i++ {
		for j := 1; j &lt;= b; j++ {
			if s1[i-1] == s2[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else {
				dp[i][j] = min(dp[i][j-1]+int(s2[j-1]), dp[i-1][j]+int(s1[i-1]))
			}
		}
	}
	return dp[a][b]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
var m [][]int

func minimumDeleteSum(s1 string, s2 string) int {
	a, b := len(s1), len(s2)
	m = make([][]int, a+1)
	for i := 0; i &lt;= a; i++ {
		m[i] = make([]int, b+1)
		for j := 0; j &lt;= b; j++ {
			m[i][j] = -1
		}
	}

	total := dfs(s1, s2, 0, 0)
	return sumAscii(s1) + sumAscii(s2) - 2*total
}

func dfs(s1 string, s2 string, i, j int) int {
	if len(s1) == i || len(s2) == j {
		return 0
	}
	if m[i][j] &gt; -1 {
		return m[i][j]
	}
	if s1[i] == s2[j] {
		m[i][j] = dfs(s1, s2, i+1, j+1) + int(s1[i])
	} else {
		m[i][j] = max(dfs(s1, s2, i, j+1), dfs(s1, s2, i+1, j))
	}
	return m[i][j]
}

func sumAscii(s string) int {
	res := 0
	for i := 0; i &lt; len(s); i++ {
		res = res + int(s[i])
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="k-1">
<h2>713.乘积小于K的子数组(1)<a class="headerlink" href="#k-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个正整数数组 nums。
找出该数组内乘积小于 k 的连续的子数组的个数。
示例 1:输入: nums = [10,5,2,6], k = 100 输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
说明:0 &lt; nums.length &lt;= 50000
    0 &lt; nums[i] &lt; 1000
    0 &lt;= k &lt; 10^6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">numSubarrayProductLessThanK</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">right</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">right</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">*</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">total</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">/</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
			<span class="nx">left</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">right</span> <span class="o">-</span> <span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>714.买卖股票的最佳时机含手续费(2)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；
非负整数 fee 代表了交易股票的手续费用。
你可以无限次地完成交易，但是你每笔交易都需要付手续费。
如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
示例 1:输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
注意:
    0 &lt; prices.length &lt;= 50000.
    0 &lt; prices[i] &lt; 50000.
    0 &lt;= fee &lt; 50000.
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划-二维</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxProfit(prices []int, fee int) int {
	dp0, dp1 := 0, math.MinInt32
	for i := 0; i &lt; len(prices); i++ {
		temp := dp0
		dp0 = max(dp0, dp1+prices[i])
		dp1 = max(dp1, temp-prices[i]-fee)
	}
	return dp0
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maxProfit(prices []int, fee int) int {
	dp := make([][2]int, len(prices))
	dp[0][0] = 0
	dp[0][1] = -prices[0]
	for i := 1; i &lt; len(prices); i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
	}
	return dp[len(prices)-1][0]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>718.最长重复子数组(3)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
示例：输入：A: [1,2,3,2,1] B: [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3, 2, 1] 。
提示：1 &lt;= len(A), len(B) &lt;= 1000
    0 &lt;= A[i], B[i] &lt; 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>滑动窗口</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findLength(A []int, B []int) int {
	n, m := len(A), len(B)
	dp := make([][]int, n+1)
	for i := 0; i &lt;= n; i++ {
		dp[i] = make([]int, m+1)
	}
	res := math.MinInt32
	for i := 1; i &lt;= n; i++ {
		for j := 1; j &lt;= m; j++ {
			if A[i-1] == B[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			}
			if dp[i][j] &gt; res {
				res = dp[i][j]
			}
		}
	}
	return res
}

# 2
func findLength(A []int, B []int) int {
	n, m := len(A), len(B)
	dp := make([]int, m+1)
	res := math.MinInt32
	for i := 1; i &lt;= n; i++ {
		for j := m; j &gt;= 1; j-- {
			if A[i-1] == B[j-1] {
				dp[j] = dp[j-1] + 1
			} else {
				dp[j] = 0 // 需要清0
			}
			if dp[j] &gt; res {
				res = dp[j]
			}
		}
	}
	return res
}

# 3
func findLength(A []int, B []int) int {
	n, m := len(A), len(B)
	res := math.MinInt32
	for i := 0; i &lt; n; i++ {
		length := min(n-i, m)
		maxLength := getMaxLength(A, B, i, 0, length)
		res = max(res, maxLength)
	}
	for i := 0; i &lt; m; i++ {
		length := min(n, m-i)
		maxLength := getMaxLength(A, B, 0, i, length)
		res = max(res, maxLength)
	}
	return res
}

func getMaxLength(A, B []int, a, b int, length int) int {
	res := 0
	count := 0
	for i := 0; i &lt; length; i++ {
		if A[a+i] == B[b+i] {
			count++
		} else {
			count = 0
		}
		res = max(res, count)
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>721.账户合并(1)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，
其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。
现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。
请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。
一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。
合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。
账户本身可以以任意顺序返回。
示例 1：输入：accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;],
[&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, 
&quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]
输出：
[[&quot;John&quot;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;], 
[&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]
解释：第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 &quot;johnsmith@mail.com&quot;。 
第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。
可以以任何顺序返回这些列表，例如答案 [[&#39;Mary&#39;，&#39;mary@mail.com&#39;]，
[&#39;John&#39;，&#39;johnnybravo@mail.com&#39;]，
[&#39;John&#39;，&#39;john00@mail.com&#39;，&#39;john_newyork@mail.com&#39;，&#39;johnsmith@mail.com&#39;]] 也是正确的。
提示：accounts的长度将在[1，1000]的范围内。
accounts[i]的长度将在[1，10]的范围内。
accounts[i][j]的长度将在[1，30]的范围内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>并查集</td>
<td>O(n^2log(n))</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">accountsMerge</span><span class="p">(</span><span class="nx">accounts</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">accounts</span><span class="p">)</span>
	<span class="nx">fa</span> <span class="p">=</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">accounts</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">accounts</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">email</span> <span class="o">:=</span> <span class="nx">accounts</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">email</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span> <span class="c1">// 邮箱重复出现，合并账户</span>
				<span class="nx">union</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">[</span><span class="nx">email</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">target</span> <span class="o">:=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="nx">temp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">temp</span><span class="p">[</span><span class="nx">target</span><span class="p">],</span> <span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">arr</span> <span class="o">:=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
			<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">accounts</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]},</span> <span class="nx">arr</span><span class="o">...</span><span class="p">)</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">fa</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// 初始化</span>
<span class="kd">func</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>

<span class="c1">// 查询</span>
<span class="kd">func</span> <span class="nx">find</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 合并</span>
<span class="kd">func</span> <span class="nx">union</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fa</span><span class="p">[</span><span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>722.删除注释(1)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。 
这表示每行源码由\n分隔。
在 C++ 中有两种注释风格，行内注释和块注释。
字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。
字符串/* 表示一个块注释，它表示直到*/的下一个（非重叠）出现的所有字符都应该被忽略。
（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。
第一个有效注释优先于其他注释：如果字符串//出现在块注释中会被忽略。
同样，如果字符串/*出现在行或块注释中也会被忽略。
如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。
样例中没有控制字符，单引号或双引号字符。比如，source = &quot;string s = &quot;/* Not a comment. */&quot;;&quot;
不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。）
我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。
最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。
从源代码中删除注释后，需要以相同的格式返回源代码。
示例 1:输入: 
source = [&quot;/*Test program */&quot;, &quot;int main()&quot;, &quot;{ &quot;, &quot;  // variable declaration &quot;, 
&quot;int a, b, c;&quot;, &quot;/* This is a test&quot;, &quot;   multiline  &quot;, &quot;   comment for &quot;, 
&quot;   testing */&quot;, &quot;a = b + c;&quot;, &quot;}&quot;]
示例代码可以编排成这样:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}
输出: [&quot;int main()&quot;,&quot;{ &quot;,&quot;  &quot;,&quot;int a, b, c;&quot;,&quot;a = b + c;&quot;,&quot;}&quot;]
编排后:
int main()
{ 
  
int a, b, c;
a = b + c;
}
解释: 第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。
示例 2:输入:  source = [&quot;a/*comment&quot;, &quot;line&quot;, &quot;more_comment*/b&quot;]
输出: [&quot;ab&quot;]
解释: 原始的 source 字符串是 &quot;a/*comment\nline\nmore_comment*/b&quot;, 其中我们用粗体显示了换行符。
删除注释后，隐含的换行符被删除，留下字符串 &quot;ab&quot; 用换行符分隔成数组时就是 [&quot;ab&quot;].
注意:source的长度范围为[1, 100].
source[i]的长度范围为[0, 80].
每个块注释都会被闭合。
给定的源码中不会有单引号、双引号或其他控制字符。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">removeComments</span><span class="p">(</span><span class="nx">source</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">flag</span> <span class="o">:=</span> <span class="kc">false</span> <span class="c1">// 判断是否是块注释</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">str</span> <span class="o">:=</span> <span class="nx">source</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="p">{</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">2</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">2</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
				<span class="nx">temp</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
			<span class="p">}</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">temp</span><span class="p">))</span>
			<span class="nx">temp</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>725.分隔链表(2)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。
每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。
这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。
返回一个符合上述规则的链表的列表。
举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]
示例 1：输入: root = [1, 2, 3], k = 5 输出: [[1],[2],[3],[],[]]
解释:输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。
示例 2：输入:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。
提示:root 的长度范围： [0, 1000].
输入的每个节点的大小范围：[0, 999].
k 的取值范围： [1, 50].
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func splitListToParts(root *ListNode, k int) []*ListNode {
	res := make([]*ListNode, 0)
	cur := root
	length := 0
	for cur != nil {
		length++
		cur = cur.Next
	}
	a, b := length/k, length%k
	for i := 0; i &lt; k; i++ {
		node := &amp;ListNode{Next: nil}
		temp := node
		for j := 0; j &lt; a; j++ {
			temp.Next = &amp;ListNode{
				Val:  root.Val,
				Next: nil,
			}
			temp = temp.Next
			root = root.Next
		}
		if b &gt; 0 {
			temp.Next = &amp;ListNode{
				Val:  root.Val,
				Next: nil,
			}
			temp = temp.Next
			root = root.Next
			b = b - 1
		}
		res = append(res, node.Next)
	}
	return res
}

# 2
func splitListToParts(root *ListNode, k int) []*ListNode {
	res := make([]*ListNode, 0)
	cur := root
	length := 0
	for cur != nil {
		length++
		cur = cur.Next
	}
	a, b := length/k, length%k
	for i := 0; i &lt; k; i++ {
		if root == nil {
			res = append(res, nil)
			continue
		}
		node := root
		for j := 1; j &lt; a &amp;&amp; root.Next != nil; j++ {
			root = root.Next
		}
		if b &gt; 0 {
			root = root.Next
			b--
		}
		temp := root.Next
		root.Next = nil
		root = temp
		res = append(res, node)
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>735.行星碰撞(1)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 asteroids，表示在同一行的行星。
对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。
每一颗行星以相同的速度移动。
找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。
如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。
示例 1:输入: asteroids = [5, 10, -5] 输出: [5, 10]
解释: 10 和 -5 碰撞后只剩下 10。 5 和 10 永远不会发生碰撞。
示例 2:输入: asteroids = [8, -8] 输出: []
解释: 8 和 -8 碰撞后，两者都发生爆炸。
示例 3:输入: asteroids = [10, 2, -5] 输出: [10]
解释: 2 和 -5 发生碰撞后剩下 -5。10 和 -5 发生碰撞后剩下 10。
示例 4:输入:  asteroids = [-2, -1, 1, 2] 输出: [-2, -1, 1, 2]
解释: -2 和 -1 向左移动，而 1 和 2 向右移动。
由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。
说明:数组 asteroids 的长度不超过 10000。
每一颗行星的大小都是非零整数，范围是 [-1000, 1000] 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">asteroidCollision</span><span class="p">(</span><span class="nx">asteroids</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">asteroids</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">asteroids</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">right</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="nx">asteroids</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="nx">left</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">asteroids</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
						<span class="k">break</span>
					<span class="p">}</span>
					<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">asteroids</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">right</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
					<span class="k">if</span> <span class="nx">sum</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
						<span class="k">break</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="k">break</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">left</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">asteroids</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>738.单调递增的数字(2)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）
示例 1:输入: N = 10 输出: 9
示例 2:输入: N = 1234 输出: 1234
示例 3:输入: N = 332 输出: 299
说明: N 是在 [0, 10^9] 范围内的一个整数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func monotoneIncreasingDigits(N int) int {
	arr := []byte(strconv.Itoa(N))
	i := 1
	for i &lt; len(arr) &amp;&amp; arr[i-1] &lt;= arr[i] {
		i++
	}
	// 前面有逆序的
	if i &lt; len(arr) {
		// 前面减去1, 如：332=&gt;2xx要减2次
		for i &gt; 0 &amp;&amp; arr[i] &lt; arr[i-1] {
			arr[i-1]--
			i--
		}
		i++
		for ; i &lt; len(arr); i++ {
			arr[i] = &#39;9&#39;
		}
	}
	res, _ := strconv.Atoi(string(arr))
	return res
}

# 2
func monotoneIncreasingDigits(N int) int {
	arr := []byte(strconv.Itoa(N))
	maxValue := -1
	index := -1
	for i := 0; i &lt; len(arr)-1; i++ {
		if int(arr[i]-&#39;0&#39;) &gt; maxValue {
			maxValue = int(arr[i] - &#39;0&#39;)
			index = i
		}
		if arr[i] &gt; arr[i+1] {
			arr[index]--
			for j := index + 1; j &lt; len(arr); j++ {
				arr[j] = &#39;9&#39;
			}
			break
		}
	}
	res, _ := strconv.Atoi(string(arr))
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>739.每日温度(3)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请根据每日 气温 列表，重新生成一个列表。
对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。
如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，
你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func dailyTemperatures(T []int) []int {
	res := make([]int, len(T))
	stack := make([]int, 0) // 栈保存递减数据的下标
	for i := 0; i &lt; len(T); i++ {
		for len(stack) &gt; 0 &amp;&amp; T[i] &gt; T[stack[len(stack)-1]] {
			last := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			res[last] = i - last
		}
		stack = append(stack, i)
	}
	return res
}

# 2
func dailyTemperatures(T []int) []int {
	res := make([]int, len(T))
	arr := make([]int, 101)
	for i := 0; i &lt; len(arr); i++ {
		arr[i] = math.MaxInt64
	}
	for i := len(T) - 1; i &gt;= 0; i-- {
		temp := math.MaxInt64
		for t := T[i] + 1; t &lt; 101; t++ {
			if arr[t] &lt; temp {
				temp = arr[t]
			}
		}
		if temp &lt; math.MaxInt64 {
			res[i] = temp - i
		}
		arr[T[i]] = i
	}
	return res
}

# 3
func dailyTemperatures(T []int) []int {
	j := 0
	for i := 0; i &lt; len(T); i++ {
		for j = i + 1; j &lt; len(T); j++ {
			if T[j] &gt; T[i] {
				T[i] = j - i
				break
			}
		}
		if j == len(T) {
			T[i] = 0
		}
	}
	return T
}
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>740.删除与获得点数(2)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 nums ，你可以对它进行一些操作。
每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。
之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。
开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
示例 1:输入: nums = [3, 4, 2] 输出: 6
解释: 删除 4 来获得 4 个点数，因此 3 也被删除。
之后，删除 2 来获得 2 个点数。总共获得 6 个点数。
示例 2:输入: nums = [2, 2, 3, 3, 3, 4] 输出: 9
解释:  删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
注意:nums的长度最大为20000。
每个整数nums[i]的大小都在[1, 10000]范围内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func deleteAndEarn(nums []int) int {
	count := make([]int, 10001)
	for i := 0; i &lt; len(nums); i++ {
		count[nums[i]]++
	}
	dp := make([]int, 10001)
	dp[1] = count[1]
	dp[2] = max(dp[1], count[2]*2)
	for i := 2; i &lt; 10001; i++ {
		dp[i] = max(dp[i-1], dp[i-2]+i*count[i])
	}
	return dp[10000]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}


# 2
func deleteAndEarn(nums []int) int {
	count := make([]int, 10001)
	for i := 0; i &lt; len(nums); i++ {
		count[nums[i]]++
	}
	a, b := 0, 0 // a使用i，b不使用i
	prev := -1
	for i := 0; i &lt; 10001; i++ {
		if count[i] &gt; 0 {
			maxValue := max(a, b)
			if prev != i-1 { // 不等于上一个，使用最大值
				a = i*count[i] + maxValue
				b = maxValue
			} else { // 等于上一个，使用b
				a = i*count[i] + b
				b = maxValue
			}
			prev = i
		}
	}
	return max(a, b)
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>752.打开转盘锁(1)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你有一个带有四个圆形拨轮的转盘锁。
每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。
每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为  &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。
锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，
这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。
示例 1:输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot; 输出：6
解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。
注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，
因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。
示例 2:输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot; 输出：1
解释： 把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。
示例 3:输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], 
target = &quot;8888&quot; 输出：-1 
解释：无法旋转到目标数字且不被锁定。
示例 4:输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot; 输出：-1
提示：
    死亡列表 deadends 的长度范围为 [1, 500]。
    目标数字 target 不会在 deadends 之中。
    每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &#39;0000&#39; 到 &#39;9999&#39; 中产生。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>广度优先搜索</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">openLock</span><span class="p">(</span><span class="nx">deadends</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="s">&quot;0000&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">deadends</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">deadends</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;0000&quot;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">deadends</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">target</span> <span class="o">==</span> <span class="s">&quot;0000&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">target</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="s">&quot;0000&quot;</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">dir</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">res</span><span class="o">++</span>
		<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">str</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dir</span><span class="p">);</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">char</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="o">+</span><span class="nx">dir</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span><span class="o">%</span><span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
					<span class="nx">newStr</span> <span class="o">:=</span> <span class="nx">str</span><span class="p">[:</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="nx">char</span> <span class="o">+</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
					<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">newStr</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
					<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">newStr</span><span class="p">)</span>
					<span class="nx">m</span><span class="p">[</span><span class="nx">newStr</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
					<span class="k">if</span> <span class="nx">newStr</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">res</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">length</span><span class="p">:]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>763.划分字母区间(2)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。
返回一个表示每个字符串片段的长度的列表。
示例 1：输入：S = &quot;ababcbacadefegdehijhklij&quot; 输出：[9,7,8]
解释：划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。
每个字母最多出现在一个片段中。
像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。
提示：S的长度在[1, 500]之间。
    S只包含小写字母 &#39;a&#39; 到 &#39;z&#39; 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func partitionLabels(S string) []int {
	m := make(map[byte]int)
	for i := 0; i &lt; len(S); i++ {
		m[S[i]] = i
	}
	res := make([]int, 0)
	left := 0
	right := 0
	for i := 0; i &lt; len(S); i++ {
		right = max(right, m[S[i]])
		if i == right {
			res = append(res, right-left+1)
			left = right + 1
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func partitionLabels(S string) []int {
	res := make([]int, 0)
	left := 0
	right := 0
	for i := 0; i &lt; len(S); i++ {
		right = max(right, strings.LastIndex(S, string(S[i])))
		if i == right {
			res = append(res, right-left+1)
			left = right + 1
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>767.重构字符串(2)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。
若可行，输出任意可行的结果。若不可行，返回空字符串。
示例 1:输入: S = &quot;aab&quot; 输出: &quot;aba&quot;
示例 2:输入: S = &quot;aaab&quot; 输出: &quot;&quot;
注意: S 只包含小写字母并且长度在[1, 500]区间内。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>自定义排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func reorganizeString(S string) string {
	n := len(S)
	if n &lt;= 1 {
		return S
	}
	res := make([]byte, 0)
	m := make(map[byte]int)
	for _, v := range S {
		m[byte(v)]++
	}
	nodeHeap := &amp;Heap{}
	heap.Init(nodeHeap)
	for k, v := range m {
		if v &gt; (n+1)/2 {
			return &quot;&quot;
		}
		heap.Push(nodeHeap, Node{
			char: k,
			num:  v,
		})
	}
	for nodeHeap.Len() &gt;= 2 {
		node1 := heap.Pop(nodeHeap).(Node)
		node2 := heap.Pop(nodeHeap).(Node)
		res = append(res, node1.char, node2.char)
		node1.num--
		node2.num--
		if node1.num &gt; 0 {
			heap.Push(nodeHeap, node1)
		}
		if node2.num &gt; 0 {
			heap.Push(nodeHeap, node2)
		}
	}
	if nodeHeap.Len() &gt; 0 {
		t := heap.Pop(nodeHeap).(Node)
		res = append(res, t.char)
	}
	return string(res)
}

type Node struct {
	char byte
	num  int
}

type Heap []Node

func (h Heap) Len() int {
	return len(h)
}

func (h Heap) Less(i, j int) bool {
	return h[i].num &gt; h[j].num
}

func (h Heap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *Heap) Push(x interface{}) {
	*h = append(*h, x.(Node))
}

func (h *Heap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
func reorganizeString(S string) string {
	arr := make([]node, 26)
	maxCount := 0
	for _, char := range S {
		index := char - &#39;a&#39;
		arr[index].char = char
		arr[index].num++
		if arr[index].num &gt; maxCount {
			maxCount = arr[index].num
		}
	}
	if maxCount &gt; (len(S)+1)/2 {
		return &quot;&quot;
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i].num &gt;= arr[j].num
	})
	res := make([]rune, len(S))
	var index int
	// 先偶后奇
	for i := 0; i &lt; 2; i++ {
		for j := i; j &lt; len(S); j = j + 2 {
			if arr[index].num == 0 {
				index++
			}
			res[j] = arr[index].char
			arr[index].num--
		}
	}
	return string(res)
}
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>769.最多能完成排序的块(1)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，
并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
我们最多能将数组分成多少块？
示例 1:输入: arr = [4,3,2,1,0] 输出: 1
解释:将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
示例 2:输入: arr = [1,0,2,3,4] 输出: 4
解释:我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
注意:arr 的长度在 [1, 10] 之间。
arr[i]是 [0, 1, ..., arr.length - 1]的一种排列。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxChunksToSorted</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
			<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">maxValue</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>775.全局倒置与局部倒置(3)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数组 A 是 [0, 1, ..., N - 1] 的一种排列，N 是数组 A 的长度。
全局倒置指的是 i,j 满足 0 &lt;= i &lt; j &lt; N 并且 A[i] &gt; A[j] ，
局部倒置指的是 i 满足 0 &lt;= i &lt; N 并且 A[i] &gt; A[i+1] 。
当数组 A 中全局倒置的数量等于局部倒置的数量时，返回 true 。
示例 1:输入: A = [1,0,2] 输出: true
解释: 有 1 个全局倒置，和 1 个局部倒置。
示例 2:输入: A = [1,2,0] 输出: false
解释: 有 2 个全局倒置，和 1 个局部倒置。
注意:A 是 [0, 1, ..., A.length - 1] 的一种排列
A 的长度在 [1, 5000]之间
这个问题的时间限制已经减少了。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isIdealPermutation(A []int) bool {
	if len(A) &lt; 3 {
		return true
	}
	// 局部倒置首先是一个全局倒置，因此无需统计局部倒置
	// 只需要判断是否存在 0&lt;=i&lt;k&lt;j&lt;N 并且A[i]&gt;A[j]
	maxValue := A[0] // 前2位数组最大值，如果存在maxValue &gt; A[i]，则不会相等
	for i := 2; i &lt; len(A); i++ {
		if maxValue &gt; A[i] {
			return false
		}
		if maxValue &lt; A[i-1] {
			maxValue = A[i-1]
		}
	}
	return true
}

# 2
func isIdealPermutation(A []int) bool {
	if len(A) &lt; 3 {
		return true
	}
	minValue := len(A)
	for i := len(A) - 1; i &gt;= 2; i-- {
		if A[i] &lt; minValue {
			minValue = A[i]
		}
		if A[i-2] &gt; minValue {
			return false
		}
	}
	return true
}

# 3
func isIdealPermutation(A []int) bool {
	if len(A) &lt; 3 {
		return true
	}
	for i := 0; i &lt; len(A); i++ {
		if abs(i-A[i]) &gt; 1 {
			return false
		}
	}
	return true
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="lr-1">
<h2>777.在LR字符串中交换相邻字符(1)<a class="headerlink" href="#lr-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个由 &#39;L&#39; , &#39;R&#39; 和 &#39;X&#39; 三个字符组成的字符串（例如&quot;RXXLRXRXL&quot;）中进行移动操作。
一次移动操作指用一个&quot;LX&quot;替换一个&quot;XL&quot;，或者用一个&quot;XR&quot;替换一个&quot;RX&quot;。
现给定起始字符串start和结束字符串end，请编写代码，
当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。
示例 :输入: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot; 输出: True
解释:我们可以通过以下几步将start转换成end:
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX
提示：1 &lt;= len(start) = len(end) &lt;= 10000。
start和end中的字符串仅限于&#39;L&#39;, &#39;R&#39;和&#39;X&#39;。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">canTransform</span><span class="p">(</span><span class="nx">start</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ReplaceAll</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ReplaceAll</span><span class="p">(</span><span class="nx">end</span><span class="p">,</span> <span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">start</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;L&#39;</span> <span class="p">{</span> <span class="c1">// LX=&gt;XL, L是往右的</span>
			<span class="k">for</span> <span class="nx">end</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;L&#39;</span> <span class="p">{</span>
				<span class="nx">j</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">start</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span> <span class="p">{</span> <span class="c1">// XR=&gt;RX, R是往左的</span>
			<span class="k">for</span> <span class="nx">end</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;R&#39;</span> <span class="p">{</span>
				<span class="nx">j</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nx">j</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-3">
<h2>779.第K个语法符号(3)<a class="headerlink" href="#k-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）
例子:输入: N = 1, K = 1 输出: 0
输入: N = 2, K = 1 输出: 0
输入: N = 2, K = 2 输出: 1
输入: N = 4, K = 5 输出: 1
解释:
第一行: 0
第二行: 01
第三行: 0110
第四行: 01101001
注意： N 的范围 [1, 30]. K 的范围 [1, 2^(N-1)].
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>位运算</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func kthGrammar(N int, K int) int {
	if K == 1 {
		return 0
	}
    // N行K的数是由N-1行(K+1)/2的数来的
	temp := kthGrammar(N-1, (K+1)/2)
	if K%2 == 1 {
		return temp
	}
	return 1 - temp
}

# 2
func kthGrammar(N int, K int) int {
	if K == 1 {
		return 0
	}
	total := int(math.Pow(2, float64(N-1)))
	half := total / 2
	if K &lt;= half {
		return kthGrammar(N-1, K)
	}
	return 1 - kthGrammar(N-1, K-half)
}

# 3
func kthGrammar(N int, K int) int {
	return bits.OnesCount(uint(K-1))%2
}
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>781.森林中的兔子(2)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。
我们将这些回答放在 answers 数组里。
返回森林中兔子的最少数量。
示例:输入: answers = [1, 1, 2] 输出: 5
解释:两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。
之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 &quot;2&quot; 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。
输入: answers = [10, 10, 10] 输出: 11
输入: answers = [] 输出: 0
说明: answers 的长度最大为1000。
    answers[i] 是在 [0, 999] 范围内的整数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numRabbits(answers []int) int {
	res := 0
	m := make(map[int]int)
	for i := 0; i &lt; len(answers); i++ {
		value := answers[i]
		if m[value] == 0 {
			res = res + value + 1
		}
		m[value]++
		if m[value] == value+1 {
			m[value] = 0
		}
	}
	return res
}

# 2
func numRabbits(answers []int) int {
	res := 0
	m := make(map[int]int)
	for i := 0; i &lt; len(answers); i++ {
		value := answers[i]
		m[value]++
	}
	for k, v := range m {
		target := k + 1
		res = res + v/target*target
		if v%target &gt; 0 {
			res = res + target
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>790.多米诺和托米诺平铺(2)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有两种形状的瓷砖：一种是 2x1 的多米诺形，另一种是形如 &quot;L&quot; 的托米诺形。两种形状都可以旋转。
XX  &lt;- 多米诺
XX  &lt;- &quot;L&quot; 托米诺
X
给定 N 的值，有多少种方法可以平铺 2 x N 的面板？返回值 mod 10^9 + 7。
（平铺指的是每个正方形都必须有瓷砖覆盖。
两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。）
示例:输入: 3 输出: 5
解释: 下面列出了五种不同的方法，不同字母代表不同瓷砖：
XYZ XXZ XYY XXY XYY
XYZ YYZ XZZ XYY XXY
提示：N  的范围是 [1, 1000]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var mod = 1000000007

func numTilings(N int) int {
	dp := [4]int{}
	dp[0] = 1
	for i := 0; i &lt; N; i++ {
		temp := [4]int{}
		temp[0] = (dp[0] + dp[3]) % mod
		temp[1] = (dp[0] + dp[2]) % mod
		temp[2] = (dp[0] + dp[1]) % mod
		temp[3] = (dp[0] + dp[1] + dp[2]) % mod
		dp = temp
	}
	return dp[0]
}

# 2
func numTilings(N int) int {
	dp := make([]int, N+3)
	dp[1] = 1
	dp[2] = 2
	dp[3] = 5
	for i := 4; i &lt;= N; i++ {
		dp[i] = (2*dp[i-1] + dp[i-3]) % 1000000007
	}
	return dp[N]
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>791.自定义字符串排序(3)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。
S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。
更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。
返回任意一种符合条件的字符串T。
示例: 输入:
S = &quot;cba&quot;
T = &quot;abcd&quot;
输出: &quot;cbad&quot;
解释: S中出现了字符 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 所以 &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 的顺序应该是 &quot;c&quot;, &quot;b&quot;, &quot;a&quot;. 
由于 &quot;d&quot; 没有在S中出现, 它可以放在T的任意位置. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; 都是合法的输出。
注意:S的最大长度为26，其中没有重复的字符。
T的最大长度为200。
S和T只包含小写字符。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>自定义排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func customSortString(S string, T string) string {
	m := make(map[uint8]int)
	for i := 0; i &lt; len(S); i++ {
		m[S[i]] = i
	}
	arr := []byte(T)
	sort.Slice(arr, func(i, j int) bool {
		return m[arr[i]] &lt; m[arr[j]]
	})
	return string(arr)
}

# 2
func customSortString(S string, T string) string {
	count := make([]int, 26)
	for i := 0; i &lt; len(T); i++ {
		count[T[i]-&#39;a&#39;]++
	}
	res := make([]byte, 0)
	for i := 0; i &lt; len(S); i++ {
		for j := 0; j &lt; count[S[i]-&#39;a&#39;]; j++ {
			res = append(res, S[i])
		}
		count[S[i]-&#39;a&#39;] = 0
	}
	for i := 0; i &lt; 26; i++ {
		for j := 0; j &lt; count[i]; j++ {
			res = append(res, byte(i+&#39;a&#39;))
		}
	}
	return string(res)
}

# 3
func customSortString(S string, T string) string {
	res := []byte(T)
	index := 0
	for i := 0; i &lt; len(S); i++ {
		for j := 0; j &lt; len(res); j++ {
			if res[j] == S[i] {
				res[j], res[index] = res[index], res[j]
				index++
			}
		}
	}
	return string(res)
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>792.匹配子序列的单词数(2)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定字符串 S 和单词字典 words, 求 words[i] 中是 S 的子序列的单词个数。
示例:输入: S = &quot;abcde&quot; words = [&quot;a&quot;, &quot;bb&quot;, &quot;acd&quot;, &quot;ace&quot;] 输出: 3
解释: 有三个是 S 的子序列的单词: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;。
注意:所有在words和 S 里的单词都只由小写字母组成。
S 的长度在 [1, 50000]。
words 的长度在 [1, 5000]。
words[i]的长度在[1, 50]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numMatchingSubseq(S string, words []string) int {
	res := 0
	m := make(map[string]int)
	for i := 0; i &lt; len(words); i++ {
		m[words[i]]++
	}
	for k, v := range m {
		if judge(S, k) == true {
			res = res + v
		}
	}
	return res
}

func judge(S string, str string) bool {
	for i, j := 0, 0; i &lt; len(S) &amp;&amp; j &lt; len(str); i++ {
		if S[i] == str[j] {
			j++
		}
		if j == len(str) {
			return true
		}
	}
	return false
}

# 2
func numMatchingSubseq(S string, words []string) int {
	res := 0
	for i := 0; i &lt; len(words); i++ {
		if len(words[i]) &gt; len(S) {
			continue
		}
		k := 0
		for j := 0; j &lt; len(S); j++ {
			if S[j] == words[i][k] {
				k++
				if k == len(words[i]) {
					res++
					break
				}
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>797. 所有可能的路径(1)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）
二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点
（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。
示例 1：输入：graph = [[1,2],[3],[3],[]] 输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3
示例 2：输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
示例 3：输入：graph = [[1],[]] 输出：[[0,1]]
示例 4：输入：graph = [[1,2,3],[2],[3],[]] 输出：[[0,1,2,3],[0,2,3],[0,3]]
示例 5：输入：graph = [[1,3],[2],[3],[]] 输出：[[0,1,2,3],[0,3]]
提示：结点的数量会在范围 [2, 15] 内。
你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(2^n*n^2)</td>
<td>O(2^n*n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">allPathsSourceTarget</span><span class="p">(</span><span class="nx">graph</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">graph</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">graph</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
		<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">))</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">temp</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">graph</span><span class="p">[</span><span class="nx">cur</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">cur</span><span class="p">][</span><span class="nx">i</span><span class="p">],</span> <span class="nx">target</span><span class="p">,</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">cur</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h2>799.香槟塔(1)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，
第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。
从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，
任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。
当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。
（当最底层的玻璃杯满了，香槟会流到地板上）
例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。
在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。
在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。
现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。
示例 1:输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.0
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。
示例 2:输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.5
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。
注意:poured 的范围[0, 10 ^ 9]。
query_glass 和query_row 的范围 [0, 99]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">champagneTower</span><span class="p">(</span><span class="nx">poured</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">query_row</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">query_glass</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">:=</span> <span class="nx">query_row</span><span class="p">,</span> <span class="nx">query_glass</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">float64</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">float64</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">poured</span><span class="p">)</span> <span class="c1">// 初始值</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>     <span class="c1">// 往左分</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="c1">// 往右分</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">m</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mf">1.0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">m</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>0701-0800-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="id42">
<h2>710.黑名单中的随机数(1)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。
对它进行优化使其尽量少调用系统方法 Math.random() 。
提示:1 &lt;= N &lt;= 1000000000
0 &lt;= B.length &lt; min(100000, N)
[0, N) 不包含 N，详细参见 interval notation 。
示例 1:输入: [&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;] [[1,[]],[],[],[]]
输出: [null,0,0,0]
示例 2:输入: [&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;] [[2,[]],[],[],[]]
输出: [null,1,1,1]
示例 3:输入: [&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;] [[3,[1]],[],[],[]]
Output: [null,0,0,2]
示例 4:输入: [&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;] [[4,[2]],[],[],[]]
输出: [null,1,3,1]
输入语法说明：
输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，N 和黑名单 B。
pick 没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Solution</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">N</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">(</span><span class="nx">N</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">blacklist</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="nx">Solution</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blacklist</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">temp</span><span class="p">[</span><span class="nx">blacklist</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nx">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blacklist</span><span class="p">)</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 需要替换为较大数</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blacklist</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">blacklist</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="p">{</span>
			<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">blacklist</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 没有使用过的较大数</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Solution</span><span class="p">{</span>
		<span class="nx">m</span><span class="p">:</span> <span class="nx">m</span><span class="p">,</span>
		<span class="nx">N</span><span class="p">:</span> <span class="nx">length</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">Solution</span><span class="p">)</span> <span class="nx">Pick</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">index</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">index</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2>765.情侣牵手(2)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 
计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。
人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，
第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。
这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。
示例 1:输入: row = [0, 2, 1, 3] 输出: 1
解释: 我们只需要交换row[1]和row[2]的位置即可。
示例 2:输入: row = [3, 2, 0, 1] 输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。
说明:len(row) 是偶数且数值在 [4, 60]范围内。
可以保证row 是序列 0...len(row)-1 的一个全排列。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>并查集</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minSwapsCouples(row []int) int {
	n := len(row) / 2
	fa := make([]int, n)
	for i := 0; i &lt; n; i++ {
		fa[i] = i
	}
	// 将每张沙发上的两个人员编号union一下，如果本来编号就相同，则表示两个人是一类
	for i := 0; i &lt; len(row); i = i + 2 {
		a, b := row[i]/2, row[i+1]/2
		union(fa, a, b)
	}
	res := 0
	for i := 0; i &lt; n; i++ {
		// 几个相同，就有几个环
		if find(fa, i) == i {
			res++
		}
	}
	// 如果3组1个环，需要的次数是3-1=2，另外4组1个环，需要的次数是4-1=3。4+3-2=5
	// 组数-减去环数
	return n - res
}

func union(fa []int, a, b int) {
	fa[find(fa, a)] = find(fa, b)
}

func find(fa []int, a int) int {
	for fa[a] != a {
		fa[a] = fa[fa[a]]
		a = fa[a]
	}
	return a
}

# 2
func minSwapsCouples(row []int) int {
	res := 0
	for i := 0; i &lt; len(row); i = i + 2 {
		a, b := row[i], row[i+1]
		if b == a^1 {
			continue
		}
		res = res + 1
		for j := i + 1; j &lt; len(row); j++ {
			if row[j] == a^1 {
				row[j], row[i+1] = row[i+1], row[j]
				break
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="0801-0900.html" class="btn btn-neutral float-right" title="0801-0900-Easy" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="0601-0700.html" class="btn btn-neutral float-left" title="0601-0700-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>