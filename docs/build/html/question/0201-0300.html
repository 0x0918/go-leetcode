

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>0201-0300-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="0301-0400-Easy" href="0301-0400.html" />
    <link rel="prev" title="0101-0200-Easy" href="0101-0200.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">0201-0300-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">202.快乐数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">203.移除链表元素(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">204.计数质数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">205.同构字符串(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">206.反转链表(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">217.存在重复元素(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-2">219.存在重复元素 II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">225.用队列实现栈(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">226.翻转二叉树(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">231.2的幂(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">232.用栈实现队列(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">234.回文链表(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">235.二叉搜索树的最近公共祖先(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">237.删除链表中的节点(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">242.有效的字母异位词(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">257.二叉树的所有路径(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">258.各位相加(4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">263.丑数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">268.缺失数字(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19">278.第一个错误的版本(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">283.移动零(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">290.单词规律(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nim-1">292.Nim 游戏(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">299.猜数字游戏(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">0201-0300-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id23">201.数字范围按位与(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">207.课程表(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trie-2">208.实现Trie(前缀树)(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">209.长度最小的子数组(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">210.课程表II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">211.添加与搜索单词-数据结构设计(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-3">213.打家劫舍II(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-3">215.数组中的第K个最大元素(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iii-1">216.组合总和III(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iii-2">220.存在重复元素III(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">221.最大正方形(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">222.完全二叉树的节点个数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">223.矩形面积(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">227.基本计算器II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">228.汇总区间(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">229.求众数II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">230.二叉搜索树中第K小的元素(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">236.二叉树的最近公共祖先(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">238.除自身以外数组的乘积(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-6">240.搜索二维矩阵II(6)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">241.为运算表达式设计优先级(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iii-3">260.只出现一次的数字III(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-1">264.丑数II(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#h-2">274.H指数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hii-2">275.H指数II(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">279.完全平方数(5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">284.顶端迭代器(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">287.寻找重复数(8)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id41">289.生命游戏(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id42">300.最长上升子序列(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">0201-0300-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id43">214.最短回文串(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">224.基本计算器(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id45">233.数字1的个数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id46">239.滑动窗口最大值(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id47">273.整数转换英文表(3)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id48">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id49">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id50">295.数据流的中位数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id51">297.二叉树的序列化与反序列化(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html">1701-1800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#medium">1701-1800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1701-1800.html#hard">1701-1800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>0201-0300-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/0201-0300.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>0201-0300-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="#0201-0300-easy">0201-0300-Easy</a><ul>
<li><a class="reference external" href="#202%E5%BF%AB%E4%B9%90%E6%95%B02">202.快乐数(2)</a></li>
<li><a class="reference external" href="#203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A02">203.移除链表元素(2)</a></li>
<li><a class="reference external" href="#204%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B02">204.计数质数(2)</a></li>
<li><a class="reference external" href="#205%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B23">205.同构字符串(3)</a></li>
<li><a class="reference external" href="#206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A84">206.反转链表(4)</a></li>
<li><a class="reference external" href="#217%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02">217.存在重复元素(2)</a></li>
<li><a class="reference external" href="#219%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii2">219.存在重复元素 II(2)</a></li>
<li><a class="reference external" href="#225%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%884">225.用队列实现栈(4)</a></li>
<li><a class="reference external" href="#226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%912">226.翻转二叉树(2)</a></li>
<li><a class="reference external" href="#2312%E7%9A%84%E5%B9%823">231.2的幂(3)</a></li>
<li><a class="reference external" href="#232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%973">232.用栈实现队列(3)</a></li>
<li><a class="reference external" href="#234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A84">234.回文链表(4)</a></li>
<li><a class="reference external" href="#235%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%882">235.二叉搜索树的最近公共祖先(2)</a></li>
<li><a class="reference external" href="#237%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91">237.删除链表中的节点(1)</a></li>
<li><a class="reference external" href="#242%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D2">242.有效的字母异位词(2)</a></li>
<li><a class="reference external" href="#257%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%842">257.二叉树的所有路径(2)</a></li>
<li><a class="reference external" href="#258%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A04">258.各位相加(4)</a></li>
<li><a class="reference external" href="#263%E4%B8%91%E6%95%B02">263.丑数(2)</a></li>
<li><a class="reference external" href="#268%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%975">268.缺失数字(5)</a></li>
<li><a class="reference external" href="#278%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC2">278.第一个错误的版本(2)</a></li>
<li><a class="reference external" href="#283%E7%A7%BB%E5%8A%A8%E9%9B%B63">283.移动零(3)</a></li>
<li><a class="reference external" href="#290%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B2">290.单词规律(2)</a></li>
<li><a class="reference external" href="#292nim-%E6%B8%B8%E6%88%8F1">292.Nim 游戏(1)</a></li>
<li><a class="reference external" href="#299%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F2">299.猜数字游戏(2)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0201-0300-medium">0201-0300-Medium</a><ul>
<li><a class="reference external" href="#201%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E2">201.数字范围按位与(2)</a></li>
<li><a class="reference external" href="#207%E8%AF%BE%E7%A8%8B%E8%A1%A82">207.课程表(2)</a></li>
<li><a class="reference external" href="#208%E5%AE%9E%E7%8E%B0trie%E5%89%8D%E7%BC%80%E6%A0%912">208.实现Trie(前缀树)(2)</a></li>
<li><a class="reference external" href="#209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%843">209.长度最小的子数组(3)</a></li>
<li><a class="reference external" href="#210%E8%AF%BE%E7%A8%8B%E8%A1%A8ii2">210.课程表II(2)</a></li>
<li><a class="reference external" href="#211%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A11">211.添加与搜索单词-数据结构设计(1)</a></li>
<li><a class="reference external" href="#213%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii3">213.打家劫舍II(3)</a></li>
<li><a class="reference external" href="#215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A03">215.数组中的第K个最大元素(3)</a></li>
<li><a class="reference external" href="#216%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Ciii1">216.组合总和III(1)</a></li>
<li><a class="reference external" href="#220%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0iii2">220.存在重复元素III(2)</a></li>
<li><a class="reference external" href="#221%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A23">221.最大正方形(3)</a></li>
<li><a class="reference external" href="#222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B03">222.完全二叉树的节点个数(3)</a></li>
<li><a class="reference external" href="#223%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF1">223.矩形面积(1)</a></li>
<li><a class="reference external" href="#227%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8ii">227.基本计算器II</a><ul>
<li><a class="reference external" href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a class="reference external" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</a></li>
</ul>
</li>
<li><a class="reference external" href="#228%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B42">228.汇总区间(2)</a></li>
<li><a class="reference external" href="#229%E6%B1%82%E4%BC%97%E6%95%B0ii2">229.求众数II(2)</a></li>
<li><a class="reference external" href="#230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A03">230.二叉搜索树中第K小的元素(3)</a></li>
<li><a class="reference external" href="#236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%882">236.二叉树的最近公共祖先(2)</a></li>
<li><a class="reference external" href="#238%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF3">238.除自身以外数组的乘积(3)</a></li>
<li><a class="reference external" href="#240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii6">240.搜索二维矩阵II(6)</a></li>
<li><a class="reference external" href="#241%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7">241.为运算表达式设计优先级</a><ul>
<li><a class="reference external" href="#%E9%A2%98%E7%9B%AE-1">题目</a></li>
<li><a class="reference external" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1">解题思路</a></li>
</ul>
</li>
<li><a class="reference external" href="#260%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97iii3">260.只出现一次的数字III(3)</a></li>
<li><a class="reference external" href="#264%E4%B8%91%E6%95%B0ii1">264.丑数II(1)</a></li>
<li><a class="reference external" href="#274h%E6%8C%87%E6%95%B02">274.H指数(2)</a></li>
<li><a class="reference external" href="#275h%E6%8C%87%E6%95%B0ii2">275.H指数II(2)</a></li>
<li><a class="reference external" href="#279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B05">279.完全平方数(5)</a></li>
<li><a class="reference external" href="#284%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8">284.顶端迭代器</a><ul>
<li><a class="reference external" href="#%E9%A2%98%E7%9B%AE-2">题目</a></li>
<li><a class="reference external" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2">解题思路</a></li>
</ul>
</li>
<li><a class="reference external" href="#287%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B08">287.寻找重复数(8)</a></li>
<li><a class="reference external" href="#289%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F2">289.生命游戏(2)</a></li>
<li><a class="reference external" href="#300%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%972">300.最长上升子序列(2)</a></li>
</ul>
</li>
<li><a class="reference external" href="#0201-0300-hard">0201-0300-Hard</a><ul>
<li><a class="reference external" href="#214%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B23">214.最短回文串(3)</a></li>
<li><a class="reference external" href="#233%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B03">233.数字1的个数(3)</a></li>
<li><a class="reference external" href="#239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC3">239.滑动窗口最大值(3)</a></li>
<li><a class="reference external" href="#295%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B01">295.数据流的中位数(1)</a></li>
<li><a class="reference external" href="#297%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%962">297.二叉树的序列化与反序列化(2)</a></li>
</ul>
</li>
</ul>
<div class="section" id="id1">
<h2>202.快乐数(2)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。
示例： 输入：19 输出：true 
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希+遍历</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>遍历+快慢判断环</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isHappy(n int) bool {
	now, next := n, nextValue(n)
	m := make(map[int]int)
	m[now] = 1
	for {
		if next == 1 {
			break
		}
		if _, ok := m[next]; ok {
			break
		} else {
			m[next] = 1
		}
		next = nextValue(next)
	}

	if next == 1 {
		return true
	}

	return false
}

func nextValue(n int) int {
	ret := 0
	for n != 0 {
		ret = ret + (n%10)*(n%10)
		n = n / 10
	}
	return ret
}

#
func isHappy(n int) bool {
	now, next := n, nextValue(n)
	for now != next {
		now = nextValue(now)
		next = nextValue(nextValue(next))
	}
	if now == 1 {
		return true
	}
	return false
}

func nextValue(n int) int {
	ret := 0
	for n != 0 {
		ret = ret + (n%10)*(n%10)
		n = n / 10
	}
	return ret
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>203.移除链表元素(2)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>删除链表中等于给定值 val 的所有节点。
示例:
输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哨兵结点+链表遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func removeElements(head *ListNode, val int) *ListNode {
	headPre := &amp;ListNode{Next: head}
	temp := headPre

	for temp.Next != nil {
		if temp.Next.Val == val {
			//delete
			temp.Next = temp.Next.Next
		} else {
			temp = temp.Next
		}
	}

	return headPre.Next
}

# 递归
func removeElements(head *ListNode, val int) *ListNode {
	if head == nil {
		return nil
	}
	head.Next = removeElements(head.Next, val)
	if head.Val == val {
		return head.Next
	}
	return head
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>204.计数质数(2)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>统计所有小于非负整数 n 的质数的数量。
示例:
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>筛选质数(厄拉多塞筛法)</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>筛选质数优化</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func countPrimes(n int) int {
	if n &lt; 3 {
		return 0
	}
	notPrimes := make([]bool, n)
	count := 0
	for i := 2; i &lt; n; i++ {
		if notPrimes[i] {
			continue
		}
		for j := i*2 ; j &lt; n; j += i  {
			notPrimes[j] = true
		}
		count++
	}
	return count
}

#
func countPrimes(n int) int {
	if n &lt; 3 {
		return 0
	}
	isPrimes := make([]bool, n)
	for i := range isPrimes {
		isPrimes[i] = true
	}
	for i := 2; i*i &lt; n; i++ {
		if !isPrimes[i] {
			continue
		}
		for j := i * i; j &lt; n; j += i {
			isPrimes[j] = false
		}
	}
	count := 0
	for i := 2; i &lt; n; i++ {
		if isPrimes[i] {
			count++
		}
	}
	return count
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>205.同构字符串(3)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。
两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例 1: 输入: s = &quot;egg&quot;, t = &quot;add&quot; 输出: true
示例 2:输入: s = &quot;foo&quot;, t = &quot;bar&quot; 输出: false
示例 3: 输入: s = &quot;paper&quot;, t = &quot;title&quot; 输出: true

说明:你可以假设 s 和 t 具有相同的长度。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组映射</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希映射</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>字符串查找匹配</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isIsomorphic(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	m1 := make([]int, 256)
	m2 := make([]int, 256)

	for i := 0; i &lt; len(s); i++ {
		a := int(s[i])
		b := int(t[i])
		if m1[a] != m2[b] {
			return false
		}
		m1[a] = i + 1
		m2[b] = i + 1
	}
	return true
}

#
func isIsomorphic(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	m := make(map[int]int)
	n := make(map[int]int)

	for i := 0; i &lt; len(s); i++ {
		a := int(s[i])
		b := int(t[i])
		if m[a] == 0 &amp;&amp; n[b] == 0 {
			m[a] = b
			n[b] = a
		} else if m[a] != b || n[b] != a {
			return false
		}
	}
	return true
}


# 
func isIsomorphic(s string, t string) bool {
	for i := 0; i &lt; len(s); i++ {
		if strings.IndexByte(s[i+1:], s[i]) != strings.IndexByte(t[i+1:], t[i]) {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>206.反转链表(4)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>反转一个单链表。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>迭代-新建节点</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}

	result := reverseList(head.Next)
	head.Next.Next = head
	head.Next = nil
	return result
}

//
func reverseList(head *ListNode) *ListNode {
	var result *ListNode
	var temp *ListNode
	for head != nil {
		temp = head.Next
		head.Next = result
		result = head
		head = temp
	}
	return result
}

#
func reverseList(head *ListNode) *ListNode {
	result := &amp;ListNode{}
	arr := make([]*ListNode, 0)
	for head != nil {
		arr = append(arr, head)
		head = head.Next
	}
	temp := result
	for i := len(arr) - 1; i &gt;= 0; i-- {
		arr[i].Next = nil
		temp.Next = arr[i]
		temp = temp.Next
	}
	return result.Next
}

#
func reverseList(head *ListNode) *ListNode {
	var res *ListNode
	for {
		if head == nil {
			break
		}
		res = &amp;ListNode{head.Val, res}
		head = head.Next
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>217.存在重复元素(2)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组，判断是否存在重复元素。
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

示例 1:输入: [1,2,3,1] 输出: true
示例 2:输入: [1,2,3,4] 输出: false
示例 3:输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序后遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func containsDuplicate(nums []int) bool {
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		if _, ok := m[nums[i]]; ok {
			return true
		} else {
			m[nums[i]] = 1
		}
	}
	return false
}

#
func containsDuplicate(nums []int) bool {
	sort.Ints(nums)
	for i := 0; i &lt; len(nums)-1; i++{
		if nums[i] == nums[i+1]{
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="ii-2">
<h2>219.存在重复元素 II(2)<a class="headerlink" href="#ii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，
使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

示例 1:输入: nums = [1,2,3,1], k = 3输出: true
示例 2:输入: nums = [1,0,1,1], k = 1 输出: true
示例 3:输入: nums = [1,2,3,1,2,3], k = 2 输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希表+滑动窗口</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>#
func containsNearbyDuplicate(nums []int, k int) bool {
	m := make(map[int]int)

	for i, n := range nums {
		if m[n] != 0 &amp;&amp; (i+1)-m[n] &lt;= k {
			return true
		}
		m[n] = i + 1
	}
	return false
}

#
func containsNearbyDuplicate(nums []int, k int) bool {
	m := make(map[int]int)

	for i, n := range nums {
		if m[n] != 0 {
			return true
		}
		m[n] = i + 1
		if len(m) &gt; k {
			delete(m, nums[i-k])
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>225.用队列实现栈(4)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>使用队列实现栈的下列操作：
    push(x) -- 元素 x 入栈
    pop() -- 移除栈顶元素
    top() -- 获取栈顶元素
    empty() -- 返回栈是否为空

注意:
    你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 
    和 is empty 这些操作是合法的。
    你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 
    只要是标准的队列操作即可。
    你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>使用切片实现</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>使用1个list实现</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>使用2个list实现</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>使用2个双端队列deque实现</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type MyStack struct {
	arr []int
}

func Constructor() MyStack {
	return MyStack{}
}

func (m *MyStack) Push(x int) {
	m.arr = append(m.arr, x)
}

func (m *MyStack) Pop() int {
	if len(m.arr) == 0 {
		return 0
	}
	last := m.arr[len(m.arr)-1]
	m.arr = m.arr[0 : len(m.arr)-1]
	return last
}

func (m *MyStack) Top() int {
	if len(m.arr) == 0 {
		return 0
	}
	return m.arr[len(m.arr)-1]
}

func (m *MyStack) Empty() bool {
	if len(m.arr) == 0 {
		return true
	}
	return false
}

# 使用1个list实现
type MyStack struct {
	*list.List
}
func Constructor() MyStack {
	return MyStack{
		list.New(),
	}
}

func (m *MyStack) Push(x int) {
	m.PushBack(x)
}

func (m *MyStack) Pop() int {
	if m.Len() == 0 {
		return -1
	}
	return m.Remove(m.Back()).(int)
}

func (m *MyStack) Top() int {
	if m.Len() == 0 {
		return -1
	}
	return m.Back().Value.(int)
}

func (m *MyStack) Empty() bool {
	return m.Len() == 0
}

#  使用2个list实现
/*
入栈过程：
1、q1 为空，放入 q2，否则放入 q1
出栈过程：
1、q1为空：依次取出q2中的元素（除了最后一个），并且放入q1中 取出q2中的最后一个元素，返回结果
否则 依次取出q1中的元素（除了最后一个），并且放入q2中 取出q1中的最后一个元素，返回结果
*/
type MyStack struct {
	l1 *list.List
	l2 *list.List
}

func Constructor() MyStack {
	return MyStack{
		l1: list.New(),
		l2: list.New(),
	}
}

func (m *MyStack) Push(x int) {
	if m.l1.Len() == 0 {
		m.l2.PushBack(x)
	} else {
		m.l1.PushBack(x)
	}
}

func (m *MyStack) Pop() int {
	var top int
	if m.l1.Len() &gt; 0 {
		for m.l1.Len() &gt; 1 {
			m.l2.PushBack(m.l1.Remove(m.l1.Front()))
		}
		top = m.l1.Remove(m.l1.Front()).(int)
	} else {
		for m.l2.Len() &gt; 1 {
			m.l1.PushBack(m.l2.Remove(m.l2.Front()))
		}
		top = m.l2.Remove(m.l2.Front()).(int)
	}
	return top
}

func (m *MyStack) Top() int {
	var top int
	if m.l1.Len() &gt; 0 {
		for m.l1.Len() &gt; 1 {
			m.l2.PushBack(m.l1.Remove(m.l1.Front()))
		}
		top = m.l1.Back().Value.(int)
		m.l2.PushBack(m.l1.Remove(m.l1.Front()))

	} else {
		for m.l2.Len() &gt; 1 {
			m.l1.PushBack(m.l2.Remove(m.l2.Front()))
		}
		top = m.l2.Back().Value.(int)
		m.l1.PushBack(m.l2.Remove(m.l2.Front()))
	}
	return top
}

func (m *MyStack) Empty() bool {
	return m.l1.Len() == 0 &amp;&amp; m.l2.Len() == 0
}

# 使用2个双端队列deque实现
type MyStack struct {
	l1 *Queue
	l2 *Queue
}

func Constructor() MyStack {
	return MyStack{
		l1: NewQueue(),
		l2: NewQueue(),
	}
}

func (m *MyStack) Push(x int) {
	m.l1.Push(x)
}

func (m *MyStack) Pop() int {
	if m.l2.Len() == 0 {
		m.l1, m.l2 = m.l2, m.l1
	}

	for m.l2.Len() &gt; 1 {
		m.l1.Push(m.l2.Pop())
	}
	return m.l2.Pop()
}

func (m *MyStack) Top() int {
	res := m.Pop()
	m.l1.Push(res)
	return res
}

func (m *MyStack) Empty() bool {
	return (m.l1.Len() + m.l2.Len()) == 0
}

type Queue struct {
	nums []int
}

func NewQueue() *Queue {
	return &amp;Queue{
		nums: []int{},
	}
}

func (q *Queue) Push(n int) {
	q.nums = append(q.nums, n)
}

func (q *Queue) Pop() int {
	if len(q.nums) == 0 {
		return 0
	}
	res := q.nums[0]
	q.nums = q.nums[1:]
	return res
}

func (q *Queue) Len() int {
	return len(q.nums)
}

func (q *Queue) IsEmpty() bool {
	return q.Len() == 0
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>226.翻转二叉树(2)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：
    谷歌：我们90％的工程师使用您编写的软件(Homebrew)，
    但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func invertTree(root *TreeNode) *TreeNode {
	if root == nil || (root.Left == nil &amp;&amp; root.Right == nil) {
		return root
	}
	root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
	return root
}

# 
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}

	var queue []*TreeNode
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		node.Left, node.Right = node.Right, node.Left
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	return root
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>231.2的幂(3)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例 1:输入: 1 输出: true 解释: 2^0 = 1
示例 2:输入: 16 输出: true 解释: 2^4 = 16
示例 3:输入: 218 输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>迭代</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>位运算</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isPowerOfTwo(n int) bool {
	if n &lt; 1 {
		return false
	}
	for n &gt; 1 {
		if n%2 == 1 {
			return false
		}
		n = n / 2
	}
	return true
}

#
func isPowerOfTwo(n int) bool {
	if n &lt; 1 {
		return false
	}
	return n &amp; (n-1) == 0
}

#
func isPowerOfTwo(n int) bool {
	if n &lt; 1 {
		return false
	}
	if n == 1{
		return true
	}
	if n % 2 != 0{
		return false
	}
	return isPowerOfTwo(n/2)
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>232.用栈实现队列(3)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>使用栈实现队列的下列操作：
    push(x) -- 将一个元素放入队列的尾部。
    pop() -- 从队列首部移除元素。
    peek() -- 返回队列首部的元素。
    empty() -- 返回队列是否为空。

示例:
MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false

说明:
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 
和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>使用切片实现</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>使用2个栈实现</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>使用2个切片实现</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type MyQueue struct {
	a []int
}

func Constructor() MyQueue {
	return MyQueue{}
}

func (m *MyQueue) Push(x int) {
	m.a = append(m.a, x)
}

func (m *MyQueue) Pop() int {
	if len(m.a) == 0 {
		return 0
	}
	first := m.a[0]
	m.a = m.a[1:]
	return first
}

func (m *MyQueue) Peek() int {
	if len(m.a) == 0 {
		return 0
	}
	return m.a[0]
}

func (m *MyQueue) Empty() bool {
	if len(m.a) == 0 {
		return true
	}
	return false
}

# 使用2个栈实现
/*
入队: 直接入栈a
出队: 栈b为空，则把栈a中全部数据出栈进入栈b，然后出栈b,不为空直接出栈b
*/
type MyQueue struct {
	a, b *Stack
}

func Constructor() MyQueue {
	return MyQueue{
		a: NewStack(),
		b: NewStack(),
	}
}

func (m *MyQueue) Push(x int) {
	m.a.Push(x)
}

func (m *MyQueue) Pop() int {
	if m.b.Len() == 0 {
		for m.a.Len() &gt; 0 {
			m.b.Push(m.a.Pop())
		}
	}
	return m.b.Pop()
}

func (m *MyQueue) Peek() int {
	res := m.Pop()
	m.b.Push(res)
	return res
}

func (m *MyQueue) Empty() bool {
	return m.a.Len() == 0 &amp;&amp; m.b.Len() == 0
}

type Stack struct {
	nums []int
}

func NewStack() *Stack {
	return &amp;Stack{
		nums: []int{},
	}
}

func (s *Stack) Push(n int) {
	s.nums = append(s.nums, n)
}

func (s *Stack) Pop() int {
	res := s.nums[len(s.nums)-1]
	s.nums = s.nums[:len(s.nums)-1]
	return res
}

func (s *Stack) Len() int {
	return len(s.nums)
}

func (s *Stack) IsEmpty() bool {
	return s.Len() == 0
}

# 使用2个切片实现
type MyQueue struct {
	a []int
	b []int
}

func Constructor() MyQueue {
	return MyQueue{}
}

func (m *MyQueue) Push(x int) {
	m.a = append(m.a, x)
}

func (m *MyQueue) Pop() int {
	m.Peek()
	temp := m.b[len(m.b)-1]
	m.b = m.b[:len(m.b)-1]
	return temp
}

func (m *MyQueue) Peek() int {
	if len(m.b) == 0 {
		for len(m.a) &gt; 0 {
			m.b = append(m.b, m.a[len(m.a)-1])
			m.a = m.a[:len(m.a)-1]
		}
	}
	if len(m.b) == 0 {
		return -1
	}
	return m.b[len(m.b)-1]
}

func (m *MyQueue) Empty() bool {
	return len(m.a) == 0 &amp;&amp; len(m.b) == 0
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>234.回文链表(4)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请判断一个链表是否为回文链表。
示例 1:输入: 1-&gt;2 输出: false
示例 2:输入: 1-&gt;2-&gt;2-&gt;1 输出: true
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>快慢指针反转链表</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isPalindrome(head *ListNode) bool {
	m := make([]int, 0)
	for head != nil {
		m = append(m, head.Val)
		head = head.Next
	}
	i, j := 0, len(m)-1
	for i &lt; j {
		if m[i] != m[j] {
			return false
		}
		i++
		j--
	}
	return true
}

# 2
func isPalindrome(head *ListNode) bool {
	fast, slow := head, head
	for fast != nil &amp;&amp; fast.Next != nil {
		fast = fast.Next.Next
		slow = slow.Next
	}
	var pre *ListNode
	cur := slow
	for cur != nil{
		next := cur.Next
		cur.Next = pre
		pre = cur
		cur = next
	}
	for pre != nil{
		if head.Val != pre.Val{
			return false
		}
		pre = pre.Next
		head = head.Next
	}
	return true
}

# 3
func isPalindrome(head *ListNode) bool {
	m := make([]int, 0)
	temp := head
	for temp != nil {
		m = append(m, temp.Val)
		temp = temp.Next
	}
	for head != nil {
		val := m[len(m)-1]
		m = m[:len(m)-1]
		if head.Val != val {
			return false
		}
		head = head.Next
	}
	return true
}

# 4
var p *ListNode
func isPalindrome(head *ListNode) bool {
	if head == nil{
		return true
	}
	if p == nil{
		p = head
	}
	if isPalindrome(head.Next) &amp;&amp; (p.Val == head.Val){
		p = p.Next
		return true
	}
	p = nil
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>235.二叉搜索树的最近公共祖先(2)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。

说明:
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉搜索树中。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val{
		return lowestCommonAncestor(root.Right, p, q)
	}else if p.Val &lt; root.Val &amp;&amp; q.Val &lt; root.Val{
		return lowestCommonAncestor(root.Left, p, q)
	}else {
		return root
	}
}

#
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	for root != nil{
		if p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val{
			root = root.Right
		}else if p.Val &lt; root.Val &amp;&amp; q.Val &lt; root.Val{
			root = root.Left
		}else {
			return root
		}
	}
	return nil
}
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>237.删除链表中的节点(1)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1: 输入: head = [4,5,1,9], node = 5  输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.

示例 2:输入: head = [4,5,1,9], node = 1 输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.

说明:
    链表至少包含两个节点。
    链表中所有节点的值都是唯一的。
    给定的节点为非末尾节点并且一定是链表中的一个有效节点。
    不要从你的函数中返回任何结果。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>把当前节点替换成下一个节点</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">deleteNode</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Val</span>
	<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>242.有效的字母异位词(2)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
示例 1:输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true
示例 2:输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false

说明:你可以假设字符串只包含小写字母。
进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>排序比较</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	sr := []rune(s)
	tr := []rune(t)

	rec := make(map[rune]int, len(sr))
	for i := range sr {
		rec[sr[i]]++
		rec[tr[i]]--
	}

	for _, n := range rec {
		if n != 0 {
			return false
		}
	}
	return true
}

#
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}
	sArr := make([]int, len(s))
	tArr := make([]int, len(t))
	for i := 0; i &lt; len(s); i++ {
		sArr[i] = int(s[i] - &#39;a&#39;)
		tArr[i] = int(t[i] - &#39;a&#39;)
	}
	sort.Ints(sArr)
	sort.Ints(tArr)
	for i := 0; i &lt; len(s); i++ {
		if sArr[i] != tArr[i] {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>257.二叉树的所有路径(2)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
示例:
输入:

   1
 /   \
2     3
 \
  5
输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]
解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span># 
func binaryTreePaths(root *TreeNode) []string {
	if root == nil {
		return nil
	}

	res := make([]string, 0)
	var dfs func(string, *TreeNode)
	dfs = func(pre string, root *TreeNode) {
		if pre == &quot;&quot; {
			pre = strconv.Itoa(root.Val)
		} else {
			pre += &quot;-&gt;&quot; + strconv.Itoa(root.Val)
		}

		if root.Left != nil {
			dfs(pre, root.Left)
		}

		if root.Right != nil {
			dfs(pre, root.Right)
		}

		if root.Left == nil &amp;&amp; root.Right == nil {
			res = append(res, pre)
		}
	}

	dfs(&quot;&quot;, root)
	return res
}

#
func binaryTreePaths(root *TreeNode) []string {
	res := make([]string, 0)
	if root == nil {
		return res
	}
	var queue []*TreeNode
	var stringQueue []string
	queue = append(queue, root)
	stringQueue = append(stringQueue, strconv.Itoa(root.Val))
	for len(queue) &gt; 0 {
		node := queue[0]
		path := stringQueue[0]
		queue = queue[1:]
		stringQueue = stringQueue[1:]
		if node.Left == nil &amp;&amp; node.Right == nil {
			res = append(res, path)
		}
		if node.Left != nil {
			queue = append(queue, node.Left)
			stringQueue = append(stringQueue, path+&quot;-&gt;&quot;+strconv.Itoa(node.Left.Val))
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
			stringQueue = append(stringQueue, path+&quot;-&gt;&quot;+strconv.Itoa(node.Right.Val))
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>258.各位相加(4)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
示例: 输入: 38 输出: 2  
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
进阶:
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>找规律1</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>找规律2</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>模拟计算-字符串</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>模拟计算-递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span># 找规律1
func addDigits(num int) int {
	if num &lt; 10 {
		return num
	}
	if num%9 == 0 {
		return 9
	}
	return num % 9
}

# 找规律2
func addDigits(num int) int {
	return (num-1)%9 + 1
}

# 模拟计算-字符串
func addDigits(num int) int {
	for num &gt;= 10 {
		num = sumDigits(num)
	}
	return num
}

func sumDigits(num int) int {
	sumVal := 0
	str := strconv.Itoa(num)
	for i := range str {
		sumVal = sumVal + int(str[i]-&#39;0&#39;)
	}
	return sumVal
}

# 模拟计算-递归
func addDigits(num int) int {
	sum := 0
	for num != 0 {
		sum = sum + num%10
		num = num / 10
	}
	if sum/10 == 0 {
		return sum
	}
	return addDigits(sum)
}
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>263.丑数(2)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>丑数就是只包含质因数 2, 3, 5 的正整数。

示例 1:输入: 6 输出: true 解释: 6 = 2 × 3
示例 2:输入: 8 输出: true 解释: 8 = 2 × 2 × 2
示例 3: 输入: 14 输出: false  解释: 14 不是丑数，因为它包含了另外一个质因数 7。

说明：
1 是丑数。
输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func isUgly(num int) bool {
	if num &lt;= 0 {
		return false
	}
	if num &lt;= 6 {
		return true
	}
	if num%2 == 0 {
		return isUgly(num / 2)
	}
	if num%3 == 0 {
		return isUgly(num / 3)
	}
	if num%5 == 0 {
		return isUgly(num / 5)
	}
	return false
}

# 迭代
func isUgly(num int) bool {
	if num &lt;= 0 {
		return false
	}
	for num != 1 {
		if num%2 == 0 {
			num = num / 2
		} else if num%3 == 0 {
			num = num / 3
		} else if num%5 == 0 {
			num = num / 5
		} else {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>268.缺失数字(5)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

示例 1:输入: [3,0,1]输出: 2
示例 2:输入: [9,6,4,2,3,5,7,0,1] 输出: 8

说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数学计算</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>异或-位运算</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>交换排序(就地排序)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func missingNumber(nums []int) int {
	n := len(nums)
	sum := n * (n + 1) / 2
	for i := 0; i &lt; n; i++ {
		sum = sum - nums[i]
	}
	return sum
}

# 2
func missingNumber(nums []int) int {
	sort.Ints(nums)
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] != i {
			return i
		}
	}
	return len(nums)
}

# 3
func missingNumber(nums []int) int {
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		res = res ^ (i+1) ^ nums[i]
	}
	return res
}

# 4
func missingNumber(nums []int) int {
	n := len(nums)
	// 假设index=n
	index := n
	for i := 0; i &lt; n; {
		// nums[i]到指定位置i后往后走
		if i == nums[i] {
			i++
			continue
		}
		if nums[i] == n {
			index = i
			i++
			continue
		}
		nums[i], nums[nums[i]] = nums[nums[i]], nums[i]
	}
	return index
}

# 5
func missingNumber(nums []int) int {
	m := make(map[int]bool)
	for i := range nums{
		m[nums[i]] = true
	}
	for i := 0; i &lt;= len(nums); i++{
		if m[i] == false{
			return i
		}
	}
	return 0
}
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>278.第一个错误的版本(2)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。
由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。
实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true
所以，4 是第一个错误的版本。 
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func firstBadVersion(n int) int {
	low := 1
	high := n
	for low &lt;= high {
		mid := low + (high-low)/2
		if isBadVersion(mid) == false {
			low = mid + 1
		} else if isBadVersion(mid) == true &amp;&amp; isBadVersion(mid-1) == true {
			high = mid - 1
		} else if isBadVersion(mid) == true &amp;&amp; isBadVersion(mid-1) == false {
			return mid
		}
	}
	return -1
}

#
func firstBadVersion(n int) int {
	low := 1
	high := n
	for low &lt; high {
		mid := low + (high-low)/2
		if isBadVersion(mid) {
			high = mid
		} else {
			low = mid + 1
		}
	}
	return low
}
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>283.移动零(3)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
    必须在原数组上操作，不能拷贝额外的数组。
    尽量减少操作次数。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前移补零</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遇零交换</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func moveZeroes(nums []int) {
	length := 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] != 0 {
			nums[length] = nums[i]
			length++
		}
	}

	for i := length; i &lt; len(nums); i++ {
		nums[i] = 0
	}
}

#
func moveZeroes(nums []int) {
	length := 0
	for i:= 0; i &lt; len(nums); i++ {
		nums[i], nums[length] = nums[length], nums[i]
		if nums[length] != 0 {
			length++
		}
	}
}

#
func moveZeroes(nums []int) {
	arr := make([]int,len(nums))
	count := 0
	for i := range nums{
		if nums[i] != 0{
			arr[count] = nums[i]
			count++
		}
	}

	copy(nums, arr)
}
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>290.单词规律(2)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，
例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

示例1:输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;输出: true
示例 2:输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;输出: false
示例 3:输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;输出: false
示例 4:输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; 输出: false

说明:
你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。  
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双哈希相互映射</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>单哈希相互映射</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func wordPattern(pattern string, str string) bool {
	pa := strings.Split(pattern, &quot;&quot;)
	sa := strings.Split(str, &quot; &quot;)
	if len(pa) != len(sa) {
		return false
	}
	length := len(pa)
	pMap := make(map[string]string, length)
	sMap := make(map[string]string, length)

	for i := 0; i &lt; length; i++ {
		pStr, ok := pMap[pa[i]]
		sStr, ok1 := sMap[sa[i]]

		if (ok &amp;&amp; pStr != sa[i]) || (ok1 &amp;&amp; sStr != pa[i]) {
			return false
		} else {
			pMap[pa[i]] = sa[i]
			sMap[sa[i]] = pa[i]
		}
	}
	return true
}

# 
func wordPattern(pattern string, str string) bool {
	pa := strings.Split(pattern, &quot;&quot;)
	sa := strings.Split(str, &quot; &quot;)
	if len(pa) != len(sa) {
		return false
	}
	return isMatch(pa, sa) &amp;&amp; isMatch(sa, pa)
}

func isMatch(pa, sa []string) bool {
	length := len(pa)
	m := make(map[string]string, length)
	for i := 0; i &lt; length; i++ {
		if w, ok := m[pa[i]]; ok &amp;&amp; w != sa[i] {
			return false
		} else {
			m[pa[i]] = sa[i]
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="nim-1">
<h2>292.Nim 游戏(1)<a class="headerlink" href="#nim-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 
拿掉最后一块石头的人就是获胜者。你作为先手。
你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

示例:
输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>推理</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">canWinNim</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// return n&amp;3 != 0</span>
	<span class="k">return</span> <span class="nx">n</span><span class="o">%</span><span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>299.猜数字游戏(2)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。
每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），
有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。
你的朋友将会根据提示继续猜，直到猜出秘密数字。

请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。
请注意秘密数字和朋友的猜测数都可能含有重复数字。

示例 1:输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;输出: &quot;1A3B&quot;
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。

示例 2:输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;输出: &quot;1A1B&quot;
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。

说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>单哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func getHint(secret string, guess string) string {
	length := len(secret)
	right := 0
	wrongLoc := 0
	m := make(map[byte]int)
	n := make(map[byte]int)
	for i := 0; i &lt; length; i++ {
		if secret[i] == guess[i] {
			right++
		} else {
			m[secret[i]]++
			n[guess[i]]++
		}
	}
	for i := range m {
		if m[i] &lt; n[i] {
			wrongLoc = wrongLoc + m[i]
		} else {
			wrongLoc = wrongLoc + n[i]
		}
	}

	return fmt.Sprintf(&quot;%dA%dB&quot;, right, wrongLoc)
}

#
func getHint(secret string, guess string) string {
	length := len(secret)
	right := 0
	wrongNum := 0
	m := make(map[int]int)
	for i := 0; i &lt; length; i++ {
		if secret[i] == guess[i] {
			right++
		}
		m[int(secret[i]-&#39;0&#39;)]++
		m[int(guess[i]-&#39;0&#39;)]--
	}
	for i := range m {
		if m[i] &gt; 0{
			wrongNum = wrongNum + m[i]
		}
	}
	// wrongLoc = 总数 - 猜对的数 - 猜错的数
	wrongLoc := length - right - wrongNum
	return fmt.Sprintf(&quot;%dA%dB&quot;, right, wrongLoc)
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>0201-0300-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id23">
<h2>201.数字范围按位与(2)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。
示例 1: 输入: [5,7]输出: 4
示例 2:输入: [0,1]输出: 0
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>位运算</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>位运算</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rangeBitwiseAnd(m int, n int) int {
	count := 0
	// 找m,n的32位二进制，前面相同的位数，然后后面添0
	for m != n {
		count++
		// 同时右移去除末尾1位
		m = m &gt;&gt; 1
		n = n &gt;&gt; 1
	}
	return m &lt;&lt; count
}

# 2
func rangeBitwiseAnd(m int, n int) int {
	for m &lt; n {
		n = n &amp; (n - 1) // n抹去右边1位1
	}
	return n
}
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>207.课程表(2)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。
在选修某些课程之前需要一些先修课程。 
例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]
给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？
示例 1:输入: 2, [[1,0]]  输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
示例 2:输入: 2, [[1,0],[0,1]] 输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，
你还应先完成课程 1。这是不可能的。
提示：
    输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。
    你可以假定输入的先决条件中没有重复的边。
    1 &lt;= numCourses &lt;= 10^5
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索-判断环</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索-拓扑排序</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res bool
var visited []int
var path []int
var edges [][]int

func canFinish(numCourses int, prerequisites [][]int) bool {
	res = true
	edges = make([][]int, numCourses) // 邻接表
	visited = make([]int, numCourses)
	path = make([]int, 0)
	for i := 0; i &lt; len(prerequisites); i++ {
		// prev-&gt;cur
		prev := prerequisites[i][1]
		cur := prerequisites[i][0]
		edges[prev] = append(edges[prev], cur)
	}
	for i := 0; i &lt; numCourses; i++ {
		if visited[i] == 0 {
			dfs(i)
		}
		if res == false {
			return false
		}
	}
	return res
}

func dfs(start int) {
	// 0 未搜索
	// 1 搜索中
	// 2 已完成
	visited[start] = 1
	for i := 0; i &lt; len(edges[start]); i++ {
		out := edges[start][i]
		if visited[out] == 0 {
			dfs(out)
			if res == false {
				return
			}
		} else if visited[out] == 1 {
			res = false
			return
		}
	}
	visited[start] = 2
	path = append(path, start)
}

# 2
func canFinish(numCourses int, prerequisites [][]int) bool {
	edges := make([][]int, numCourses)
	path := make([]int, 0)
	inEdges := make([]int, numCourses)
	for i := 0; i &lt; len(prerequisites); i++ {
		// prev-&gt;cur
		prev := prerequisites[i][1]
		cur := prerequisites[i][0]
		edges[prev] = append(edges[prev], cur)
		inEdges[cur]++ // 入度
	}
	// 入度为0
	queue := make([]int, 0)
	for i := 0; i &lt; numCourses; i++ {
		if inEdges[i] == 0 {
			queue = append(queue, i)
		}
	}
	for len(queue) &gt; 0 {
		start := queue[0]
		queue = queue[1:]
		path = append(path, start)
		for i := 0; i &lt; len(edges[start]); i++ {
			out := edges[start][i]
			inEdges[out]--
			if inEdges[out] == 0 {
				queue = append(queue, out)
			}
		}
	}
	return len(path) == numCourses
}
</pre></div>
</div>
</div>
<div class="section" id="trie-2">
<h2>208.实现Trie(前缀树)(2)<a class="headerlink" href="#trie-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
示例:Trie trie = new Trie();
trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // 返回 true
trie.search(&quot;app&quot;);     // 返回 false
trie.startsWith(&quot;app&quot;); // 返回 true
trie.insert(&quot;app&quot;);   
trie.search(&quot;app&quot;);     // 返回 true
说明:你可以假设所有的输入都是由小写字母 a-z 构成的。
    保证所有输入均为非空字符串。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>trie树</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>trie树</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type Trie struct {
	next   [26]*Trie
	ending int
}

func Constructor() Trie {
	return Trie{
		next:   [26]*Trie{},
		ending: 0,
	}
}

func (this *Trie) Insert(word string) {
	temp := this
	for _, v := range word {
		value := v - &#39;a&#39;
		if temp.next[value] == nil {
			temp.next[value] = &amp;Trie{
				next:   [26]*Trie{},
				ending: 0,
			}
		}
		temp = temp.next[value]
	}
	temp.ending++
}

func (this *Trie) Search(word string) bool {
	temp := this
	for _, v := range word {
		value := v - &#39;a&#39;
		if temp = temp.next[value]; temp == nil {
			return false
		}
	}
	if temp.ending &gt; 0 {
		return true
	}
	return false
}

func (this *Trie) StartsWith(prefix string) bool {
	temp := this
	for _, v := range prefix {
		value := v - &#39;a&#39;
		if temp = temp.next[value]; temp == nil {
			return false
		}
	}
	return true
}

# 2
type Trie struct {
	next   map[byte]*Trie
	ending int
}

/** Initialize your data structure here. */
func Constructor() Trie {
	return Trie{
		next:   make(map[byte]*Trie),
		ending: 0,
	}
}

/** Inserts a word into the trie. */
func (this *Trie) Insert(word string) {
	temp := this
	for _, v := range word {
		value := byte(v - &#39;a&#39;)
		if temp.next[value] == nil {
			temp.next[value] = &amp;Trie{
				next:   make(map[byte]*Trie),
				ending: 0,
			}
		}
		temp = temp.next[value]
	}
	temp.ending++
}

/** Returns if the word is in the trie. */
func (this *Trie) Search(word string) bool {
	temp := this
	for _, v := range word {
		value := byte(v - &#39;a&#39;)
		if temp = temp.next[value]; temp == nil {
			return false
		}
	}
	if temp.ending &gt; 0 {
		return true
	}
	return false
}

/** Returns if there is any word in the trie that starts with the given prefix. */
func (this *Trie) StartsWith(prefix string) bool {
	temp := this
	for _, v := range prefix {
		value := byte(v - &#39;a&#39;)
		if temp = temp.next[value]; temp == nil {
			return false
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>209.长度最小的子数组(3)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，
并返回其长度。如果不存在符合条件的子数组，返回 0。
示例：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
进阶：如果你已经完成了 O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和-二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minSubArrayLen(s int, nums []int) int {
	res := math.MaxInt32
	for i := 0; i &lt; len(nums); i++ {
		sum := 0
		for j := i; j &lt; len(nums); j++ {
			sum = sum + nums[j]
			if sum &gt;= s {
				if res &gt; j-i+1 {
					res = j - i + 1
				}
				break
			}
		}
	}
	if res == math.MaxInt32 {
		return 0
	}
	return res
}

# 2
func minSubArrayLen(s int, nums []int) int {
	res := math.MaxInt32
	arr := make([]int, len(nums)+1)
	for i := 1; i &lt;= len(nums); i++ {
		arr[i] = arr[i-1] + nums[i-1]
	}
	for i := 1; i &lt;= len(nums); i++ {
		target := s + arr[i-1]
		index := sort.SearchInts(arr, target)
		if index &lt;= len(nums) {
			if res &gt; index-i+1 {
				res = index - i + 1
			}
		}
	}
	if res == math.MaxInt32 {
		return 0
	}
	return res
}

# 3
func minSubArrayLen(s int, nums []int) int {
	res := math.MaxInt32
	i, j := 0, 0
	sum := 0
	for ; j &lt; len(nums); j++ {
		sum = sum + nums[j]
		for sum &gt;= s {
			if res &gt; j-i+1 {
				res = j - i + 1
			}
			sum = sum - nums[i]
			i++
		}
	}
	if res == math.MaxInt32 {
		return 0
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>210.课程表II(2)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 
例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
示例 1:输入: 2, [[1,0]]  输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:输入: 4, [[1,0],[2,0],[3,1],[3,2]] 输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。
并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
说明:输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
    你可以假定输入的先决条件中没有重复的边。
提示:
    这个问题相当于查找一个循环是否存在于有向图中。
    如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
    通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
    拓扑排序也可以通过 BFS 完成。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先搜索</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>广度优先搜索-拓扑排序</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res bool
var visited []int
var path []int
var edges [][]int

func findOrder(numCourses int, prerequisites [][]int) []int {
	res = true
	edges = make([][]int, numCourses) // 邻接表
	visited = make([]int, numCourses)
	path = make([]int, 0)
	for i := 0; i &lt; len(prerequisites); i++ {
		// prev-&gt;cur
		prev := prerequisites[i][1]
		cur := prerequisites[i][0]
		edges[prev] = append(edges[prev], cur)
	}
	for i := 0; i &lt; numCourses; i++ {
		if visited[i] == 0 {
			dfs(i)
		}
		if res == false {
			return nil
		}
	}
	for i := 0; i &lt; len(path)/2; i++ {
		path[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]
	}
	return path
}

func dfs(start int) {
	// 0 未搜索
	// 1 搜索中
	// 2 已完成
	visited[start] = 1
	for i := 0; i &lt; len(edges[start]); i++ {
		out := edges[start][i]
		if visited[out] == 0 {
			dfs(out)
			if res == false {
				return
			}
		} else if visited[out] == 1 {
			res = false
			return
		}
	}
	visited[start] = 2
	path = append(path, start)
}

# 2
func findOrder(numCourses int, prerequisites [][]int) []int {
	edges := make([][]int, numCourses)
	path := make([]int, 0)
	inEdges := make([]int, numCourses)
	for i := 0; i &lt; len(prerequisites); i++ {
		// prev-&gt;cur
		prev := prerequisites[i][1]
		cur := prerequisites[i][0]
		edges[prev] = append(edges[prev], cur)
		inEdges[cur]++ // 入度
	}
	// 入度为0
	queue := make([]int, 0)
	for i := 0; i &lt; numCourses; i++ {
		if inEdges[i] == 0 {
			queue = append(queue, i)
		}
	}
	for len(queue) &gt; 0 {
		start := queue[0]
		queue = queue[1:]
		path = append(path, start)
		for i := 0; i &lt; len(edges[start]); i++ {
			out := edges[start][i]
			inEdges[out]--
			if inEdges[out] == 0 {
				queue = append(queue, out)
			}
		}
	}
	if len(path) != numCourses {
		return nil
	}
	return path
}
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>211.添加与搜索单词-数据结构设计(1)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果数据结构中有任何与word匹配的字符串，则bool search（word）返回true，否则返回false。 
单词可能包含点“。” 点可以与任何字母匹配的地方。
请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。
实现词典类 WordDictionary ：
    WordDictionary() 初始化词典对象
    void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
    bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；
    否则，返回  false 。word 中可能包含一些 &#39;.&#39; ，每个 . 都可以表示任何一个字母。
示例：输入：
[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]
[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]
输出：[null,null,null,null,false,true,true,true]
解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord(&quot;bad&quot;);
wordDictionary.addWord(&quot;dad&quot;);
wordDictionary.addWord(&quot;mad&quot;);
wordDictionary.search(&quot;pad&quot;); // return False
wordDictionary.search(&quot;bad&quot;); // return True
wordDictionary.search(&quot;.ad&quot;); // return True
wordDictionary.search(&quot;b..&quot;); // return True
提示：1 &lt;= word.length &lt;= 500
    addWord 中的 word 由小写英文字母组成
    search 中的 word 由 &#39;.&#39; 或小写英文字母组成
    最调用多 50000 次 addWord 和 search
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>trie树</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Trie</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span>   <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="o">*</span><span class="nx">Trie</span>
	<span class="nx">ending</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">Trie</span><span class="p">)</span> <span class="nx">Insert</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">this</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">word</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">v</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
		<span class="k">if</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Trie</span><span class="p">{</span>
				<span class="nx">next</span><span class="p">:</span>   <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="o">*</span><span class="nx">Trie</span><span class="p">{},</span>
				<span class="nx">ending</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">temp</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">temp</span><span class="p">.</span><span class="nx">ending</span><span class="o">++</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">Trie</span><span class="p">)</span> <span class="nx">Search</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">this</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">word</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Search</span><span class="p">(</span><span class="nx">word</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">word</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
		<span class="k">if</span> <span class="nx">temp</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">value</span><span class="p">];</span> <span class="nx">temp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">ending</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">WordDictionary</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">trie</span> <span class="o">*</span><span class="nx">Trie</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="nx">WordDictionary</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">WordDictionary</span><span class="p">{</span><span class="nx">trie</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">Trie</span><span class="p">{}}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">WordDictionary</span><span class="p">)</span> <span class="nx">AddWord</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">trie</span><span class="p">.</span><span class="nx">Insert</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">WordDictionary</span><span class="p">)</span> <span class="nx">Search</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">this</span><span class="p">.</span><span class="nx">trie</span><span class="p">.</span><span class="nx">Search</span><span class="p">(</span><span class="nx">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ii-3">
<h2>213.打家劫舍II(3)<a class="headerlink" href="#ii-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
示例 1:输入: [2,3,2] 输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2:输入: [1,2,3,1] 输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	} else if n == 1 {
		return nums[0]
	}
	dp1 := make([]int, n) // 从第一家开始打劫，最后一家不可选
	dp2 := make([]int, n) // 从第二家开始打劫，最后一家可以选
	dp1[0] = nums[0]
	dp1[1] = max(nums[0], nums[1])
	dp2[0] = 0
	dp2[1] = nums[1]
	for i := 2; i &lt; n; i++ {
		dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i])
		dp2[i] = max(dp2[i-1], dp2[i-2]+nums[i])
	}
	return max(dp1[n-2], dp2[n-1])
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	} else if n == 1 {
		return nums[0]
	} else if n == 2 {
		return max(nums[0], nums[1])
	}
	return max(getMax(nums[:n-1]), getMax(nums[1:]))
}

func getMax(nums []int) int {
	n := len(nums)
	dp := make([]int, n+1)
	dp[0] = nums[0]
	dp[1] = max(nums[0], nums[1])
	for i := 2; i &lt; n; i++ {
		dp[i] = max(dp[i-1], dp[i-2]+nums[i])
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	} else if n == 1 {
		return nums[0]
	} else if n == 2 {
		return max(nums[0], nums[1])
	}
	return max(getMax(nums[:n-1]), getMax(nums[1:]))
}

func getMax(nums []int) int {
	var a, b int
	for i, v := range nums {
		if i%2 == 0 {
			a = max(a+v, b)
		} else {
			b = max(a, b+v)
		}
	}
	return max(a, b)
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="k-3">
<h2>215.数组中的第K个最大元素(3)<a class="headerlink" href="#k-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在未排序的数组中找到第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1:输入: [3,2,1,5,6,4] 和 k = 2 输出: 5
示例 2:输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4
说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>堆排序</td>
<td>O(nlog(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>03</td>
<td>快排</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findKthLargest(nums []int, k int) int {
	sort.Ints(nums)
	return nums[len(nums)-k]
}

# 2
func findKthLargest(nums []int, k int) int {
	heapSize := len(nums)
	buildMaxHeap(nums, heapSize)
	for i := len(nums) - 1; i &gt;= len(nums)-k+1; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		heapSize--
		maxHeapify(nums, 0, heapSize)
	}
	return nums[0]
}

func buildMaxHeap(a []int, heapSize int) {
	for i := heapSize / 2; i &gt;= 0; i-- {
		maxHeapify(a, i, heapSize)
	}
}

func maxHeapify(a []int, i, heapSize int) {
	l, r, largest := i*2+1, i*2+2, i
	if l &lt; heapSize &amp;&amp; a[l] &gt; a[largest] {
		largest = l
	}
	if r &lt; heapSize &amp;&amp; a[r] &gt; a[largest] {
		largest = r
	}
	if largest != i {
		a[i], a[largest] = a[largest], a[i]
		maxHeapify(a, largest, heapSize)
	}
}

# 3
func findKthLargest(nums []int, k int) int {
	return findK(nums, 0, len(nums)-1, k)
}

func findK(nums []int, start, end int, k int) int {
	if start &gt;= end {
		return nums[end]
	}
	index := partition(nums, start, end)
	if index+1 == k {
		return nums[index]
	} else if index+1 &lt; k {
		return findK(nums, index+1, end, k)
	}
	return findK(nums, start, index-1, k)
}

func partition(nums []int, start, end int) int {
	temp := nums[end]
	i := start
	for j := start; j &lt; end; j++ {
		if nums[j] &gt; temp {
			if i != j {
				nums[i], nums[j] = nums[j], nums[i]
			}
			i++
		}
	}
	nums[i], nums[end] = nums[end], nums[i]
	return i
}
</pre></div>
</div>
</div>
<div class="section" id="iii-1">
<h2>216.组合总和III(1)<a class="headerlink" href="#iii-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
说明：
    所有数字都是正整数。
    解集不能包含重复的组合。 
示例 1:输入: k = 3, n = 7 输出: [[1,2,4]]
示例 2:输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯算法</td>
<td>O(n*C(9,n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">combinationSum3</span><span class="p">(</span><span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">level</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">temp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">level</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dfs</span><span class="p">(</span><span class="nx">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iii-2">
<h2>220.存在重复元素III(2)<a class="headerlink" href="#iii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，
且满足 i 和 j 的差的绝对值也小于等于 ķ 。
如果存在则返回 true，不存在返回 false。
示例 1:输入: nums = [1,2,3,1], k = 3, t = 0 输出: true
示例 2:输入: nums = [1,0,1,1], k = 1, t = 2 输出: true
示例 3:输入: nums = [1,5,9,1,5,9], k = 2, t = 3 输出: false
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>桶</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {
	if len(nums) &lt;= 1 {
		return false
	}
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums) &amp;&amp; j &lt;= i+k; j++ {
			if abs(nums[i], nums[j]) &lt;= t {
				return true
			}
		}
	}
	return false
}

# 2
func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {
	if len(nums) &lt;= 1 || t &lt; 0 {
		return false
	}
	m := make(map[int]int)
	width := t + 1
	for i := 0; i &lt; len(nums); i++ {
		key := getKey(nums[i], width)
		if _, ok := m[key]; ok {
			return true
		}
		if value, ok := m[key-1]; ok &amp;&amp; abs(nums[i], value) &lt; width {
			return true
		}
		if value, ok := m[key+1]; ok &amp;&amp; abs(nums[i], value) &lt; width {
			return true
		}
		m[key] = nums[i]
		if i &gt;= k {
			// 满足i和j的差的绝对值也小于等于ķ
			delete(m, getKey(nums[i-k], width))
		}
	}
	return false
}

func getKey(value, width int) int {
	if value &lt; 0 {
		return (value+1)/width - 1
	}
	return value / width
}

func abs(a, b int) int {
	if a &gt; b {
		return a - b
	}
	return b - a
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>221.最大正方形(3)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:输入: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
输出: 4
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^4)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximalSquare(matrix [][]byte) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}
	res := 0
	n, m := len(matrix), len(matrix[0])
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == &#39;1&#39; {
				res = max(res, 1)
				minLength := min(n-i, m-j)
				for k := 1; k &lt; minLength; k++ {
					flag := true
					if matrix[i+k][j+k] == &#39;0&#39; {
						break
					}
					for l := 0; l &lt; k; l++ {
						if matrix[i+k][j+l] == &#39;0&#39; || matrix[i+l][j+k] == &#39;0&#39; {
							flag = false
							break
						}
					}
					if flag == true {
						res = max(res, k+1)
					} else {
						break
					}
				}
			}
		}
	}
	return res * res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 2
func maximalSquare(matrix [][]byte) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}
	res := 0
	n, m := len(matrix), len(matrix[0])
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, m)
		for j := 0; j &lt; m; j++ {
			dp[i][j] = int(matrix[i][j] - &#39;0&#39;)
			if dp[i][j] == 1 {
				res = 1
			}
		}
	}
	for i := 1; i &lt; n; i++ {
		for j := 1; j &lt; m; j++ {
			if dp[i][j] == 1 {
				dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1
				res = max(res, dp[i][j])
			}
		}
	}
	return res * res

}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
func maximalSquare(matrix [][]byte) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}
	res := 0
	n, m := len(matrix), len(matrix[0])
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if matrix[i][j] == &#39;1&#39; {
				res = max(res, int(matrix[i][j]-&#39;0&#39;))
			}
			if i == 0 || j == 0 {
				continue
			}
			if matrix[i][j] == &#39;1&#39; {
				a := int(matrix[i-1][j-1] - &#39;0&#39;)
				b := int(matrix[i-1][j] - &#39;0&#39;)
				c := int(matrix[i][j-1] - &#39;0&#39;)
				matrix[i][j] = byte(min(a, min(b, c)) + 1 + &#39;0&#39;)
				res = max(res, int(matrix[i][j]-&#39;0&#39;))
			}
		}
	}
	return res * res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>222.完全二叉树的节点个数(3)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个完全二叉树，求出该树的节点个数。
说明：
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，
并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
示例:输入: 
    1
   / \
  2   3
 / \  /
4  5 6
输出: 6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(log(n)^2)</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func countNodes(root *TreeNode) int {
	if root == nil {
		return 0
	}
	return 1 + countNodes(root.Left) + countNodes(root.Right)
}

# 2
func countNodes(root *TreeNode) int {
	if root == nil {
		return 0
	}
	res := 0
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		res++
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	return res
}

# 3
func countNodes(root *TreeNode) int {
	if root == nil {
		return 0
	}
	left := getLevel(root.Left)
	right := getLevel(root.Right)
	if left == right{
		return 1&lt;&lt;left+countNodes(root.Right)
	}
	return countNodes(root.Left) + 1&lt;&lt;right
}

func getLevel(root *TreeNode)int  {
	level := 0
	for root != nil{
		level++
		root = root.Left
	}
	return level
}
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>223.矩形面积(1)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。
每个矩形由其左下顶点和右上顶点坐标表示，如图所示。
示例:输入: -3, 0, 3, 4, 0, -1, 9, 2 输出: 45
说明: 假设矩形面积不会超出 int 的范围。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数学计算</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">computeArea</span><span class="p">(</span><span class="nx">A</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">C</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">D</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">E</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">F</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">G</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">H</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">E</span><span class="p">),</span> <span class="nx">min</span><span class="p">(</span><span class="nx">C</span><span class="p">,</span> <span class="nx">G</span><span class="p">)</span>
	<span class="nx">bottom</span><span class="p">,</span> <span class="nx">top</span> <span class="o">:=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">B</span><span class="p">,</span> <span class="nx">F</span><span class="p">),</span> <span class="nx">min</span><span class="p">(</span><span class="nx">D</span><span class="p">,</span> <span class="nx">H</span><span class="p">)</span>
	<span class="nx">area1</span><span class="p">,</span> <span class="nx">area2</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">C</span><span class="o">-</span><span class="nx">A</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">D</span><span class="o">-</span><span class="nx">B</span><span class="p">),</span> <span class="p">(</span><span class="nx">G</span><span class="o">-</span><span class="nx">E</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">H</span><span class="o">-</span><span class="nx">F</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="p">&lt;</span> <span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="nx">bottom</span> <span class="p">&lt;</span> <span class="nx">top</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">area1</span> <span class="o">+</span> <span class="nx">area2</span> <span class="o">-</span> <span class="p">(</span><span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">top</span><span class="o">-</span><span class="nx">bottom</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">area1</span> <span class="o">+</span> <span class="nx">area2</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>227.基本计算器II(2)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现一个基本的计算器来计算一个简单的字符串表达式的值。
字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。
示例 1:输入: &quot;3+2*2&quot; 输出: 7
示例 2:输入: &quot; 3/2 &quot; 输出: 1
示例 3:输入: &quot; 3+5 / 2 &quot; 输出: 5
说明：
    你可以假设所给定的表达式都是有效的。
    请不要使用内置的库函数 eval。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>栈辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func calculate(s string) int {
	stack := make([]int, 0)
	op := make([]int, 0)
	num := 0
	for i := 0; i &lt; len(s); i++ {
		if &#39;0&#39; &lt;= s[i] &amp;&amp; s[i] &lt;= &#39;9&#39; {
			num = 0
			for i &lt; len(s) &amp;&amp; &#39;0&#39; &lt;= s[i] &amp;&amp; s[i] &lt;= &#39;9&#39; {
				num = num*10 + int(s[i]-&#39;0&#39;)
				i++
			}
			// 处理乘除计算
			if len(op) &gt; 0 &amp;&amp; op[len(op)-1] &gt; 1 {
				if op[len(op)-1] == 2 {
					stack[len(stack)-1] = stack[len(stack)-1] * num
				} else {
					stack[len(stack)-1] = stack[len(stack)-1] / num
				}
				op = op[:len(op)-1]
			} else {
				stack = append(stack, num)
			}
			i--
		} else if s[i] == &#39;+&#39; {
			op = append(op, 1)
		} else if s[i] == &#39;-&#39; {
			op = append(op, -1)
		} else if s[i] == &#39;*&#39; {
			op = append(op, 2)
		} else if s[i] == &#39;/&#39; {
			op = append(op, 3)
		}
	}
	// 处理加减
	for len(op) &gt; 0 {
		stack[1] = stack[0] + stack[1]*op[0]
		stack = stack[1:]
		op = op[1:]
	}
	return stack[0]
}

# 2
func calculate(s string) int {
	s = strings.Trim(s, &quot; &quot;) // 避免&quot;3/2 &quot;的情况
	stack := make([]int, 0)
	num := 0
	sign := byte(&#39;+&#39;)
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39; &#39; {
			continue
		}
		if &#39;0&#39; &lt;= s[i] &amp;&amp; s[i] &lt;= &#39;9&#39; {
			num = num*10 + int(s[i]-&#39;0&#39;)
		}
		if s[i] == &#39;+&#39; || s[i] == &#39;-&#39; || s[i] == &#39;*&#39; || s[i] == &#39;/&#39; || i == len(s)-1 {
            // 处理前一个符号
			switch sign {
			case &#39;+&#39;:
				stack = append(stack, num)
			case &#39;-&#39;:
				stack = append(stack, -num)
			case &#39;*&#39;:
				prev := stack[len(stack)-1]
				stack = stack[:len(stack)-1]
				stack = append(stack, num*prev)
			case &#39;/&#39;:
				prev := stack[len(stack)-1]
				stack = stack[:len(stack)-1]
				stack = append(stack, prev/num)
			}
			num = 0
			sign = s[i]
		}
	}
	res := 0
	for i := 0; i &lt; len(stack); i++ {
		res = res + stack[i]
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>228.汇总区间(2)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。
示例 1:输入: [0,1,2,4,5,7]输出: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;] 
解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。
示例 2:输入: [0,2,3,4,6,8,9]输出: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]
解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func summaryRanges(nums []int) []string {
	res := make([]string, 0)
	if len(nums) == 0 {
		return res
	}
	i, j := 0, 1
	for j &lt; len(nums) {
		if nums[j]-nums[j-1] != 1 {
			str := &quot;&quot;
			if j-i &gt; 1 {
				str = strconv.Itoa(nums[i]) + &quot;-&gt;&quot; + strconv.Itoa(nums[j-1])
			} else {
				str = strconv.Itoa(nums[i])
			}
			res = append(res, str)
			i = j
		}
		j++
	}
	if j == len(nums) {
		str := &quot;&quot;
		if j-i &gt; 1 {
			str = strconv.Itoa(nums[i]) + &quot;-&gt;&quot; + strconv.Itoa(nums[j-1])
		} else {
			str = strconv.Itoa(nums[i])
		}
		res = append(res, str)
	}
	return res
}

# 2
func summaryRanges(nums []int) []string {
	res := make([]string, 0)
	if len(nums) == 0 {
		return res
	}
	nums = append(nums, nums[0])
	i, j := 0, 1
	index := 0
	res = append(res, strconv.Itoa(nums[i]))
	for j = 1; j &lt; len(nums); j++ {
		if nums[j]-nums[j-1] != 1 {
			if j-i &gt; 1 {
				str := strconv.Itoa(nums[i]) + &quot;-&gt;&quot; + strconv.Itoa(nums[j-1])
				res[index] = str
			}
			res = append(res, strconv.Itoa(nums[j]))
			i = j
			index++
		}
	}
	return res[:index]
}
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>229.求众数II(2)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。
示例 1:输入: [3,2,3] 输出: [3]
示例 2:输入: [1,1,1,3,3,2,2,2] 输出: [1,2]
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>摩尔投票法</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func majorityElement(nums []int) []int {
	m := make(map[int]int)
	res := make([]int, 0)
	for i := 0; i &lt; len(nums); i++ {
		m[nums[i]]++
	}
	for k, v := range m {
		if v &gt; len(nums)/3 {
			res = append(res, k)
		}
	}
	return res
}

# 2
func majorityElement(nums []int) []int {
	res := make([]int, 0)
	if len(nums) == 0 {
		return res
	}
	a, b := nums[0], nums[0]
	countA, countB := 0, 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] == a {
			countA++
			continue
		}
		if nums[i] == b {
			countB++
			continue
		}
		if countA == 0 {
			a = nums[i]
			countA++
			continue
		}
		if countB == 0 {
			b = nums[i]
			countB++
			continue
		}
		countA--
		countB--
	}
	countA, countB = 0, 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] == a {
			countA++
		} else if nums[i] == b {
			countB++
		}
	}
	if countA &gt; len(nums)/3 {
		res = append(res, a)
	}
	if countB &gt; len(nums)/3 {
		res = append(res, b)
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>230.二叉搜索树中第K小的元素(3)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。
说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
示例 1:输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
示例 2:输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，
你将如何优化 kthSmallest 函数？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res int
var index int

func kthSmallest(root *TreeNode, k int) int {
	res = 0
	index = k
	dfs(root)
	return res
}

func dfs(root *TreeNode) {
	if root != nil {
		dfs(root.Left)
		index--
		if index == 0 {
			res = root.Val
			return
		}
		dfs(root.Right)
	}
}

# 2
func kthSmallest(root *TreeNode, k int) int {
	res := 0
	stack := make([]*TreeNode, 0)
	for k &gt; 0 {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		res = root.Val
		k--
		root = root.Right
	}
	return res
}

# 3
var res []int

func kthSmallest(root *TreeNode, k int) int {
	res = make([]int, 0)
	dfs(root)
	return res[k-1]
}

func dfs(root *TreeNode) {
	if root != nil {
		dfs(root.Left)
		res = append(res, root.Val)
		dfs(root.Right)
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>236.二叉树的最近公共祖先(2)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
说明:所有节点的值都是唯一的。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	if root.Val == p.Val || root.Val == q.Val {
		return root
	}
	left := lowestCommonAncestor(root.Left, p, q)
	right := lowestCommonAncestor(root.Right, p, q)
	if left != nil &amp;&amp; right != nil {
		return root
	}
	if left == nil {
		return right
	}
	return left
}

# 2
var m map[int]*TreeNode

func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	m = make(map[int]*TreeNode)
	dfs(root)
	visited := make(map[int]bool)
	for p != nil {
		visited[p.Val] = true
		p = m[p.Val]
	}
	for q != nil {
		if visited[q.Val] == true {
			return q
		}
		q = m[q.Val]
	}
	return nil
}

func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	if root.Left != nil {
		m[root.Left.Val] = root
		dfs(root.Left)
	}
	if root.Right != nil {
		m[root.Right.Val] = root
		dfs(root.Right)
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>238.除自身以外数组的乘积(3)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，
其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:输入: [1,2,3,4] 输出: [24,12,8,6]
提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func productExceptSelf(nums []int) []int {
	left := make([]int, len(nums))
	right := make([]int, len(nums))
	res := make([]int, 0)
	left[0] = 1
	right[len(nums)-1] = 1
	for i := 1; i &lt; len(nums); i++ {
		left[i] = left[i-1] * nums[i-1]
	}
	for i := len(nums) - 2; i &gt;= 0; i-- {
		right[i] = right[i+1] * nums[i+1]
	}
	for i := 0; i &lt; len(nums); i++ {
		res = append(res, left[i]*right[i])
	}
	return res
}

# 2
func productExceptSelf(nums []int) []int {
	res := make([]int, 0)
	for i := 0; i &lt; len(nums); i++ {
		value := 1
		for j := 0; j &lt; len(nums); j++ {
			if i != j {
				value = value * nums[j]
			}
		}
		res = append(res, value)
	}
	return res
}

# 3
func productExceptSelf(nums []int) []int {
	res := make([]int, len(nums))
	res[0] = 1
	for i := 1; i &lt; len(nums); i++ {
		res[i] = res[i-1] * nums[i-1]
	}
	value := 1
	for i := len(nums) - 1; i &gt;= 0; i-- {
		res[i] = res[i] * value
		value = value * nums[i]
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="ii-6">
<h2>240.搜索二维矩阵II(6)<a class="headerlink" href="#ii-6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
    每行的元素从左到右升序排列。
    每列的元素从上到下升序排列。
示例:现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法-优化</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>左下角查找</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>右上角查找</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>06</td>
<td>内置函数</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		for j := 0; j &lt; len(matrix[i]); j++ {
			if matrix[i][j] == target {
				return true
			}
		}
	}
	return false
}

# 2
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		if matrix[i][0] &lt;= target &amp;&amp; matrix[i][len(matrix[i])-1] &gt;= target {
			for j := 0; j &lt; len(matrix[i]); j++ {
				if matrix[i][j] == target {
					return true
				}
			}
		}
	}
	return false
}

# 3
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		if matrix[i][0] &lt;= target &amp;&amp; matrix[i][len(matrix[i])-1] &gt;= target {
			res := binarySearch(matrix[i], target)
			if res == true {
				return true
			}
		}
	}
	return false
}

func binarySearch(arr []int, target int) bool {
	left := 0
	right := len(arr) - 1
	for left &lt;= right {
		mid := left + (right-left)/2
		if arr[mid] == target {
			return true
		} else if arr[mid] &gt; target {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return false
}

# 4
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	i := len(matrix) - 1
	j := 0
	for i &gt;= 0 &amp;&amp; j &lt; len(matrix[0]) {
		if matrix[i][j] == target {
			return true
		} else if matrix[i][j] &gt; target {
			i--
		} else {
			j++
		}
	}
	return false
}

# 5
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	i := 0
	j := len(matrix[0]) - 1
	for j &gt;= 0 &amp;&amp; i &lt; len(matrix) {
		if matrix[i][j] == target {
			return true
		} else if matrix[i][j] &gt; target {
			j--
		} else {
			i++
		}
	}
	return false
}

# 6
func searchMatrix(matrix [][]int, target int) bool {
	if len(matrix) == 0 {
		return false
	}
	if len(matrix[0]) == 0 {
		return false
	}
	for i := 0; i &lt; len(matrix); i++ {
		index := sort.SearchInts(matrix[i], target)
		if index &lt; len(matrix[i]) &amp;&amp; target == matrix[i][index] {
			return true
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>241.为运算表达式设计优先级(2)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。
你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。

示例 1:输入: &quot;2-1-1&quot; 输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
示例 2:输入: &quot;2*3-4*5&quot; 输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>分治递归</td>
<td>O(C(2n,n)/(n+1))</td>
<td>O(C(2n,n)/(n+1))</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^3)</td>
<td>O(n^3)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func diffWaysToCompute(input string) []int {
	if value, err := strconv.Atoi(input); err == nil {
		return []int{value}
	}
	res := make([]int, 0)
	for i := 0; i &lt; len(input); i++ {
		char := string(input[i])
		if char == &quot;+&quot; || char == &quot;-&quot; || char == &quot;*&quot; {
			left := diffWaysToCompute(input[:i])
			right := diffWaysToCompute(input[i+1:])
			for _, leftNum := range left {
				for _, rightNum := range right {
					temp := 0
					if char == &quot;+&quot; {
						temp = leftNum + rightNum
					} else if char == &quot;-&quot; {
						temp = leftNum - rightNum
					} else if char == &quot;*&quot; {
						temp = leftNum * rightNum
					}
					res = append(res, temp)
				}
			}
		}
	}
	return res
}

# 2
func diffWaysToCompute(input string) []int {
	if value, err := strconv.Atoi(input); err == nil {
		return []int{value}
	}
	numArr := make([]int, 0)
	opArr := make([]byte, 0)
	num := 0
	for i := 0; i &lt; len(input); i++ {
		if input[i] == &#39;+&#39; || input[i] == &#39;-&#39; || input[i] == &#39;*&#39; {
			opArr = append(opArr, input[i])
			numArr = append(numArr, num)
			num = 0
			continue
		}
		num = num*10 + int(input[i]-&#39;0&#39;)
	}
	numArr = append(numArr, num)
	n := len(numArr)
	dp := make([][][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([][]int, n)
		arr := make([]int, 0)
		arr = append(arr, numArr[i])
		dp[i][i] = arr
	}
	for k := 2; k &lt;= n; k++ { // 长度
		for i := 0; i &lt; n; i++ { // 起点
			j := i + k - 1 // 终点
			if j &gt;= n {
				break
			}
			temp := make([]int, 0)
			for l := i; l &lt; j; l++ { // 切割点
				left := dp[i][l]
				right := dp[l+1][j]
				for a := 0; a &lt; len(left); a++ {
					for b := 0; b &lt; len(right); b++ {
						op := opArr[l]
						if op == &#39;+&#39; {
							temp = append(temp, left[a]+right[b])
						} else if op == &#39;-&#39; {
							temp = append(temp, left[a]-right[b])
						} else if op == &#39;*&#39; {
							temp = append(temp, left[a]*right[b])
						}
					}
				}
			}
			dp[i][j] = temp
		}
	}
	return dp[0][n-1]
}
</pre></div>
</div>
</div>
<div class="section" id="iii-3">
<h2>260.只出现一次的数字III(3)<a class="headerlink" href="#iii-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
示例 :
输入: [1,2,1,3,2,5]
输出: [3,5]
注意：
    结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
    你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>位运算</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>位运算</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func singleNumber(nums []int) []int {
	res := make([]int, 0)
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		m[nums[i]]++
	}
	for k, v := range m {
		if v == 1 {
			res = append(res, k)
		}
	}
	return res
}

# 2
func singleNumber(nums []int) []int {
	a := 0
	for i := 0; i &lt; len(nums); i++ {
		a = a ^ nums[i]
	}
	b := a &amp; (-a) // x &amp; (-x) 是保留位中最右边 1 ，且将其余的 1 设位 0 的方法。
	value := 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i]&amp;b == 0 {
			value = value ^ nums[i]
		}
	}
	return []int{value, a ^ value}
}

# 3
func singleNumber(nums []int) []int {
	a := 0
	for i := 0; i &lt; len(nums); i++ {
		a = a ^ nums[i]
	}
	b := 1
	for a&amp;1 == 0 {
		a = a &gt;&gt; 1
		b = b &lt;&lt; 1
	}
	res := []int{0, 0}
	for i := 0; i &lt; len(nums); i++ {
		if nums[i]&amp;b == 0 {
			res[0] = res[0] ^ nums[i]
		} else {
			res[1] = res[1] ^ nums[i]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="ii-1">
<h2>264.丑数II(1)<a class="headerlink" href="#ii-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个程序，找出第 n 个丑数。
丑数就是质因数只包含 2, 3, 5 的正整数。
示例:输入: n = 10 输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
说明:  
    1 是丑数。
    n 不超过1690。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nthUglyNumber</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="c1">// 丑数*2或3或5之后还是丑数</span>
	<span class="nx">idx2</span><span class="p">,</span> <span class="nx">idx3</span><span class="p">,</span> <span class="nx">idx5</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">idx2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">idx3</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">idx5</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">idx2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
			<span class="nx">idx2</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">idx3</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nx">idx3</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">idx5</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span> <span class="p">{</span>
			<span class="nx">idx5</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="h-2">
<h2>274.H指数(2)<a class="headerlink" href="#h-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。
h 指数的定义：h 代表“高引用次数”（high citations），
一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。
（其余的 N - h 篇论文每篇被引用次数 不超过 h 次。）
例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。
示例：输入：citations = [3,0,6,1,5]输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，
     所以她的 h 指数是 3。
提示：如果 h 有多种可能的值，h 指数是其中最大的那个。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>计数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func hIndex(citations []int) int {
	sort.Ints(citations)
	for i := 0; i &lt; len(citations); i++ {
		if citations[i] &gt;= len(citations)-i {
			return len(citations) - i
		}
	}
	return 0
}

#
func hIndex(citations []int) int {
	arr := make([]int, len(citations)+1)
	for i := 0; i &lt; len(citations); i++ {
		if citations[i] &gt;= len(citations) {
			arr[len(citations)]++
		} else {
			arr[citations[i]]++
		}
	}
	count := 0
	for i := len(citations); i &gt;= 0; i-- {
		count = count + arr[i]
		if count &gt;= i {
			return i
		}
	}
	return 0
}
</pre></div>
</div>
</div>
<div class="section" id="hii-2">
<h2>275.H指数II(2)<a class="headerlink" href="#hii-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。
编写一个方法，计算出研究者的 h 指数。
h 指数的定义: “h 代表“高引用次数”（high citations），
一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。
（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）&quot;
示例:输入: citations = [0,1,3,5,6] 输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，
     所以她的 h 指数是 3。
说明:如果 h 有多有种可能的值 ，h 指数是其中最大的那个。
进阶：
    这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。
    你可以优化你的算法到对数时间复杂度吗？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func hIndex(citations []int) int {
	for i := 0; i &lt; len(citations); i++ {
		if citations[i] &gt;= len(citations)-i {
			return len(citations) - i
		}
	}
	return 0
}

#
func hIndex(citations []int) int {
	left := 0
	right := len(citations) - 1
	for left &lt;= right {
		mid := left + (right-left)/2
		if citations[mid] == len(citations)-mid {
			return len(citations) - mid
		} else if citations[mid] &gt; len(citations)-mid {
			right = mid - 1
		} else if citations[mid] &lt; len(citations)-mid {
			left = mid + 1
		}
	}
	return len(citations) - left
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>279.完全平方数(5)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。
你需要让组成和的完全平方数的个数最少。
示例 1:输入: n = 12 输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:输入: n = 13 输出: 2
解释: 13 = 4 + 9.
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^(3/2))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^(3/2))</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>广度优先搜索</td>
<td>O(n^1/2)</td>
<td>O(n^1/2)</td>
</tr>
<tr>
<td>04</td>
<td>递归</td>
<td>O(n^1/2)</td>
<td>O(n^1/2)</td>
</tr>
<tr>
<td>05</td>
<td>数学</td>
<td>O(n^1/2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numSquares(n int) int {
	dp := make([]int, n+1)
	for i := 1; i &lt;= n; i++ {
		dp[i] = math.MaxInt32
	}
	arr := make([]int, 0)
	arr = append(arr, 0)
	for i := 1; i*i &lt;= n; i++ {
		arr = append(arr, i*i)
	}
	for i := 1; i &lt;= n; i++ {
		for j := 1; j*j &lt;= i; j++ {
			if i &lt; arr[j] {
				break
			}
			dp[i] = min(dp[i], dp[i-arr[j]]+1)
		}
	}
	return dp[n]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

#
func numSquares(n int) int {
	dp := make([]int, n+1)
	for i := 1; i &lt;= n; i++ {
		dp[i] = i
		for j := 1; j*j &lt;= i; j++ {
			dp[i] = min(dp[i], dp[i-j*j]+1)
		}
	}
	return dp[n]
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 3
func numSquares(n int) int {
	if n == 0 {
		return 0
	}
	list := make([]int, 0)
	list = append(list, n)
	level := 0
	for len(list) &gt; 0 {
		level++
		length := len(list)
		for i := 0; i &lt; length; i++ {
			value := list[i]
			for j := 1; j*j &lt;= value; j++ {
				if j*j == value {
					return level
				}
				list = append(list, value-j*j)
			}
		}
		list = list[length:]
	}
	return level
}

# 4
var m map[int]int

func numSquares(n int) int {
	m = make(map[int]int)
	return dfs(n)
}

func dfs(n int) int {
	if m[n] &gt; 0 {
		return m[n]
	}
	if n == 0 {
		return 0
	}
	count := math.MaxInt32
	for i := 1; i*i &lt;= n; i++ {
		count = min(count, dfs(n-i*i)+1)
	}
	return count
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

# 5
func numSquares(n int) int {
	if judge(n) {
		return 1
	}
	res := n
	for res%4 == 0 {
		res = res / 4
	}
	if res%8 == 7 {
		return 4
	}
	for i := 1; i*i &lt; n; i++ {
		if judge(n - i*i) {
			return 2
		}
	}
	return 3
}

func judge(n int) bool {
	value := int(math.Sqrt(float64(n)))
	return value*value == n
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>284.顶端迭代器(2)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个迭代器类的接口，接口包含两个方法： next() 和 hasNext()。
设计并实现一个支持 peek() 操作的顶端迭代器 -- 其本质就是把原本应由 next() 方法返回的元素 peek() 出来。
示例:假设迭代器被初始化为列表 [1,2,3]。
调用 next() 返回 1，得到列表中的第一个元素。
现在调用 peek() 返回 2，下一个元素。在此之后调用 next() 仍然返回 2。
最后一次调用 next() 返回 3，末尾元素。在此之后调用 hasNext() 应该返回 false。
进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>缓存</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>缓存</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type PeekingIterator struct {
	Iter    *Iterator
	cache   int
	isCache bool
}

func Constructor(iter *Iterator) *PeekingIterator {
	return &amp;PeekingIterator{
		Iter:    iter,
		cache:   0,
		isCache: false,
	}
}

func (this *PeekingIterator) hasNext() bool {
	return this.isCache || this.Iter.hasNext()
}

func (this *PeekingIterator) next() int {
	if this.isCache == false {
		return this.Iter.next()
	}
	res := this.cache
	this.isCache = false
	return res
}

func (this *PeekingIterator) peek() int {
	if this.isCache == false {
		this.cache = this.Iter.next()
		this.isCache = true
	}
	return this.cache
}

# 2
type PeekingIterator struct {
	Iter  *Iterator
	cache *int
}

func Constructor(iter *Iterator) *PeekingIterator {
	return &amp;PeekingIterator{
		Iter:  iter,
		cache: nil,
	}
}

func (this *PeekingIterator) hasNext() bool {
	return this.cache != nil || this.Iter.hasNext()
}

func (this *PeekingIterator) next() int {
	if this.cache != nil {
		res := *this.cache
		this.cache = nil
		return res
	}
	return this.Iter.next()
}

func (this *PeekingIterator) peek() int {
	if this.cache == nil {
		value := this.Iter.next()
		this.cache = &amp;value
	}
	return *this.cache
}
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>287.寻找重复数(8)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），
可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
示例 1:输入: [1,3,4,2,2] 输出: 2
示例 2:输入: [3,1,3,4,2] 输出: 3
说明：
    不能更改原数组（假设数组是只读的）。
    只能使用额外的 O(1) 的空间。
    时间复杂度小于 O(n^2) 。
    数组中只有一个重复的数字，但它可能不止重复出现一次。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
<tr>
<td>04</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>05</td>
<td>快慢指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>06</td>
<td>位运算</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>07</td>
<td>交换</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>08</td>
<td>负号标记</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findDuplicate(nums []int) int {
	m := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		if m[nums[i]] &gt; 0 {
			return nums[i]
		}
		m[nums[i]] = 1
	}
	return -1
}

# 2
func findDuplicate(nums []int) int {
	sort.Ints(nums)
	for i := 1; i &lt; len(nums); i++{
		if nums[i] == nums[i-1]{
			return nums[i]
		}
	}
	return -1
}

# 3
func findDuplicate(nums []int) int {
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			if nums[i] == nums[j] {
				return nums[i]
			}
		}
	}
	return -1
}

# 4
func findDuplicate(nums []int) int {
	left, right := 1, len(nums)-1
	res := -1
	for left &lt;= right {
		mid := left + (right-left)/2
		count := 0
		for i := 0; i &lt; len(nums); i++ {
			if nums[i] &lt;= mid {
				count++
			}
		}
		if count &lt;= mid {
			left = mid + 1
		} else {
			right = mid - 1
			res = mid
		}
	}
	return res
}

# 5
func findDuplicate(nums []int) int {
	slow, fast := nums[0], nums[nums[0]]
	for slow != fast {
		slow, fast = nums[slow], nums[nums[fast]]
	}
	slow = 0
	for slow != fast {
		slow, fast = nums[slow], nums[fast]
	}
	return slow
}

# 6
func findDuplicate(nums []int) int {
	arrV := [32]int{}
	arrI := [32]int{}
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		value := nums[i]
		index := i
		for j := 0; j &lt; 32; j++ {
			if value&amp;(1&lt;&lt;j) &gt; 0 {
				arrV[j]++
			}
			if index &gt; 0 &amp;&amp; (index&amp;(1&lt;&lt;j) &gt; 0) {
				arrI[j]++
			}
		}
	}

	for i := 0; i &lt; len(arrV); i++ {
		if arrV[i] &gt; arrI[i] {
			res = res ^ (1 &lt;&lt; i)
		}
	}
	return res
}

# 7
func findDuplicate(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	for i := 1; i &lt;= len(nums)-1; i++ {
		for i != nums[i] {
			value := nums[i]
			if value == nums[value] {
				return value
			}
			nums[i], nums[value] = nums[value], nums[i]
		}
	}
	return nums[0]
}

# 8
func findDuplicate(nums []int) int {
	for i := 0; i &lt; len(nums); i++ {
		index := abs(nums[i]) - 1
		if nums[index] &gt; 0 {
			nums[index] = -1 * nums[index]
		} else {
			return abs(nums[i])
		}
	}
	return 0
}

func abs(a int) int {
	if a &gt;= 0 {
		return a
	}
	return -a
}
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h2>289.生命游戏(2)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：
1 即为活细胞（live），或 0 即为死细胞（dead）。
每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
    如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
    如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
    如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
    如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。
示例：输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
进阶：
    你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：
    你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
    本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。
    你将如何解决这些问题？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>数组辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func gameOfLife(board [][]int) {
	temp := make([][]int, len(board))
	for i := 0; i &lt; len(board); i++ {
		temp[i] = make([]int, len(board[i]))
	}
	for i := 0; i &lt; len(board); i++ {
		for j := 0; j &lt; len(board[i]); j++ {
			count := 0
			for a := i - 1; a &lt; i+1; a++ {
				for b := j - 1; b &lt; j+1; b++ {
					if 0 &lt;= a &amp;&amp; a &lt; len(board) &amp;&amp;
						0 &lt;= b &amp;&amp; b &lt; len(board[i]) &amp;&amp; board[i][j] == 1 {
						count++
					}
				}
			}
			if count &lt; 2 || count &gt; 3 {
				temp[i][j] = 0
			}
			if count == 3 &amp;&amp; temp[i][j] == 0 {
				temp[i][j] = 1
			}
		}
	}
	copy(board, temp)
}

# 2
func gameOfLife(board [][]int) {
	// 0 00 =&gt; 死
	// 1 01 =&gt; 活
	// 2 10 =&gt; 死=&gt;活
	// 3 11 =&gt; 活=&gt;死
	for i := 0; i &lt; len(board); i++ {
		for j := 0; j &lt; len(board[i]); j++ {
			count := 0
			for a := i - 1; a &lt;= i+1; a++ {
				for b := j - 1; b &lt;= j+1; b++ {
					if a == i &amp;&amp; b == j {
						continue
					}
					if 0 &lt;= a &amp;&amp; a &lt; len(board) &amp;&amp;
						0 &lt;= b &amp;&amp; b &lt; len(board[i]) {
						count = count + board[a][b]%2
					}
				}
			}
			if (count &lt; 2 || count &gt; 3) &amp;&amp; board[i][j] == 1 {
				board[i][j] = 3
			}
			if count == 3 &amp;&amp; board[i][j] == 0 {
				board[i][j] = 2
			}
		}
	}
	for i := 0; i &lt; len(board); i++ {
		for j := 0; j &lt; len(board[i]); j++ {
			if board[i][j] == 2 {
				board[i][j] = 1
			} else if board[i][j] == 3 {
				board[i][j] = 0
			}
		}
	}
}
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h2>300.最长上升子序列(2)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个无序的整数数组，找到其中最长上升子序列的长度。
示例:输入: [10,9,2,5,3,7,101,18] 输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
    你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>贪心+二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>/*
dp[i] = max(dp[j]+1, dp[i]),其中0&lt;=j&lt;i, nums[j]&lt;nums[i])
*/
func lengthOfLIS(nums []int) int {
	if len(nums) &lt; 2 {
		return len(nums)
	}
	dp := make([]int, len(nums))
	res := 1
	for i := 0; i &lt; len(nums); i++ {
		dp[i] = 1
		for j := 0; j &lt; i; j++ {
			if nums[j] &lt; nums[i] {
				dp[i] = max(dp[j]+1, dp[i])
			}
		}
		res = max(res, dp[i])
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func lengthOfLIS(nums []int) int {
	if len(nums) &lt; 2 {
		return len(nums)
	}
	arr := make([]int, len(nums)+1)
	arr[1] = nums[0]
	res := 1
	for i := 1; i &lt; len(nums); i++ {
		if arr[res] &lt; nums[i] {
			res++
			arr[res] = nums[i]
		} else {
			left, right := 1, res
			index := 0
			for left &lt;= right {
				mid := left + (right-left)/2
				if arr[mid] &lt; nums[i] {
					index = mid
					left = mid + 1
				} else {
					right = mid - 1
				}
			}
			arr[index+1] = nums[i]
		}
	}
	return res
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>0201-0300-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="id43">
<h2>214.最短回文串(3)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。
找到并返回可以用这种方式转换的最短回文串。
示例 1:输入: &quot;aacecaaa&quot; 输出: &quot;aaacecaaa&quot;
示例 2:输入: &quot;abcd&quot; 输出: &quot;dcbabcd&quot;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>反转比较</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>manacher</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func shortestPalindrome(s string) string {
	str := reverse(s)
	i := 0
	for i = 0; i &lt; len(s); i++ {
		if str[i:] == s[:len(s)-i] {
			break
		}
	}
	return str[:i] + s
}

func reverse(s string) string {
	res := make([]byte, 0)
	for i := len(s) - 1; i &gt;= 0; i-- {
		res = append(res, s[i])
	}
	return string(res)
}

# 2
func shortestPalindrome(s string) string {
	i := len(s)
	for {
		if isPalindrome(s[:i]) == true {
			break
		}
		i--
	}
	res := s
	for j := i; j &lt; len(s); j++ {
		res = string(s[j]) + res
	}
	return res
}

func isPalindrome(s string) bool {
	i, j := 0, len(s)-1
	for i &lt; j {
		if s[i] != s[j] {
			return false
		}
		i++
		j--
	}
	return true
}

# 3
func shortestPalindrome(s string) string {
	str := add(s)
	index := 0
	for i := len(str) / 2; i &lt;= len(str)/2; i-- {
		j := i
		for ; j &gt; 0; j-- {
			if str[i-j] != str[i+j] {
				break
			}
		}
		if j == 0 {
			index = i
			break
		}
	}
	res := s
	for j := index; j &lt; len(s); j++ {
		res = string(s[j]) + res
	}
	return res
}

func add(s string) string {
	var res []rune
	for _, v := range s {
		res = append(res, &#39;#&#39;)
		res = append(res, v)
	}
	res = append(res, &#39;#&#39;)
	return string(res)
}
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>224.基本计算器(1)<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。
示例 1：输入：s = &quot;1 + 1&quot; 输出：2
示例 2：输入：s = &quot; 2-1 + 2 &quot; 输出：3
示例 3：输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot; 输出：23
提示：1 &lt;= s.length &lt;= 3 * 105
s 由数字、&#39;+&#39;、&#39;-&#39;、&#39;(&#39;、&#39;)&#39;、和 &#39; &#39; 组成
s 表示一个有效的表达式
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">calculate</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">sign</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span> <span class="p">{</span>
			<span class="nx">num</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">num</span> <span class="p">=</span> <span class="nx">num</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">sign</span><span class="o">*</span><span class="nx">num</span>
			<span class="nx">i</span><span class="o">--</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="p">{</span>
			<span class="nx">sign</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="p">{</span>
			<span class="nx">sign</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">sign</span><span class="p">)</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">sign</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span> <span class="p">{</span>
			<span class="nx">sign</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">prev</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">prev</span> <span class="o">+</span> <span class="nx">sign</span><span class="o">*</span><span class="nx">res</span><span class="o">*</span><span class="nx">sign</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h2>233.数字1的个数(3)<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
示例:输入: 13输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>找规律-遍历</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>找规律-递归</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>03</td>
<td>找规律</td>
<td>O(log(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func countDigitOne(n int) int {
	res := 0
	digit := 1
	high := n / 10
	cur := n % 10
	low := 0
	for high != 0 || cur != 0 {
		if cur == 0 {
			res = res + high*digit
		} else if cur == 1 {
			res = res + high*digit + low + 1
		} else {
			res = res + (high+1)*digit
		}
		low = low + cur*digit
		cur = high % 10
		high = high / 10
		digit = digit * 10
	}
	return res
}

# 2
func countDigitOne(n int) int {
	if n &lt;= 0 {
		return 0
	}
	str := strconv.Itoa(n)
	return dfs(str)
}

func dfs(str string) int {
	if str == &quot;&quot; {
		return 0
	}
	first := int(str[0] - &#39;0&#39;)
	if len(str) == 1 &amp;&amp; first == 0 {
		return 0
	}
	if len(str) == 1 &amp;&amp; first &gt;= 1 {
		return 1
	}
	count := 0
	if first &gt; 1 {
		count = int(math.Pow(float64(10), float64(len(str)-1)))
	} else if first == 1 {
		count, _ = strconv.Atoi(str[1:])
		count = count + 1
	}
	other := first * (len(str) - 1) * int(math.Pow(float64(10), float64(len(str)-2)))
	numLeft := dfs(str[1:])
	return count + numLeft + other
}

# 3
func countDigitOne(n int) int {
	if n &lt;= 0 {
		return 0
	}
	res := 0
	for i := 1; i &lt;= n; i = i * 10 {
		left := n / i
		right := n % i
		res = res + (left+8)/10*i
		if left%10 == 1 {
			res = res + right + 1
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id46">
<h2>239.滑动窗口最大值(3)<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。
进阶：你能在线性时间复杂度内解决此题吗？
示例:输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 
解释: 
  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
提示：
    1 &lt;= nums.length &lt;= 10^5
    -10^4 &lt;= nums[i] &lt;= 10^4
    1 &lt;= k &lt;= nums.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>暴力法-有条件更新最大值</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>双端队列</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>04</td>
<td>堆排序(超时)</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxSlidingWindow(nums []int, k int) []int {
	res := make([]int, 0)
	if len(nums) == 0 {
		return res
	}
	for i := 0; i &lt; len(nums)-k+1; i++ {
		max := nums[i]
		for j := i; j &lt; i+k; j++ {
			if nums[j] &gt; max {
				max = nums[j]
			}
		}
		res = append(res, max)
	}
	return res
}

# 2
func maxSlidingWindow(nums []int, k int) []int {
	res := make([]int, 0)
	if len(nums) == 0 {
		return res
	}
	max := math.MaxInt32
	for i := 0; i &lt; len(nums)-k+1; i++ {
		if i == 0 || nums[i-1] == max {
			max = nums[i]
			for j := i; j &lt; i+k; j++ {
				if nums[j] &gt; max {
					max = nums[j]
				}
			}
		} else {
			if nums[i+k-1] &gt; max {
				max = nums[i+k-1]
			}
		}
		res = append(res, max)
	}
	return res
}

# 3
func maxSlidingWindow(nums []int, k int) []int {
	res := make([]int, 0)
	if len(nums) == 0 {
		return res
	}
	// 递减下标
	deque := make([]int, 0)
	for i := 0; i &lt; k; i++ {
		for len(deque) &gt; 0 &amp;&amp; nums[i] &gt;= nums[deque[len(deque)-1]] {
			deque = deque[:len(deque)-1]
		}
		deque = append(deque, i)
	}
	for i := k; i &lt; len(nums); i++ {
		res = append(res, nums[deque[0]])
		for len(deque) &gt; 0 &amp;&amp; nums[i] &gt;= nums[deque[len(deque)-1]] {
			deque = deque[:len(deque)-1]
		}
		if len(deque) &gt; 0 &amp;&amp; deque[0] &lt;= i-k {
			deque = deque[1:]
		}
		deque = append(deque, i)
	}
	res = append(res, nums[deque[0]])
	return res
}

# 4
func maxSlidingWindow(nums []int, k int) []int {
	res := make([]int, 0)
	if len(nums) == 0 {
		return res
	}
	intHeap := make(IntHeap, 0, k)
	heap.Init(&amp;intHeap)
	for i := 0; i &lt; k; i++ {
		heap.Push(&amp;intHeap, nums[i])
	}
	for i := k; i &lt; len(nums); i++ {
		temp := heap.Pop(&amp;intHeap).(int)
		res = append(res, temp)
		if temp != nums[i-k] {
			intHeap.Remove(nums[i-k])
			heap.Push(&amp;intHeap, temp)
			heap.Push(&amp;intHeap, nums[i])
		} else {
			heap.Push(&amp;intHeap, nums[i])
		}
	}
	res = append(res, heap.Pop(&amp;intHeap).(int))
	return res
}

type IntHeap []int

func (i IntHeap) Len() int {
	return len(i)
}

func (i IntHeap) Less(x, y int) bool {
	return i[x] &gt; i[y]
}

func (i IntHeap) Swap(x, y int) {
	i[x], i[y] = i[y], i[x]
}
func (i *IntHeap) Push(v interface{}) {
	*i = append(*i, v.(int))
}

func (i *IntHeap) Pop() interface{} {
	value := (*i)[len(*i)-1]
	*i = (*i)[:len(*i)-1]
	return value
}

func (i *IntHeap) Remove(x interface{}) {
	for j := 0; j &lt; len(*i); j++ {
		if (*i)[j] == x {
			*i = append((*i)[:j], (*i)[j+1:]...)
			break
		}
	}
	heap.Init(i)
}
</pre></div>
</div>
</div>
<div class="section" id="id47">
<h2>273.整数转换英文表(3)<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h2>
<div class="section" id="id48">
<h3>题目<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>将非负整数转换为其对应的英文表示。可以保证给定输入小于 2^31 - 1 。
示例 1:输入: 123 输出: &quot;One Hundred Twenty Three&quot;
示例 2:输入: 12345 输出: &quot;Twelve Thousand Three Hundred Forty Five&quot;
示例 3:输入: 1234567
输出: &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;
示例 4:输入: 1234567891
输出: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven 
Thousand Eight Hundred Ninety One&quot;
</pre></div>
</div>
</div>
<div class="section" id="id49">
<h3>解题思路<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>递归</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func numberToWords(num int) string {
	if num == 0 {
		return &quot;Zero&quot;
	}
	res := &quot;&quot;
	billion := num / 1000000000
	million := (num - billion*1000000000) / 1000000
	thousand := (num - billion*1000000000 - million*1000000) / 1000
	left := num - billion*1000000000 - million*1000000 - thousand*1000
	if billion != 0 {
		res += three(billion) + &quot; Billion&quot;
	}
	if million != 0 {
		if res != &quot;&quot; {
			res += &quot; &quot;
		}
		res += three(million) + &quot; Million&quot;
	}
	if thousand != 0 {
		if res != &quot;&quot; {
			res += &quot; &quot;
		}
		res += three(thousand) + &quot; Thousand&quot;
	}
	if left != 0 {
		if res != &quot;&quot; {
			res += &quot; &quot;
		}
		res += three(left)
	}
	return res
}

func three(num int) string {
	hundred := num / 100
	left := num - hundred*100
	if hundred == 0 {
		return two(num)
	}
	res := transfer[hundred] + &quot; Hundred&quot;
	if left != 0 {
		res += &quot; &quot; + two(left)
	}
	return res
}

func two(num int) string {
	if num == 0 {
		return &quot;&quot;
	} else if num &lt; 10 {
		return transfer[num]
	} else if num &lt; 20 {
		return transfer[num]
	}
	ten := num / 10
	left := num - ten*10
	ten = ten * 10
	res := transfer[ten]
	if left != 0 {
		res += &quot; &quot; + transfer[left]
	}
	return res
}

var transfer = map[int]string{
	0:  &quot;Zero&quot;,
	1:  &quot;One&quot;,
	2:  &quot;Two&quot;,
	3:  &quot;Three&quot;,
	4:  &quot;Four&quot;,
	5:  &quot;Five&quot;,
	6:  &quot;Six&quot;,
	7:  &quot;Seven&quot;,
	8:  &quot;Eight&quot;,
	9:  &quot;Nine&quot;,
	10: &quot;Ten&quot;,
	11: &quot;Eleven&quot;,
	12: &quot;Twelve&quot;,
	13: &quot;Thirteen&quot;,
	14: &quot;Fourteen&quot;,
	15: &quot;Fifteen&quot;,
	16: &quot;Sixteen&quot;,
	17: &quot;Seventeen&quot;,
	18: &quot;Eighteen&quot;,
	19: &quot;Nineteen&quot;,
	20: &quot;Twenty&quot;,
	30: &quot;Thirty&quot;,
	40: &quot;Forty&quot;,
	50: &quot;Fifty&quot;,
	60: &quot;Sixty&quot;,
	70: &quot;Seventy&quot;,
	80: &quot;Eighty&quot;,
	90: &quot;Ninety&quot;,
}

# 2
func numberToWords(num int) string {
	if num == 0 {
		return &quot;Zero&quot;
	}
	return strings.Trim(dfs(num), &quot; &quot;)
}

func dfs(n int) string {
	if n &lt; 20 {
		return transfer[n]
	}
	if n &lt; 100 {
		return transfer[n/10*10] + dfs(n%10)
	}
	if n &lt; 1000 {
		return transfer[n/100] + &quot;Hundred &quot; + dfs(n%100)
	}
	if n &lt; 1000000 {
		return dfs(n/1000) + &quot;Thousand &quot; + dfs(n%1000)
	}
	if n &lt; 1000000000 {
		return dfs(n/1000000) + &quot;Million &quot; + dfs(n%1000000)
	}
	return dfs(n/1000000000) + &quot;Billion &quot; + dfs(n%1000000000)
}

var transfer = map[int]string{
	1:  &quot;One &quot;,
	2:  &quot;Two &quot;,
	3:  &quot;Three &quot;,
	4:  &quot;Four &quot;,
	5:  &quot;Five &quot;,
	6:  &quot;Six &quot;,
	7:  &quot;Seven &quot;,
	8:  &quot;Eight &quot;,
	9:  &quot;Nine &quot;,
	10: &quot;Ten &quot;,
	11: &quot;Eleven &quot;,
	12: &quot;Twelve &quot;,
	13: &quot;Thirteen &quot;,
	14: &quot;Fourteen &quot;,
	15: &quot;Fifteen &quot;,
	16: &quot;Sixteen &quot;,
	17: &quot;Seventeen &quot;,
	18: &quot;Eighteen &quot;,
	19: &quot;Nineteen &quot;,
	20: &quot;Twenty &quot;,
	30: &quot;Thirty &quot;,
	40: &quot;Forty &quot;,
	50: &quot;Fifty &quot;,
	60: &quot;Sixty &quot;,
	70: &quot;Seventy &quot;,
	80: &quot;Eighty &quot;,
	90: &quot;Ninety &quot;,
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id50">
<h2>295.数据流的中位数(1)<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
    void addNum(int num) - 从数据流中添加一个整数到数据结构中。
    double findMedian() - 返回目前所有元素的中位数。
示例：
addNum(1)
addNum(2)
findMedian() -&gt; 1.5
addNum(3) 
findMedian() -&gt; 2
进阶:
    如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
    如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>大小根堆-内置heap接口</td>
<td>O(log(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MinHeap</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MinHeap</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MinHeap</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">i</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">[</span><span class="nx">y</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MinHeap</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">[</span><span class="nx">x</span><span class="p">],</span> <span class="nx">i</span><span class="p">[</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span><span class="p">[</span><span class="nx">y</span><span class="p">],</span> <span class="nx">i</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">MinHeap</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">i</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">MinHeap</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="o">*</span><span class="nx">i</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MaxHeap</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MaxHeap</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MaxHeap</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">i</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">i</span><span class="p">[</span><span class="nx">y</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MaxHeap</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">[</span><span class="nx">x</span><span class="p">],</span> <span class="nx">i</span><span class="p">[</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span><span class="p">[</span><span class="nx">y</span><span class="p">],</span> <span class="nx">i</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">MaxHeap</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">i</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">MaxHeap</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="o">*</span><span class="nx">i</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MedianFinder</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">minArr</span> <span class="o">*</span><span class="nx">MinHeap</span>
	<span class="nx">maxArr</span> <span class="o">*</span><span class="nx">MaxHeap</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="nx">MedianFinder</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MedianFinder</span><span class="p">)</span>
	<span class="nx">res</span><span class="p">.</span><span class="nx">minArr</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MinHeap</span><span class="p">)</span>
	<span class="nx">res</span><span class="p">.</span><span class="nx">maxArr</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MaxHeap</span><span class="p">)</span>
	<span class="nx">heap</span><span class="p">.</span><span class="nx">Init</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">minArr</span><span class="p">)</span>
	<span class="nx">heap</span><span class="p">.</span><span class="nx">Init</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">*</span><span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MedianFinder</span><span class="p">)</span> <span class="nx">AddNum</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="o">==</span> <span class="nx">this</span><span class="p">.</span><span class="nx">minArr</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">heap</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">minArr</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
		<span class="nx">heap</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">,</span> <span class="nx">heap</span><span class="p">.</span><span class="nx">Pop</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">minArr</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">heap</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
		<span class="nx">heap</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">minArr</span><span class="p">,</span> <span class="nx">heap</span><span class="p">.</span><span class="nx">Pop</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MedianFinder</span><span class="p">)</span> <span class="nx">FindMedian</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">minArr</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="o">==</span> <span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">float64</span><span class="p">((</span><span class="o">*</span><span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">float64</span><span class="p">((</span><span class="o">*</span><span class="nx">this</span><span class="p">.</span><span class="nx">minArr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">float64</span><span class="p">((</span><span class="o">*</span><span class="nx">this</span><span class="p">.</span><span class="nx">maxArr</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h2>297.二叉树的序列化与反序列化(2)<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，
同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，
你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
示例: 你可以将以下二叉树：
    1
   / \
  2   3
     / \
    4   5
序列化为 &quot;[1,2,3,null,null,4,5]&quot;
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。
你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>迭代</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type Codec struct {
	res []string
}

func Constructor() Codec {
	return Codec{}
}

// Serializes a tree to a single string.
func (this *Codec) serialize(root *TreeNode) string {
	if root == nil {
		return &quot;#&quot;
	}
	return strconv.Itoa(root.Val) + &quot;,&quot; + this.serialize(root.Left) + &quot;,&quot; + this.serialize(root.Right)
}

// Deserializes your encoded data to tree.
func (this *Codec) deserialize(data string) *TreeNode {
	this.res = strings.Split(data, &quot;,&quot;)
	return this.dfsDeserialize()
}

func (this *Codec) dfsDeserialize() *TreeNode {
	node := this.res[0]
	this.res = this.res[1:]
	if node == &quot;#&quot; {
		return nil
	}
	value, _ := strconv.Atoi(node)
	return &amp;TreeNode{
		Val:   value,
		Left:  this.dfsDeserialize(),
		Right: this.dfsDeserialize(),
	}
}

# 2
type Codec struct {
	res []string
}

func Constructor() Codec {
	return Codec{}
}

// Serializes a tree to a single string.
func (this *Codec) serialize(root *TreeNode) string {
	if root == nil {
		return &quot;&quot;
	}
	res := make([]string, 0)
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		node := queue[0]
		queue = queue[1:]
		if node != nil {
			res = append(res, strconv.Itoa(node.Val))
			queue = append(queue, node.Left, node.Right)
		} else {
			res = append(res, &quot;#&quot;)
		}
	}
	return strings.Join(res, &quot;,&quot;)
}

// Deserializes your encoded data to tree.
func (this *Codec) deserialize(data string) *TreeNode {
	if len(data) == 0 || data == &quot;&quot; {
		return nil
	}
	res := strings.Split(data, &quot;,&quot;)
	root := &amp;TreeNode{}
	root.Val, _ = strconv.Atoi(res[0])
	res = res[1:]
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	for len(queue) &gt; 0 {
		if res[0] != &quot;#&quot; {
			left, _ := strconv.Atoi(res[0])
			queue[0].Left = &amp;TreeNode{Val: left}
			queue = append(queue, queue[0].Left)
		}
		if res[1] != &quot;#&quot; {
			right, _ := strconv.Atoi(res[1])
			queue[0].Right = &amp;TreeNode{Val: right}
			queue = append(queue, queue[0].Right)
		}
		queue = queue[1:]
		res = res[2:]
	}
	return root
}
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="0301-0400.html" class="btn btn-neutral float-right" title="0301-0400-Easy" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="0101-0200.html" class="btn btn-neutral float-left" title="0101-0200-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>