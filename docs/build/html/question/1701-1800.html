

<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1701-1800-Easy &mdash; go-leetcode v1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="1801-1900-Easy" href="1801-1900.html" />
    <link rel="prev" title="1601-1700-Easy" href="1601-1700.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">0001-0100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#medium">0001-0100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#hard">0001-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#medium">0101-0200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#hard">0101-0200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#medium">0201-0300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#hard">0201-0300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">0301-0400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#medium">0301-0400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#hard">0301-0400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">0401-0500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#medium">0401-0500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#hard">0401-0500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">0501-0600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#medium">0501-0600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#hard">0501-0600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">0601-0700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#medium">0601-0700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#hard">0601-0700-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">0701-0800-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#medium">0701-0800-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#hard">0701-0800-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">0801-0900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#medium">0801-0900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#hard">0801-0900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">0901-1000-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#medium">0901-1000-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#hard">0901-1000-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">1001-1100-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#medium">1001-1100-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#hard">1001-1100-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">1101-1200-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#medium">1101-1200-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#hard">1101-1200-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">1201-1300-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#medium">1201-1300-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#hard">1201-1300-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">1301-1400-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#medium">1301-1400-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#hard">1301-1400-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">1401-1500-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#medium">1401-1500-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#hard">1401-1500-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html">1501-1600-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#medium">1501-1600-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1501-1600.html#hard">1501-1600-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html">1601-1700-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#medium">1601-1700-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1601-1700.html#hard">1601-1700-Hard</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">1701-1800-Easy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">1704.判断字符串的两半是否相似(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">1710.卡车上的最大单元数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">1716.计算力扣银行的钱(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">1720.解码异或后的数组(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1725.可以形成最大正方形的矩形数目(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">1732.找到最高海拔(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">1736.替换隐藏数字得到的最晚时间(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">1742.盒子中小球的最大数量(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">1748.唯一元素的和(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">1752.检查数组是否经排序和轮转得到(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">1758.生成交替二进制字符串的最少操作数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">1763.最长的美好子字符串(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">1768.交替合并字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">1773.统计匹配检索规则的物品数量(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xy-1">1779.找到最近的有相同X或Y坐标的点(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">1784.检查二进制字符串字段(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">1790.仅执行一次字符串交换能否使两个字符串相等(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">1796.字符串中第二大的数字(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">1800.最大升序子数组和(2)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#medium">1701-1800-Medium</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id19">1701.平均等待时间(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">1702.修改后的最大二进制字符串(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">1705.吃苹果的最大数目(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">1706.球会落何处(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id23">1711.大餐计数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id24">1712.将数组分成三个子数组的方案数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id25">1717.删除子字符串的最大得分(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id26">1718.构建字典序最大的可行序列(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">1721.交换链表中的节点(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">1722.执行交换操作后的最小汉明距离(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id29">1726.同积元组(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">1727.重新排列后的最大子矩阵(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">1733.需要教语言的最少人数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">1734.解码异或后的排列(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">1737.满足三条件之一需改变的最少字符数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#k-2">1738.找出第K大的异或坐标值(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">1743.从相邻元素对还原数组(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">1749.任意子数组和的绝对值的最大值(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">1750.删除字符串两端相同字符后的最短长度(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id38">1753.移除石子的最大得分(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id39">1754.构造字典序最大的合并字符串(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40">1759.统计同构子字符串的数目(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id41">1760.袋子里最少数目的球(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id42">1764.通过连接另一个数组的子数组得到一个数组(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43">1765.地图中的最高点(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id44">1769.移动所有球到每个盒子所需的最小操作数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id45">1770.执行乘法运算的最大分数(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id46">1774.最接近目标价格的甜点成本(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id47">1775.通过最少操作次数使数组的和相等(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id48">1780.判断一个数字是否可以表示成三的幂的和(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id49">1781.所有子字符串美丽值之和(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id50">1785.构成特定和需要添加的最少元素(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id51">1791.找出星型图的中心节点(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id52">1792.最大平均通过率(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id53">1797.设计一个验证系统(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id54">1798.你能构造出连续值的最大数目(2)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id55">解题思路</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hard">1701-1800-Hard</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#iv-2">1745.回文串分割IV(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id56">1761.一个图中连通三元组的最小度数(1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id57">1771.由子序列构造的最长回文串的长度(3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id58">1793.好子数组的最大分数(2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#n">1799.N次操作后的最大分数和</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id59">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id60">解题思路</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html">1801-1900-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#medium">1801-1900-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="1801-1900.html#hard">1801-1900-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">剑指offer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcci.html">程序员面试金典</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">LCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html">Mysql-Easy</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#mysql-medium">Mysql-Medium</a></li>
<li class="toctree-l1"><a class="reference internal" href="mysql.html#mysql-hard">Mysql-Hard</a></li>
<li class="toctree-l1"><a class="reference internal" href="patB.html">PAT (Basic Level) Practice 乙级</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>1701-1800-Easy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/question/1701-1800.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy">
<h1>1701-1800-Easy<a class="headerlink" href="#easy" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>1704.判断字符串的两半是否相似(1)<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。
两个字符串 相似 的前提是它们都含有相同数目的元音（&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39;，&#39;A&#39;，&#39;E&#39;，&#39;I&#39;，&#39;O&#39;，&#39;U&#39;）。注意，s 可能同时含有大写和小写字母。
如果 a 和 b 相似，返回 true ；否则，返回 false 。
示例 1：输入：s = &quot;book&quot; 输出：true
解释：a = &quot;bo&quot; 且 b = &quot;ok&quot; 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。
示例 2：输入：s = &quot;textbook&quot; 输出：false
解释：a = &quot;text&quot; 且 b = &quot;book&quot; 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。
注意，元音 o 在 b 中出现两次，记为 2 个。
示例 3：输入：s = &quot;MerryChristmas&quot; 输出：false
示例 4：输入：s = &quot;AbCdEfGh&quot; 输出：true
提示：2 &lt;= s.length &lt;= 1000
s.length 是偶数
s 由 大写和小写 字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">halvesAreAlike</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">isVowel</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
				<span class="nx">total</span><span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">total</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">total</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">isVowel</span><span class="p">(</span><span class="nx">b</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">b</span> <span class="o">==</span> <span class="sc">&#39;a&#39;</span> <span class="o">||</span> <span class="nx">b</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span>
		<span class="nx">b</span> <span class="o">==</span> <span class="sc">&#39;i&#39;</span> <span class="o">||</span> <span class="nx">b</span> <span class="o">==</span> <span class="sc">&#39;o&#39;</span> <span class="o">||</span> <span class="nx">b</span> <span class="o">==</span> <span class="sc">&#39;u&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>1710.卡车上的最大单元数(1)<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请你将一些箱子装在 一辆卡车 上。
给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：
numberOfBoxesi 是类型 i 的箱子的数量。
numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。
整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。
只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。
返回卡车可以装载 单元 的 最大 总数。
示例 1：输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 输出：8
解释：箱子的情况如下：
- 1 个第一类的箱子，里面含 3 个单元。
- 2 个第二类的箱子，每个里面含 2 个单元。
- 3 个第三类的箱子，每个里面含 1 个单元。
可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
示例 2：输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10 输出：91
提示：1 &lt;= boxTypes.length &lt;= 1000
1 &lt;= numberOfBoxesi, numberOfUnitsPerBoxi &lt;= 1000
1 &lt;= truckSize &lt;= 106
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maximumUnits</span><span class="p">(</span><span class="nx">boxTypes</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">truckSize</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">boxTypes</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">boxTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">boxTypes</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">})</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">boxTypes</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">boxTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">truckSize</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">boxTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nx">boxTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">truckSize</span><span class="o">*</span><span class="nx">boxTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">truckSize</span> <span class="p">=</span> <span class="nx">truckSize</span> <span class="o">-</span> <span class="nx">boxTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>1716.计算力扣银行的钱(2)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。
最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。
在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。
给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。
示例 1：输入：n = 4 输出：10
解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。
示例 2：输入：n = 10 输出：37
解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。
注意到第二个星期一，Hercy 存入 2 块钱。
示例 3：输入：n = 20 输出：96
解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) +
(2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。
提示：1 &lt;= n &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func totalMoney(n int) int {
	res := 0
	for i := 0; i &lt; n; i++ {
		a, b := i/7, i%7+1
		res = res + a + b
	}
	return res
}

# 2
func totalMoney(n int) int {
	res := 0
	a, b := n/7, n%7
	res = res + (28+(a-1)*7+28)*a/2
	res = res + (a+1+a+b)*b/2
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>1720.解码异或后的数组(1)<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>未知 整数数组 arr 由 n 个非负整数组成。
经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。
例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。
给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。
请解码返回原数组 arr 。可以证明答案存在并且是唯一的。
示例 1：输入：encoded = [1,2,3], first = 1 输出：[1,0,2,1]
解释：若 arr = [1,0,2,1] ，
那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
示例 2：输入：encoded = [6,2,7,3], first = 4 输出：[4,2,0,7,4]
提示：2 &lt;= n &lt;= 104
encoded.length == n - 1
0 &lt;= encoded[i] &lt;= 105
0 &lt;= first &lt;= 105
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">decode</span><span class="p">(</span><span class="nx">encoded</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">first</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">first</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">encoded</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">encoded</span><span class="p">[</span><span class="nx">i</span><span class="p">]^</span><span class="nx">res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>1725.可以形成最大正方形的矩形数目(1)<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。
如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。
例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。
设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。
返回可以切出边长为 maxLen 的正方形的矩形 数目 。
示例 1：输入：rectangles = [[5,8],[3,9],[5,12],[16,5]] 输出：3
解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。
最大正方形的边长为 5 ，可以由 3 个矩形切分得到。
示例 2：输入：rectangles = [[2,3],[3,7],[4,3],[3,7]] 输出：3
提示：1 &lt;= rectangles.length &lt;= 1000
rectangles[i].length == 2
1 &lt;= li, wi &lt;= 109
li != wi
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countGoodRectangles</span><span class="p">(</span><span class="nx">rectangles</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rectangles</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">minValue</span> <span class="o">:=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">rectangles</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">rectangles</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">minValue</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">minValue</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">minValue</span> <span class="o">==</span> <span class="nx">maxValue</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>1732.找到最高海拔(1)<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。
自行车手从海拔为 0 的点 0 开始骑行。
给你一个长度为 n 的整数数组 gain ，
其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &lt;= i &lt; n）。请你返回 最高点的海拔 。
示例 1：输入：gain = [-5,1,5,0,-7] 输出：1
解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。
示例 2：输入：gain = [-4,-3,-2,-1,4,3,2] 输出：0
解释：海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。
提示：n == gain.length
1 &lt;= n &lt;= 100
-100 &lt;= gain[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">largestAltitude</span><span class="p">(</span><span class="nx">gain</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">gain</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">gain</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>1736.替换隐藏数字得到的最晚时间(1)<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。
有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。
替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。
示例 1：输入：time = &quot;2?:?0&quot; 输出：&quot;23:50&quot;
解释：以数字 &#39;2&#39; 开头的最晚一小时是 23 ，以 &#39;0&#39; 结尾的最晚一分钟是 50 。
示例 2：输入：time = &quot;0?:3?&quot; 输出：&quot;09:39&quot;
示例 3：输入：time = &quot;1?:22&quot; 输出：&quot;19:22&quot; 
提示：time 的格式为 hh:mm
题目数据保证你可以由输入的字符串生成有效的时间
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maximumTime</span><span class="p">(</span><span class="nx">time</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="nx">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">time</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   	<span class="k">if</span> <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span> <span class="p">{</span>
   		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span><span class="p">)</span> <span class="p">{</span>
   			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;2&#39;</span>
   		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;1&#39;</span>
   		<span class="p">}</span>
   		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
   			<span class="k">if</span> <span class="nx">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;2&#39;</span> <span class="o">||</span> <span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;2&#39;</span> <span class="p">{</span>
   				<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;3&#39;</span>
   			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   				<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;9&#39;</span>
   			<span class="p">}</span>
   		<span class="p">}</span>
   		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
   			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;5&#39;</span>
   		<span class="p">}</span>
   		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
   			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;9&#39;</span>
   		<span class="p">}</span>
   	<span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>1742.盒子中小球的最大数量(1)<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，
到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。
另有无限数量的盒子，编号从 1 到 infinity 。
你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。
例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，
而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。
给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。
如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。
示例 1：输入：lowLimit = 1, highLimit = 10 输出：2
解释：盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...
小球数量：2 1 1 1 1 1 1 1 1 0  0  ...
编号 1 的盒子放有最多小球，小球数量为 2 。
示例 2：输入：lowLimit = 5, highLimit = 15 输出：2
解释：盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...
小球数量：1 1 1 1 2 2 1 1 1 0  0  ...
编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2 。
示例 3：输入：lowLimit = 19, highLimit = 28 输出：2
解释：盒子编号：1 2 3 4 5 6 7 8 9 10 11 12 ...
小球数量：0 1 1 1 1 1 1 1 1 2  0  0  ...
编号 10 的盒子放有最多小球，小球数量为 2 。
提示：1 &lt;= lowLimit &lt;= highLimit &lt;= 105
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历模拟</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countBalls</span><span class="p">(</span><span class="nx">lowLimit</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">highLimit</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">lowLimit</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">highLimit</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">getSum</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">sum</span><span class="p">]</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">sum</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">sum</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">getSum</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">i</span><span class="o">%</span><span class="mi">10</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">/</span> <span class="mi">10</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>1748.唯一元素的和(1)<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。
请你返回 nums 中唯一元素的 和 。
示例 1：输入：nums = [1,2,3,2] 输出：4
解释：唯一元素为 [1,3] ，和为 4 。
示例 2：输入：nums = [1,1,1,1,1] 输出：0
解释：没有唯一元素，和为 0 。
示例 3 ：输入：nums = [1,2,3,4,5] 输出：15
解释：唯一元素为 [1,2,3,4,5] ，和为 15 。
提示：1 &lt;= nums.length &lt;= 100
1 &lt;= nums[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sumOfUnique</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">k</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>1752.检查数组是否经排序和轮转得到(2)<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个数组 nums 。nums 的源数组中，所有元素与 nums 相同，但按非递减顺序排列。
如果 nums 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 true ；否则，返回 false 。
源数组中可能存在 重复项 。
注意：我们称数组 A 在轮转 x 个位置后得到长度相同的数组 B ，
当它们满足 A[i] == B[(i+x) % A.length] ，其中 % 为取余运算。
示例 1：输入：nums = [3,4,5,1,2] 输出：true
解释：[1,2,3,4,5] 为有序的源数组。
可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。
示例 2：输入：nums = [2,1,3,4] 输出：false
解释：源数组无法经轮转得到 nums 。
示例 3：输入：nums = [1,2,3] 输出：true
解释：[1,2,3] 为有序的源数组。
可以轮转 x = 0 个位置（即不轮转）得到 nums 。
示例 4：输入：nums = [1,1,1] 输出：true
解释：[1,1,1] 为有序的源数组。
轮转任意个位置都可以得到 nums 。
示例 5：输入：nums = [2,1] 输出：true
解释：[1,2] 为有序的源数组。
可以轮转 x = 5 个位置，使新数组从值为 2 的元素开始：[2,1] 。
提示：1 &lt;= nums.length &lt;= 100
1 &lt;= nums[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func check(nums []int) bool {
	temp := make([]int, len(nums))
	copy(temp, nums)
	sort.Ints(temp)
	nums = append(nums, nums...)
	a := change(temp)
	b := change(nums)
	if strings.Contains(b, a) {
		return true
	}
	return false
}

func change(arr []int) string {
	res := &quot;&quot;
	for i := 0; i &lt; len(arr); i++ {
		res = res + strconv.Itoa(arr[i]) + &quot;,&quot;
	}
	res = strings.TrimRight(res, &quot;,&quot;)
	return res
}

# 2
func check(nums []int) bool {
	count := 0
	for i := 0; i &lt; len(nums)-1; i++ {
		if nums[i] &gt; nums[i+1] {
			count++
			if count &gt; 1 {
				return false
			}
			if nums[0] &lt; nums[len(nums)-1] {
				return false
			}
		}
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>1758.生成交替二进制字符串的最少操作数(2)<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个仅由字符 &#39;0&#39; 和 &#39;1&#39; 组成的字符串 s 。
一步操作中，你可以将任一 &#39;0&#39; 变成 &#39;1&#39; ，或者将 &#39;1&#39; 变成 &#39;0&#39; 。
交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。
例如，字符串 &quot;010&quot; 是交替字符串，而字符串 &quot;0100&quot; 不是。
返回使 s 变成 交替字符串 所需的 最少 操作数。
示例 1：输入：s = &quot;0100&quot; 输出：1
解释：如果将最后一个字符变为 &#39;1&#39; ，s 就变成 &quot;0101&quot; ，即符合交替字符串定义。
示例 2：输入：s = &quot;10&quot; 输出：0
解释：s 已经是交替字符串。
示例 3：输入：s = &quot;1111&quot; 输出：2
解释：需要 2 步操作得到 &quot;0101&quot; 或 &quot;1010&quot; 。
提示：1 &lt;= s.length &lt;= 104
s[i] 是 &#39;0&#39; 或 &#39;1&#39;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minOperations(s string) int {
	a, b := 0, 0
	for i := 0; i &lt; len(s); i++ {
		if i%2 == 0 &amp;&amp; s[i] == &#39;1&#39; { // a以偶0，奇1
			a++
		} else if i%2 == 1 &amp;&amp; s[i] == &#39;0&#39; {
			a++
		}
		if i%2 == 0 &amp;&amp; s[i] == &#39;0&#39; { // b以偶1，奇0
			b++
		} else if i%2 == 1 &amp;&amp; s[i] == &#39;1&#39; {
			b++
		}
	}
	if a &gt; b {
		return b
	}
	return a
}

# 2
func minOperations(s string) int {
	a, b := 0, 0
	for i := 0; i &lt; len(s); i++ {
		if int(s[i]-&#39;0&#39;)%2 != i%2 {
			a++
		} else {
			b++
		}
	}
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>1763.最长的美好子字符串(1)<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。
比方说，&quot;abABB&quot; 是美好字符串，因为 &#39;A&#39; 和 &#39;a&#39; 同时出现了，且 &#39;B&#39; 和 &#39;b&#39; 也同时出现了。
然而，&quot;abA&quot; 不是美好字符串因为 &#39;b&#39; 出现了，而 &#39;B&#39; 没有出现。
给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。
如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。
示例 1：输入：s = &quot;YazaAay&quot; 输出：&quot;aAa&quot;
解释：&quot;aAa&quot; 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 &#39;a&#39; 和大写形式 &#39;A&#39; 也同时出现了。
&quot;aAa&quot; 是最长的美好子字符串。
示例 2：输入：s = &quot;Bb&quot; 输出：&quot;Bb&quot;
解释：&quot;Bb&quot; 是美好字符串，因为 &#39;B&#39; 和 &#39;b&#39; 都出现了。整个字符串也是原字符串的子字符串。
示例 3：输入：s = &quot;c&quot; 输出：&quot;&quot;
解释：没有美好子字符串。
示例 4：输入：s = &quot;dDzeE&quot; 输出：&quot;dD&quot;
解释：&quot;dD&quot; 和 &quot;eE&quot; 都是最长美好子字符串。
由于有多个美好子字符串，返回 &quot;dD&quot; ，因为它出现得最早。
提示：1 &lt;= s.length &lt;= 100
s 只包含大写和小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">longestNiceSubstring</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="p">])</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="p">])</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">A</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span> <span class="p">{</span>
			<span class="nx">a</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">A</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;A&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>1768.交替合并字符串(2)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。
如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。
返回 合并后的字符串 。
示例 1：输入：word1 = &quot;abc&quot;, word2 = &quot;pqr&quot; 输出：&quot;apbqcr&quot;
解释：字符串合并情况如下所示：
word1：  a   b   c
word2：    p   q   r
合并后：  a p b q c r
示例 2：输入：word1 = &quot;ab&quot;, word2 = &quot;pqrs&quot; 输出：&quot;apbqrs&quot;
解释：注意，word2 比 word1 长，&quot;rs&quot; 需要追加到合并后字符串的末尾。
word1：  a   b 
word2：    p   q   r   s
合并后：  a p b q   r   s
示例 3：输入：word1 = &quot;abcd&quot;, word2 = &quot;pq&quot; 输出：&quot;apbqcd&quot;
解释：注意，word1 比 word2 长，&quot;cd&quot; 需要追加到合并后字符串的末尾。
word1：  a   b   c   d
word2：    p   q 
合并后：  a p b q c   d
提示：1 &lt;= word1.length, word2.length &lt;= 100
word1 和 word2 由小写英文字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func mergeAlternately(word1 string, word2 string) string {
	res := &quot;&quot;
	i, j := 0, 0
	for i &lt; len(word1) &amp;&amp; j &lt; len(word2) {
		res = res + string(word1[i])
		res = res + string(word2[j])
		i++
		j++
	}
	if i &lt; len(word1) {
		res = res + string(word1[i:])
	}
	if j &lt; len(word2) {
		res = res + string(word2[j:])
	}
	return res
}

# 2
func mergeAlternately(word1 string, word2 string) string {
	res := &quot;&quot;
	for i := 0; i &lt; len(word1) || i &lt; len(word2); i++ {
		if i &lt; len(word1) {
			res = res + string(word1[i])
		}
		if i &lt; len(word2) {
			res = res + string(word2[i])
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>1773.统计匹配检索规则的物品数量(1)<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，
描述第 i 件物品的类型、颜色以及名称。
另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。
如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：
ruleKey == &quot;type&quot; 且 ruleValue == typei 。
ruleKey == &quot;color&quot; 且 ruleValue == colori 。
ruleKey == &quot;name&quot; 且 ruleValue == namei 。
统计并返回 匹配检索规则的物品数量 。
示例 1：输入：items = [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;],
[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey = &quot;color&quot;, ruleValue = &quot;silver&quot;
输出：1 解释：只有一件物品匹配检索规则，这件物品是 [&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;] 。
示例 2：输入：items = [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;],
[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey = &quot;type&quot;, ruleValue = &quot;phone&quot;
输出：2 解释：只有两件物品匹配检索规则，这两件物品分别是 [&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;] 和 [&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;] 。注意，[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;] 未匹配检索规则。
提示：1 &lt;= items.length &lt;= 104
1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10
ruleKey 等于 &quot;type&quot;、&quot;color&quot; 或 &quot;name&quot;
所有字符串仅由小写字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countMatches</span><span class="p">(</span><span class="nx">items</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">ruleKey</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ruleValue</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ruleKey</span> <span class="o">==</span> <span class="s">&quot;type&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">ruleValue</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">ruleKey</span> <span class="o">==</span> <span class="s">&quot;color&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">ruleValue</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">ruleKey</span> <span class="o">==</span> <span class="s">&quot;name&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nx">ruleValue</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="xy-1">
<h2>1779.找到最近的有相同X或Y坐标的点(1)<a class="headerlink" href="#xy-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个整数 x 和 y ，表示你在一个笛卡尔坐标系下的 (x, y) 处。
同时，在同一个坐标系下给你一个数组 points ，其中 points[i] = [ai, bi] 表示在 (ai, bi) 处有一个点。
当一个点与你所在的位置有相同的 x 坐标或者相同的 y 坐标时，我们称这个点是 有效的 。
请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。
如果有多个最近的有效点，请返回下标 最小 的一个。如果没有有效点，请返回 -1 。
两个点 (x1, y1) 和 (x2, y2) 之间的 曼哈顿距离 为 abs(x1 - x2) + abs(y1 - y2) 。
示例 1：输入：x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]] 输出：2
解释：所有点中，[3,1]，[2,4] 和 [4,4] 是有效点。
有效点中，[2,4] 和 [4,4] 距离你当前位置的曼哈顿距离最小，都为 1 。[2,4] 的下标最小，所以返回 2 。
示例 2：输入：x = 3, y = 4, points = [[3,4]] 输出：0
提示：答案可以与你当前所在位置坐标相同。
示例 3：输入：x = 3, y = 4, points = [[2,3]] 输出：-1
解释：没有有效点。
提示：1 &lt;= points.length &lt;= 104
points[i].length == 2
1 &lt;= x, y, ai, bi &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nearestValidPoint</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">points</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">maxValue</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">x</span> <span class="o">||</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">y</span> <span class="p">{</span>
			<span class="nx">value</span> <span class="o">:=</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">b</span><span class="o">-</span><span class="nx">y</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">value</span> <span class="p">&lt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">i</span>
				<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">value</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>1784.检查二进制字符串字段(3)<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个二进制字符串 s ，该字符串 不含前导零 。
如果 s 最多包含 一个由连续的 &#39;1&#39; 组成的字段 ，返回 true 。否则，返回 false 。
示例 1：输入：s = &quot;1001&quot; 输出：false
解释：字符串中的 1 没有形成一个连续字段。
示例 2：输入：s = &quot;110&quot; 输出：true
提示：1 &lt;= s.length &lt;= 100
s[i]为 &#39;0&#39; 或 &#39;1&#39;
s[0] 为 &#39;1&#39;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func checkOnesSegment(s string) bool {
	flag := true
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;0&#39; {
			flag = false
		}
		if flag == false &amp;&amp; s[i] == &#39;1&#39; {
			return false
		}
	}
	return true
}

# 2
func checkOnesSegment(s string) bool {
	if strings.Contains(s, &quot;01&quot;) {
		return false
	}
	return true
}

# 3
func checkOnesSegment(s string) bool {
	arr := strings.Split(s, &quot;0&quot;)
	return len(arr) == 1
}
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>1790.仅执行一次字符串交换能否使两个字符串相等(1)<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你长度相等的两个字符串 s1 和 s2 。
一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。
如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。
示例 1：输入：s1 = &quot;bank&quot;, s2 = &quot;kanb&quot; 输出：true
解释：例如，交换 s2 中的第一个和最后一个字符可以得到 &quot;bank&quot;
示例 2：输入：s1 = &quot;attack&quot;, s2 = &quot;defend&quot; 输出：false
解释：一次字符串交换无法使两个字符串相等
示例 3：输入：s1 = &quot;kelb&quot;, s2 = &quot;kelb&quot; 输出：true
解释：两个字符串已经相等，所以不需要进行字符串交换
示例 4：输入：s1 = &quot;abcd&quot;, s2 = &quot;dcba&quot; 输出：false
提示：1 &lt;= s1.length, s2.length &lt;= 100
s1.length == s2.length
s1 和 s2 仅由小写英文字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">areAlmostEqual</span><span class="p">(</span><span class="nx">s1</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">s2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s1</span> <span class="o">==</span> <span class="nx">s2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">count</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="nx">s2</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="nx">s2</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>1796.字符串中第二大的数字(1)<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。
混合字符串 由小写英文字母和数字组成。
示例 1：输入：s = &quot;dfa12321afd&quot; 输出：2
解释：出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。
示例 2：输入：s = &quot;abc1111&quot; 输出：-1
解释：出现在 s 中的数字只包含 [1] 。没有第二大的数字。
提示：1 &lt;= s.length &lt;= 500
s 只包含小写英文字母和（或）数字。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">secondHighest</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)]</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
			<span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">i</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>1800.最大升序子数组和(2)<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。
子数组是数组中的一个连续数字序列。
已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），
numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。
示例 1：输入：nums = [10,20,30,5,10,50] 输出：65
解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。
示例 2：输入：nums = [10,20,30,40,50] 输出：150
解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 
示例 3：输入：nums = [12,17,15,13,10,11,12] 输出：33
解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 
示例 4：输入：nums = [100,10,1] 输出：100
提示：1 &lt;= nums.length &lt;= 100
1 &lt;= nums[i] &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxAscendingSum(nums []int) int {
	res, sum := nums[0], nums[0]
	for i := 1; i &lt; len(nums); i++ {
		if nums[i-1] &lt; nums[i] {
			sum = sum + nums[i]
		} else {
			sum = nums[i]
		}
		res = max(res, sum)
	}
	return res
}

func max(x, y int) int {
	if x &gt; y {
		return x
	}
	return y
}

# 2
func maxAscendingSum(nums []int) int {
	res := nums[0]
	dp := make([]int, len(nums))
	dp[0] = nums[0]
	for i := 1; i &lt; len(nums); i++ {
		if nums[i-1] &lt; nums[i] {
			dp[i] = dp[i-1] + nums[i]
		} else {
			dp[i] = nums[i]
		}
		res = max(res, dp[i])
	}
	return res
}

func max(x, y int) int {
	if x &gt; y {
		return x
	}
	return y
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="medium">
<h1>1701-1800-Medium<a class="headerlink" href="#medium" title="永久链接至标题">¶</a></h1>
<div class="section" id="id19">
<h2>1701.平均等待时间(1)<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个餐厅，只有一位厨师。你有一个顾客数组 customers ，其中 customers[i] = [arrivali, timei] ：
arrivali 是第 i 位顾客到达的时间，到达时间按 非递减 顺序排列。
timei 是给第 i 位顾客做菜需要的时间。
当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。
每位顾客会一直等待到厨师完成他的订单。
厨师同时只能做一个人的订单。厨师会严格按照 订单给他的顺序 做菜。
请你返回所有顾客需要等待的 平均 时间。与标准答案误差在 10-5 范围以内，都视为正确结果。
示例 1：输入：customers = [[1,2],[2,5],[4,3]] 输出：5.00000
解释：1) 第一位顾客在时刻 1 到达，厨师拿到他的订单并在时刻 1 立马开始做菜，
并在时刻 3 完成，第一位顾客等待时间为 3 - 1 = 2 。
2) 第二位顾客在时刻 2 到达，厨师在时刻 3 开始为他做菜，
并在时刻 8 完成，第二位顾客等待时间为 8 - 2 = 6 。
3) 第三位顾客在时刻 4 到达，厨师在时刻 8 开始为他做菜，并在时刻 11 完成，
第三位顾客等待时间为 11 - 4 = 7 。
平均等待时间为 (2 + 6 + 7) / 3 = 5 。
示例 2：输入：customers = [[5,2],[5,4],[10,3],[20,1]] 输出：3.25000
解释：1) 第一位顾客在时刻 5 到达，厨师拿到他的订单并在时刻 5 立马开始做菜，
并在时刻 7 完成，第一位顾客等待时间为 7 - 5 = 2 。
2) 第二位顾客在时刻 5 到达，厨师在时刻 7 开始为他做菜，并在时刻 11 完成，
第二位顾客等待时间为 11 - 5 = 6 。
3) 第三位顾客在时刻 10 到达，厨师在时刻 11 开始为他做菜，并在时刻 14 完成，
第三位顾客等待时间为 14 - 10 = 4 。
4) 第四位顾客在时刻 20 到达，厨师拿到他的订单并在时刻 20 立马开始做菜，
并在时刻 21 完成，第四位顾客等待时间为 21 - 20 = 1 。
平均等待时间为 (2 + 6 + 4 + 1) / 4 = 3.25 。
提示：1 &lt;= customers.length &lt;= 105
1 &lt;= arrivali, timei &lt;= 104
arrivali &lt;= arrivali+1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历模拟</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">averageWaitingTime</span><span class="p">(</span><span class="nx">customers</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">customers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">customers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cur</span> <span class="p">&lt;</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">cur</span> <span class="p">=</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// 做菜时间</span>
		<span class="p">}</span>
		<span class="nx">wait</span> <span class="o">:=</span> <span class="nx">cur</span> <span class="o">-</span> <span class="nx">customers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// 等待时间</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">wait</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">customers</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>1702.修改后的最大二进制字符串(2)<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：
操作 1 ：如果二进制串包含子字符串 &quot;00&quot; ，你可以用 &quot;10&quot; 将其替换。
比方说， &quot;00010&quot; -&gt; &quot;10010&quot;
操作 2 ：如果二进制串包含子字符串 &quot;10&quot; ，你可以用 &quot;01&quot; 将其替换。
比方说， &quot;00010&quot; -&gt; &quot;00001&quot;
请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。
如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，
那么我们称二进制字符串 x 大于二进制字符串 y 。
示例 1：输入：binary = &quot;000110&quot; 输出：&quot;111011&quot;
解释：一个可行的转换为：
&quot;000110&quot; -&gt; &quot;000101&quot; 
&quot;000101&quot; -&gt; &quot;100101&quot; 
&quot;100101&quot; -&gt; &quot;110101&quot; 
&quot;110101&quot; -&gt; &quot;110011&quot; 
&quot;110011&quot; -&gt; &quot;111011&quot;
示例 2：输入：binary = &quot;01&quot; 输出：&quot;01&quot;
解释：&quot;01&quot; 没办法进行任何转换。
提示：1 &lt;= binary.length &lt;= 105
binary 仅包含 &#39;0&#39; 和 &#39;1&#39; 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximumBinaryString(binary string) string {
	flag := true
	rightOne := 0 // 记录第1个0后面1的数量
	for i := 0; i &lt; len(binary); i++ {
		if binary[i] == &#39;0&#39; {
			flag = false
		} else {
			if flag == false {
				rightOne++
			}
		}
	}
	if flag == true { // 全是1，直接返回
		return binary
	}
	// 首先：第1个0之前的1不需要移动。
	// 然后：把第1个0之后的1移到后面，后移：10=&gt;01。
	// 最后：然后把中间的000，都变成110，00=&gt;10。
	arr := make([]byte, len(binary))
	for i := 0; i &lt; len(arr); i++ {
		arr[i] = &#39;1&#39;
	}
	arr[len(arr)-1-rightOne] = &#39;0&#39;
	return string(arr)
}

# 2
func maximumBinaryString(binary string) string {
	n := len(binary)
	count := strings.Count(binary, &quot;1&quot;)
	if count &gt;= n-1 {
		return binary
	}
	indexZero := strings.IndexByte(binary, &#39;0&#39;)
	count = count - indexZero
	return strings.Repeat(&quot;1&quot;, n-1-count) + &quot;0&quot; + strings.Repeat(&quot;1&quot;, count)
}
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2>1705.吃苹果的最大数目(2)<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。
在第 i 天，树上会长出 apples[i] 个苹果，
这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。
也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。
你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。
示例 1：输入：apples = [1,2,3,5,2], days = [3,2,1,4,2] 输出：7
解释：你可以吃掉 7 个苹果：
- 第一天，你吃掉第一天长出来的苹果。
- 第二天，你吃掉一个第二天长出来的苹果。
- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。
- 第四天到第七天，你吃的都是第四天长出来的苹果。
示例 2：输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] 输出：5
解释：你可以吃掉 5 个苹果：
- 第一天到第三天，你吃的都是第一天长出来的苹果。
- 第四天和第五天不吃苹果。
- 第六天和第七天，你吃的都是第六天长出来的苹果。
提示：apples.length == n
days.length == n
1 &lt;= n &lt;= 2 * 104
0 &lt;= apples[i], days[i] &lt;= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>模拟</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func eatenApples(apples []int, days []int) int {
	res := 0
	nodeHeap := make(NodeHeap, 0)
	heap.Init(&amp;nodeHeap)
	for i := 0; i &lt; len(apples) || nodeHeap.Len() &gt; 0; i++ {
		if i &lt; len(apples) &amp;&amp; apples[i] &gt; 0 {
			heap.Push(&amp;nodeHeap, Node{
				date: days[i] + i,
				num:  apples[i],
			})
		}
		for nodeHeap.Len() &gt; 0 &amp;&amp; nodeHeap[0].date == i {
			heap.Pop(&amp;nodeHeap)
		}
		if nodeHeap.Len() &gt; 0 &amp;&amp; nodeHeap[0].num &gt; 0 {
			res++
			nodeHeap[0].num--
			if nodeHeap[0].num == 0 {
				heap.Pop(&amp;nodeHeap)
			}
		}
	}
	return res
}

type Node struct {
	date int
	num  int
}

type NodeHeap []Node

func (h NodeHeap) Len() int {
	return len(h)
}

// 小根堆&lt;,大根堆变换方向&gt;
func (h NodeHeap) Less(i, j int) bool {
	return h[i].date &lt; h[j].date
}

func (h NodeHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *NodeHeap) Push(x interface{}) {
	*h = append(*h, x.(Node))
}

func (h *NodeHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
func eatenApples(apples []int, days []int) int {
	arr := make([]int, 40000)
	res := 0
	left, right := 0, 0
	for i := 0; ; i++ {
		if i &lt; len(apples) {
			target := i + days[i] // 保质期内
			arr[target] = arr[target] + apples[i]
			if target &gt; right {
				right = target
			}
			if left &gt; target {
				left = target
			}
		} else {
			if left &gt; right {
				break
			}
		}
		// 吃苹果
		for left = i + 1; left &lt;= right; left++ {
			if arr[left] &gt; 0 {
				res++
				arr[left]--
				break
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>1706.球会落何处(3)<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。
箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。
将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。
将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。
在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。
如果球恰好卡在两块挡板之间的 &quot;V&quot; 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。
返回一个大小为 n 的数组 answer ，
其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。
示例 1：
输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
输出：[1,-1,-1,-1,-1]
解释：示例如图：
b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。
b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。
b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。
b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。
b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。
示例 2：输入：grid = [[-1]] 输出：[-1]
解释：球被卡在箱子左侧边上。
示例 3：输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
输出：[0,1,2,3,4,-1]
提示：m == grid.length
n == grid[i].length
1 &lt;= m, n &lt;= 100
grid[i][j] 为 1 或 -1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findBall(grid [][]int) []int {
	n, m := len(grid), len(grid[0])
	res := make([]int, m)
	for i := 0; i &lt; m; i++ {
		res[i] = i
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if res[j] != -1 {
				if res[j] != m-1 &amp;&amp; grid[i][res[j]] == 1 &amp;&amp; grid[i][res[j]+1] == 1 { // 向右侧 \
					res[j] = res[j] + 1 // 坐标向右+1
				} else if res[j] != 0 &amp;&amp; grid[i][res[j]] == -1 &amp;&amp; grid[i][res[j]-1] == -1 { // 向左侧 /
					res[j] = res[j] - 1 // 坐标向左-1
				} else {
					res[j] = -1
				}
			}
		}
	}
	return res
}

# 2
func findBall(grid [][]int) []int {
	n, m := len(grid), len(grid[0])
	res := make([]int, 0)
	for j := 0; j &lt; m; j++ { // 每列模拟
		index := j
		for i := 0; i &lt; n; i++ {
			if (grid[i][index] == 1 &amp;&amp; (index == m-1 || grid[i][index+1] == -1)) ||
				(grid[i][index] == -1 &amp;&amp; (index == 0 || grid[i][index-1] == 1)) {
				index = -1
				break
			}
			index = index + grid[i][index]
		}
		res = append(res, index)
	}
	return res
}

# 3
func findBall(grid [][]int) []int {
	n, m := len(grid), len(grid[0])
	res := make([]int, m)
	for i := 0; i &lt; m; i++ {
		res[i] = i
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; m; j++ {
			if res[j] == -1 {
				continue
			}
			if (grid[i][res[j]] == 1 &amp;&amp; (res[j] == m-1 || grid[i][res[j]+1] == -1)) ||
				(grid[i][res[j]] == -1 &amp;&amp; (res[j] == 0 || grid[i][res[j]-1] == 1)) {
				res[j] = -1
				continue
			}
			res[j] = res[j] + grid[i][res[j]]
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>1711.大餐计数(1)<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。
你可以搭配 任意 两道餐品做一顿大餐。
给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i道餐品的美味程度，
返回你可以用数组中的餐品做出的不同大餐的数量。
结果需要对 109 + 7 取余。
注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。
示例 1：输入：deliciousness = [1,3,5,7,9] 输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
示例 2：输入：deliciousness = [1,1,1,3,3,3,7] 输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
提示：1 &lt;= deliciousness.length &lt;= 105
0 &lt;= deliciousness[i] &lt;= 220
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">countPairs</span><span class="p">(</span><span class="nx">deliciousness</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">deliciousness</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">total</span> <span class="o">:=</span> <span class="mi">1</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="mi">21</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">total</span><span class="o">-</span><span class="nx">deliciousness</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">m</span><span class="p">[</span><span class="nx">total</span><span class="o">-</span><span class="nx">deliciousness</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
			<span class="p">}</span>
			<span class="nx">total</span> <span class="p">=</span> <span class="nx">total</span> <span class="o">*</span> <span class="mi">2</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">deliciousness</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span> <span class="o">%</span> <span class="mi">1000000007</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>1712.将数组分成三个子数组的方案数(2)<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们称一个分割整数数组的方案是 好的 ，当它满足：
数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。
left 中元素和小于等于 mid 中元素和，mid 中元素和小于等于 right 中元素和。
给你一个 非负 整数数组 nums ，请你返回 好的 分割 nums 方案数目。
由于答案可能会很大，请你将结果对 109 + 7 取余后返回。
示例 1：输入：nums = [1,1,1] 输出：1
解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。
示例 2：输入：nums = [1,2,2,2,5,0] 输出：3
解释：nums 总共有 3 种好的分割方案：
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
示例 3：输入：nums = [3,2,1] 输出：0
解释：没有好的分割方案。
提示：3 &lt;= nums.length &lt;= 105
0 &lt;= nums[i] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前缀和+双指针</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和+二分查找</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func waysToSplit(nums []int) int {
	res := 0
	n := len(nums)
	arr := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		arr[i+1] = arr[i] + nums[i]
	}
	left, right := 2, 2
	for i := 1; i &lt;= n-1; i++ {
		first := arr[i] // 第1个数
		left = max(left, i+1)
		right = max(right, i+1)
		for left &lt;= n-1 &amp;&amp; arr[left]-first &lt; first { // 找到第一个满足的中间数组左边坐标
			left++
		}
		for right &lt;= n-1 &amp;&amp; arr[right]-first &lt;= arr[n]-arr[right] {
			right++
		}
		if left &lt;= right {
			res = (res + right - left) % 1000000007
		}
	}
	return res % 1000000007
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func waysToSplit(nums []int) int {
	res := 0
	n := len(nums)
	arr := make([]int, n+1)
	for i := 0; i &lt; n; i++ {
		arr[i+1] = arr[i] + nums[i]
	}
	for i := 1; i &lt;= n-1; i++ {
		first := arr[i] // 第1个数
		if first*3 &gt; arr[n] {
			break
		}
		left, right := i+1, n-1
		for left &lt;= right {
			mid := left + (right-left)/2
			if arr[n]-arr[mid] &lt; arr[mid]-first {
				right = mid - 1
			} else {
				left = mid + 1
			}
		}
		b := left
		left, right = i+1, n-1
		for left &lt;= right {
			mid := left + (right-left)/2
			if arr[mid]-first &lt; first {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
		a := left
		res = (res + b - a) % 1000000007
	}
	return res % 1000000007
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2>1717.删除子字符串的最大得分(2)<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s 和两个整数 x 和 y 。你可以执行下面两种操作任意次。
删除子字符串 &quot;ab&quot; 并得到 x 分。
比方说，从 &quot;cabxbae&quot; 删除 ab ，得到 &quot;cxbae&quot; 。
删除子字符串&quot;ba&quot; 并得到 y 分。
比方说，从 &quot;cabxbae&quot; 删除 ba ，得到 &quot;cabxe&quot; 。
请返回对 s 字符串执行上面操作若干次能得到的最大得分。
示例 1：输入：s = &quot;cdbcbbaaabab&quot;, x = 4, y = 5 输出：19
解释：- 删除 &quot;cdbcbbaaabab&quot; 中加粗的 &quot;ba&quot; ，得到 s = &quot;cdbcbbaaab&quot; ，加 5 分。
- 删除 &quot;cdbcbbaaab&quot; 中加粗的 &quot;ab&quot; ，得到 s = &quot;cdbcbbaa&quot; ，加 4 分。
- 删除 &quot;cdbcbbaa&quot; 中加粗的 &quot;ba&quot; ，得到 s = &quot;cdbcba&quot; ，加 5 分。
- 删除 &quot;cdbcba&quot; 中加粗的 &quot;ba&quot; ，得到 s = &quot;cdbc&quot; ，加 5 分。
总得分为 5 + 4 + 5 + 5 = 19 。
示例 2：输入：s = &quot;aabbaaxybbaabb&quot;, x = 5, y = 4 输出：20
提示：1 &lt;= s.length &lt;= 105
1 &lt;= x, y &lt;= 104
s 只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximumGain(s string, x int, y int) int {
	if x &gt; y {
		x, y = y, x
		s = reverse(s)
	}
	res := 0
	stack := make([]byte, 0)
	// 先处理ba,y分多
	for i := 0; i &lt; len(s); i++ {
		if s[i] != &#39;a&#39; {
			stack = append(stack, s[i])
		} else {
			if len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == &#39;b&#39; {
				stack = stack[:len(stack)-1]
				res = res + y
			} else {
				stack = append(stack, s[i])
			}
		}
	}
	// 处理ab
	temp := make([]byte, 0)
	for len(stack) &gt; 0 {
		c := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if c != &#39;a&#39; {
			temp = append(temp, c)
		} else {
			if len(temp) &gt; 0 &amp;&amp; temp[len(temp)-1] == &#39;b&#39; {
				temp = temp[:len(temp)-1]
				res = res + x
			} else {
				temp = append(temp, c)
			}
		}
	}
	return res
}

func reverse(s string) string {
	arr := []byte(s)
	for i := 0; i &lt; len(s)/2; i++ {
		arr[i], arr[len(s)-1-i] = arr[len(s)-1-i], arr[i]
	}
	return string(arr)
}

# 2
func maximumGain(s string, x int, y int) int {
	if x &gt; y {
		x, y = y, x
		s = reverse(s)
	}
	res := 0
	a, b := 0, 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] == &#39;a&#39; || s[i] == &#39;b&#39; {
			if s[i] == &#39;a&#39; {
				a++
			} else {
				b++
			}
			// 处理ba
			if s[i] == &#39;a&#39; &amp;&amp; b &gt; 0 {
				a--
				b--
				res = res + y
			}
		} else {
			res = res + x*min(a, b) // 处理ab
			a, b = 0, 0
		}
	}
	res = res + x*min(a, b) // 处理ab
	return res
}

func reverse(s string) string {
	arr := []byte(s)
	for i := 0; i &lt; len(s)/2; i++ {
		arr[i], arr[len(s)-1-i] = arr[len(s)-1-i], arr[i]
	}
	return string(arr)
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2>1718.构建字典序最大的可行序列(1)<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n ，请你找到满足下面条件的一个序列：
整数 1 在序列中只出现一次。
2 到 n 之间每个整数都恰好出现两次。
对于每个 2 到 n 之间的整数 i ，两个 i 之间出现的距离恰好为 i 。
序列里面两个数 a[i] 和 a[j] 之间的 距离 ，我们定义为它们下标绝对值之差 |j - i| 。
请你返回满足上述条件中 字典序最大 的序列。题目保证在给定限制条件下，一定存在解。
一个序列 a 被认为比序列 b （两者长度相同）字典序更大的条件是： 
a 和 b 中第一个不一样的数字处，a 序列的数字比 b 序列的数字大。
比方说，[0,1,9,0] 比 [0,1,5,6] 字典序更大，因为第一个不同的位置是第三个数字，且 9 比 5 大。
示例 1：输入：n = 3 输出：[3,1,2,3,2]
解释：[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。
示例 2：输入：n = 5 输出：[5,3,1,4,3,5,2,4,2]
提示：1 &lt;= n &lt;= 20
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>回溯</td>
<td>O(n!)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">res</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">constructDistancedSequence</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">visited</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">dfs</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">visited</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">cur</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">path</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">visited</span> <span class="o">*</span><span class="p">[]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="o">*</span><span class="nx">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">cur</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span> <span class="c1">// 从大的开始尝试</span>
		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">i</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">visited</span><span class="p">)[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">next</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">next</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">next</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// 1特判</span>
			<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">cur</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">visited</span><span class="p">)[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">b</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
		<span class="k">if</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">b</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">visited</span><span class="p">)[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h2>1721.交换链表中的节点(2)<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你链表的头节点 head 和一个整数 k 。
交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。
示例 1：输入：head = [1,2,3,4,5], k = 2 输出：[1,4,3,2,5]
示例 2：输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5 输出：[7,9,6,6,8,7,3,0,9,5]
示例 3：输入：head = [1], k = 1 输出：[1]
示例 4：输入：head = [1,2], k = 1 输出：[2,1]
示例 5：输入：head = [1,2,3], k = 2 输出：[1,2,3]
提示：链表中节点的数目是 n
1 &lt;= k &lt;= n &lt;= 105
0 &lt;= Node.val &lt;= 100
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数组</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func swapNodes(head *ListNode, k int) *ListNode {
	slow, fast := head, head
	for i := 0; i &lt; k-1; i++ {
		fast = fast.Next
	}
	a := fast
	for fast != nil &amp;&amp; fast.Next != nil {
		fast = fast.Next
		slow = slow.Next
	}
	slow.Val, a.Val = a.Val, slow.Val
	return head
}

# 2
func swapNodes(head *ListNode, k int) *ListNode {
	res := make([]*ListNode, 0)
	cur := head
	for cur != nil {
		res = append(res, cur)
		cur = cur.Next
	}
	res[k-1].Val, res[len(res)-k].Val = res[len(res)-k].Val, res[k-1].Val
	return head
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h2>1722.执行交换操作后的最小汉明距离(1)<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个整数数组 source 和 target ，长度都是 n 。
还有一个数组 allowedSwaps ，其中每个 allowedSwaps[i] = [ai, bi] 
表示你可以交换数组 source 中下标为 ai 和 bi（下标从 0 开始）的两个元素。
注意，你可以按 任意 顺序 多次 交换一对特定下标指向的元素。
相同长度的两个数组 source 和 target 间的 汉明距离 是元素不同的下标数量。
形式上，其值等于满足 source[i] != target[i] （下标从 0 开始）的下标 i（0 &lt;= i &lt;= n-1）的数量。
在对数组 source 执行 任意 数量的交换操作后，返回 source 和 target 间的 最小汉明距离 。
示例 1：输入：source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] 输出：1
解释：source 可以按下述方式转换：
- 交换下标 0 和 1 指向的元素：source = [2,1,3,4]
- 交换下标 2 和 3 指向的元素：source = [2,1,4,3]
source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。
示例 2：输入：source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] 输出：2
解释：不能对 source 执行交换操作。
source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。
示例 3：输入：source = [5,1,2,4,3], target = [1,5,4,2,3], 
allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] 输出：0
提示：n == source.length == target.length
1 &lt;= n &lt;= 105
1 &lt;= source[i], target[i] &lt;= 105
0 &lt;= allowedSwaps.length &lt;= 105
allowedSwaps[i].length == 2
0 &lt;= ai, bi &lt;= n - 1
ai != bi
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>并查集</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minimumHammingDistance</span><span class="p">(</span><span class="nx">source</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">allowedSwaps</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
	<span class="nx">fa</span> <span class="p">=</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allowedSwaps</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">allowedSwaps</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">allowedSwaps</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">union</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">v</span> <span class="o">:=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">][</span><span class="nx">source</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">v</span> <span class="o">:=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">][</span><span class="nx">target</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">res</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">][</span><span class="nx">target</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">fa</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// 初始化</span>
<span class="kd">func</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>

<span class="c1">// 查询</span>
<span class="kd">func</span> <span class="nx">find</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fa</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 合并</span>
<span class="kd">func</span> <span class="nx">union</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fa</span><span class="p">[</span><span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h2>1726.同积元组(1)<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a * b = c * d 的元组 (a, b, c, d) 的数量。
其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。
示例 1：输入：nums = [2,3,4,6] 输出：8
解释：存在 8 个满足题意的元组：
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (3,4,2,6) , (3,4,6,2) , (4,3,6,2)
示例 2：输入：nums = [1,2,4,5,10] 输出：16
解释：存在 16 个满足题意的元组：
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,4,5)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
示例 3：输入：nums = [2,3,4,6,8,12] 输出：40
示例 4：输入：nums = [2,3,5,7] 输出：0
提示：1 &lt;= nums.length &lt;= 1000
1 &lt;= nums[i] &lt;= 104
nums 中的所有元素 互不相同
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">tupleSameProduct</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">total</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">v</span><span class="o">*</span><span class="p">(</span><span class="nx">v</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h2>1727.重新排列后的最大子矩阵(1)<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个二进制矩阵 matrix ，它的大小为 m x n ，你可以将 matrix 中的 列 按任意顺序重新排列。
请你返回最优方案下将 matrix 重新排列后，全是 1 的子矩阵面积。
示例 1：输入：matrix = [[0,0,1],[1,1,1],[1,0,1]] 输出：4
解释：你可以按照上图方式重新排列矩阵的每一列。
最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。
示例 2：输入：matrix = [[1,0,1,0,1]] 输出：3
解释：你可以按照上图方式重新排列矩阵的每一列。
最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。
示例 3：输入：matrix = [[1,1,0],[1,0,1]] 输出：2
解释：由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。
示例 4：输入：matrix = [[0,0],[0,0]] 输出：0
解释：由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。
提示：m == matrix.length
n == matrix[i].length
1 &lt;= m * n &lt;= 105
matrix[i][j] 要么是 0 ，要么是 1 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">largestSubmatrix</span><span class="p">(</span><span class="nx">matrix</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// 统计以该行为基连续1的个数</span>
				<span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">height</span> <span class="o">:=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="c1">// 高度有序，右边最高=&gt;高度取决于左边</span>
			<span class="nx">width</span> <span class="o">:=</span> <span class="nx">m</span> <span class="o">-</span> <span class="nx">j</span>
			<span class="k">if</span> <span class="nx">height</span><span class="o">*</span><span class="nx">width</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">height</span> <span class="o">*</span> <span class="nx">width</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h2>1733.需要教语言的最少人数(1)<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在一个由 m 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。
两个用户之间可以相互沟通的条件是他们都掌握同一门语言。
给你一个整数 n ，数组 languages 和数组 friendships ，它们的含义如下：
总共有 n 种语言，编号从 1 到 n 。
languages[i] 是第 i 位用户掌握的语言集合。
friendships[i] = [ui, vi] 表示 ui和 vi 为好友关系。
你可以选择 一门 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你 最少 需要教会多少名用户。
请注意，好友关系没有传递性，也就是说如果 x 和 y 是好友，且 y 和 z 是好友， x 和 z 不一定是好友。
示例 1：输入：n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]] 输出：1
解释：你可以选择教用户 1 第二门语言，也可以选择教用户 2 第一门语言。
示例 2：
输入：n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
输出：2
解释：教用户 1 和用户 3 第三门语言，需要教 2 名用户。
提示：2 &lt;= n &lt;= 500
languages.length == m
1 &lt;= m &lt;= 500
1 &lt;= languages[i].length &lt;= n
1 &lt;= languages[i][j] &lt;= n
1 &lt;= ui &lt; vi &lt;= languages.length
1 &lt;= friendships.length &lt;= 500
所有的好友关系 (ui, vi) 都是唯一的。
languages[i] 中包含的值互不相同。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minimumTeachings</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">languages</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">friendships</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">languages</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">languages</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nx">languages</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">a</span><span class="p">][</span><span class="nx">b</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">need</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// 需要沟通的人列表</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">friendships</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">friendships</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">friendships</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">a</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">m</span><span class="p">[</span><span class="nx">b</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="nx">need</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">need</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">need</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">count</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">res</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">count</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">need</span><span class="p">)</span> <span class="o">-</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h2>1734.解码异或后的排列(2)<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。
它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。
比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。
给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。
示例 1：输入：encoded = [3,1] 输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
示例 2：输入：encoded = [6,5,4,6] 输出：[2,4,1,5,3]
提示：3 &lt;= n &lt; 105
n 是奇数。
encoded.length == n - 1
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>异或</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>异或</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func decode(encoded []int) []int {
	n := len(encoded)
	temp := make([]int, n)
	copy(temp, encoded)
	first := encoded[0]
	for i := 1; i &lt; n; i++ {
		temp[i] = encoded[i] ^ temp[i-1]
		first = first ^ temp[i]
	}
	for i := 1; i &lt;= n+1; i++ {
		first = first ^ i
	}

	res := make([]int, n+1)
	res[0] = first
	for i := 0; i &lt; n; i++ {
		res[i+1] = encoded[i] ^ res[i]
	}
	return res
}

# 2
func decode(encoded []int) []int {
	n := len(encoded)
	first := 0
	for i := 1; i &lt;= n+1; i++ {
		first = first ^ i
	}
	for i := 1; i &lt;= n; i = i + 2 {
		first = first ^ encoded[i]
	}
	res := make([]int, n+1)
	res[0] = first
	for i := 0; i &lt; n; i++ {
		res[i+1] = encoded[i] ^ res[i]
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>1737.满足三条件之一需改变的最少字符数(1)<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串 a 和 b ，二者均由小写字母组成。
一步操作中，你可以将 a 或 b 中的 任一字符 改变为 任一小写字母 。
操作的最终目标是满足下列三个条件 之一 ：
a 中的 每个字母 在字母表中 严格小于 b 中的 每个字母 。
b 中的 每个字母 在字母表中 严格小于 a 中的 每个字母 。
a 和 b 都 由 同一个 字母组成。
返回达成目标所需的 最少 操作数。
示例 1：输入：a = &quot;aba&quot;, b = &quot;caa&quot; 输出：2
解释：满足每个条件的最佳方案分别是：
1) 将 b 变为 &quot;ccc&quot;，2 次操作，满足 a 中的每个字母都小于 b 中的每个字母；
2) 将 a 变为 &quot;bbb&quot; 并将 b 变为 &quot;aaa&quot;，3 次操作，满足 b 中的每个字母都小于 a 中的每个字母；
3) 将 a 变为 &quot;aaa&quot; 并将 b 变为 &quot;aaa&quot;，2 次操作，满足 a 和 b 由同一个字母组成。
最佳的方案只需要 2 次操作（满足条件 1 或者条件 3）。
示例 2：输入：a = &quot;dabadd&quot;, b = &quot;cda&quot; 输出：3
解释：满足条件 1 的最佳方案是将 b 变为 &quot;eee&quot; 。
提示：1 &lt;= a.length, b.length &lt;= 105
a 和 b 只由小写字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">minCharacters</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arrA</span><span class="p">,</span> <span class="nx">arrB</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{},</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arrA</span><span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arrB</span><span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
	<span class="nx">lengthA</span><span class="p">,</span> <span class="nx">lengthB</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">sumA</span><span class="p">,</span> <span class="nx">sumB</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="c1">// a-y的情况</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sumA</span> <span class="p">=</span> <span class="nx">sumA</span> <span class="o">+</span> <span class="nx">arrA</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">sumB</span> <span class="p">=</span> <span class="nx">sumB</span> <span class="o">+</span> <span class="nx">arrB</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">lengthA</span><span class="o">-</span><span class="nx">sumA</span><span class="o">+</span><span class="nx">sumB</span><span class="p">)</span>               <span class="c1">// 条件1：a&lt;b</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">sumA</span><span class="o">+</span><span class="nx">lengthB</span><span class="o">-</span><span class="nx">sumB</span><span class="p">)</span>               <span class="c1">// 条件2: b&lt;a</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">lengthA</span><span class="o">-</span><span class="nx">arrA</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">lengthB</span><span class="o">-</span><span class="nx">arrB</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// 条件3：全都相同</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">lengthA</span><span class="o">-</span><span class="nx">arrA</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span><span class="o">+</span><span class="nx">lengthB</span><span class="o">-</span><span class="nx">arrB</span><span class="p">[</span><span class="mi">25</span><span class="p">])</span> <span class="c1">// z全都相同</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="k-2">
<h2>1738.找出第K大的异或坐标值(2)<a class="headerlink" href="#k-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。
矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 
matrix[i][j]（下标从 0 开始计数）执行异或运算得到。
请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。
示例 1：输入：matrix = [[5,2],[1,6]], k = 1 输出：7
解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。
示例 2：输入：matrix = [[5,2],[1,6]], k = 2 输出：5
解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。
示例 3：输入：matrix = [[5,2],[1,6]], k = 3 输出：4
解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。
示例 4：输入：matrix = [[5,2],[1,6]], k = 4 输出：0
解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。
提示：m == matrix.length
n == matrix[i].length
1 &lt;= m, n &lt;= 1000
0 &lt;= matrix[i][j] &lt;= 106
1 &lt;= k &lt;= m * n
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序</td>
<td>O((nlog(n))^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>堆排序</td>
<td>O(n^2log(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func kthLargestValue(matrix [][]int, k int) int {
	m := len(matrix)
	n := len(matrix[0])
	arr := make([]int, 0)
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if i == 0 &amp;&amp; j &gt; 0 {
				matrix[i][j] = matrix[i][j-1] ^ matrix[i][j]
			} else if i &gt; 0 &amp;&amp; j == 0 {
				matrix[i][j] = matrix[i-1][j] ^ matrix[i][j]
			} else if i &gt; 0 &amp;&amp; j &gt; 0 {
				matrix[i][j] = matrix[i-1][j] ^ matrix[i][j-1] ^ matrix[i][j] ^ matrix[i-1][j-1]
			}
			arr = append(arr, matrix[i][j])
		}
	}
	sort.Ints(arr)
	return arr[len(arr)-k]
}

# 2
func kthLargestValue(matrix [][]int, k int) int {
	m := len(matrix)
	n := len(matrix[0])
	intHeap := make(IntHeap, 0)
	heap.Init(&amp;intHeap)
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if i == 0 &amp;&amp; j &gt; 0 {
				matrix[i][j] = matrix[i][j-1] ^ matrix[i][j]
			} else if i &gt; 0 &amp;&amp; j == 0 {
				matrix[i][j] = matrix[i-1][j] ^ matrix[i][j]
			} else if i &gt; 0 &amp;&amp; j &gt; 0 {
				matrix[i][j] = matrix[i-1][j] ^ matrix[i][j-1] ^ matrix[i][j] ^ matrix[i-1][j-1]
			}
			heap.Push(&amp;intHeap, matrix[i][j])
			if intHeap.Len() &gt; k {
				heap.Pop(&amp;intHeap)
			}
		}
	}
	return intHeap[0]
}

type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

func (h IntHeap) Less(i, j int) bool {
	return h[i] &lt; h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>1743.从相邻元素对还原数组(2)<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。
好在你还记得 nums 中的每一对相邻元素。
给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，
其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。
题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，
存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。
这些相邻元素对可以 按任意顺序 出现。
返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。
示例 1：输入：adjacentPairs = [[2,1],[3,4],[3,2]] 输出：[1,2,3,4]
解释：数组的所有相邻元素对都在 adjacentPairs 中。
特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。
示例 2：输入：adjacentPairs = [[4,-2],[1,4],[-3,1]] 输出：[-2,4,1,-3]
解释：数组中可能存在负数。
另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。
示例 3：输入：adjacentPairs = [[100000,-100000]] 输出：[100000,-100000]
提示：nums.length == n
adjacentPairs.length == n - 1
adjacentPairs[i].length == 2
2 &lt;= n &lt;= 105
-105 &lt;= nums[i], ui, vi &lt;= 105
题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>深度优先遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res []int
var m map[int][]int

func restoreArray(adjacentPairs [][]int) []int {
	m = make(map[int][]int)
	for i := 0; i &lt; len(adjacentPairs); i++ {
		a, b := adjacentPairs[i][0], adjacentPairs[i][1]
		m[a] = append(m[a], b)
		m[b] = append(m[b], a)
	}
	arr := make([]int, 0)
	for k, v := range m {
		if len(v) == 1 {
			arr = append(arr, k)
		}
	}
	res = make([]int, 0)
	dfs(arr[0], make(map[int]bool))
	return res
}

func dfs(cur int, visited map[int]bool) {
	res = append(res, cur)
	visited[cur] = true
	for i := range m[cur] {
		if visited[m[cur][i]] == false {
			dfs(m[cur][i], visited)
		}
	}
}

# 2
func restoreArray(adjacentPairs [][]int) []int {
	m := make(map[int][]int)
	for i := 0; i &lt; len(adjacentPairs); i++ {
		a, b := adjacentPairs[i][0], adjacentPairs[i][1]
		m[a] = append(m[a], b)
		m[b] = append(m[b], a)
	}
	prev := 0
	cur := 0
	for k, v := range m {
		if len(v) == 1 {
			prev = k
			cur = v[0]
			break
		}
	}
	res := make([]int, 0)
	res = append(res, prev)
	n := len(adjacentPairs) + 1
	for n &gt; len(res) {
		res = append(res, cur)
		for i := 0; i &lt; len(m[cur]); i++ {
			if m[cur][i] != prev {
				prev = cur
				cur = m[cur][i]
				break
			}
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h2>1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？(1)<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个下标从 0 开始的正整数数组 candiesCount ，
其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。
同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。
你按照如下规则进行一场游戏：
你从第 0 天开始吃糖果。
你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。
在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。
请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。
answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，
你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。
注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。
请你返回得到的数组 answer 。
示例 1：输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
输出：[true,false,true]
提示：1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。
2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），
你也没办法在第 2 天吃到类型 4 的糖果。
换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。
3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。
示例 2：输入：candiesCount = [5,2,6,4,1], 
queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
输出：[false,true,true,false,false]
提示：1 &lt;= candiesCount.length &lt;= 105
1 &lt;= candiesCount[i] &lt;= 105
1 &lt;= queries.length &lt;= 105
queries[i].length == 3
0 &lt;= favoriteTypei &lt; candiesCount.length
0 &lt;= favoriteDayi &lt;= 109
1 &lt;= dailyCapi &lt;= 109
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前缀和+遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">canEat</span><span class="p">(</span><span class="nx">candiesCount</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">queries</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candiesCount</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candiesCount</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">candiesCount</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queries</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queries</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">queries</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// 第几类</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">queries</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// 第几天，到第n天共n+1天</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">queries</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// 每天最多吃c颗</span>
		<span class="nx">total</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">total</span> <span class="o">&lt;=</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// 最少一天一颗</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">c</span><span class="o">*</span><span class="p">(</span><span class="nx">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// 最多每天吃c颗</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h2>1749.任意子数组和的绝对值的最大值(3)<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums 。一个子数组 [numsl, numsl+1, ..., numsr-1, numsr] 
的 和的绝对值 为 abs(numsl + numsl+1 + ... + numsr-1 + numsr) 。
请你找出 nums 中 和的绝对值 最大的任意子数组（可能为空），并返回该 最大值 。
abs(x) 定义如下：
如果 x 是负整数，那么 abs(x) = -x 。
如果 x 是非负整数，那么 abs(x) = x 。
示例 1：输入：nums = [1,-3,2,3,-4] 输出：5
解释：子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。
示例 2：输入：nums = [2,-5,1,-4,3,-2] 输出：8
解释：子数组 [-5,1,-4] 和的绝对值最大，为 abs(-5+1-4) = abs(-8) = 8 。
提示：1 &lt;= nums.length &lt;= 105
-104 &lt;= nums[i] &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>前缀和</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maxAbsoluteSum(nums []int) int {
	arr := make([]int, len(nums)+1)
	for i := 1; i &lt;= len(nums); i++ {
		arr[i] = arr[i-1] + nums[i-1]
	}
	sort.Ints(arr)
	return arr[len(nums)] - arr[0]
}

# 2
func maxAbsoluteSum(nums []int) int {
	arr := make([]int, len(nums)+1)
	for i := 1; i &lt;= len(nums); i++ {
		arr[i] = arr[i-1] + nums[i-1]
	}
	maxValue, minValue := 0, 0
	res := 0
	for i := 1; i &lt; len(arr); i++ {
		res = max(res, abs(arr[i]-maxValue))
		res = max(res, abs(arr[i]-minValue))
		maxValue = max(maxValue, arr[i])
		minValue = min(minValue, arr[i])
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}

# 3
func maxAbsoluteSum(nums []int) int {
	maxValue, minValue := 0, 0
	res := 0
	for i := 0; i &lt; len(nums); i++ {
		if maxValue &gt;= 0 {
			maxValue = maxValue + nums[i]
		} else {
			maxValue = nums[i]
		}
		if minValue &lt;= 0 {
			minValue = minValue + nums[i]
		} else {
			minValue = nums[i]
		}
		res = max(res, abs(maxValue))
		res = max(res, abs(minValue))
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2>1750.删除字符串两端相同字符后的最短长度(2)<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个只包含字符 &#39;a&#39;，&#39;b&#39; 和 &#39;c&#39; 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：
选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。
选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。
前缀和后缀在字符串中任意位置都不能有交集。
前缀和后缀包含的所有字符都要相同。
同时删除前缀和后缀。
请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。
示例 1：输入：s = &quot;ca&quot; 输出：2
解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。
示例 2：输入：s = &quot;cabaabac&quot; 输出：0
解释：最优操作序列为：
- 选择前缀 &quot;c&quot; 和后缀 &quot;c&quot; 并删除它们，得到 s = &quot;abaaba&quot; 。
- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;baab&quot; 。
- 选择前缀 &quot;b&quot; 和后缀 &quot;b&quot; 并删除它们，得到 s = &quot;aa&quot; 。
- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;&quot; 。
示例 3：输入：s = &quot;aabccabba&quot; 输出：3
解释：最优操作序列为：
- 选择前缀 &quot;aa&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;bccabb&quot; 。
- 选择前缀 &quot;b&quot; 和后缀 &quot;bb&quot; 并删除它们，得到 s = &quot;cca&quot; 。
提示：1 &lt;= s.length &lt;= 105
s 只包含字符 &#39;a&#39;，&#39;b&#39; 和 &#39;c&#39; 。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>内置函数</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minimumLength(s string) int {
	for len(s) &gt; 0 {
		if s[0] == s[len(s)-1] &amp;&amp; len(s) != 1 {
			temp := string(s[0])
			s = strings.TrimLeft(s, temp)
			s = strings.TrimRight(s, temp)
		} else {
			break
		}
	}
	return len(s)
}

# 2
func minimumLength(s string) int {
	left, right := 0, len(s)-1
	for left &lt; right {
		if s[left] != s[right] {
			break
		}
		temp := s[left]
		for left &lt;= right &amp;&amp; s[left] == temp {
			left++
		}
		for left &lt;= right &amp;&amp; s[right] == temp {
			right--
		}
	}
	return right - left + 1
}
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2>1753.移除石子的最大得分(2)<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你正在玩一个单人游戏，面前放置着大小分别为 a、b 和 c的 三堆 石子。
每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。
给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。
示例 1：输入：a = 2, b = 4, c = 6 输出：6
解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是：
- 从第一和第三堆取，石子状态现在是 (1, 4, 5)
- 从第一和第三堆取，石子状态现在是 (0, 4, 4)
- 从第二和第三堆取，石子状态现在是 (0, 3, 3)
- 从第二和第三堆取，石子状态现在是 (0, 2, 2)
- 从第二和第三堆取，石子状态现在是 (0, 1, 1)
- 从第二和第三堆取，石子状态现在是 (0, 0, 0)
总分：6 分 。
示例 2：输入：a = 4, b = 4, c = 6 输出：7
解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是：
- 从第一和第二堆取，石子状态现在是 (3, 3, 6)
- 从第一和第三堆取，石子状态现在是 (2, 3, 5)
- 从第一和第三堆取，石子状态现在是 (1, 3, 4)
- 从第一和第三堆取，石子状态现在是 (0, 3, 3)
- 从第二和第三堆取，石子状态现在是 (0, 2, 2)
- 从第二和第三堆取，石子状态现在是 (0, 1, 1)
- 从第二和第三堆取，石子状态现在是 (0, 0, 0)
总分：7 分 。
示例 3：输入：a = 1, b = 8, c = 8 输出：8
解释：最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。
注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。
提示：1 &lt;= a, b, c &lt;= 105
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>数学</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximumScore(a int, b int, c int) int {
	res := 0
	arr := []int{a, b, c}
	for {
		sort.Ints(arr)
		if arr[2] &gt; 0 &amp;&amp; arr[1] &gt; 0 {
			arr[2]--
			arr[1]--
			res++
		} else {
			break
		}
	}
	return res
}

# 2
func maximumScore(a int, b int, c int) int {
	arr := []int{a, b, c}
	sort.Ints(arr)
	if arr[0]+arr[1] &lt;= arr[2] {
		return arr[0] + arr[1]
	}
	return (arr[0] + arr[1] + arr[2]) / 2
}
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2>1754.构造字典序最大的合并字符串(1)<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个字符串 word1 和 word2 。
你需要按下述方式构造一个新字符串 merge ：如果 word1 或 word2 非空，选择 下面选项之一 继续操作：
如果 word1 非空，将 word1 中的第一个字符附加到 merge 的末尾，并将其从 word1 中移除。
例如，word1 = &quot;abc&quot; 且 merge = &quot;dv&quot; ，在执行此选项操作之后，word1 = &quot;bc&quot; ，同时 merge = &quot;dva&quot; 。
如果 word2 非空，将 word2 中的第一个字符附加到 merge 的末尾，并将其从 word2 中移除。
例如，word2 = &quot;abc&quot; 且 merge = &quot;&quot; ，在执行此选项操作之后，word2 = &quot;bc&quot; ，同时 merge = &quot;a&quot; 。
返回你可以构造的字典序 最大 的合并字符串 merge 。
长度相同的两个字符串 a 和 b 比较字典序大小，如果在 a 和 b 出现不同的第一个位置，
a 中字符在字母表中的出现顺序位于 b 中相应字符之后，就认为字符串 a 按字典序比字符串 b 更大。
例如，&quot;abcd&quot; 按字典序比 &quot;abcc&quot; 更大，因为两个字符串出现不同的第一个位置是第四个字符，
而 d 在字母表中的出现顺序位于 c 之后。
示例 1：输入：word1 = &quot;cabaa&quot;, word2 = &quot;bcaaa&quot; 输出：&quot;cbcabaaaaa&quot;
解释：构造字典序最大的合并字符串，可行的一种方法如下所示：
- 从 word1 中取第一个字符：merge = &quot;c&quot;，word1 = &quot;abaa&quot;，word2 = &quot;bcaaa&quot;
- 从 word2 中取第一个字符：merge = &quot;cb&quot;，word1 = &quot;abaa&quot;，word2 = &quot;caaa&quot;
- 从 word2 中取第一个字符：merge = &quot;cbc&quot;，word1 = &quot;abaa&quot;，word2 = &quot;aaa&quot;
- 从 word1 中取第一个字符：merge = &quot;cbca&quot;，word1 = &quot;baa&quot;，word2 = &quot;aaa&quot;
- 从 word1 中取第一个字符：merge = &quot;cbcab&quot;，word1 = &quot;aa&quot;，word2 = &quot;aaa&quot;
- 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。
示例 2：输入：word1 = &quot;abcabc&quot;, word2 = &quot;abdcaba&quot; 输出：&quot;abdcabcabcaba&quot;
提示：1 &lt;= word1.length, word2.length &lt;= 3000
word1 和 word2 仅由小写英文组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">largestMerge</span><span class="p">(</span><span class="nx">word1</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">word2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word1</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">word2</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">word1</span> <span class="p">&lt;</span> <span class="nx">word2</span> <span class="p">{</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">word2</span> <span class="p">=</span> <span class="nx">word2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">word2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">word1</span> <span class="p">=</span> <span class="nx">word1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">word1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2>1759.统计同构子字符串的数目(3)<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。
同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。
子字符串 是字符串中的一个连续字符序列。
示例 1：输入：s = &quot;abbcccaa&quot; 输出：13
解释：同构子字符串如下所列：
&quot;a&quot;   出现 3 次。
&quot;aa&quot;  出现 1 次。
&quot;b&quot;   出现 2 次。
&quot;bb&quot;  出现 1 次。
&quot;c&quot;   出现 3 次。
&quot;cc&quot;  出现 2 次。
&quot;ccc&quot; 出现 1 次。
3 + 1 + 2 + 1 + 3 + 2 + 1 = 13
示例 2：输入：s = &quot;xy&quot; 输出：2
解释：同构子字符串是 &quot;x&quot; 和 &quot;y&quot; 。
示例 3：输入：s = &quot;zzzzz&quot; 输出：15
提示：1 &lt;= s.length &lt;= 105
s 由小写字符串组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func countHomogenous(s string) int {
	res := 0
	left, right := 0, 0
	for right &lt; len(s) {
		if s[left] == s[right] {
			right++
		} else {
			length := right - left
			res = res + length*(length+1)/2
			left = right
			right++
		}
	}
	length := right - left
	res = res + length*(length+1)/2
	return res % 1000000007
}

# 2
func countHomogenous(s string) int {
	res := 0
	left, right := 0, 0
	for right &lt; len(s) {
		if s[left] != s[right] {
			left = right
		} else {
			res = res + (right-left+1)%1000000007
			right++
		}
	}
	return res % 1000000007
}

# 3
func countHomogenous(s string) int {
	res := 1
	count := 1
	for i := 1; i &lt; len(s); i++ {
		if s[i] == s[i-1] {
			count++
		} else {
			count = 1
		}
		res = res + count
	}
	return res % 1000000007
}
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h2>1760.袋子里最少数目的球(3)<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
你可以进行如下操作至多 maxOperations 次：
选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，
分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
请你返回进行上述操作后的最小开销。
示例 1：输入：nums = [9], maxOperations = 2 输出：3
解释：- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。
- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。
装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。
示例 2：输入：nums = [2,4,8,2], maxOperations = 4 输出：2
解释：- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -&gt; [2,4,4,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -&gt; [2,2,2,4,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2] 。
装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。
示例 3：输入：nums = [7,17], maxOperations = 2 输出：7
提示：1 &lt;= nums.length &lt;= 105
1 &lt;= maxOperations, nums[i] &lt;= 109
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>03</td>
<td>二分查找</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minimumSize(nums []int, maxOperations int) int {
	sort.Ints(nums)
	left := 1
	right := nums[len(nums)-1]
	res := 0
	for left &lt;= right {
		mid := (left + right) / 2
		count := getCount(nums, mid)
		if count &lt;= maxOperations {
			res = mid
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return res
}

func getCount(nums []int, per int) int {
	count := 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i]%per == 0 {
			count = count + nums[i]/per - 1
		} else {
			count = count + nums[i]/per
		}
	}
	return count
}

# 2
func minimumSize(nums []int, maxOperations int) int {
	sort.Ints(nums)
	left := 1
	right := nums[len(nums)-1]
	res := 0
	for left &lt;= right {
		mid := (left + right) / 2
		count := getCount(nums, mid)
		if count &lt;= maxOperations {
			res = mid
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return res
}

func getCount(nums []int, per int) int {
	count := 0
	for i := 0; i &lt; len(nums); i++ {
		count = count + (nums[i]-1)/per
	}
	return count
}

# 3
func minimumSize(nums []int, maxOperations int) int {
	left := 1
	right := nums[0]
	for i := 1; i &lt; len(nums); i++ {
		if nums[i] &gt; right {
			right = nums[i]
		}
	}
	res := 0
	for left &lt;= right {
		mid := (left + right) / 2
		count := getCount(nums, mid)
		if count &lt;= maxOperations {
			res = mid
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return res
}

func getCount(nums []int, per int) int {
	count := 0
	for i := 0; i &lt; len(nums); i++ {
		count = count + (nums[i]-1)/per
	}
	return count
}
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h2>1764.通过连接另一个数组的子数组得到一个数组(1)<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。
你是否可以从 nums 中选出 n 个 不相交 的子数组，
使得第 i 个子数组与 groups[i] （下标从 0 开始）完全相同，且如果 i &gt; 0 ，
那么第 (i-1) 个子数组在 nums 中出现的位置在第 i 个子数组前面。
（也就是说，这些子数组在 nums 中出现的顺序需要与 groups 顺序相同）
如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。
如果不存在下标为 k 的元素 nums[k] 属于不止一个子数组，就称这些子数组是 不相交 的。
子数组指的是原数组中连续元素组成的一个序列。
示例 1：输入：groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0] 输出：true
解释：你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,1,-1,-1,3,-2,0]
和第 1 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 。
这两个子数组是不相交的，因为它们没有任何共同的元素。
示例 2：输入：groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2] 输出：false
解释：选择子数组 [1,2,3,4,10,-2] 和 [1,2,3,4,10,-2] 是不正确的，
因为它们出现的顺序与 groups 中顺序不同。
[10,-2] 必须出现在 [1,2,3,4] 之前。
示例 3：输入：groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7] 输出：false
解释：选择子数组 [7,7,1,2,3,4,7,7] 和 [7,7,1,2,3,4,7,7] 是不正确的，因为它们不是不相交子数组。
它们有一个共同的元素 nums[4] （下标从 0 开始）。
提示：groups.length == n
1 &lt;= n &lt;= 103
1 &lt;= groups[i].length, sum(groups[i].length) &lt;= 103
1 &lt;= nums.length &lt;= 103
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">canChoose</span><span class="p">(</span><span class="nx">groups</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">groups</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="o">:=</span> <span class="nx">groups</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="nx">count</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">count</span><span class="p">:</span><span class="nx">count</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)])</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
				<span class="nx">count</span> <span class="p">=</span> <span class="nx">count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">break</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">count</span> <span class="p">=</span> <span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">judge</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2>1765.地图中的最高点(1)<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。
如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。
如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。
你需要按照如下规则给每个单元格安排高度：
每个格子的高度都必须是非负的。
如果一个格子是是 水域 ，那么它的高度必须为 0 。
任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。
（也就是说它们有一条公共边）
找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。
请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。
如果有多种解法，请返回 任意一个 。
示例 1：输入：isWater = [[0,1],[0,0]] 输出：[[1,0],[2,1]]
解释：上图展示了给各个格子安排的高度。
蓝色格子是水域格，绿色格子是陆地格。
示例 2：输入：isWater = [[0,0,1],[1,0,0],[0,0,0]] 输出：[[1,1,0],[0,1,1],[1,2,2]]
解释：所有安排方案中，最高可行高度为 2 。
任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。
提示：m == isWater.length
n == isWater[i].length
1 &lt;= m, n &lt;= 1000
isWater[i][j] 要么是 0 ，要么是 1 。
至少有 1 个水域格子。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>广度优先搜索</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">dx</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">dy</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">highestPeak</span><span class="p">(</span><span class="nx">isWater</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">isWater</span><span class="p">)</span>
   <span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">isWater</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
   <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   	<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
   		<span class="k">if</span> <span class="nx">isWater</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
   			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
   			<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">})</span>
   		<span class="p">}</span>
   	<span class="p">}</span>
   <span class="p">}</span>
   <span class="nx">level</span> <span class="o">:=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
   	<span class="nx">level</span><span class="o">++</span>
   	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>
   	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
   		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
   			<span class="nx">x</span> <span class="o">:=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
   			<span class="nx">y</span> <span class="o">:=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
   			<span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">res</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
   				<span class="nx">res</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="nx">level</span>
   				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">})</span>
   			<span class="p">}</span>
   		<span class="p">}</span>
   	<span class="p">}</span>
   	<span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">length</span><span class="p">:]</span>
   <span class="p">}</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
   		<span class="k">if</span> <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
   			<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
   		<span class="p">}</span>
   	<span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>1769.移动所有球到每个盒子所需的最小操作数(3)<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，
其中 boxes[i] 的值为 &#39;0&#39; 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 &#39;1&#39; 表示盒子里有 一个 小球。
在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。
第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。
注意，操作执行后，某些盒子中可能会存在不止一个小球。
返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。
每个 answer[i] 都需要根据盒子的 初始状态 进行计算。
示例 1：输入：boxes = &quot;110&quot; 输出：[1,1,3]
解释：每个盒子对应的最小操作数如下：
1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。
2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。
3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。
示例 2：输入：boxes = &quot;001011&quot; 输出：[11,8,5,4,3,4]
提示：n == boxes.length
1 &lt;= n &lt;= 2000
boxes[i] 为 &#39;0&#39; 或 &#39;1&#39;
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>前缀和+后缀和</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minOperations(boxes string) []int {
	n := len(boxes)
	res := make([]int, n)
	right, rightCount := 0, 0
	for i := 0; i &lt; n; i++ {
		if boxes[i] == &#39;1&#39; {
			right = right + i
			rightCount++
		}
	}
	left, leftCount := 0, 0
	for i := 0; i &lt; n; i++ {
		res[i] = left + right
		if boxes[i] == &#39;1&#39; {
			leftCount++
			rightCount--
		}
		left = left + leftCount
		right = right - rightCount
	}
	return res
}

# 2
func minOperations(boxes string) []int {
	n := len(boxes)
	res := make([]int, n)
	pre := make([]int, n)
	count, sum := 0, 0
	for i := 0; i &lt; n; i++ {
		pre[i] = sum
		if boxes[i] == &#39;1&#39; {
			count++
		}
		sum = sum + count
	}
	suf := make([]int, n)
	count, sum = 0, 0
	for i := n - 1; i &gt;= 0; i-- {
		suf[i] = sum
		if boxes[i] == &#39;1&#39; {
			count++
		}
		sum = sum + count
	}
	for i := 0; i &lt; n; i++ {
		res[i] = pre[i] + suf[i]
	}
	return res
}

# 3
func minOperations(boxes string) []int {
	n := len(boxes)
	res := make([]int, n)
	arr := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		if boxes[i] == &#39;1&#39; {
			arr = append(arr, i)
		}
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; len(arr); j++ {
			res[i] = res[i] + abs(arr[j]-i)
		}
	}
	return res
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h2>1770.执行乘法运算的最大分数(3)<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n &gt;= m ，数组下标 从 1 开始 计数。
初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要：
选择数组 nums 开头处或者末尾处 的整数 x 。
你获得 multipliers[i] * x 分，并累加到你的分数中。
将 x 从数组 nums 中移除。
在执行 m 步操作后，返回 最大 分数。
示例 1：输入：nums = [1,2,3], multipliers = [3,2,1] 输出：14
解释：一种最优解决方案如下：
- 选择末尾处的整数 3 ，[1,2,3] ，得 3 * 3 = 9 分，累加到分数中。
- 选择末尾处的整数 2 ，[1,2] ，得 2 * 2 = 4 分，累加到分数中。
- 选择末尾处的整数 1 ，[1] ，得 1 * 1 = 1 分，累加到分数中。
总分数为 9 + 4 + 1 = 14 。
示例 2：输入：nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] 输出：102
解释：一种最优解决方案如下：
- 选择开头处的整数 -5 ，[-5,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。
- 选择开头处的整数 -3 ，[-3,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。
- 选择开头处的整数 -3 ，[-3,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。
- 选择末尾处的整数 1 ，[-2,7,1] ，得 1 * 4 = 4 分，累加到分数中。
- 选择末尾处的整数 7 ，[-2,7] ，得 7 * 6 = 42 分，累加到分数中。
总分数为 50 + 15 - 9 + 4 + 42 = 102 。
提示：n == nums.length
m == multipliers.length
1 &lt;= m &lt;= 103
m &lt;= n &lt;= 105
-1000 &lt;= nums[i], multipliers[i] &lt;= 1000
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximumScore(nums []int, multipliers []int) int {
	n, m := len(nums), len(multipliers)
	dp := make([][]int, m+1) // dp[i][j] 左i右j的值
	for i := 0; i &lt;= m; i++ {
		dp[i] = make([]int, m+1)
	}
	dp[0][0] = 0
	for i := 1; i &lt;= m; i++ {
		dp[i][0] = dp[i-1][0] + nums[i-1]*multipliers[i-1] // 左i右0
		dp[0][i] = dp[0][i-1] + nums[n-i]*multipliers[i-1] // 左0右i
	}
	for i := 1; i &lt;= m; i++ {
		for j := 1; i+j &lt;= m; j++ {
			left := dp[i-1][j] + nums[i-1]*multipliers[i+j-1]
			right := dp[i][j-1] + nums[n-j]*multipliers[i+j-1]
			dp[i][j] = max(left, right)
		}
	}
	res := math.MinInt32
	for i := 0; i &lt;= m; i++ {
		res = max(res, dp[i][m-i])
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maximumScore(nums []int, multipliers []int) int {
	n, m := len(nums), len(multipliers)
	dp := make([][]int, m+1) // dp[i][j] 左i右j的值
	for i := 0; i &lt;= m; i++ {
		dp[i] = make([]int, m+1)
	}
	res := math.MinInt32
	for k := 1; k &lt;= m; k++ {
		for i := 0; i &lt;= k; i++ {
			left := i
			right := k - i
			if i == 0 {
				dp[left][right] = dp[left][right-1] + nums[n-right]*multipliers[k-1]
			} else if i == k {
				dp[left][right] = dp[left-1][right] + nums[left-1]*multipliers[k-1]
			} else {
				l := dp[left][right-1] + nums[n-right]*multipliers[k-1]
				r := dp[left-1][right] + nums[left-1]*multipliers[k-1]
				dp[left][right] = max(l, r)
			}
			if k == m {
				res = max(res, dp[left][right])
			}
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
var dp [][]int

func maximumScore(nums []int, multipliers []int) int {
	n, m := len(nums), len(multipliers)
	dp = make([][]int, m) // dp[i][j] 左i右j的值
	for i := 0; i &lt; m; i++ {
		dp[i] = make([]int, m)
		for j := 0; j &lt; m; j++ {
			dp[i][j] = math.MinInt32
		}
	}
	res := dfs(nums, multipliers, 0, n-1)
	return res
}

func dfs(nums []int, multipliers []int, i, j int) int {
	n, m := len(nums), len(multipliers)
	if dp[i][j-n+m] != math.MinInt32 {
		return dp[i][j-n+m]
	}
	if j-i == n-m {
		dp[i][j-n+m] = max(dp[i][j-n+m], nums[i]*multipliers[m-1])
		dp[i][j-n+m] = max(dp[i][j-n+m], nums[j]*multipliers[m-1])
		return dp[i][j-n+m]
	}
	k := i + n - 1 - j
	left := dfs(nums, multipliers, i+1, j) + nums[i]*multipliers[k]
	right := dfs(nums, multipliers, i, j-1) + nums[j]*multipliers[k]
	dp[i][j-n+m] = max(left, right)
	return dp[i][j-n+m]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id46">
<h2>1774.最接近目标价格的甜点成本(2)<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。
而制作甜点需要遵循以下几条规则：
必须选择 一种 冰激凌基料。
可以添加 一种或多种 配料，也可以不添加任何配料。
每种类型的配料 最多两份 。
给你以下三个输入：
baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。
toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。
target ，一个整数，表示你制作甜点的目标价格。
你希望自己做的甜点总成本尽可能接近目标价格 target 。
返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。
示例 1：输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10 输出：10
解释：考虑下面的方案组合（所有下标均从 0 开始）：
- 选择 1 号基料：成本 7
- 选择 1 份 0 号配料：成本 1 x 3 = 3
- 选择 0 份 1 号配料：成本 0 x 4 = 0
总成本：7 + 3 + 0 = 10 。
示例 2：输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18 输出：17
解释：考虑下面的方案组合（所有下标均从 0 开始）：
- 选择 1 号基料：成本 3
- 选择 1 份 0 号配料：成本 1 x 4 = 4
- 选择 2 份 1 号配料：成本 2 x 5 = 10
- 选择 0 份 2 号配料：成本 0 x 100 = 0
总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。
示例 3：输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9 输出：8
解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。
示例 4：输入：baseCosts = [10], toppingCosts = [1], target = 1 输出：10
解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。
提示：n == baseCosts.length
m == toppingCosts.length
1 &lt;= n, m &lt;= 10
1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 104
1 &lt;= target &lt;= 104
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>递归</td>
<td>O(2^n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n^2*4^n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var res int

func closestCost(baseCosts []int, toppingCosts []int, target int) int {
	res = math.MaxInt32
	for i := 0; i &lt; len(baseCosts); i++ {
		dfs(toppingCosts, target, baseCosts[i], 0)
	}
	return res
}

func dfs(toppingCosts []int, target int, sum int, index int) {
	if abs(res-target) &gt; abs(sum-target) {
		res = sum
	} else if abs(res-target) == abs(sum-target) &amp;&amp; sum &lt; res {
		res = sum
	}
	if sum &gt; target {
		return
	}
	if index == len(toppingCosts) {
		return
	}
	dfs(toppingCosts, target, sum, index+1)
	dfs(toppingCosts, target, sum+toppingCosts[index], index+1)
	dfs(toppingCosts, target, sum+2*toppingCosts[index], index+1)
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}

# 2
func closestCost(baseCosts []int, toppingCosts []int, target int) int {
	res := math.MaxInt32
	n, m := len(baseCosts), len(toppingCosts)
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; (1 &lt;&lt; m); j++ { // 选择第1次
			for k := j; k &lt; (1 &lt;&lt; m); k++ { // 选择第2次
				total := baseCosts[i]
				for l := 0; l &lt; m; l++ {
					if j&amp;(1&lt;&lt;l) != 0 {
						total = total + toppingCosts[l]
					}
					if k&amp;(1&lt;&lt;l) != 0 {
						total = total + toppingCosts[l]
					}
				}
				if abs(res-target) &gt; abs(total-target) {
					res = total
				} else if abs(res-target) == abs(total-target) &amp;&amp; total &lt; res {
					res = total
				}
			}
		}
	}
	return res
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id47">
<h2>1775.通过最少操作次数使数组的和相等(2)<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。
每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。
请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。
如果无法使两个数组的和相等，请返回 -1 。
示例 1：输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 输出：3
解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。
- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。
- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。
示例 2：输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6] 输出：-1
解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。
示例 3：输入：nums1 = [6,6], nums2 = [1] 输出：3
解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。
- 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。
- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。
提示：1 &lt;= nums1.length, nums2.length &lt;= 105
1 &lt;= nums1[i], nums2[i] &lt;= 6
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>贪心</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minOperations(nums1 []int, nums2 []int) int {
	aMin, bMin := len(nums1), len(nums2)
	aMax, bMax := aMin*6, bMin*6
	if aMin &gt; bMax || aMax &lt; bMin {
		return -1
	}
	a, b := 0, 0
	arrA, arrB := [7]int{}, [7]int{}
	for i := 0; i &lt; len(nums1); i++ {
		a = a + nums1[i]
		arrA[nums1[i]]++
	}
	for i := 0; i &lt; len(nums2); i++ {
		b = b + nums2[i]
		arrB[nums2[i]]++
	}
	if a == b {
		return 0
	}
	if b &gt; a {
		arrA, arrB = arrB, arrA
		a, b = b, a
	}
	arr := make([]int, 0) // 存储
	for i := 1; i &lt; 6; i++ {
		if arrA[7-i] &gt; arrB[i] {
			arr = append(arr, arrA[7-i], arrB[i])
		} else {
			arr = append(arr, arrB[i], arrA[7-i])
		}
	}
	res := 0
	total := a - b
	for i := 0; i &lt; len(arr); i++ {
		diff := 6 - (i+2)/2
		if total-diff*arr[i] &gt; 0 {
			total = total - diff*arr[i]
			res = res + arr[i]
		} else {
			if total%diff == 0 {
				res = res + total/diff
			} else {
				res = res + total/diff + 1
			}
			return res
		}
	}
	return res
}

# 2
func minOperations(nums1 []int, nums2 []int) int {
	aMin, bMin := len(nums1), len(nums2)
	aMax, bMax := aMin*6, bMin*6
	if aMin &gt; bMax || aMax &lt; bMin {
		return -1
	}
	a, b := 0, 0
	arrA, arrB := [7]int{}, [7]int{}
	for i := 0; i &lt; len(nums1); i++ {
		a = a + nums1[i]
		arrA[nums1[i]]++
	}
	for i := 0; i &lt; len(nums2); i++ {
		b = b + nums2[i]
		arrB[nums2[i]]++
	}
	if a == b {
		return 0
	}
	if b &gt; a {
		arrA, arrB = arrB, arrA
		a, b = b, a
	}
	arr := make([]int, 6) // 存储
	for i := 1; i &lt; 6; i++ {
		arr[i-1] = arr[i-1] + arrA[7-i] + arrB[i]
	}
	res, total := 0, a-b
	for i := 0; i &lt; len(arr); i++ {
		diff := 5 - i
		if total-diff*arr[i] &gt; 0 {
			total = total - diff*arr[i]
			res = res + arr[i]
		} else {
			if total%diff == 0 {
				res = res + total/diff
			} else {
				res = res + total/diff + 1
			}
			return res
		}
	}
	return res
}
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h2>1780.判断一个数字是否可以表示成三的幂的和(2)<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。
对于一个整数 y ，如果存在整数 x 满足 y == 3x ，我们称这个整数 y 是三的幂。
示例 1：输入：n = 12 输出：true
解释：12 = 31 + 32
示例 2：输入：n = 91 输出：true
解释：91 = 30 + 32 + 34
示例 3：输入：n = 21 输出：false
提示：1 &lt;= n &lt;= 107
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func checkPowersOfThree(n int) bool {
	arr := make([]int, 0)
	arr = append(arr, 1)
	sum := 1
	for i := 0; i &lt; 15; i++ {
		sum = sum * 3
		arr = append(arr, sum)
	}
	for i := len(arr) - 1; i &gt;= 0; i-- {
		if n &gt; arr[i] {
			n = n - arr[i]
		} else if n == arr[i] {
			return true
		}
	}
	return false
}

# 2
func checkPowersOfThree(n int) bool {
	for n &gt; 0 {
		if n%3 == 2 { // 转换为3进制，n*3^x，其中n为0或者1，不会为2
			return false
		}
		n = n / 3
	}
	return true
}
</pre></div>
</div>
</div>
<div class="section" id="id49">
<h2>1781.所有子字符串美丽值之和(1)<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。
比方说，&quot;abaacc&quot; 的美丽值为 3 - 1 = 2 。
给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。
示例 1：输入：s = &quot;aabcb&quot; 输出：5
解释：美丽值不为零的字符串包括 [&quot;aab&quot;,&quot;aabc&quot;,&quot;aabcb&quot;,&quot;abcb&quot;,&quot;bcb&quot;] ，每一个字符串的美丽值都为 1 。
示例 2：输入：s = &quot;aabcbaa&quot; 输出：17
提示：1 &lt;= s.length &lt;= 500
s 只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">beautySum</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">arr</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">getCount</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">getCount</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">maxValue</span><span class="p">,</span> <span class="nx">minValue</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">maxValue</span> <span class="p">{</span>
				<span class="nx">maxValue</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">minValue</span> <span class="p">{</span>
				<span class="nx">minValue</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">maxValue</span> <span class="o">-</span> <span class="nx">minValue</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id50">
<h2>1785.构成特定和需要添加的最少元素(2)<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：
abs(nums[i]) &lt;= limit 。
返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，
添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。
注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。
示例 1：输入：nums = [1,-1,1], limit = 3, goal = -4 输出：2
解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。
示例 2：输入：nums = [1,-10,9,1], limit = 100, goal = 0 输出：1
提示：1 &lt;= nums.length &lt;= 105
1 &lt;= limit &lt;= 106
-limit &lt;= nums[i] &lt;= limit
-109 &lt;= goal &lt;= 109
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>遍历</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func minElements(nums []int, limit int, goal int) int {
	sum := 0
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
	}
	left := abs(goal - sum)
	a := left / limit
	b := left % limit
	if b != 0 {
		a = a + 1
	}
	return a
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}

# 2
func minElements(nums []int, limit int, goal int) int {
	sum := 0
	for i := 0; i &lt; len(nums); i++ {
		sum = sum + nums[i]
	}
	res := abs(goal - sum)
	return (res - 1 + limit) / limit
}

func abs(a int) int {
	if a &lt; 0 {
		return -a
	}
	return a
}
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h2>1791.找出星型图的中心节点(2)<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。
星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。
给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。
请你找出并返回 edges 所表示星型图的中心节点。
示例 1：输入：edges = [[1,2],[2,3],[4,2]] 输出：2
解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。
示例 2：输入：edges = [[1,2],[5,1],[1,3],[1,4]] 输出：1
提示：3 &lt;= n &lt;= 105
edges.length == n - 1
edges[i].length == 2
1 &lt;= ui, vi &lt;= n
ui != vi
题目数据给出的 edges 表示一个有效的星型图
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>遍历统计</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>判断</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func findCenter(edges [][]int) int {
	m := make(map[int]int)
	for i := 0; i &lt; len(edges); i++ {
		a, b := edges[i][0], edges[i][1]
		m[a]++
		m[b]++
	}
	for k, v := range m {
		if v == len(edges) {
			return k
		}
	}
	return -1
}

# 2
func findCenter(edges [][]int) int {
	if edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] {
		return edges[0][0]
	}
	return edges[0][1]
}
</pre></div>
</div>
</div>
<div class="section" id="id52">
<h2>1792.最大平均通过率(1)<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。
给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，
表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。
给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，
他们 一定 能通过任何班级的期末考。
你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。
一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。
平均通过率 是所有班级的通过率之和除以班级数目。
请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。
与标准答案误差范围在 10-5 以内的结果都会视为正确结果。
示例 1：输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2 输出：0.78333
解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。
示例 2：输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 输出：0.53485
提示：1 &lt;= classes.length &lt;= 105
classes[i].length == 2
1 &lt;= passi &lt;= totali &lt;= 105
1 &lt;= extraStudents &lt;= 105
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>堆</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxAverageRatio</span><span class="p">(</span><span class="nx">classes</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">extraStudents</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">nodeHeap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">NodeHeap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">heap</span><span class="p">.</span><span class="nx">Init</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nodeHeap</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">classes</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">heap</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nodeHeap</span><span class="p">,</span> <span class="nx">Node</span><span class="p">{</span>
			<span class="nx">id</span><span class="p">:</span>    <span class="nx">i</span><span class="p">,</span>
			<span class="nx">ratio</span><span class="p">:</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">extraStudents</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">heap</span><span class="p">.</span><span class="nx">Pop</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nodeHeap</span><span class="p">).(</span><span class="nx">Node</span><span class="p">)</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">id</span>
		<span class="nx">classes</span><span class="p">[</span><span class="nx">id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">classes</span><span class="p">[</span><span class="nx">id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span>
		<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">id</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">id</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">heap</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nodeHeap</span><span class="p">,</span> <span class="nx">Node</span><span class="p">{</span>
			<span class="nx">id</span><span class="p">:</span>    <span class="nx">id</span><span class="p">,</span>
			<span class="nx">ratio</span><span class="p">:</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">classes</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">x</span><span class="o">/</span><span class="nx">y</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sum</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">classes</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">id</span>    <span class="kt">int</span>
	<span class="nx">ratio</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NodeHeap</span> <span class="p">[]</span><span class="nx">Node</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">NodeHeap</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 小根堆&lt;,大根堆变换方向&gt;</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">NodeHeap</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">ratio</span> <span class="p">&gt;</span> <span class="nx">h</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">ratio</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">NodeHeap</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">h</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">h</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">h</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">NodeHeap</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">h</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">,</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">Node</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">NodeHeap</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="o">*</span><span class="nx">h</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">value</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id53">
<h2>1797.设计一个验证系统(2)<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，
这个验证码在 currentTime 时刻之后 timeToLive 秒过期。
如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。
请你实现 AuthenticationManager 类：
AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。
generate(string tokenId, int currentTime) 给定 tokenId ，
在当前时间 currentTime 生成一个新的验证码。
renew(string tokenId, int currentTime) 将给定 tokenId 
且 未过期 的验证码在 currentTime 时刻更新。
如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。
countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。
如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），
过期事件 优先于 其他操作。
示例 1：输入：[&quot;AuthenticationManager&quot;, &quot;renew&quot;, &quot;generate&quot;, 
&quot;countUnexpiredTokens&quot;, &quot;generate&quot;, &quot;renew&quot;, &quot;renew&quot;, &quot;countUnexpiredTokens&quot;]
[[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]
输出：[null, null, null, 1, null, null, null, 0]
解释：AuthenticationManager authenticationManager = new AuthenticationManager(5); 
// 构造 AuthenticationManager ，设置 timeToLive = 5 秒。
authenticationManager.renew(&quot;aaa&quot;, 1); 
// 时刻 1 时，没有验证码的 tokenId 为 &quot;aaa&quot; ，没有验证码被更新。
authenticationManager.generate(&quot;aaa&quot;, 2); 
// 时刻 2 时，生成一个 tokenId 为 &quot;aaa&quot; 的新验证码。
authenticationManager.countUnexpiredTokens(6); 
// 时刻 6 时，只有 tokenId 为 &quot;aaa&quot; 的验证码未过期，所以返回 1 。
authenticationManager.generate(&quot;bbb&quot;, 7); 
// 时刻 7 时，生成一个 tokenId 为 &quot;bbb&quot; 的新验证码。
authenticationManager.renew(&quot;aaa&quot;, 8); 
// tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，
且 8 &gt;= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。
authenticationManager.renew(&quot;bbb&quot;, 10);
// tokenId 为 &quot;bbb&quot; 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。
authenticationManager.countUnexpiredTokens(15);
// tokenId 为 &quot;bbb&quot; 的验证码在时刻 15 过期，
tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。
提示：1 &lt;= timeToLive &lt;= 108
1 &lt;= currentTime &lt;= 108
1 &lt;= tokenId.length &lt;= 5
tokenId 只包含小写英文字母。
所有 generate 函数的调用都会包含独一无二的 tokenId 值。
所有函数调用中，currentTime 的值 严格递增 。
所有函数的调用次数总共不超过 2000 次。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>哈希辅助</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>type AuthenticationManager struct {
	m          map[string]int
	timeToLive int
}

func Constructor(timeToLive int) AuthenticationManager {
	return AuthenticationManager{
		m:          make(map[string]int),
		timeToLive: timeToLive,
	}
}

func (this *AuthenticationManager) Generate(tokenId string, currentTime int) {
	this.m[tokenId] = currentTime + this.timeToLive
}

func (this *AuthenticationManager) Renew(tokenId string, currentTime int) {
	if v, ok := this.m[tokenId]; ok {
		if v &lt;= currentTime {
			delete(this.m, tokenId)
		} else {
			this.m[tokenId] = currentTime + this.timeToLive
		}
	}
}

func (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {
	count := 0
	arr := make([]string, 0)
	for k, v := range this.m {
		if v &gt; currentTime {
			count++
		} else {
			arr = append(arr, k)
		}
	}
	for i := 0; i &lt; len(arr); i++ {
		delete(this.m, arr[i])
	}
	return count
}

# 2
type AuthenticationManager struct {
	m          map[string]int
	timeToLive int
}

func Constructor(timeToLive int) AuthenticationManager {
	return AuthenticationManager{
		m:          make(map[string]int),
		timeToLive: timeToLive,
	}
}

func (this *AuthenticationManager) Generate(tokenId string, currentTime int) {
	this.m[tokenId] = currentTime + this.timeToLive
}

func (this *AuthenticationManager) Renew(tokenId string, currentTime int) {
	if v, ok := this.m[tokenId]; ok {
		if v &lt;= currentTime {
			delete(this.m, tokenId)
		} else {
			this.m[tokenId] = currentTime + this.timeToLive
		}
	}
}

func (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {
	count := 0
	for _, v := range this.m {
		if v &gt; currentTime {
			count++
		}
	}
	return count
}
</pre></div>
</div>
</div>
<div class="section" id="id54">
<h2>1798.你能构造出连续值的最大数目(2)<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。
如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。
请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。
你可能有多个相同值的硬币。
示例 1：输入：coins = [1,3] 输出：2
解释：你可以得到以下这些值：
- 0：什么都不取 []
- 1：取 [1]
从 0 开始，你可以构造出 2 个连续整数。
示例 2：输入：coins = [1,1,1,4] 输出：8
解释：你可以得到以下这些值：
- 0：什么都不取 []
- 1：取 [1]
- 2：取 [1,1]
- 3：取 [1,1,1]
- 4：取 [4]
- 5：取 [4,1]
- 6：取 [4,1,1]
- 7：取 [4,1,1,1]
从 0 开始，你可以构造出 8 个连续整数。
示例 3：输入：nums = [1,4,10,3,1] 输出：20
提示：coins.length == n
1 &lt;= n &lt;= 4 * 104
1 &lt;= coins[i] &lt;= 4 * 104
</pre></div>
</div>
<div class="section" id="id55">
<h3>解题思路<a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>排序遍历</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func getMaximumConsecutive(coins []int) int {
	sort.Ints(coins)
	res := 1
	target := 1
	sum := 0
	for i := 0; i &lt; len(coins); i++ {
		sum = sum + coins[i]
		if coins[i] &lt;= target {
			target = sum + 1
			res = target
		} else {
			break
		}
	}
	return res
}

# 2
func getMaximumConsecutive(coins []int) int {
	sort.Ints(coins)
	res := 0
	for i := 0; i &lt; len(coins); i++ {
		if res &gt;= coins[i]-1 {
			res = res + coins[i]
		}else {
			break
		}
	}
	return res + 1
}
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="hard">
<h1>1701-1800-Hard<a class="headerlink" href="#hard" title="永久链接至标题">¶</a></h1>
<div class="section" id="iv-2">
<h2>1745.回文串分割IV(2)<a class="headerlink" href="#iv-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个字符串 s ，如果可以将它分割成三个 非空 回文子字符串，那么返回 true ，否则返回 false 。
当一个字符串正着读和反着读是一模一样的，就称其为 回文字符串 。
示例 1：输入：s = &quot;abcbdd&quot; 输出：true
解释：&quot;abcbdd&quot; = &quot;a&quot; + &quot;bcb&quot; + &quot;dd&quot;，三个子字符串都是回文的。
示例 2：输入：s = &quot;bcbddxy&quot; 输出：false
解释：s 没办法被分割成 3 个回文子字符串。
提示：3 &lt;= s.length &lt;= 2000
s只包含小写英文字母。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func checkPartitioning(s string) bool {
	for i := 1; i &lt; len(s)-1; i++ {
		a := s[0:i]
		if check(a) == false {
			continue
		}
		for j := len(s) - 1; j &gt; i; j-- {
			c := s[j:]
			if check(c) == false {
				continue
			}
			b := s[i:j]
			if check(b) == true {
				return true
			}
		}
	}
	return false
}

func check(s string) bool {
	left, right := 0, len(s)-1
	for left &lt; right {
		if s[left] != s[right] {
			return false
		}
		left++
		right--
	}
	return true
}

# 2
func checkPartitioning(s string) bool {
	n := len(s)
	dp := make([][]bool, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]bool, n)
	}
	for i := n - 1; i &gt;= 0; i-- {
		for j := i; j &lt; n; j++ {
			if i == j {
				dp[i][j] = true
			} else if i+1 == j &amp;&amp; s[i] == s[j] {
				dp[i][j] = true
			} else {
				if s[i] == s[j] &amp;&amp; dp[i+1][j-1] == true {
					dp[i][j] = true
				}
			}
		}
	}
	for i := 0; i &lt; n-2; i++ {
		if dp[0][i] == false {
			continue
		}
		for j := i + 1; j &lt; n-1; j++ {
			if dp[i+1][j] &amp;&amp; dp[j+1][n-1] {
				return true
			}
		}
	}
	return false
}
</pre></div>
</div>
</div>
<div class="section" id="id56">
<h2>1761.一个图中连通三元组的最小度数(1)<a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个无向图，整数 n 表示图中节点的数目，edges 数组表示图中的边，
其中 edges[i] = [ui, vi] ，表示 ui 和 vi 之间有一条无向边。
一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。
连通三元组的度数 是所有满足此条件的边的数目：一个顶点在三元组内，而另一个顶点不在三元组内。
请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 -1 。
示例 1：输入：n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] 输出：3
解释：只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。
示例 2：输入：n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] 输出：0
解释：有 3 个三元组：
1) [1,4,3]，度数为 0 。
2) [2,5,6]，度数为 2 。
3) [5,6,7]，度数为 2 。
提示：2 &lt;= n &lt;= 400
edges[i].length == 2
1 &lt;= edges.length &lt;= n * (n-1) / 2
1 &lt;= ui, vi &lt;= n
ui != vi
图中没有重复的边。
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>暴力法</td>
<td>O(n^3)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
<div class="section" id="id57">
<h2>1771.由子序列构造的最长回文串的长度(3)<a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>给你两个字符串 word1 和 word2 ，请你按下述方法构造一个字符串：
从 word1 中选出某个 非空 子序列 subsequence1 。
从 word2 中选出某个 非空 子序列 subsequence2 。
连接两个子序列 subsequence1 + subsequence2 ，得到字符串。
返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。
字符串 s 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。
回文串 是正着读和反着读结果一致的字符串。
示例 1：输入：word1 = &quot;cacb&quot;, word2 = &quot;cbba&quot; 输出：5
解释：从 word1 中选出 &quot;ab&quot; ，从 word2 中选出 &quot;cba&quot; ，得到回文串 &quot;abcba&quot; 。
示例 2：输入：word1 = &quot;ab&quot;, word2 = &quot;ab&quot; 输出：3
解释：从 word1 中选出 &quot;ab&quot; ，从 word2 中选出 &quot;a&quot; ，得到回文串 &quot;aba&quot; 。
示例 3：输入：word1 = &quot;aa&quot;, word2 = &quot;bb&quot; 输出：0
解释：无法按题面所述方法构造回文串，所以返回 0 。
提示：1 &lt;= word1.length, word2.length &lt;= 1000
word1 和 word2 由小写英文字母组成
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>02</td>
<td>动态规划</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>03</td>
<td>递归</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func longestPalindrome(word1 string, word2 string) int {
	s := word1 + word2
	a := len(word1)
	n := len(s)
	dp := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
		dp[i][i] = 1
	}
	res := 0
	for i := n - 2; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			if s[i] == s[j] {
				dp[i][j] = dp[i+1][j-1] + 2 // 内层+2
				if i &lt; a &amp;&amp; j &gt;= a {
					res = max(res, dp[i][j])
				}
			} else {
				dp[i][j] = max(dp[i+1][j], dp[i][j-1])
			}
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func longestPalindrome(word1 string, word2 string) int {
	s := word1 + word2
	a := len(word1)
	n := len(s)
	dp := make([]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = 1
	}
	res := 0
	for i := n - 1; i &gt;= 0; i-- {
		prev := 0
		for j := i + 1; j &lt; n; j++ {
			temp := dp[j]
			if s[i] == s[j] {
				dp[j] = prev + 2 // 内层+2
				if i &lt; a &amp;&amp; j &gt;= a {
					res = max(res, dp[j])
				}
			} else {
				dp[j] = max(dp[j], dp[j-1])
			}
			prev = temp
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 3
var dp [][]int
var a int
var res int

func longestPalindrome(word1 string, word2 string) int {
	s := word1 + word2
	a = len(word1)
	res = 0
	n := len(s)
	dp = make([][]int, n)
	for i := 0; i &lt; n; i++ {
		dp[i] = make([]int, n)
	}
	dfs(s, 0, n-1)
	return res
}

func dfs(s string, i, j int) int {
	if i == j {
		return 1
	}
	if i &gt; j {
		return 0
	}
	if dp[i][j] &gt; 0 {
		return dp[i][j]
	}
	if s[i] == s[j] {
		dp[i][j] = dfs(s, i+1, j-1) + 2
		if i &lt; a &amp;&amp; j &gt;= a {
			res = max(res, dp[i][j])
		}
	} else {
		dp[i][j] = max(dfs(s, i+1, j), dfs(s, i, j-1))
	}
	return dp[i][j]
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="id58">
<h2>1793.好子数组的最大分数(2)<a class="headerlink" href="#id58" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>题目</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。
一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。
一个 好 子数组的两个端点下标需要满足 i &lt;= k &lt;= j 。
请你返回 好 子数组的最大可能 分数 。
示例 1：输入：nums = [1,4,3,7,4,5], k = 3 输出：15
解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。
示例 2：输入：nums = [5,5,4,5,4,1,1,1], k = 0 输出：20
解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。
提示：1 &lt;= nums.length &lt;= 105
1 &lt;= nums[i] &lt;= 2 * 104
0 &lt;= k &lt; nums.length
</pre></div>
</div>
<ul class="simple">
<li>解题思路</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>02</td>
<td>单调栈</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>func maximumScore(nums []int, k int) int {
	left, right := k, k
	res := 0
	for minValue := nums[k]; minValue &gt;= 1; minValue-- {
		for left &gt;= 0 &amp;&amp; nums[left] &gt;= minValue {
			left--
		}
		for right &lt; len(nums) &amp;&amp; nums[right] &gt;= minValue {
			right++
		}
		left++  // left注意+1
		right-- // right注意-1
		res = max(res, minValue*(right-left+1))
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}

# 2
func maximumScore(nums []int, k int) int {
	res := 0
	n := len(nums)
	left := make([]int, n)
	right := make([]int, n)
	stack := make([]int, 0)
	for i := 0; i &lt; n; i++ {
		for len(stack) &gt; 0 &amp;&amp; nums[stack[len(stack)-1]] &gt;= nums[i] {
			stack = stack[:len(stack)-1]
		}
		if len(stack) == 0 {
			left[i] = -1
		} else {
			left[i] = stack[len(stack)-1]
		}
		stack = append(stack, i)
	}
	stack = make([]int, 0)
	for i := n - 1; i &gt;= 0; i-- {
		for len(stack) &gt; 0 &amp;&amp; nums[stack[len(stack)-1]] &gt;= nums[i] {
			stack = stack[:len(stack)-1]
		}
		if len(stack) == 0 {
			right[i] = n
		} else {
			right[i] = stack[len(stack)-1]
		}
		stack = append(stack, i)
	}
	for i := 0; i &lt; n; i++ {
		if left[i] &lt; k &amp;&amp; right[i] &gt; k {
			res = max(res, nums[i]*(right[i]-left[i]-1))
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</pre></div>
</div>
</div>
<div class="section" id="n">
<h2>1799.N次操作后的最大分数和<a class="headerlink" href="#n" title="永久链接至标题">¶</a></h2>
<div class="section" id="id59">
<h3>题目<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。
在第 i 次操作时（操作编号从 1 开始），你需要：
选择两个元素 x 和 y 。
获得分数 i * gcd(x, y) 。
将 x 和 y 从 nums 中删除。
请你返回 n 次操作后你能获得的分数和最大为多少。
函数 gcd(x, y) 是 x 和 y 的最大公约数。
示例 1：输入：nums = [1,2] 输出：1
解释：最优操作是：(1 * gcd(1, 2)) = 1
示例 2：输入：nums = [3,4,6,8] 输出：11
解释：最优操作是：(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
示例 3：输入：nums = [1,2,3,4,5,6] 输出：14
解释：最优操作是：(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
提示：1 &lt;= n &lt;= 7
nums.length == 2 * n
1 &lt;= nums[i] &lt;= 106
</pre></div>
</div>
</div>
<div class="section" id="id60">
<h3>解题思路<a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>No.</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>双指针</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table><div class="highlight-go notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="1801-1900.html" class="btn btn-neutral float-right" title="1801-1900-Easy" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="1601-1700.html" class="btn btn-neutral float-left" title="1601-1700-Easy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, willshang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>