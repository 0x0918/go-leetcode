# 0801-0900-Easy

## 804.唯一摩尔斯密码词(1)

- 题目

```
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 
比如: "a" 对应 ".-", "b" 对应 "-...", "c" 对应 "-.-.", 等等。
为了方便，所有26个英文字母对应摩尔斯密码表如下：
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..",
"--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。
例如，"cab" 可以写成 "-.-..--..."，(即 "-.-." + "-..." + ".-"字符串的结合)。
我们将这样一个连接过程称作单词翻译。
返回我们可以获得所有词不同单词翻译的数量。
例如:
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
注意:
    单词列表words 的长度不会超过 100。
    每个单词 words[i]的长度范围为 [1, 12]。
    每个单词 words[i]只包含小写字母。
```

- 解题思路

| No.  | 思路     | 时间n复杂度 | 空间复杂度 |
| ---- | -------- | ----------- | ---------- |
| 01   | 哈希辅助 | O(n)        | O(n)       |

```go
var table = []string{
	".-", "-...", "-.-.", "-..", ".",
	"..-.", "--.", "....", "..", ".---",
	"-.-", ".-..", "--", "-.", "---",
	".--.", "--.-", ".-.", "...", "-",
	"..-", "...-", ".--", "-..-", "-.--",
	"--..",
}

func uniqueMorseRepresentations(words []string) int {
	res := make(map[string]bool)
	for _, w := range words {
		b := ""
		for i := 0; i < len(w); i++ {
			b = b + table[w[i]-'a']
		}
		res[b] = true
	}
	return len(res)
}
```

## 806.写字符串需要的行数(1)

- 题目

```
我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，
如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。
我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， 
widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。
现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？
将你的答案作为长度为2的整数列表返回。

示例 1:输入: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
输出: [3, 60]
解释: 
所有的字符拥有相同的占用单位10。所以书写所有的26个字母，
我们需要2个整行和占用60个单位的一行。

示例 2:输入: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
输出: [2, 4]
解释: 
除去字母'a'所有的字符都是相同的单位10，并且字符串 "bbbcccdddaa" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。
注:
    字符串 S 的长度在 [1, 1000] 的范围。
    S 只包含小写字母。
    widths 是长度为 26的数组。
    widths[i] 值的范围在 [2, 10]。
```

- 解题思路

| No.  | 思路      | 时间n复杂度 | 空间复杂度 |
| ---- | --------- | ----------- | ---------- |
| 01   | 遍历-模拟 | O(n)        | O(1)       |

```go
func numberOfLines(widths []int, S string) []int {
	res := []int{0, 0}
	if len(S) == 0 {
		return res
	}
	res[0] = 1

	for i := 0; i < len(S); i++ {
		if res[1]+widths[S[i]-'a'] > 100 {
			res[0]++
			res[1] = widths[S[i]-'a']
		} else {
			res[1] = res[1] + widths[S[i]-'a']
		}
	}
	return res
}
```

## 811.子域名访问计数

### 题目

### 解题思路

## 812.最大三角形面积(2)

- 题目

```
给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。
示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] 输出: 2
解释: 这五个点如下图所示。组成的橙色三角形是最大的，面积为2。
注意:
    3 <= points.length <= 50.
    不存在重复的点。
     -50 <= points[i][j] <= 50.
    结果误差值在 10^-6 以内都认为是正确答案。
```

- 解题思路

| No.  | 思路            | 时间n复杂度 | 空间复杂度 |
| ---- | --------------- | ----------- | ---------- |
| 01   | 暴力法-鞋带公式 | O(n^3)      | O(1)       |
| 02   | 暴力法-海伦公式 | O(n^3)      | O(1)       |

```go
func largestTriangleArea(points [][]int) float64 {
	maxArea := 0.0
	n := len(points)
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			for k := j + 1; k < n; k++ {
				if area(points[i], points[j], points[k]) > maxArea {
					maxArea = area(points[i], points[j], points[k])
				}
			}
		}
	}
	return maxArea
}

// 三角形面积=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2
func area(p1, p2, p3 []int) float64 {
	return abs(
		p1[0]*p2[1]+p2[0]*p3[1]+p3[0]*p1[1]-
			p1[0]*p3[1]-p2[0]*p1[1]-p3[0]*p2[1]) / 2
}

func abs(num int) float64 {
	if num < 0 {
		num = -num
	}
	return float64(num)
}

#
func largestTriangleArea(points [][]int) float64 {
	maxArea := 0.0
	n := len(points)
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			for k := j + 1; k < n; k++ {
				// p = (a+b+c)/2
				// s = p*(p-a)*(p-b)*(p-c)
				a := length(points[i], points[j])
				b := length(points[i], points[k])
				c := length(points[j], points[k])
				p := (a + b + c) / 2
				area := math.Sqrt(p * (p - a) * (p - b) * (p - c))
				if area > maxArea {
					maxArea = area
				}
			}
		}
	}
	return maxArea
}

// 求两点距离
func length(p1, p2 []int) float64 {
	l := (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1])
	return math.Sqrt(float64(l))
}
```

## 819.最常见的单词