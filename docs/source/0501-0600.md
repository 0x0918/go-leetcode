# 0501-0600-Easy

## 501.二叉搜索树中的众数(2)

- 题目

```
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：
    结点左子树中所含结点的值小于等于当前结点的值
    结点右子树中所含结点的值大于等于当前结点的值
    左子树和右子树都是二叉搜索树
例如：
给定 BST [1,null,2,2],
   1
    \
     2
    /
   2
返回[2].
提示：如果众数超过1个，不需考虑输出顺序
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 递归+哈希辅助 | O(n)       | O(n)       |
| 02   | 递归+中序遍历 | O(n)       | O(log(n))  |

```go
func findMode(root *TreeNode) []int {
	m := map[int]int{}
	dfs(root, m)
	max := -1
	res := make([]int, 0)
	for i, v := range m {
		if max <= v {
			if max < v {
				max = v
				res = res[0:0]
			}
			res = append(res, i)
		}
	}
	return res
}

func dfs(root *TreeNode, rec map[int]int) {
	if root == nil {
		return
	}
	rec[root.Val]++
	dfs(root.Left, rec)
	dfs(root.Right, rec)
}

#
var max int
var res []int
var cur int
var count int

func findMode(root *TreeNode) []int {
	res = make([]int, 0)
	max, cur, count = 0, 0, 0
	dfs(root)
	return res
}

// 中序遍历保证利用二叉搜索树的性质，得到的结果是升序的
func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)
	if root.Val != cur {
		count = 0
	}
	count++
	if max < count {
		max = count
		res = []int{root.Val}
	} else if max == count {
		res = append(res, root.Val)
	}
	cur = root.Val
	dfs(root.Right)
}
```

## 504.七进制数(3)

- 题目

```
给定一个整数，将其转化为7进制，并以字符串形式输出。
示例 1:输入: 100 输出: "202"
示例 2: 输入: -7 输出: "-10"
注意: 输入范围是 [-1e7, 1e7] 。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(log(n))  | O(1)       |
| 02   | 内置函数 | O(log(n))  | O(1)       |
| 03   | 递归     | O(log(n))  | O(log(n))  |

```go
func convertToBase7(num int) string {
	if num == 0 {
		return "0"
	}

	minus := ""
	if num < 0 {
		minus = "-"
		num = -1 * num
	}

	s := ""
	for num > 0 {
		s = fmt.Sprintf("%d", num%7) + s
		num = num / 7
	}
	return minus + s
}

#
func convertToBase7(num int) string {
	return strconv.FormatInt(int64(num), 7)
}

#
func convertToBase7(num int) string {
	if num < 0 {
		return "-" + convertToBase7(-1*num)
	}
	if num < 7 {
		return strconv.Itoa(num)
	}
	return convertToBase7(num/7) + strconv.Itoa(num%7)
}
```

## 506.相对名次(1)

- 题目

```
给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。
前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”
（"Gold Medal", "Silver Medal", "Bronze Medal"）。
(注：分数越高的选手，排名越靠前。)

示例 1:
输入: [5, 4, 3, 2, 1]
输出: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
解释: 前三名运动员的成绩为前三高的，
因此将会分别被授予 “金牌”，“银牌”和“铜牌” ("Gold Medal", "Silver Medal" and "Bronze Medal").
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。
提示:
    N 是一个正整数并且不会超过 10000。
    所有运动员的成绩都不相同。
```

- 解题思路

| No.  | 思路      | 时间复杂度 | 空间复杂度 |
| ---- | --------- | ---------- | ---------- |
| 01   | 排序+遍历 | O(nlog(n)) | O(n)       |

```go
func findRelativeRanks(nums []int) []string {
	temp := make([]int, len(nums))
	copy(temp, nums)
	sort.Ints(temp)
	m := make(map[int]string)
	for i := 0; i < len(temp); i++ {
		if i == len(temp)-1 {
			m[temp[i]] = "Gold Medal"
		} else if i == len(temp)-2 {
			m[temp[i]] = "Silver Medal"
		} else if i == len(temp)-3 {
			m[temp[i]] = "Bronze Medal"
		} else {
			m[temp[i]] = strconv.Itoa(len(temp) - i)
		}
	}
	res := make([]string,0)
	for i := 0; i < len(nums); i++ {
		res = append(res, m[nums[i]])
	}
	return res
}
```

## 507.完美数(1)

- 题目

```
对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。
给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False
示例：输入: 28 输出: True 解释: 28 = 1 + 2 + 4 + 7 + 14
提示：输入的数字 n 不会超过 100,000,000. (1e8)
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n^1/2)   | O(1)       |

```go
func checkPerfectNumber(num int) bool {
	if num == 1 {
		return false
	}
	sum := 1
	for i := 2; i <= num/i; i++ {
		if num%i == 0 {
			sum = sum + i + (num / i)
		}
	}
	return sum == num
}
```

## 509.斐波那契数(4)

- 题目

```
斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。
示例 1：输入：2输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：输入：3输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：输入：4输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
提示：
    0 ≤ N ≤ 30
```

- 解题思路

| No.  | 思路      | 时间复杂度 | 空间复杂度 |
| ---- | --------- | ---------- | ---------- |
| 01   | 遍历      | O(n)       | O(1)       |
| 02   | 遍历+数组 | O(n)       | O(n)       |
| 03   | 递归      | O(2^n)     | O(n)       |
| 04   | 公式法    | O(1)       | O(1)       |

```go
func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	n1, n2 := 0, 1
	for i := 2; i <= N; i++ {
		n1, n2 = n2, n1+n2
	}
	return n2
}

#
func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	res := make([]int, N+1)
	res[0] = 0
	res[1] = 1
	for i := 2; i <= N; i++ {
		res[i] = res[i-1] + res[i-2]
	}
	return res[N]
}

#
func fib(N int) int {
	if N == 0 {
		return 0
	}
	if N == 1 {
		return 1
	}
	return fib(N-1) + fib(N-2)
}

#
func fib(N int) int {
	temp1 := (1 + math.Sqrt(5)) / 2
	temp2 := (1 - math.Sqrt(5)) / 2
	fn := math.Round((math.Pow(temp1, float64(N))- math.Pow(temp2, float64(N)))/ math.Sqrt(5))
	return int(fn)
}
```

## 520.检测大写字母(2)

- 题目

```
给定一个单词，你需要判断单词的大写使用是否正确。
我们定义，在以下情况时，单词的大写用法是正确的：
    全部字母都是大写，比如"USA"。
    单词中所有字母都不是大写，比如"leetcode"。
    如果单词不只含有一个字母，只有首字母大写， 比如 "Google"。
否则，我们定义这个单词没有正确使用大写字母。
示例 1:输入: "USA"输出: True
示例 2:输入: "FlaG"输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 正则 | O(n)       | O(1)       |

```go
func detectCapitalUse(word string) bool {
	if word == "" {
		return false
	}
	count := 0
	for i := 0; i < len(word); i++ {
		if word[i] >= 'A' && word[i] <= 'Z' {
			count++
		}
	}

	if count == 0 || count == len(word) ||
		(count == 1 && word[0] >= 'A' && word[0] <= 'Z') {
		return true
	}
	return false
}

#
func detectCapitalUse(word string) bool {
	pattern := "(^[a-z]+)$|(^[A-Z]+)$|(^[A-Z]{1}[a-z]*)$"
	isMatch, _ := regexp.MatchString(pattern, word)
	return isMatch
}
```

## 521.最长特殊序列Ⅰ(1)

- 题目

```
给你两个字符串，请你从这两个字符串中找出最长的特殊序列。
「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

示例 1：输入: "aba", "cdc" 输出: 3 
解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。
示例 2：输入：a = "aaa", b = "bbb"输出：3
示例 3：输入：a = "aaa", b = "aaa"输出：-1
提示：
    两个字符串长度均处于区间 [1 - 100] 。
    字符串中的字符仅含有 'a'~'z' 。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 比较 | O(1)       | O(1)       |

```go
func findLUSlength(a string, b string) int {
	if a == b {
		return -1
	}
	return max(len(a), len(b))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 530.二叉搜索树的最小绝对差(2)

### 题目

```
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
示例：
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。

提示：
    树中至少有 2 个节点。
    本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同
```

### 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 递归+中序遍历 | O(n)       | O(log(n))  |
| 02   | 递归+遍历     | O(n)       | O(n)       |

```go
var minDiff, previous int
func getMinimumDifference(root *TreeNode) int {
	minDiff, previous  = math.MaxInt32, math.MaxInt32
	dfs(root)
	return minDiff
}

func dfs(root *TreeNode) {
	if root == nil {
		return
	}
	dfs(root.Left)

	newDiff := diff(previous, root.Val)
	if minDiff > newDiff {
		minDiff = newDiff
	}
	previous = root.Val
	dfs(root.Right)
}

func diff(a, b int) int {
	if a > b {
		return a - b
	}
	return b - a
}

#
func getMinimumDifference(root *TreeNode) int {
	arr := make([]int, 0)
	dfs(root, &arr)
	minDiff := arr[1] - arr[0]
	for i := 2; i < len(arr); i++ {
		if minDiff > arr[i]-arr[i-1] {
			minDiff = arr[i] - arr[i-1]
		}
	}
	return minDiff
}

func dfs(root *TreeNode, arr *[]int) {
	if root == nil {
		return
	}
	dfs(root.Left, arr)
	*arr = append(*arr, root.Val)
	dfs(root.Right, arr)
}
```



