# 0901-1000-Easy

* [0901\-1000\-Easy](#0901-1000-easy)
  * [905\.按奇偶排序数组(4)](#905%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%844)
  * [908\.最小差值I(2)](#908%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BCi2)
  * [914\.卡牌分组](#914%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84)
  * [917\.仅仅反转字母(4)](#917%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D4)
  * [922\.按奇偶排序数组 II(3)](#922%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii3)
  * [925\.长按键入(2)](#925%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A52)
  * [929\.独特的电子邮件地址(2)](#929%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%802)
  * [933\.最近的请求次数(2)](#933%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B02)
  * [937\.重新排列日志文件(2)](#937%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B62)
  * [938\.二叉搜索树的范围和(2)](#938%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C2)
  * [941\.有效的山脉数组(2)](#941%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%842)
  * [942\.增减字符串匹配(1)](#942%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D1)
  * [944\.删列造序(1)](#944%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F1)
  * [949\.给定数字能组成的最大时间(2)](#949%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E8%83%BD%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B42)
  * [953\.验证外星语词典(2)](#953%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B82)
  * [961\.重复 N 次的元素(5)](#961%E9%87%8D%E5%A4%8D-n-%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A05)
  * [965\.单值二叉树(4)](#965%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%914)
  * [970\.强整数(2)](#970%E5%BC%BA%E6%95%B4%E6%95%B02)
  * [976\.三角形的最大周长(2)](#976%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF2)
  * [977\.有序数组的平方(3)](#977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B93)
  * [985\.查询后的偶数和(1)](#985%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E5%81%B6%E6%95%B0%E5%92%8C1)
  * [989\.数组形式的整数加法(4)](#989%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%954)
  * [993\.二叉树的堂兄弟节点(2)](#993%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B92)
  * [997\.找到小镇的法官(2)](#997%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%982)
  * [999\.可以被一步捕获的棋子数(2)](#999%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%B8%80%E6%AD%A5%E6%8D%95%E8%8E%B7%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B02)
* [0901\-1000\-Medium](#0901-1000-medium)
  * [901\.股票价格跨度(1)](#901%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A61)
  * [912\.排序数组(7)](#912%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%847)
  * [921\.使括号有效的最少添加(3)](#921%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A03)
  * [945\.使数组唯一的最小增量(3)](#945%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F3)
  * [946\.验证栈序列(2)](#946%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%972)
  * [974\.和可被K整除的子数组(2)](#974%E5%92%8C%E5%8F%AF%E8%A2%ABk%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%842)
  * [983\.最低票价(3)](#983%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B73)
  * [994\.腐烂的橘子(2)](#994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%902)
* [0901\-1000\-Hard](#0901-1000-hard)
  * [956\.最高的广告牌(5)](#956%E6%9C%80%E9%AB%98%E7%9A%84%E5%B9%BF%E5%91%8A%E7%89%8C5)



## 905.按奇偶排序数组(4)

- 题目

```
给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：输入：[3,1,2,4] 输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
提示：
    1 <= A.length <= 5000
    0 <= A[i] <= 5000
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 双指针 | O(n)       | O(1)       |
| 02   | 双指针 | O(n)       | O(1)       |
| 03   | 遍历   | O(n)       | O(n)       |
| 04   | 遍历   | O(n)       | O(1)       |

```go
func sortArrayByParity(A []int) []int {
	i := 0
	j := len(A)-1
	for i < j{
		if A[i] % 2== 0{
			i++
		}else if A[j] % 2 == 1{
			j--
		}else {
			A[i], A[j] = A[j], A[i]
		}
	}
	return A
}

#
func sortArrayByParity(A []int) []int {
	i := 0
	j := len(A) - 1
	for i < j {
		for i < j && A[i]%2 == 0 {
			i++
		}
		for i < j && A[j]%2 == 1 {
			j--
		}
		A[i], A[j] = A[j], A[i]
	}
	return A
}

#
func sortArrayByParity(A []int) []int {
	res := make([]int, 0)
	for i := 0; i < len(A); i++ {
		if A[i]%2 == 0 {
			res = append(res, A[i])
		}
	}
	for i := 0; i < len(A); i++ {
		if A[i]%2 == 1 {
			res = append(res, A[i])
		}
	}
	return res
}

#
func sortArrayByParity(A []int) []int {
	count := 0
	for i := 0; i < len(A); i++{
		if A[i] % 2 == 0{
			A[count],A[i] = A[i], A[count]
			count++
		}
	}
	return A
}
```

## 908.最小差值I(2)

- 题目

```
给你一个整数数组 A，对于每个整数 A[i]，我们可以选择处于区间 [-K, K] 中的任意数 x ，
将 x 与 A[i] 相加，结果存入 A[i] 。
在此过程之后，我们得到一些数组 B。
返回 B 的最大值和 B 的最小值之间可能存在的最小差值。
示例 1：输入：A = [1], K = 0 输出：0
解释：B = [1]
示例 2：输入：A = [0,10], K = 2 输出：6
解释：B = [2,8]
示例 3：输入：A = [1,3,6], K = 3 输出：0
解释：B = [3,3,3] 或 B = [4,4,4]
提示：
    1 <= A.length <= 10000
    0 <= A[i] <= 10000
    0 <= K <= 10000
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func smallestRangeI(A []int, K int) int {
	if len(A) == 1 {
		return 0
	}
	sort.Ints(A)
	if A[len(A)-1]-A[0] > 2*K {
		return A[len(A)-1] - A[0] - 2*K
	}
	return 0
}

#
func smallestRangeI(A []int, K int) int {
	if len(A) == 1 {
		return 0
	}
	min := A[0]
	max := A[0]
	for i := 0; i < len(A); i++ {
		if A[i] > max {
			max = A[i]
		}
		if A[i] < min {
			min = A[i]
		}
	}
	if max-min > 2*K {
		return max - min - 2*K
	}
	return 0
}
```

## 914.卡牌分组

- 题目

```
给定一副牌，每张牌上都写着一个整数。
此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
    每组都有 X 张牌。
    组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

示例 1：输入：[1,2,3,4,4,3,2,1] 输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 
示例 2：输入：[1,1,1,2,2,2,3,3] 输出：false
解释：没有满足要求的分组。
示例 3：输入：[1] 输出：false
解释：没有满足要求的分组。
示例 4：输入：[1,1] 输出：true
解释：可行的分组是 [1,1]
示例 5：输入：[1,1,2,2,2,2] 输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]
提示：
    1 <= deck.length <= 10000
    0 <= deck[i] < 10000
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 哈希辅助+求公约数 | O(nlog(n)) | O(n)       |
| 02   | 暴力法            | O(n^2)     | O(n)       |

```go
func hasGroupsSizeX(deck []int) bool {
	if len(deck) < 2 {
		return false
	}
	m := make(map[int]int)
	for i := 0; i < len(deck); i++ {
		m[deck[i]]++
	}
	v := m[deck[0]]
	for _, value := range m {
		v = gcd(v, value)
		if v < 2 {
			return false
		}
	}
	return true
}

func gcd(x, y int) int {
	a := x % y
	if a > 0 {
		return gcd(y, a)
	}
	return y
}

#
func hasGroupsSizeX(deck []int) bool {
	if len(deck) < 2 {
		return false
	}
	m := make(map[int]int)
	for i := 0; i < len(deck); i++ {
		m[deck[i]]++
	}
	for i := 2; i <= len(deck); i++ {
		flag := true
		if len(deck)%i == 0 {
			for _, v := range m {
				if v%i != 0 {
					flag = false
					break
				}
			}
			if flag == true {
				return true
			}
		}
	}
	return false
}
```

## 917.仅仅反转字母(4)

- 题目

```
给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。
示例 1：输入："ab-cd" 输出："dc-ba"
示例 2：输入："a-bC-dEf-ghIj" 输出："j-Ih-gfE-dCba"
示例 3：输入："Test1ng-Leet=code-Q!" 输出："Qedo1ct-eeLg=ntse-T!"
提示：
    S.length <= 100
    33 <= S[i].ASCIIcode <= 122 
    S 中不包含 \ or "
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 双指针          | O(n)       | O(n)       |
| 02   | 双指针          | O(n)       | O(n)       |
| 03   | 双指针-内置函数 | O(n)       | O(n)       |
| 04   | 栈辅助          | O(n)       | O(n)       |

```go
func reverseOnlyLetters(S string) string {
	i := 0
	j := len(S) - 1
	arr := []byte(S)
	for i < j {
		for i < j && !isLetter(arr[i]) {
			i++
		}
		for i < j && !isLetter(arr[j]) {
			j--
		}
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
	return string(arr)
}

func isLetter(b byte) bool {
	if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') {
		return true
	}
	return false
}

#
func reverseOnlyLetters(S string) string {
	i := 0
	j := len(S) - 1
	arr := []byte(S)
	for i < j {
		if !isLetter(arr[i]) {
			i++
		} else if !isLetter(arr[j]) {
			j--
		} else {
			arr[i], arr[j] = arr[j], arr[i]
			i++
			j--
		}
	}
	return string(arr)
}

func isLetter(b byte) bool {
	if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') {
		return true
	}
	return false
}

#
func reverseOnlyLetters(S string) string {
	i := 0
	j := len(S) - 1
	arr := []rune(S)
	for i < j {
		if !unicode.IsLetter(arr[i]) {
			i++
		} else if !unicode.IsLetter(arr[j]) {
			j--
		} else {
			arr[i], arr[j] = arr[j], arr[i]
			i++
			j--
		}
	}
	return string(arr)
}

#
func reverseOnlyLetters(S string) string {
	stack := make([]rune, 0)
	res := make([]rune, 0)
	arr := []rune(S)
	for i := 0; i < len(arr); i++ {
		if unicode.IsLetter(arr[i]) {
			stack = append(stack, arr[i])
		}
	}
	for i := 0; i < len(arr); i++ {
		if unicode.IsLetter(arr[i]) {
			res = append(res, stack[len(stack)-1])
			stack = stack[:len(stack)-1]
		} else {
			res = append(res, arr[i])
		}
	}
	return string(res)
}
```

## 922.按奇偶排序数组 II(3)

- 题目

```
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
你可以返回任何满足上述条件的数组作为答案。
示例：输入：[4,2,5,7]输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 
提示：
    2 <= A.length <= 20000
    A.length % 2 == 0
    0 <= A[i] <= 1000
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 双指针   | O(n)       | O(1)       |
| 02   | 双指针   | O(n)       | O(1)       |
| 03   | 数组辅助 | O(n)       | O(n)       |

```go
func sortArrayByParityII(A []int) []int {
	i := 0
	j := 1
	for i < len(A) || j < len(A) {
		for i < len(A) && A[i]%2 == 0 {
			i = i + 2
		}
		for j < len(A) && A[j]%2 == 1 {
			j = j + 2
		}
		if i >= len(A) || j >= len(A) {
			break
		}
		A[i], A[j] = A[j], A[i]
	}
	return A
}

#
func sortArrayByParityII(A []int) []int {
	i := 0
	j := 1
	for i < len(A) {
		for A[i]%2 != 0 {
			if A[j]%2 == 0 {
				A[i], A[j] = A[j], A[i]
			} else {
				j = j + 2
			}
		}
		i = i + 2
	}
	return A
}

#
func sortArrayByParityII(A []int) []int {
	i := 0
	j := 1
	res := make([]int, len(A))
	for k := 0; k < len(A); k++ {
		if A[k]%2 == 0 {
			res[i] = A[k]
			i = i + 2
		} else {
			res[j] = A[k]
			j = j + 2
		}
	}
	return res
}
```

## 925.长按键入(2)

- 题目

```
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，
而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。
如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

示例 1： 输入：name = "alex", typed = "aaleex" 输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2： 输入：name = "saeed", typed = "ssaaedd" 输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3： 输入：name = "leelee", typed = "lleeelee" 输出：true
示例 4： 输入：name = "laiden", typed = "laiden" 输出：true
解释：长按名字中的字符并不是必要的。
提示：
    name.length <= 1000
    typed.length <= 1000
    name 和 typed 的字符都是小写字母。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 双指针       | O(n)       | O(1)       |
| 02   | 遍历统计比较 | O(n)       | O(1)       |

```go
func isLongPressedName(name string, typed string) bool {
	i := 0
	j := 0
	for j < len(typed) {
		if i == len(name) {
			i = len(name) - 1
		}
		if name[i] == typed[j] {
			// 正确的话，保证i == len(name) && j == len(typed)
			i++
			j++
		} else {
			if i == 0 {
				return false
			}
			if name[i-1] != typed[j] {
				return false
			} else {
				j++
			}
		}
	}
	return i == len(name) && j == len(typed)
}

#
func isLongPressedName(name string, typed string) bool {
	i := 1
	j := 1
	countI := 0
	countJ := 0
	for i < len(name) || j < len(typed) {
		for i < len(name) && name[i] == name[i-1] {
			i++
			countI++
		}
		for j < len(typed) && typed[j] == typed[j-1] {
			j++
			countJ++
		}
		if name[i-1] != typed[j-1] || countJ < countI {
			return false
		}
		i++
		j++
		countI = 0
		countJ = 0
	}
	return name[len(name)-1] == typed[len(typed)-1]
}
```

## 929.独特的电子邮件地址(2)

- 题目

```
每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。
例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。
除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。
如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），
则发往那里的邮件将会转发到本地名称中没有点的同一地址。
例如，"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 
（请注意，此规则不适用于域名。）
如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。
这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 
（同样，此规则不适用于域名。）
可以同时使用这两个规则。
给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？
示例：
输入：["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com",
"testemail+david@lee.tcode.com"]
输出：2
解释：实际收到邮件的是 "testemail@leetcode.com" 和 "testemail@lee.tcode.com"。
提示：
    1 <= emails[i].length <= 100
    1 <= emails.length <= 100
    每封 emails[i] 都包含有且仅有一个 '@' 字符。
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 哈希辅助+内置函数 | O(n^2)     | O(n)       |
| 02   | 哈希辅助          | O(n^2)     | O(n)       |

```go
func numUniqueEmails(emails []string) int {
	m := make(map[string]bool)
	for i := 0; i < len(emails); i++ {
		addr := ""
		arr := strings.Split(emails[i], "@")
		for j := 0; j < len(arr[0]); j++ {
			if arr[0][j] == '+' {
				break
			} else if arr[0][j] == '.' {
				continue
			} else {
				addr = addr + string(arr[0][j])
			}
		}
		m[addr+"@"+arr[1]] = true
	}
	return len(m)
}

#
func numUniqueEmails(emails []string) int {
	m := make(map[string]bool)
	for i := 0; i < len(emails); i++ {
		addr := ""
		isBreak := false
		for j := 0; j < len(emails[i]); j++ {
			if emails[i][j] == '+' {
				isBreak = true
			} else if emails[i][j] == '.' {
				continue
			} else if emails[i][j] == '@' {
				addr = addr + emails[i][j:]
				break
			} else if isBreak == true {
			} else {
				addr = addr + string(emails[i][j])
			}
		}
		m[addr] = true
	}
	return len(m)
}
```

## 933.最近的请求次数(2)

- 题目

```
写一个 RecentCounter 类来计算最近的请求。
它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。
返回从 3000 毫秒前到现在的 ping 数。
任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。
保证每次对 ping 的调用都使用比之前更大的 t 值。

示例：
输入：inputs = ["RecentCounter","ping","ping","ping","ping"], 
inputs = [[],[1],[100],[3001],[3002]]
输出：[null,1,2,3,3]
提示：
    每个测试用例最多调用 10000 次 ping。
    每个测试用例会使用严格递增的 t 值来调用 ping。
    每次调用 ping 都有 1 <= t <= 10^9。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组操作 | O(n)       | O(1)       |
| 02   | 数组操作 | O(n)       | O(1)       |

```go
type RecentCounter struct {
	arr []int
}

func Constructor() RecentCounter {
	return RecentCounter{
		arr: make([]int, 0),
	}
}

func (r *RecentCounter) Ping(t int) int {
	r.arr = append(r.arr, t)
	res := 1
	for i := len(r.arr) - 2; i >= 0; i-- {
		if t-r.arr[i] <= 3000 {
			res++
		} else {
			r.arr = r.arr[i+1:]
			break
		}
	}
	return res
}

#
type RecentCounter struct {
	arr []int
}

func Constructor() RecentCounter {
	return RecentCounter{
		arr: make([]int, 0),
	}
}

func (r *RecentCounter) Ping(t int) int {
	r.arr = append(r.arr, t)
	start := t - 3000
	for len(r.arr) > 0 && r.arr[0] < start {
		r.arr = r.arr[1:]
	}
	return len(r.arr)
}
```

## 937.重新排列日志文件(2)

- 题目

```
你有一个日志数组 logs。每条日志都是以空格分隔的字串。
对于每条日志，其第一个字为字母与数字混合的 标识符。
    除标识符之外，所有字均由小写字母组成的，称为 字母日志
    除标识符之外，所有字均由数字组成的，称为 数字日志
题目所用数据保证每个日志在其标识符后面至少有一个字。
请按下述规则将日志重新排序：
    所有 字母日志 都排在 数字日志 之前。
    字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序；
    数字日志 应该按原来的顺序排列。
返回日志的最终顺序。
示例 ：
输入：["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
提示：
    0 <= logs.length <= 100
    3 <= logs[i].length <= 100
    logs[i] 保证有一个标识符，并且标识符后面有一个字。
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   |先分类后排序 | O(nlog(n))     | O(n)       |
| 02 |先分类后自定义排序 | O(nlog(n)) | O(n) |

```go
func reorderLogFiles(logs []string) []string {
	numLogs := make([]string, 0)
	wordLogs := make([]string, 0)
	for key := range logs {
		for i := 0; i < len(logs[key]); i++ {
			if logs[key][i] == ' ' && i != len(logs[key])-1 {
				if strings.ContainsAny(logs[key][i+1:], "0123456789") {
					numLogs = append(numLogs, logs[key])
				} else {
					wordLogs = append(wordLogs, logs[key])
				}
				break
			}
		}
	}
	sort.Slice(wordLogs, func(i, j int) bool {
		firstIndex := strings.Index(wordLogs[i], " ")
		secondIndex := strings.Index(wordLogs[j], " ")
		if wordLogs[i][firstIndex+1:] == wordLogs[j][secondIndex+1:] {
			return wordLogs[i][:firstIndex] < wordLogs[j][:secondIndex]
		}
		return wordLogs[i][firstIndex+1:] < wordLogs[j][secondIndex+1:]
	})
	return append(wordLogs, numLogs...)
}

#
type Logs []string

func (l Logs) Len() int {
	return len(l)
}

func (l Logs) Less(i, j int) bool {
	firstIndex := strings.Index(l[i], " ")
	secondIndex := strings.Index(l[j], " ")
	if l[i][firstIndex+1:] == l[j][secondIndex+1:] {
		return l[i][:firstIndex] < l[j][:secondIndex]
	}
	return l[i][firstIndex+1:] < l[j][secondIndex+1:]
}

func (l Logs) Swap(i, j int) {
	l[i], l[j] = l[j], l[i]
}

func reorderLogFiles(logs []string) []string {
	numLogs := make([]string, 0)
	wordLogs := make([]string, 0)
	for key := range logs {
		for i := 0; i < len(logs[key]); i++ {
			if logs[key][i] == ' ' && i != len(logs[key])-1 {
				if strings.ContainsAny(logs[key][i+1:], "0123456789") {
					numLogs = append(numLogs, logs[key])
				} else {
					wordLogs = append(wordLogs, logs[key])
				}
				break
			}
		}
	}
	sort.Sort(Logs(wordLogs))
	return append(wordLogs, numLogs...)
}
```

## 938.二叉搜索树的范围和(2)

- 题目

```
给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。
二叉搜索树保证具有唯一的值。
示例 1：输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32
示例 2：输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23
提示：
    树中的结点数量最多为 10000 个。
    最终的答案保证小于 2^31。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |
| 02   | 迭代 | O(n)       | O(n)       |

```go
func rangeSumBST(root *TreeNode, L int, R int) int {
	if root == nil {
		return 0
	}
	if root.Val < L {
		return rangeSumBST(root.Right, L, R)
	}
	if root.Val > R {
		return rangeSumBST(root.Left, L, R)
	}
	return root.Val + rangeSumBST(root.Right, L, R) + rangeSumBST(root.Left, L, R)
}

#
func rangeSumBST(root *TreeNode, L int, R int) int {
	if root == nil {
		return 0
	}
	stack := make([]*TreeNode, 0)
	if root.Val > R && root.Left != nil {
		stack = append(stack, root.Left)
	} else if root.Val < L && root.Right != nil {
		stack = append(stack, root.Right)
	} else {
		stack = append(stack, root)
	}
	res := 0
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node.Val <= R && node.Val >= L {
			if node.Left != nil {
				stack = append(stack, node.Left)
			}
			if node.Right != nil {
				stack = append(stack, node.Right)
			}
			res = res + node.Val
		} else if node.Val > R && node.Left != nil {
			stack = append(stack, node.Left)
		} else if node.Val < L && node.Right != nil {
			stack = append(stack, node.Right)
		}
	}
	return res
}
```

## 941.有效的山脉数组(2)

- 题目

```
定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。
让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：
    A.length >= 3
    在 0 < i < A.length - 1 条件下，存在 i 使得：
        A[0] < A[1] < ... A[i-1] < A[i]
        A[i] > A[i+1] > ... > A[A.length - 1]
示例 1：输入：[2,1] 输出：false
示例 2：输入：[3,5,5] 输出：false
示例 3：输入：[0,3,2,1] 输出：true
提示：
    0 <= A.length <= 10000
    0 <= A[i] <= 10000 
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 遍历        | O(n)       | O(1)       |
| 02   | 遍历-双指针 | O(n)       | O(1)       |

```go
func validMountainArray(A []int) bool {
	if len(A) < 3 {
		return false
	}
	pre := A[0]
	i := 0
	for i = 1; i < len(A); i++ {
		if pre < A[i] {
			pre = A[i]
		} else if pre == A[i] {
			return false
		} else {
			break
		}
	}
	if i >= len(A) || i == 1 {
		return false
	}
	for ; i < len(A); i++ {
		if pre > A[i] {
			pre = A[i]
		} else if pre == A[i] {
			return false
		} else {
			return false
		}
	}
	return true
}

#
func validMountainArray(A []int) bool {
	if len(A) < 3 {
		return false
	}
	i := 0
	j := len(A) - 1
	for i < j && A[i] < A[i+1] {
		i++
	}
	for i < j && A[j] < A[j-1] {
		j--
	}
	return i == j && i != 0 && j != len(A)-1
}
```

## 942.增减字符串匹配(1)

- 题目

```
给定只含 "I"（增大）或 "D"（减小）的字符串 S ，令 N = S.length。
返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有：
    如果 S[i] == "I"，那么 A[i] < A[i+1]
    如果 S[i] == "D"，那么 A[i] > A[i+1]
示例 1：输出："IDID" 输出：[0,4,1,3,2]
示例 2：输出："III" 输出：[0,1,2,3]
示例 3：输出："DDI" 输出：[3,2,0,1]
提示： 1 <= S.length <= 10000  S 只包含字符 "I" 或 "D"。
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 遍历-双指针 | O(n)       | O(n)       |

```go
func diStringMatch(S string) []int {
	res := make([]int, len(S)+1)
	left := 0
	right := len(S)
	for i := 0; i < len(S); i++ {
		if S[i] == 'I' {
			res[i] = left
			left++
		} else {
			res[i] = right
			right--
		}
	}
	res[len(S)] = left
	return res
}
```

## 944.删列造序(1)

- 题目

```
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。
你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，
然后请你返回 D.length 的最小可能值。
删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，
形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。（可以参见 删除操作范例）
示例 1：输入：["cba", "daf", "ghi"] 输出：1
解释： 当选择 D = {1}，删除后 A 的列为：["c","d","g"] 和 ["a","f","i"]，均为非降序排列。
若选择 D = {}，那么 A 的列 ["b","a","h"] 就不是非降序排列了。
示例 2：输入：["a", "b"] 输出：0 解释：D = {}
示例 3：输入：["zyx", "wvu", "tsr"] 输出：3 解释：D = {0, 1, 2}
提示：
    1 <= A.length <= 100
    1 <= A[i].length <= 1000
删除操作范例：
比如，有 A = ["abcdef", "uvwxyz"]，
要删掉的列为 {0, 2, 3}，删除后 A 为["bef", "vyz"]， 
A 的列分别为["b","v"], ["e","y"], ["f","z"]。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n^2)     | O(1)       |

```go
func minDeletionSize(A []string) int {
	res := 0
	if len(A) == 1 {
		return res
	}
	for i := 0; i < len(A[0]); i++ {
		for j := 1; j < len(A); j++ {
			if A[j][i] < A[j-1][i] {
				res++
				break
			}
		}
	}
	return res
}
```

## 949.给定数字能组成的最大时间(2)

- 题目

```
给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。
最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。
以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。
示例 1：输入：[1,2,3,4] 输出："23:41"
示例 2：输入：[5,5,5,5] 输出：""
提示：
    A.length == 4
    0 <= A[i] <= 9
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 暴力法 | O(1)       | O(1)       |
| 02   | 全排列 | O(1)       | O(1)       |

```go
func largestTimeFromDigits(A []int) string {
	res := ""
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			for k := 0; k < 4; k++ {
				for l := 0; l < 4; l++ {
					if i != j && i != k && i != l &&
						j != k && j != l && k != l {
						hour := A[i]*10 + A[j]
						minute := A[k]*10 + A[l]
						if hour <= 23 && minute <= 59 {
							ans := fmt.Sprintf("%02d:%02d", hour, minute)
							if ans > res && res != "" {
								res = ans
							} else if res == "" {
								res = ans
							}
						}
					}
				}
			}
		}
	}
	return res
}

#
var arr []string

func largestTimeFromDigits(A []int) string {
	res := ""
	arr = make([]string, 0)
	dfs(A, 0, len(A)-1)
	for i := range arr {
		if (arr[i] > res && res != "") || (res == "") {
			res = arr[i]
		}
	}
	return res
}

func dfs(A []int, start, length int) {
	if start == length {
		hour := A[0]*10 + A[1]
		minute := A[2]*10 + A[3]
		if hour <= 23 && minute <= 59 {
			ans := fmt.Sprintf("%02d:%02d", hour, minute)
			arr = append(arr, ans)
		}
	} else {
		for i := start; i <= length; i++ {
			A[i], A[start] = A[start], A[i]
			dfs(A, start+1, length)
			A[i], A[start] = A[start], A[i]
		}
	}
}
```

## 953.验证外星语词典(2)

- 题目

```
某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。
给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，
返回 true；否则，返回 false。
示例 1：
输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
示例 2：
输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
示例 3：
输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
输出：false
解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
提示：
    1 <= words.length <= 100
    1 <= words[i].length <= 20
    order.length == 26
    在 words[i] 和 order 中的所有字符都是英文小写字母。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 哈希辅助-替换 | O(n)       | O(n)       |
| 02   | 遍历比较      | O(n)       | O(1)       |

```go
func isAlienSorted(words []string, order string) bool {
	newWords := make([]string, len(words))
	m := make(map[byte]int)
	for i := 0; i < len(order); i++ {
		m[order[i]] = i
	}
	for i := 0; i < len(words); i++ {
		str := ""
		for j := 0; j < len(words[i]); j++ {
			str = str + string(m[words[i][j]]+'a')
		}
		newWords[i] = str
	}
	for i := 0; i < len(newWords)-1; i++ {
		if newWords[i] > newWords[i+1] {
			return false
		}
	}
	return true
}

#
func isAlienSorted(words []string, order string) bool {
	m := make(map[byte]int)
	for i := 0; i < len(order); i++ {
		m[order[i]] = i
	}

	for i := 0; i < len(words)-1; i++ {
		length := len(words[i])
		if len(words[i+1]) < length {
			length = len(words[i+1])
		}
		for j := 0; j < length; j++ {
			if m[words[i][j]] < m[words[i+1][j]] {
				break
			}
			if m[words[i][j]] > m[words[i+1][j]] {
				return false
			}
			if j == length-1 {
				if len(words[i]) > len(words[i+1]) {
					return false
				}
			}
		}
	}
	return true
}
```

## 961.重复 N 次的元素(5)

- 题目

```
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。
返回重复了 N 次的那个元素。
示例 1：输入：[1,2,3,3] 输出：3
示例 2：输入：[2,1,2,5,3,2] 输出：2
示例 3：输入：[5,1,5,2,5,3,5,4] 输出：5
提示：
    4 <= A.length <= 10000
    0 <= A[i] < 10000
    A.length 为偶数
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(n)       |
| 02   | 排序     | O(nlog(n)) | O(1)       |
| 03   | 哈希统计 | O(n)       | O(n)       |
| 04   | 遍历     | O(n)       | O(1)       |
| 05   | 暴力法   | O(n^2)     | O(1)       |

```go
func repeatedNTimes(A []int) int {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		if _, ok := m[A[i]]; ok {
			return A[i]
		}
		m[A[i]]++
	}
	return 0
}

#
func repeatedNTimes(A []int) int {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		if _, ok := m[A[i]]; ok {
			return A[i]
		}
		m[A[i]]++
	}
	return 0
}

#
func repeatedNTimes(A []int) int {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		m[A[i]]++
	}
	for key, value := range m {
		if value == len(A)/2 {
			return key
		}
	}
	return 0
}

# 4
func repeatedNTimes(A []int) int {
	for i := 0; i < len(A)-2; i++ {
		if A[i] == A[i+1] || A[i] == A[i+2] {
			return A[i]
		}
	}
	return A[len(A)-1]
}

# 5
func repeatedNTimes(A []int) int {
	for i := 0; i < len(A); i++ {
		for j := i + 1; j < len(A); j++ {
			if A[i] == A[j] {
				return A[i]
			}
		}
	}
	return A[len(A)-1]
}
```

## 965.单值二叉树(4)

- 题目

```
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回 true；否则返回 false。
示例 1：输入：[1,1,1,1,1,null,1] 输出：true
示例 2：输入：[2,2,2,5,2] 输出：false
提示：
    给定树的节点数范围是 [1, 100]。
    每个节点的值都是整数，范围为 [0, 99] 。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 递归-数组辅助 | O(n)       | O(n)       |
| 02   | 递归          | O(n)       | O(log(n))  |
| 03   | 递归          | O(n)       | O(log(n))  |
| 04   | 迭代          | O(n)       | O(n)       |

```go
var arr []int

func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	arr = make([]int, 0)
	dfs(root)
	for i := 1; i < len(arr); i++ {
		if arr[i] != arr[i-1] {
			return false
		}
	}
	return true
}

func dfs(root *TreeNode) {
	if root != nil {
		arr = append(arr, root.Val)
		dfs(root.Left)
		dfs(root.Right)
	}
}

#
var value int
var res bool

func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	res = true
	value = root.Val
	dfs(root)
	return res
}

func dfs(root *TreeNode) {
	if root != nil {
		if root.Val != value {
			res = false
			return
		}
		dfs(root.Left)
		dfs(root.Right)
	}
}

#
func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	if (root.Left != nil && root.Left.Val != root.Val) ||
		(root.Right != nil && root.Right.Val != root.Val) {
		return false
	}
	return isUnivalTree(root.Left) && isUnivalTree(root.Right)
}

#
func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	value := root.Val
	for len(queue) > 0 {
		node := queue[len(queue)-1]
		queue = queue[:len(queue)-1]
		if node.Val != value {
			return false
		}
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	return true
}
```

## 970.强整数(2)

- 题目

```
给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，
那么我们认为该整数是一个强整数。
返回值小于或等于 bound 的所有强整数组成的列表。
你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。
示例 1：输入：x = 2, y = 3, bound = 10 输出：[2,3,4,5,7,9,10]
解释： 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2
示例 2：输入：x = 3, y = 5, bound = 15
输出：[2,4,6,8,10,14]
提示：
    1 <= x <= 100
    1 <= y <= 100
    0 <= bound <= 10^6
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度  |
| ---- | ---- | ---------- | ----------- |
| 01   | 遍历 | O(log(n))  | O(log(n)^2) |
| 02   | 遍历 | O(log(n))  | O(log(n)^2) |

```go
func powerfulIntegers(x int, y int, bound int) []int {
	res := make([]int, 0)
	m := make(map[int]int)
	if bound < 2 {
		return res
	}
	for i := 1; i < bound; i = i * x {
		for j := 1; i+j <= bound; j = j * y {
			if _, ok := m[i+j]; !ok {
				res = append(res, i+j)
				m[i+j] = 1
			}
			if y == 1 {
				break
			}
		}
		if x == 1 {
			break
		}
	}
	return res
}

#
func powerfulIntegers(x int, y int, bound int) []int {
	res := make([]int, 0)
	m := make(map[int]int)
	if bound < 2 {
		return res
	}
	xArr := make([]int, 0)
	yArr := make([]int, 0)
	for i := 1; i < bound; i = i * x {
		xArr = append(xArr, i)
		if x == 1 {
			break
		}
	}
	for i := 1; i < bound; i = i * y {
		yArr = append(yArr, i)
		if y == 1 {
			break
		}
	}
	for i := 0; i < len(xArr); i++ {
		for j := 0; j < len(yArr); j++ {
			if xArr[i]+yArr[j] <= bound && m[xArr[i]+yArr[j]] == 0 {
				res = append(res, xArr[i]+yArr[j])
				m[xArr[i]+yArr[j]] = 1
			}
		}
	}
	return res
}
```

## 976.三角形的最大周长(2)

- 题目

```
给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。
如果不能形成任何面积不为零的三角形，返回 0。
示例 1：输入：[2,1,2] 输出：5
示例 2：输入：[1,2,1] 输出：0
示例 3：输入：[3,2,3,4] 输出：10
示例 4：输入：[3,6,2,3] 输出：8
提示： 
3 <= A.length <= 10000
1 <= A[i] <= 10^6
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序     | O(nlog(n)) | O(1)       |
| 02   | 冒泡排序 | O(n^2)     | O(1)       |

```go
func largestPerimeter(A []int) int {
	sort.Ints(A)
	for i := len(A) - 3; i >= 0; i-- {
		if A[i]+A[i+1] > A[i+2] {
			return A[i] + A[i+1] + A[i+2]
		}
	}
	return 0
}

#
func largestPerimeter(A []int) int {
	if len(A) < 3 {
		return 0
	}
	for i := 0; i < len(A)-1; i++ {
		for j := 0; j < len(A)-1-i; j++ {
			if A[j] > A[j+1] {
				A[j], A[j+1] = A[j+1], A[j]
			}
		}
		if i >= 2 {
			index := len(A) - 1 - i
			if A[index]+A[index+1] > A[index+2] {
				return A[index] + A[index+1] + A[index+2]
			}
		}
	}
	if A[0]+A[1] > A[2] {
		return A[0] + A[1] + A[2]
	}
	return 0
}
```

## 977.有序数组的平方(3)

- 题目

```
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
示例 1：输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100]
示例 2：输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121]
提示：
    1 <= A.length <= 10000
    -10000 <= A[i] <= 10000
    A 已按非递减顺序排序。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 双指针       | O(n)       | O(n)       |
| 02   | 排序         | O(nlog(n)) | O(n)       |
| 03   | 直接插入排序 | O(n^2)     | O(n)       |

```go
func sortedSquares(A []int) []int {
	res := make([]int, len(A))
	i := 0
	j := len(A) - 1
	index := len(A) - 1
	for i <= j {
		if A[i]*A[i] < A[j]*A[j] {
			res[index] = A[j] * A[j]
			j--
		} else {
			res[index] = A[i] * A[i]
			i++
		}
		index--
	}
	return res
}

#
func sortedSquares(A []int) []int {
	res := make([]int, 0)
	for i := 0; i < len(A); i++ {
		res = append(res, A[i]*A[i])
	}
	sort.Ints(res)
	return res
}

#
func sortedSquares(A []int) []int {
	res := make([]int, len(A))
	res[0] = A[0] * A[0]
	j := 0
	for i := 1; i < len(A); i++ {
		value := A[i] * A[i]
		for j = i - 1; j >= 0; j-- {
			if value < res[j] {
				res[j+1] = res[j]
			} else {
				break
			}
		}
		res[j+1] = value
	}
	return res
}
```

## 985.查询后的偶数和(1)

- 题目

```
给出一个整数数组 A 和一个查询数组 queries。
对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，
我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。
（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）
返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。
示例：输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
输出：[8,6,2,4]
解释：开始时，数组为 [1,2,3,4]。
将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。
将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。
将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。
将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。

提示：
    1 <= A.length <= 10000
    -10000 <= A[i] <= 10000
    1 <= queries.length <= 10000
    -10000 <= queries[i][0] <= 10000
    0 <= queries[i][1] < A.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历模拟 | O(n)       | O(n)       |

```go
func sumEvenAfterQueries(A []int, queries [][]int) []int {
	res := make([]int, 0)
	sum := 0
	for _, value := range A {
		if value%2 == 0 {
			sum = sum + value
		}
	}
	for i := 0; i < len(queries); i++ {
		value := queries[i][0]
		index := queries[i][1]
		if A[index]%2 == 0 {
			sum = sum - A[index]
		}
		A[index] = A[index] + value
		if A[index]%2 == 0 {
			sum = sum + A[index]
		}
		res = append(res, sum)
	}
	return res
}
```

## 989.数组形式的整数加法(4)

- 题目

```
对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。
例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。
给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。
示例 1：输入：A = [1,2,0,0], K = 34 输出：[1,2,3,4]
解释：1200 + 34 = 1234

示例 2：
输入：A = [2,7,4], K = 181
输出：[4,5,5]
解释：274 + 181 = 455

示例 3：
输入：A = [2,1,5], K = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021

示例 4：
输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1
输出：[1,0,0,0,0,0,0,0,0,0,0]
解释：9999999999 + 1 = 10000000000

提示：
    1 <= A.length <= 10000
    0 <= A[i] <= 9
    0 <= K <= 10000
    如果 A.length > 1，那么 A[0] != 0
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组辅助 | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |
| 03   | 遍历     | O(n)       | O(n)       |
| 04   | 遍历     | O(n)       | O(n)       |

```go
func addToArrayForm(A []int, K int) []int {
	B := make([]int, 0)
	for K > 0 {
		B = append([]int{K % 10}, B...)
		K = K / 10
	}
	length := len(A)
	if len(B) > len(A) {
		length = len(B)
	}
	res := make([]int, length)
	flag := 0
	i := len(A) - 1
	j := len(B) - 1
	count := 0
	for i >= 0 && j >= 0 {
		sum := A[i] + B[j] + flag
		if sum >= 10 {
			sum = sum - 10
			flag = 1
		} else {
			flag = 0
		}
		res[length-1-count] = sum
		i--
		j--
		count++
	}
	for i >= 0 {
		sum := A[i] + flag
		if sum >= 10 {
			sum = sum - 10
			flag = 1
		} else {
			flag = 0
		}
		res[length-1-count] = sum
		i--
		count++
	}
	for j >= 0 {
		sum := B[j] + flag
		if sum >= 10 {
			sum = sum - 10
			flag = 1
		} else {
			flag = 0
		}
		res[length-1-count] = sum
		j--
		count++
	}
	if flag == 1 {
		return append([]int{1}, res...)
	}
	return res
}

#
func addToArrayForm(A []int, K int) []int {
	A[len(A)-1] = A[len(A)-1] + K
	carry := 0
	for i := len(A) - 1; i >= 0; i-- {
		carry = A[i] / 10
		A[i] = A[i] % 10
		if i > 0 {
			A[i-1] = A[i-1] + carry
		}
	}
	for carry > 0 {
		A = append([]int{carry % 10}, A...)
		carry = carry / 10
	}
	return A
}

#
func addToArrayForm(A []int, K int) []int {
	i := len(A) - 1
	res := make([]int, 0)
	for i >= 0 || K > 0 {
		if i >= 0 {
			K = K + A[i]
		}
		res = append(res, K%10)
		K = K / 10
		i--
	}
	for i := 0; i < len(res)/2; i++ {
		res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]
	}
	return res
}

#
func addToArrayForm(A []int, K int) []int {
	i := len(A) - 1
	res := make([]int, 0)
	for i >= 0 || K > 0 {
		if i >= 0 {
			K = K + A[i]
		}
		res = append([]int{K % 10}, res...)
		K = K / 10
		i--
	}
	return res
}
```

## 993.二叉树的堂兄弟节点(2)

- 题目

```
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。
示例 1：输入：root = [1,2,3,4], x = 4, y = 3 输出：false
示例 2：输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true
示例 3：输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false

提示：
    二叉树的节点数介于 2 到 100 之间。
    每个节点的值都是唯一的、范围为 1 到 100 的整数。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |
| 02   | 迭代 | O(n)       | O(n)       |
| 03   | 递归 | O(n)       | O(n)       |

```go
func isCousins(root *TreeNode, x int, y int) bool {
	xNode, xDepth := dfs(root, x, 0)
	yNode, yDepth := dfs(root, y, 0)
	return xDepth == yDepth && xNode != yNode
}

func dfs(root *TreeNode, value int, level int) (*TreeNode, int) {
	if root == nil {
		return nil, -1
	}
	if root.Val == value {
		return nil, 0
	}
	if (root.Left != nil && root.Left.Val == value) ||
		(root.Right != nil && root.Right.Val == value) {
		return root, level + 1
	}
	leftNode, leftLevel := dfs(root.Left, value, level+1)
	if leftNode != nil {
		return leftNode, leftLevel
	}
	return dfs(root.Right, value, level+1)
}

#
func isCousins(root *TreeNode, x int, y int) bool {
	if root == nil {
		return true
	}
	fatherM := make(map[int]int)
	levelM := make(map[int]int)
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	level := 0
	for len(queue) > 0 {
		length := len(queue)
		for i := 0; i < length; i++ {
			node := queue[i]
			levelM[node.Val] = level
			if node.Left != nil {
				fatherM[node.Left.Val] = node.Val
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				fatherM[node.Right.Val] = node.Val
				queue = append(queue, node.Right)
			}
		}
		queue = queue[length:]
		level++
	}
	return levelM[x] == levelM[y] && fatherM[x] != fatherM[y]
}

#
var fatherM map[int]int
var levelM map[int]int

func isCousins(root *TreeNode, x int, y int) bool {
	fatherM = make(map[int]int)
	levelM = make(map[int]int)
	dfs(root, nil, 0)
	return levelM[x] == levelM[y] && fatherM[x] != fatherM[y]
}

func dfs(root *TreeNode, father *TreeNode, level int) {
	if root == nil {
		return
	}
	if father == nil {
		fatherM[root.Val] = 0
	} else {
		fatherM[root.Val] = father.Val
	}
	levelM[root.Val] = level
	dfs(root.Left, root, level+1)
	dfs(root.Right, root, level+1)
}
```

## 997.找到小镇的法官(2)

- 题目

```
在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。
如果小镇的法官真的存在，那么：
    小镇的法官不相信任何人。
    每个人（除了小镇法官外）都信任小镇的法官。
    只有一个人同时满足属性 1 和属性 2 。
给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。
如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。
示例 1：输入：N = 2, trust = [[1,2]] 输出：2
示例 2：输入：N = 3, trust = [[1,3],[2,3]] 输出：3
示例 3：输入：N = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1
示例 4：输入：N = 3, trust = [[1,2],[2,3]] 输出：-1
示例 5：输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] 输出：3
提示：
    1 <= N <= 1000
    trust.length <= 10000
    trust[i] 是完全不同的
    trust[i][0] != trust[i][1]
    1 <= trust[i][0], trust[i][1] <= N
```

- 解题思路 

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 遍历-数组辅助   | O(n)       | O(n)       |
| 02   | 遍历-双数组辅助 | O(n)       | O(n)       |

```go
func findJudge(N int, trust [][]int) int {
	arr := make([]int, N+1)
	for i := range trust {
		arr[trust[i][0]] = -1
		if arr[trust[i][1]] == -1 {
			continue
		}
		arr[trust[i][1]]++
	}
	for i := 1; i <= N; i++ {
		if arr[i] == N-1 {
			return i
		}
	}
	return -1
}

#
func findJudge(N int, trust [][]int) int {
	out := make([]int, N+1)
	in := make([]int, N+1)
	for i := range trust {
		out[trust[i][0]] = -1
		in[trust[i][1]]++
	}
	for i := 1; i <= N; i++ {
		// 出度为0，入度为N-1
		if out[i] == 0 && in[i] == N-1 {
			return i
		}
	}
	return -1
}
```

## 999.可以被一步捕获的棋子数(2)

- 题目

```
在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，
白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。
不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。

车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，
直到满足下列四个条件之一：
    棋手选择主动停下来。
    棋子因到达棋盘的边缘而停下。
    棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
    车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。
示例 1：输入：
[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],
[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：在本例中，车能够捕获所有的卒。
示例 2：输入：
[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],
[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],
[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],
[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：0
解释：象阻止了车捕获任何卒。
示例 3：输入：
[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],
[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],
[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],
[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释： 车可以捕获位置 b5，d6 和 f5 的卒。
提示：
    board.length == board[i].length == 8
    board[i][j] 可以是 'R'，'.'，'B' 或 'p'
    只有一个格子上存在 board[i][j] == 'R'
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(1)       | O(1)       |
| 02   | 遍历 | O(1)       | O(1)       |

```go
func numRookCaptures(board [][]byte) int {
	res := 0
	var x, y int
	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[0]); j++ {
			if board[i][j] == 'R' {
				x = i
				y = j
				break
			}
		}
	}
	// 向右
	for i := y; i < 8 && board[x][i] != 'B'; i++ {
		if board[x][i] == 'p' {
			res++
			break
		}
	}
	// 向左
	for i := y; i >= 0 && board[x][i] != 'B'; i-- {
		if board[x][i] == 'p' {
			res++
			break
		}
	}
	// 向下
	for i := x; i < 8 && board[i][y] != 'B'; i++ {
		if board[i][y] == 'p' {
			res++
			break
		}
	}
	// 向上
	for i := x; i >= 0 && board[i][y] != 'B'; i-- {
		if board[i][y] == 'p' {
			res++
			break
		}
	}
	return res
}

#
func numRookCaptures(board [][]byte) int {
	res := 0
	var x, y int
	var dx = []int{-1, 1, 0, 0}
	var dy = []int{0, 0, -1, 1}
	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[0]); j++ {
			if board[i][j] == 'R' {
				x = i
				y = j
				break
			}
		}
	}
	for i := 0; i < 4; i++ {
		newX := x + dx[i]
		newY := y + dy[i]
		for newX >= 0 && newX < len(board) && newY >= 0 && newY < len(board[0]) {
			if board[newX][newY] == 'B' {
				break
			}
			if board[newX][newY] == 'p' {
				res++
				break
			}
			newX = newX + dx[i]
			newY = newY + dy[i]
		}
	}
	return res
}
```

# 0901-1000-Medium

## 901.股票价格跨度(1)

- 题目

```
编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。
今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。
例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，
那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。
示例：
输入：["StockSpanner","next","next","next","next","next","next","next"], 
[[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。
注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
提示：
    调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
    每个测试用例最多可以调用  10000 次 StockSpanner.next。
    在所有测试用例中，最多调用 150000 次 StockSpanner.next。
    此问题的总时间限制减少了 50%。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 单调栈 | O(n)       | O(n)       |

```go
type StockSpanner struct {
	prices []int
	count  []int
}

func Constructor() StockSpanner {
	return StockSpanner{
		prices: make([]int, 0),
		count:  make([]int, 0),
	}
}

func (this *StockSpanner) Next(price int) int {
	res := 1
	for len(this.prices) > 0 && this.prices[len(this.prices)-1] <= price {
		this.prices = this.prices[:len(this.prices)-1]
		temp := this.count[len(this.count)-1]
		this.count = this.count[:len(this.count)-1]
		res = res + temp
	}
	this.prices = append(this.prices, price)
	this.count = append(this.count, res)
	return res
}
```

## 904.水果成篮(1)

- 题目

```
在一排树中，第 i 棵树产生 tree[i] 型的水果。
你可以从你选择的任何树开始，然后重复执行以下步骤：
把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。
移动到当前树右侧的下一棵树。如果右边没有树，就停下来。
请注意，在选择一颗树后，你没有任何选择：
你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。
你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。
用这个程序你能收集的水果树的最大总量是多少？
示例 1：输入：[1,2,1] 输出：3
解释：我们可以收集 [1,2,1]。
示例 2：输入：[0,1,2,2] 输出：3
解释：我们可以收集 [1,2,2]
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
示例 3：输入：[1,2,3,2,2] 输出：4
解释：我们可以收集 [2,3,2,2]
如果我们从第一棵树开始，我们将只能收集到 [1, 2]。
示例 4：输入：[3,3,3,1,2,1,1,2,3,3,4] 输出：5
解释：我们可以收集 [1,2,1,1,2]
如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。
提示：1 <= tree.length <= 40000
0 <= tree[i] < tree.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 滑动窗口 | O(n)       | O(1)       |

```go
func totalFruit(tree []int) int {
	res := 0
	m := make(map[int]int)
	left := 0
	total := 0
	for i := 0; i < len(tree); i++ {
		target := tree[i]
		if _, ok := m[target]; ok {
			m[target]++
		} else {
			for len(m) >= 2 {
				m[tree[left]]--
				total--
				if m[tree[left]] == 0 {
					delete(m, tree[left])
				}
				left++
			}
			m[target] = 1
		}
		total++
		if total > res {
			res = total
		}
	}
	return res
}
```

## 907.子数组的最小值之和

### 题目

```
给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。
由于答案可能很大，因此返回答案模 10^9 + 7。
示例：输入：[3,1,2,4] 输出：17
解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
提示：1 <= A <= 30000
1 <= A[i] <= 30000
```

### 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(nlog(n)) | O(1)       |

```go

```

## 910.最小差值II(1)

- 题目

```
给你一个整数数组 A，对于每个整数 A[i]，可以选择 x = -K 或是 x = K （K 总是非负整数），
并将 x 加到 A[i] 中。
在此过程之后，得到数组 B。
返回 B 的最大值和 B 的最小值之间可能存在的最小差值。
示例 1：输入：A = [1], K = 0 输出：0
解释：B = [1]
示例 2：输入：A = [0,10], K = 2 输出：6
解释：B = [2,8]
示例 3：输入：A = [1,3,6], K = 3 输出：3
解释：B = [4,6,3]
提示：1 <= A.length <= 10000
0 <= A[i] <= 10000
0 <= K <= 10000
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(nlog(n)) | O(1)       |

```go
func smallestRangeII(A []int, K int) int {
	sort.Ints(A)
	n := len(A)
	res := A[n-1] - A[0]
	// 排序后，为了最小差值，必定是A[0,i]+K,A[i+1:]-K
	// 最小值落在A[0]+K，A[i+1]-K之中
	// 最大值落在A[n-1]-K，A[i]+K之中
	for i := 0; i < n-1; i++ {
		minValue := min(A[0]+K, A[i+1]-K)
		maxValue := max(A[n-1]-K, A[i]+K)
		res = min(maxValue-minValue, res)
	}
	return res
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 912.排序数组(7)

- 题目

```
给你一个整数数组 nums，请你将该数组升序排列。
示例 1：输入：nums = [5,2,3,1] 输出：[1,2,3,5]
示例 2：输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5]
提示：1 <= nums.length <= 50000
    -50000 <= nums[i] <= 50000
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 内置函数        | O(nlog(n)) | O(1)       |
| 02   | 插入排序        | O(n^2)     | O(1)       |
| 03   | 希尔排序        | O(n^1.3)   | O(1)       |
| 04   | 归并排序        | O(nlog(n)) | O(n)       |
| 05   | 快速排序        | O(nlog(n)) | O(log(n))  |
| 06   | 堆排序-内置heap | O(nlog(n)) | O(n)       |
| 07   | 堆排序          | O(nlog(n)) | O(log(n))  |

```go
func sortArray(nums []int) []int {
	sort.Ints(nums)
	return nums
}

# 2
func sortArray(nums []int) []int {
	for i := 1; i < len(nums); i++ {
		pos := i - 1 // 已经有序的最后一个下标
		cur := nums[i]
		for pos >= 0 && nums[pos] > cur {
			nums[pos+1] = nums[pos] // 后移
			pos--
		}
		nums[pos+1] = cur
	}
	return nums
}

# 3
func sortArray(nums []int) []int {
	n := len(nums)
	for gap := n / 2; gap > 0; gap = gap / 2 {
		for i := gap; i < n; i++ {
			j := i
			cur := nums[i]
			for j-gap >= 0 && cur < nums[j-gap] {
				nums[j] = nums[j-gap]
				j = j - gap
			}
			nums[j] = cur
		}
	}
	return nums
}

# 4
func sortArray(nums []int) []int {
	n := len(nums)
	if n < 2 {
		return nums
	}
	return merge(sortArray(nums[:len(nums)/2]), sortArray(nums[len(nums)/2:]))
}

func merge(left, right []int) []int {
	res := make([]int, 0)
	for len(left) > 0 && len(right) > 0 {
		if left[0] <= right[0] {
			res = append(res, left[0])
			left = left[1:]
		} else {
			res = append(res, right[0])
			right = right[1:]
		}
	}
	if len(left) > 0 {
		res = append(res, left...)
	}
	if len(right) > 0 {
		res = append(res, right...)
	}
	return res
}

# 5
func sortArray(nums []int) []int {
	quick(nums, 0, len(nums)-1)
	return nums
}

func quick(arr []int, left, right int) {
	if left >= right {
		return
	}
	index := partition(arr, left, right)
	quick(arr, left, index-1)
	quick(arr, index+1, right)
}

func partition(arr []int, left, right int) int {
	baseValue := arr[left] // 基准值
	for left < right {
		for baseValue <= arr[right] && left < right {
			right-- // 依次查找大于基准值的位置
		}
		arr[left] = arr[right]
		for arr[left] <= baseValue && left < right {
			left++ // 依次查找小于基准值的位置
		}
		arr[right] = arr[left]
	}
	arr[right] = baseValue
	return right
}

# 6
type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h IntHeap) Less(i, j int) bool {
	return h[i] < h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

func sortArray(nums []int) []int {
	intHeap := make(IntHeap, 0)
	heap.Init(&intHeap)
	for i := 0; i < len(nums); i++ {
		heap.Push(&intHeap, nums[i])
	}
	res := make([]int, 0)
	for i := 0; i < len(nums); i++ {
		value := heap.Pop(&intHeap).(int)
		res = append(res, value)
	}
	return res
}

# 7
func sortArray(nums []int) []int {
	buildHeap(nums, len(nums))
	for i := len(nums) - 1; i > 0; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		heapModify(nums, 0, i-1)
	}
	return nums
}

func buildHeap(arr []int, length int) {
	for i := len(arr)/2 - 1; i >= 0; i-- {
		heapModify(arr, i, length-1)
	}
}

func heapModify(arr []int, start, end int) {
	temp := arr[start]
	for left := 2*start + 1; left <= end; left = 2*left + 1 {
		if left < end && arr[left] < arr[left+1] {
			left++
		}
		if arr[start] < arr[left] {
			arr[start] = arr[left]
			start = left
		}
		arr[start] = temp
	}
}
```

## 915.分割数组(2)

- 题目

```
给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得：
left 中的每个元素都小于或等于 right 中的每个元素。
left 和 right 都是非空的。
left 要尽可能小。
在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。
示例 1：输入：[5,0,3,8,6] 输出：3
解释：left = [5,0,3]，right = [8,6]
示例 2：输入：[1,1,1,0,6,12] 输出：4
解释：left = [1,1,1,0]，right = [6,12]
提示：2 <= A.length <= 30000
0 <= A[i] <= 10^6
可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组辅助 | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |

```go
func partitionDisjoint(A []int) int {
	n := len(A)
	maxLeft := make([]int, n)
	minRight := make([]int, n)
	maxValue := A[0]
	for i := 0; i < n; i++ {
		if maxValue < A[i] {
			maxValue = A[i]
		}
		maxLeft[i] = maxValue
	}
	minValue := A[n-1]
	for i := n - 1; i >= 0; i-- {
		if minValue > A[i] {
			minValue = A[i]
		}
		minRight[i] = minValue
	}
	for i := 1; i < n; i++ {
		if maxLeft[i-1] <= minRight[i] {
			return i
		}
	}
	return -1
}

# 2
func partitionDisjoint(A []int) int {
	n := len(A)
	res := 0
	maxLeft := A[0]
	maxValue := A[0]
	for i := 1; i < n; i++ {
		maxValue = max(maxValue, A[i])
		if A[i] < maxLeft {
			res = i
			maxLeft = maxValue
		}
	}
	return res + 1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 921.使括号有效的最少添加(3)

- 题目

```
给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），
以使得到的括号字符串有效。
从形式上讲，只有满足下面几点之一，括号字符串才是有效的：
    它是一个空字符串，或者
    它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
    它可以被写作 (A)，其中 A 是有效字符串。
给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。
示例 1：输入："())" 输出：1
示例 2：输入："(((" 输出：3
示例 3：输入："()" 输出：0
示例 4：输入："()))((" 输出：4
提示：S.length <= 1000  S 只包含 '(' 和 ')' 字符。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 栈辅助   | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |
| 03   | 内置函数 | O(n)       | O(1)       |

```go
func minAddToMakeValid(S string) int {
	stack := make([]byte,0)
	res := 0
	for i := 0; i < len(S); i++{
		if S[i] == '('{
			stack = append(stack, '(')
		}else {
			if len(stack) == 0{
				res++
			}else {
				stack = stack[:len(stack)-1]
			}
		}
	}
	return res+len(stack)
}

# 2
func minAddToMakeValid(S string) int {
	left := 0
	right := 0
	for i := 0; i < len(S); i++ {
		if S[i] == '(' {
			left++
		} else {
			if left > 0 {
				left--
			} else {
				right++
			}
		}
	}
	return left + right
}

# 3
func minAddToMakeValid(S string) int {
	for strings.Contains(S, "()") == true {
		S = strings.ReplaceAll(S, "()", "")
	}
	return len(S)
}
```

## 945.使数组唯一的最小增量(3)

- 题目

```
给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。
返回使 A 中的每个值都是唯一的最少操作次数。
示例 1:输入：[1,2,2] 输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
示例 2:输入：[3,2,1,2,1,7] 输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
提示：
    0 <= A.length <= 40000
    0 <= A[i] < 40000
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 排序遍历      | O(nlog(n)) | O(1)       |
| 02   | 计数          | O(n)       | O(n)       |
| 03   | 状态探测-递归 | O(n)       | O(n)       |

```go
func minIncrementForUnique(A []int) int {
	res := 0
	sort.Ints(A)
	for i := 0; i < len(A)-1; i++ {
		if A[i] >= A[i+1] {
			value := A[i] - A[i+1] + 1
			res = res + value
			A[i+1] = A[i+1] + value
		}
	}
	return res
}

# 2
func minIncrementForUnique(A []int) int {
	res := 0
	arr := make([]int, 80001)
	for i := 0; i < len(A); i++ {
		arr[A[i]]++
	}
	sum := 0
	for i := 0; i < len(arr); i++ {
		if arr[i] >= 2 {
			sum = sum + arr[i] - 1
			res = res - i*(arr[i]-1)
		} else if arr[i] == 0 && sum > 0 {
			sum--
			res = res + i
		}
	}
	return res
}

# 3
var arr []int

func minIncrementForUnique(A []int) int {
	res := 0
	arr = make([]int, 21)
	for i := 0; i < len(arr); i++ {
		arr[i] = -1
	}
	for i := 0; i < len(A); i++ {
		b := findNext(A[i])
		res = res + b - A[i]
	}
	return res
}

func findNext(a int) int {
	b := arr[a]
	if b == -1 {
		arr[a] = a
		return a
	}
	b = findNext(b + 1)
	arr[a] = b
	return b
}
```



## 946.验证栈序列(2)

- 题目

```
给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，
只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。
示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false
解释：1 不能在 2 之前弹出。
提示：
    0 <= pushed.length == popped.length <= 1000
    0 <= pushed[i], popped[i] < 1000
    pushed 是 popped 的排列。
```

- 解题思路 

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 栈辅助 | O(n)       | O(n)       |
| 02   | 栈辅助 | O(n)       | O(n)       |

```go
func validateStackSequences(pushed []int, popped []int) bool {
	stack := make([]int, 0)
	j := 0
	for i := 0; i < len(pushed); i++ {
		stack = append(stack, pushed[i])
		for len(stack) > 0 && stack[len(stack)-1] == popped[j] {
			stack = stack[:len(stack)-1]
			j++
		}
	}
	if len(stack) == 0 {
		return true
	}
	return false
}

# 2
func validateStackSequences(pushed []int, popped []int) bool {
	stack := make([]int, 0)
	res := false
	i := 0
	j := 0
	for j < len(popped) {
		for len(stack) == 0 || stack[len(stack)-1] != popped[j] {
			if i == len(pushed) {
				break
			}
			stack = append(stack, pushed[i])
			i++
		}
		if stack[len(stack)-1] != popped[j] {
			break
		}
		stack = stack[:len(stack)-1]
		j++
	}
	if len(stack) == 0 && j == len(popped) {
		res = true
	}
	return res
}
```

## 947.移除最多的同行或同列石头(2)

- 题目

```
我们将石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。
每次 move 操作都会移除一块所在行或者列上有其他石头存在的石头。
请你设计一个算法，计算最多能执行多少次 move 操作？
示例 1：输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] 输出：5
示例 2：输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] 输出：3
示例 3：输入：stones = [[0,0]] 输出：0
提示：1 <= stones.length <= 1000
0 <= stones[i][j] < 10000
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 并查集       | O(n)       | O(n)       |
| 02   | 深度优先搜索 | O(n^2)     | O(n)       |

```go
func removeStones(stones [][]int) int {
	fa := make([]int, 20000)
	for i := 0; i < 20000; i++ {
		fa[i] = i
	}
	for i := 0; i < len(stones); i++ {
		a, b := stones[i][0], stones[i][1]
		// 连接同一行、列
		union(fa, a, b+10000)
	}
	m := make(map[int]bool)
	for i := 0; i < len(stones); i++ {
		a := stones[i][0]
		m[find(fa, a)] = true
	}
	return len(stones) - len(m)
}

func union(fa []int, a, b int) {
	fa[find(fa, a)] = find(fa, b)
}

func find(fa []int, a int) int {
	for fa[a] != a {
		fa[a] = fa[fa[a]]
		a = fa[a]
	}
	return a
}

# 2
var arr [][]int
var m []bool

func removeStones(stones [][]int) int {
	n := len(stones)
	arr = make([][]int, n)
	for i := 0; i < n; i++ {
		arr[i] = make([]int, 0)
	}
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if stones[i][0] == stones[j][0] || // 同行
				stones[i][1] == stones[j][1] { // 同列
				arr[i] = append(arr[i], j)
				arr[j] = append(arr[j], i)
			}
		}
	}
	m = make([]bool, n)
	count := 0
	for i := 0; i < n; i++ {
		count = count + dfs(i)
	}
	return len(stones) - count
}

func dfs(index int) int {
	if m[index] == true {
		return 0
	}
	m[index] = true
	for i := 0; i < len(arr[index]); i++ {
		dfs(arr[index][i])
	}
	return 1
}
```

## 951.翻转等价二叉树(1)

- 题目

```
我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。
只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。
编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。
示例：输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], 
root2 =[1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：我们翻转值为 1，3 以及 5 的三个节点。
提示：每棵树最多有 100 个节点。
    每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |

```go
func flipEquiv(root1 *TreeNode, root2 *TreeNode) bool {
	if root1 == nil && root2 == nil {
		return true
	}
	if (root1 == nil && root2 != nil) || (root1 != nil && root2 == nil) {
		return false
	}
	if root1.Val == root2.Val {
		return (flipEquiv(root1.Left, root2.Left) && flipEquiv(root1.Right, root2.Right)) ||
			(flipEquiv(root1.Left, root2.Right) && flipEquiv(root1.Right, root2.Left))
	}
	return false
}
```

## 954.二倍数对数组(1)

- 题目

```
给定一个长度为偶数的整数数组 A，只有对 A 进行重组后可以满足 “对于每个 0 <= i < len(A) / 2，
都有 A[2 * i + 1] = 2 * A[2 * i]” 时，返回 true；否则，返回 false。
示例 1：输入：[3,1,3,6] 输出：false
示例 2：输入：[2,1,2,6] 输出：false
示例 3：输入：[4,-2,2,-4] 输出：true
解释：我们可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]
示例 4：输入：[1,2,4,16,8,4] 输出：false
提示：0 <= A.length <= 30000
    A.length 为偶数
    -100000 <= A[i] <= 100000
```

- 解题思路

| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- | ---------- |
| 01   | 自定义排序 | O(nlog(n)) | O(n)       |

```go
func canReorderDoubled(A []int) bool {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		m[A[i]]++
	}
	sort.Slice(A, func(i, j int) bool {
		return abs(A[i]) < abs(A[j])
	})
	for i := 0; i < len(A); i++ {
		if m[A[i]] == 0 {
			continue
		}
		if m[2*A[i]] == 0 {
			return false
		}
		m[A[i]]--
		m[2*A[i]]--
	}
	return true
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```

## 958.二叉树的完全性检验(2)

- 题目

```
给定一个二叉树，确定它是否是一个完全二叉树。
百度百科中对完全二叉树的定义如下：
若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，
第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）
示例 1：输入：[1,2,3,4,5,6] 输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），
且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
示例 2：输入：[1,2,3,4,5,null,7] 输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
提示：树中将会有 1 到 100 个结点。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(n)       |
| 02   | 迭代 | O(n)       | O(n)       |

```go
var m map[int]bool

func isCompleteTree(root *TreeNode) bool {
	m = make(map[int]bool)
	dfs(root, 1)
	for i := 1; i <= len(m); i++ {
		if m[i] == false {
			return false
		}
	}
	return true
}

func dfs(root *TreeNode, id int) {
	if root == nil {
		return
	}
	m[id] = true
	dfs(root.Left, id*2)
	dfs(root.Right, id*2+1)
}

# 2
func isCompleteTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	prev := root
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		if prev == nil && node != nil {
			return false
		}
		if node != nil {
			queue = append(queue, node.Left)
			queue = append(queue, node.Right)
		}
		prev = node
	}
	return true
}
```

## 966.元音拼写检查器(1)

- 题目

```
在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。
对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：
大小写：如果查询匹配单词列表中的某个单词（不区分大小写），则返回的正确单词与单词列表中的大小写相同。
例如：wordlist = ["yellow"], query = "YellOw": correct = "yellow"
例如：wordlist = ["Yellow"], query = "yellow": correct = "Yellow"
例如：wordlist = ["yellow"], query = "yellow": correct = "yellow"
元音错误：如果在将查询单词中的元音（‘a’、‘e’、‘i’、‘o’、‘u’）分别替换为任何元音后，
能与单词列表中的单词匹配（不区分大小写），则返回的正确单词与单词列表中的匹配项大小写相同。
例如：wordlist = ["YellOw"], query = "yollow": correct = "YellOw"
例如：wordlist = ["YellOw"], query = "yeellow": correct = "" （无匹配项）
例如：wordlist = ["YellOw"], query = "yllw": correct = "" （无匹配项）
此外，拼写检查器还按照以下优先级规则操作：
当查询完全匹配单词列表中的某个单词（区分大小写）时，应返回相同的单词。
当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。
当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。
如果该查询在单词列表中没有匹配项，则应返回空字符串。
给出一些查询 queries，返回一个单词列表 answer，
其中 answer[i] 是由查询 query = queries[i] 得到的正确单词。
示例：输入：wordlist = ["KiTe","kite","hare","Hare"], 
queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]
输出：["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]
提示：1 <= wordlist.length <= 5000
1 <= queries.length <= 5000
1 <= wordlist[i].length <= 7
1 <= queries[i].length <= 7
wordlist 和 queries 中的所有字符串仅由英文字母组成。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(n)       |

```go
func spellchecker(wordlist []string, queries []string) []string {
	m := make(map[string]bool)
	mLower := make(map[string]string)
	mVowel := make(map[string]string)
	for i := 0; i < len(wordlist); i++ {
		m[wordlist[i]] = true
		lowerStr := strings.ToLower(wordlist[i])
		if _, ok := mLower[lowerStr]; ok == false {
			mLower[lowerStr] = wordlist[i]
		}
		vowelStr := changeVowel(lowerStr)
		if _, ok := mVowel[vowelStr]; ok == false {
			mVowel[vowelStr] = wordlist[i]
		}
	}
	for i := 0; i < len(queries); i++ {
		if m[queries[i]] == true {
			continue
		}
		lowerStr := strings.ToLower(queries[i])
		if v, ok := mLower[lowerStr]; ok {
			queries[i] = v
			continue
		}
		vowelStr := changeVowel(lowerStr)
		if v, ok := mVowel[vowelStr]; ok {
			queries[i] = v
			continue
		}
		queries[i] = ""
	}
	return queries
}

func changeVowel(str string) string {
	str = strings.ReplaceAll(str, "a", "?")
	str = strings.ReplaceAll(str, "e", "?")
	str = strings.ReplaceAll(str, "i", "?")
	str = strings.ReplaceAll(str, "o", "?")
	str = strings.ReplaceAll(str, "u", "?")
	return str
}
```

## 967.连续差相同的数字(2)

- 题目

```
返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。
请注意，除了 数字 0 本身之外，答案中的每个数字都 不能 有前导零。
例如，01 有一个前导零，所以是无效的；但 0 是有效的。
你可以按 任何顺序 返回答案。
示例 1：输入：n = 3, k = 7 输出：[181,292,707,818,929]
解释：注意，070 不是一个有效的数字，因为它有前导零。
示例 2：输入：n = 2, k = 1 输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
示例 3：输入：n = 2, k = 0 输出：[11,22,33,44,55,66,77,88,99]
示例 4：输入：n = 2, k = 1
输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
示例 5：输入：n = 2, k = 2
输出：[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]
提示：2 <= n <= 9
0 <= k <= 9
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 回溯     | O(2^n)     | O(n)       |
| 02   | 动态规划 | O(2^n)     | O(2^n)     |

```go
var res []int

func numsSameConsecDiff(n int, k int) []int {
	res = make([]int, 0)
	for i := 1; i <= 9; i++ {
		dfs(i, n, k, i)
	}
	return res
}

func dfs(index, n, k, value int) {
	if n == 1 {
		res = append(res, value)
		return
	}
	a := index + k
	if 0 <= a && a <= 9 && k != 0 {
		value = value*10 + a
		dfs(a, n-1, k, value)
		value = (value - a) / 10
	}
	b := index - k
	if 0 <= b && b <= 9 {
		value = value*10 + b
		dfs(b, n-1, k, value)
		value = (value - b) / 10
	}
}

# 2
func numsSameConsecDiff(n int, k int) []int {
	dp := make([][]int, n)
	dp[0] = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	for i := 1; i < n; i++ {
		temp := make([]int, 0)
		for j := 0; j < len(dp[i-1]); j++ {
			num := dp[i-1][j]
			a := num%10 - k
			if a >= 0 {
				temp = append(temp, num*10+a)
			}
			b := num%10 + k
			if b <= 9 && k > 0 {
				temp = append(temp, num*10+b)
			}
		}
		dp[i] = temp
	}
	return dp[n-1]
}
```

## 969.煎饼排序(1)

- 题目

```
给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k <= A.length，
然后反转 A 的前 k 个元素的顺序。
我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。
返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。
任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。
示例 1：输入：[3,2,4,1] 输出：[4,2,4,3]
解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 A = [3, 2, 4, 1]
第一次翻转后 (k=4): A = [1, 4, 2, 3]
第二次翻转后 (k=2): A = [4, 1, 2, 3]
第三次翻转后 (k=4): A = [3, 2, 1, 4]
第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 
示例 2：输入：[1,2,3] 输出：[]
解释：输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如[3，3]，也将被接受。
提示：1 <= A.length <= 100
    A[i] 是 [1, 2, ..., A.length] 的排列
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 模拟 | O(n^2)     | O(n)       |

```go
func pancakeSort(arr []int) []int {
	res := make([]int, 0)
	n := len(arr) - 1
	for n >= 0 {
		maxValue := arr[0]
		index := 0
		for i := 1; i <= n; i++ {
			if arr[i] > maxValue {
				maxValue = arr[i]
				index = i
			}
		}
		if index == n {
			n--
			continue
		}
		if index != 0 {
			res = append(res, index+1)
			reverse(arr, 0, index)
		}
		res = append(res, n+1)
		reverse(arr, 0, n)
		n--
	}
	return res
}

func reverse(arr []int, left, right int) {
	for left < right {
		arr[left], arr[right] = arr[right], arr[left]
		left++
		right--
	}
}
```

## 973.最接近原点的K个点(3)

- 题目

```
我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。
（这里，平面上两点之间的距离是欧几里德距离。）
你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。
示例 1：输入：points = [[1,3],[-2,2]], K = 1 输出：[[-2,2]]
解释： (1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
示例 2：输入：points = [[3,3],[5,-1],[-2,4]], K = 2 输出：[[3,3],[-2,4]]
（答案 [[-2,4],[3,3]] 也会被接受。）
提示： 1 <= K <= points.length <= 10000
    -10000 < points[i][0] < 10000
    -10000 < points[i][1] < 10000
```

- 解题思路

| No.  | 思路   | 时间复杂度  | 空间复杂度 |
| ---- | ------ | ----------- | ---------- |
| 01   | 排序   | O(nlog(n))  | O(1)       |
| 02   | 堆排序 | O(nlog(n))) | O(n)       |
| 03   | 分治   | O(n)        | O(1)       |

```go
func kClosest(points [][]int, K int) [][]int {
	sort.Slice(points, func(i, j int) bool {
		return points[i][0]*points[i][0]+points[i][1]*points[i][1] <
			points[j][0]*points[j][0]+points[j][1]*points[j][1]
	})
	return points[:K]
}

# 2
func kClosest(points [][]int, K int) [][]int {
	intHeap := make(IntHeap, 0)
	heap.Init(&intHeap)
	for i := 0; i < len(points); i++ {
		heap.Push(&intHeap, points[i])
	}
	res := make([][]int, 0)
	for i := 0; i < K; i++ {
		value := heap.Pop(&intHeap).([]int)
		res = append(res, value)
	}
	return res
}

type IntHeap [][]int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h IntHeap) Less(i, j int) bool {
	return h[i][0]*h[i][0]+h[i][1]*h[i][1] <
		h[j][0]*h[j][0]+h[j][1]*h[j][1]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.([]int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 3
func kClosest(points [][]int, K int) [][]int {
	quick(points, 0, len(points)-1, K)
	return points[:K]
}

func quick(points [][]int, left, right int, K int) {
	if left >= right {
		return
	}
	for {
		target := partition(points, left, right)
		if target == K-1 {
			return
		}
		if target < K-1 {
			left = target + 1
		} else {
			right = target - 1
		}
	}
}

func partition(points [][]int, left, right int) int {
	baseValue := points[left]
	for left < right {
		for left < right && dist(baseValue) <= dist(points[right]) {
			right--
		}
		points[left] = points[right]
		for left < right && dist(points[left]) <= dist(baseValue) {
			left++
		}
		points[right] = points[left]
	}
	points[right] = baseValue
	return right
}

func dist(points []int) int {
	return points[0]*points[0] + points[1]*points[1]
}
```

## 974.和可被K整除的子数组(2)

- 题目

```
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
示例：输入：A = [4,5,0,-2,-3,1], K = 5 输出：7
解释： 有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
提示： 1 <= A.length <= 30000
    -10000 <= A[i] <= 10000
    2 <= K <= 10000
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 前缀和-哈希辅助 | O(n)       | O(n)       |
| 02   | 前缀和-哈希辅助 | O(n)       | O(n)       |

```go
func subarraysDivByK(A []int, K int) int {
	m := make(map[int]int)
	m[0] = 1
	sum := 0
	res := 0
	for i := 0; i < len(A); i++ {
		sum = sum + A[i]
		value := (sum%K + K) % K
		res = res + m[value]
		m[value]++
	}
	return res
}

# 2
func subarraysDivByK(A []int, K int) int {
	m := make(map[int]int)
	m[0] = 1
	sum := 0
	res := 0
	for i := 0; i < len(A); i++ {
		sum = sum + A[i]
		value := (sum%K + K) % K
		m[value]++
	}
	for _, v := range m {
		res = res + v*(v-1)/2
	}
	return res
}
```

## 983.最低票价(3)

- 题目

```
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。
在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
    一张为期一天的通行证售价为 costs[0] 美元；
    一张为期七天的通行证售价为 costs[1] 美元；
    一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，
那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
示例 1：输入：days = [1,4,6,7,8,20], costs = [2,7,15] 输出：11
解释：  例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
示例 2：输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] 输出：17
解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
你总共花了 $17，并完成了你计划的每一天旅行。
提示：1 <= days.length <= 365
    1 <= days[i] <= 365
    days 按顺序严格递增
    costs.length == 3
    1 <= costs[i] <= 1000
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 动态规划-递归 | O(n)       | O(n)       |
| 02   | 动态规划      | O(n)       | O(n)       |
| 03   | 动态规划      | O(n)       | O(n)       |

```go
var dp [366]int
var m map[int]bool

func mincostTickets(days []int, costs []int) int {
	dp = [366]int{}
	m = make(map[int]bool)
	for i := 0; i < len(days); i++ {
		m[days[i]] = true
	}
	return dfs(1, costs)
}

func dfs(day int, costs []int) int {
	if day > 365 {
		return 0
	}
	if dp[day] > 0 {
		return dp[day]
	}
	if m[day] == true {
		dp[day] = min(min(dfs(day+1, costs)+costs[0], dfs(day+7, costs)+costs[1]),
			dfs(day+30, costs)+costs[2])
	} else {
		dp[day] = dfs(day+1, costs)
	}
	return dp[day]
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

# 2
var dp [366]int
var duration = []int{1, 7, 30}

func mincostTickets(days []int, costs []int) int {
	dp = [366]int{}
	return dfs(0, costs, days)
}

func dfs(day int, costs []int, days []int) int {
	if day >= len(days) {
		return 0
	}
	if dp[day] > 0 {
		return dp[day]
	}
	dp[day] = math.MaxInt32
	j := day
	for i := 0; i < 3; i++ {
		for ; j < len(days) && days[j] < days[day]+duration[i]; j++ {
		}
		dp[day] = min(dp[day], dfs(j, costs, days)+costs[i])
	}
	return dp[day]
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

# 3
func mincostTickets(days []int, costs []int) int {
	n := days[len(days)-1] + 1
	dp := make([]int, n)
	for i := 0; i < len(days); i++ {
		dp[days[i]] = 1 // 出行日
	}
	for i := 1; i < n; i++ {
		if dp[i] > 0 {
			dp[i] = min(dp[i-1]+costs[0],
				min(dp[max(i-7, 0)]+costs[1], dp[max(i-30, 0)]+costs[2]))
		} else {
			dp[i] = dp[i-1]
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
```

## 987.二叉树的垂序遍历(2)

- 题目

```
给定二叉树，按垂序遍历返回其结点值。
对位于 (X, Y) 的每个结点而言，其左右子结点分别位于 (X-1, Y-1) 和 (X+1, Y-1)。
把一条垂线从 X = -infinity 移动到 X = +infinity ，
每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（ Y 坐标递减）。
如果两个结点位置相同，则首先报告的结点值较小。
按 X 坐标顺序返回非空报告的列表。每个报告都有一个结点值列表。
示例 1：输入：[3,9,20,null,null,15,7] 输出：[[9],[3,15],[20],[7]]
解释： 在不丧失其普遍性的情况下，我们可以假设根结点位于 (0, 0)：
然后，值为 9 的结点出现在 (-1, -1)；
值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；
值为 20 的结点出现在 (1, -1)；
值为 7 的结点出现在 (2, -2)。
示例 2：输入：[1,2,3,4,5,6,7] 输出：[[4],[2],[1,5,6],[3],[7]]
解释：根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。
然而，在报告 "[1,5,6]" 中，结点值 5 排在前面，因为 5 小于 6。
提示：树的结点数介于 1 和 1000 之间。
每个结点值介于 0 和 1000 之间。
```

- 解题思路

| No.  | 思路 | 时间复杂度   | 空间复杂度 |
| ---- | ---- | ------------ | ---------- |
| 01   | 递归 | O(n^2log(n)) | O(n)       |
| 02   | 迭代 | O(n^2log(n)) | O(n)       |

```go
var m map[int][][2]int

func verticalTraversal(root *TreeNode) [][]int {
	m = make(map[int][][2]int)
	res := make([][]int, 0)
	dfs(root, 0, 0)
	arr := make([]int, 0)
	for k := range m {
		arr = append(arr, k)
	}
	sort.Ints(arr)
	for i := 0; i < len(arr); i++ {
		temp := m[arr[i]]
		sort.Slice(temp, func(i, j int) bool {
			if temp[i][1] == temp[j][1] {
				return temp[i][0] < temp[j][0]
			}
			return temp[i][1] < temp[j][1]
		})
		tempArr := make([]int, 0)
		for j := 0; j < len(temp); j++ {
			tempArr = append(tempArr, temp[j][0])
		}
		res = append(res, tempArr)
	}
	return res
}

func dfs(root *TreeNode, x, y int) {
	if root == nil {
		return
	}
	m[x] = append(m[x], [2]int{root.Val, y})
	dfs(root.Left, x-1, y+1)
	dfs(root.Right, x+1, y+1)
}

# 2
var m map[int][][2]int

func verticalTraversal(root *TreeNode) [][]int {
	m = make(map[int][][2]int)
	res := make([][]int, 0)
	bfs(root, 0, 0)
	arr := make([]int, 0)
	for k := range m {
		arr = append(arr, k)
	}
	sort.Ints(arr)
	for i := 0; i < len(arr); i++ {
		temp := m[arr[i]]
		sort.Slice(temp, func(i, j int) bool {
			if temp[i][1] == temp[j][1] {
				return temp[i][0] < temp[j][0]
			}
			return temp[i][1] < temp[j][1]
		})
		tempArr := make([]int, 0)
		for j := 0; j < len(temp); j++ {
			tempArr = append(tempArr, temp[j][0])
		}
		res = append(res, tempArr)
	}
	return res
}

func bfs(root *TreeNode, x, y int) {
	if root == nil {
		return
	}
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	queueArr := make([][2]int, 0)
	queueArr = append(queueArr, [2]int{0, 0})
	for len(queue) > 0 {
		length := len(queue)
		for i := 0; i < length; i++ {
			node := queue[i]
			x, y := queueArr[i][0], queueArr[i][1]
			m[x] = append(m[x], [2]int{node.Val, y})
			if node.Left != nil {
				queue = append(queue, node.Left)
				queueArr = append(queueArr, [2]int{x - 1, y + 1})
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
				queueArr = append(queueArr, [2]int{x + 1, y + 1})
			}
		}
		queue = queue[length:]
		queueArr = queueArr[length:]
	}
}
```



## 990.等式方程的可满足性(1)

- 题目

```
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，
并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
示例 1：输入：["a==b","b!=a"] 输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。
没有办法分配变量同时满足这两个方程。
示例 2：输入：["b==a","a==b"] 输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
示例 3：输入：["a==b","b==c","a==c"] 输出：true
示例 4：输入：["a==b","b!=c","c==a"] 输出：false
示例 5：输入：["c==c","b==d","x!=z"] 输出：true
提示：1 <= equations.length <= 500
equations[i].length == 4
equations[i][0] 和 equations[i][3] 是小写字母
equations[i][1] 要么是 '='，要么是 '!'
equations[i][2] 是 '='
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 并查集 | O(n)       | O(1)       |

```go
func equationsPossible(equations []string) bool {
	fa := make([]int, 26)
	for i := 0; i < 26; i++ {
		fa[i] = i
	}
	for i := 0; i < len(equations); i++ {
		if equations[i][1] == '=' {
			a, b := int(equations[i][0]-'a'), int(equations[i][3]-'a')
			union(fa, a, b)
		}
	}
	for i := 0; i < len(equations); i++ {
		if equations[i][1] == '!' {
			a, b := int(equations[i][0]-'a'), int(equations[i][3]-'a')
			if find(fa, a) == find(fa, b) {
				return false
			}
		}
	}
	return true
}

func union(fa []int, a, b int) {
	fa[find(fa, a)] = find(fa, b)
}

func find(fa []int, a int) int {
	for fa[a] != a {
		fa[a] = fa[fa[a]]
		a = fa[a]
	}
	return a
}
```

## 994.腐烂的橘子(2)

- 题目

```
在给定的网格中，每个单元格可以有以下三个值之一：
    值 0 代表空单元格；
    值 1 代表新鲜橘子；
    值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
示例 1：输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4
示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
示例 3：输入：[[0,2]] 输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
提示：
    1 <= grid.length <= 10
    1 <= grid[0].length <= 10
    grid[i][j] 仅为 0、1 或 2
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 广度优先搜索 | O(n^2)     | O(n^2)     |
| 02   | 广度优先搜索 | O(n^2)     | O(n^2)     |

```go
// 上、右、下、左
var dx = []int{0, 1, 0, -1}
var dy = []int{1, 0, -1, 0}

func orangesRotting(grid [][]int) int {
	queue := make([][]int, 0)
	count := 0
	times := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[i]); j++ {
			if grid[i][j] == 2 {
				queue = append(queue, []int{i, j})
			} else if grid[i][j] == 1 {
				count = count + 1
			}
		}
	}
	for len(queue) > 0 && count > 0 {
		times++
		length := len(queue)
		for i := 0; i < length; i++ {
			for j := 0; j < 4; j++ {
				x := queue[i][0] + dx[j]
				y := queue[i][1] + dy[j]
				if x >= 0 && x < len(grid) && 
					y >= 0 && y < len(grid[0]) && grid[x][y] == 1 {
					grid[x][y] = 2
					queue = append(queue, []int{x, y})
					count--
				}
			}
		}
		queue = queue[length:]
	}
	if count > 0 {
		return -1
	}
	return times
}

# 2
// 上、右、下、左
var dx = []int{0, 1, 0, -1}
var dy = []int{1, 0, -1, 0}

func orangesRotting(grid [][]int) int {
	queue := make([][]int, 0)
	count := 0
	times := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[i]); j++ {
			if grid[i][j] == 2 {
				queue = append(queue, []int{i, j})
			} else if grid[i][j] == 1 {
				count = count + 1
			}
		}
	}
	for len(queue) > 0 {
		times++
		length := len(queue)
		for i := 0; i < length; i++ {
			for j := 0; j < 4; j++ {
				x := queue[i][0] + dx[j]
				y := queue[i][1] + dy[j]
				if x >= 0 && x < len(grid) &&
					y >= 0 && y < len(grid[0]) && grid[x][y] == 1 {
					grid[x][y] = 2
					queue = append(queue, []int{x, y})
					count--
				}
			}
		}
		queue = queue[length:]
		if len(queue) == 0 {
			times--
		}
	}
	if count > 0 {
		return -1
	}
	return times
}
```

# 0901-1000-Hard

## 956.最高的广告牌(5)

- 题目

```
你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。
举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。
示例 1：输入：[1,2,3,6] 输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：输入：[1,2,3,4,5,6] 输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
示例 3：输入：[1,2] 输出：0
解释：没法安装广告牌，所以返回 0。
提示：0 <= rods.length <= 20
    1 <= rods[i] <= 1000
    钢筋的长度总和最多为 5000
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 动态规划-递归 | O(3^n)     | O(n^2)     |
| 02   | 动态规划      | O(3^n)     | O(n)       |
| 03   | 动态规划      | O(3^n)     | O(n)       |
| 04   | 动态规划      | O(3^n)     | O(n^2)     |
| 05   | 折半搜索      | O(3^(n/2)) | O(3^(n/2)) |

```go
const MinValue = math.MinInt32 / 100

// 官方题解(从后往前比较难理解)
// dp[i][s] 表示当我们可以使用 rods[j] (j >= i) 时能得到的最大 score
// dp[i][s] = max(dp[i+1][s], dp[i+1][s-rods[i]], rods[i] + dp[i+1][s+rods[i]])
// 例如:rods=[1,2,3,6],可以有dp[1][1]=5,
// 在写下1之后,可以写下+2,+3,-6使得剩下的rods[i:]获得score为5
var dp [][]int

func tallestBillboard(rods []int) int {
	dp = make([][]int, len(rods))
	for i := 0; i < len(rods); i++ {
		dp[i] = make([]int, 10001)
	}
	res := dfs(rods, 0, 5000)
	return res
}

func dfs(rods []int, index, total int) int {
	if index == len(rods) {
		if total == 5000 {
			return 0
		}
		return MinValue
	}
	if dp[index][total] != 0 {
		return dp[index][total]
	}
	res := dfs(rods, index+1, total)
	res = max(res, dfs(rods, index+1, total-rods[index]))
	res = max(res, dfs(rods, index+1, total+rods[index])+rods[index])
	dp[index][total] = res
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func tallestBillboard(rods []int) int {
	dp := make(map[int]int) // 保存和为i中正整数的和
	dp[0] = 0
	// 每个rods[i]有3个选择，+rods[i]、-rods[i]、0
	for i := 0; i < len(rods); i++ {
		value := rods[i]
		temp := make(map[int]int)
		for k, v := range dp {
			temp[k+value] = max(temp[k+value], v+value) // +value>0，是正整数，需要加上
			temp[k] = max(temp[k], v)
			temp[k-value] = max(temp[k-value], v) // -value<0，不需要加上
		}
		dp = temp
	}
	return dp[0]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func tallestBillboard(rods []int) int {
	dp := make(map[int]int) // 保存高度差为i时最低一边的高度
	dp[0] = 0
	// 每个rods[i]有3个选择，+rods[i]、-rods[i]、0
	for i := 0; i < len(rods); i++ {
		temp := make(map[int]int)
		for k, v := range dp {
			temp[k] = v
		}
		for k, v := range temp {
			dp[k+rods[i]] = max(dp[k+rods[i]], v)                           // 往高的一侧加，高度差变大，但最低一边高度不变
			dp[k] = dp[k]                                                   // 不加，高度差不变，可忽略
			dp[abs(k-rods[i])] = max(dp[abs(k-rods[i])], v+min(k, rods[i])) // 往低的一侧加，高度差有变化，高度差有增长
		}
	}
	return dp[0]
}

func abs(a int) int {
	if a >= 0 {
		return a
	}
	return -a
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 4
// dp[i][s] 表示当我们可以使用 rods[j] (j >= i) 时能得到的最大 score
// dp[i][s] = max(dp[i+1][s], dp[i+1][s-rods[i]], rods[i] + dp[i+1][s+rods[i]])
// 例如:rods=[1,2,3,6],可以有dp[1][1]=5,
// 在写下1之后,可以写下+2,+3,-6使得剩下的rods[i:]获得score为5
const MinValue = math.MinInt32 / 100

func tallestBillboard(rods []int) int {
	dp := make([][]int, len(rods)+1)
	for i := 0; i < len(rods)+1; i++ {
		dp[i] = make([]int, 10001)
	}
	for j := 0; j < len(dp[len(rods)]); j++ {
		dp[len(rods)][j] = MinValue
	}
	sum := 0
	for i := 0; i < len(rods); i++ {
		sum = sum + rods[i]
	}
	m := 2*sum
	dp[len(rods)][sum] = 0
	for i := len(rods) - 1; i >= 0; i-- {
		for s := rods[i]; s <= m-rods[i]; s++ {
			dp[i][s] = max(dp[i+1][s], max(dp[i+1][s-rods[i]], rods[i]+dp[i+1][s+rods[i]]))
		}
	}
	return dp[0][sum]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 5
func tallestBillboard(rods []int) int {
	leftM := makeM(rods, 0, len(rods)/2)
	rightM := makeM(rods, len(rods)/2, len(rods))
	res := 0
	for k := range leftM {
		if rightM[k] > 0 {
			res = max(res, leftM[k]+rightM[-k])
		}
	}
	return res
}

func makeM(rods []int, left, right int) map[int]int {
	dp := make([][2]int, 100001)
	dp[0] = [2]int{0, 0}
	count := 1
	for i := left; i < right; i++ {
		length := count
		for j := 0; j < length; j++ {
			dp[count] = [2]int{dp[j][0] + rods[i], dp[j][1]}
			count++
			dp[count] = [2]int{dp[j][0], dp[j][1] + rods[i]}
			count++
		}
	}
	m := make(map[int]int)
	for i := 0; i < count; i++ {
		a := dp[i][0]
		b := dp[i][1]
		m[a-b] = max(m[a-b], a)
	}
	return m
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 968.监控二叉树(2)

- 题目

```
给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
示例 1：输入：[0,0,null,0,0] 输出：1
解释：如图所示，一台摄像头足以监控所有节点。
示例 2：输入：[0,0,null,0,null,0,null,null,0] 输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
提示：给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |
| 02   | 递归 | O(n)       | O(log(n))  |

```go
var maxValue = math.MaxInt32 / 10

func minCameraCover(root *TreeNode) int {
	_, res, _ := dfs(root)
	return res
}

func dfs(root *TreeNode) (a, b, c int) {
	if root == nil {
		return maxValue, 0, 0
	}
	la, lb, lc := dfs(root.Left)
	ra, rb, rc := dfs(root.Right)
	a = lc + rc + 1               // root必须放置摄像头的情况下，覆盖整棵树需要的摄像头数目。
	b = min(a, min(la+rb, ra+lb)) // 覆盖整棵树需要的摄像头数目,无论root是否放置摄像头。
	c = min(a, lb+rb)             // 覆盖两棵子树需要的摄像头数目,无论节点root本身是否被监控到。
	return a, b, c
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

# 2
var res int

func minCameraCover(root *TreeNode) int {
	res = 0
	if dfs(root) == 0 { // root未被监控
		res++
	}
	return res
}

// 0=>未被监控， 1=>已监控， 2=>安装监控
func dfs(root *TreeNode) int {
	if root == nil {
		return 1 // 空节点假设有监控
	}
	left, right := dfs(root.Left), dfs(root.Right)
	if left == 1 && right == 1 { // 左右节点都有监控，比如都是空节点，那么当前节点是无未被监控
		return 0
	}
	if left+right >= 3 { // 1+2 / 2+1 / 2+2 => 当前节点已经被监控
		return 1
	}
	res++ // 1+0, 0+1, 0+2, 2+0, 0+0 => 需要安装监控
	return 2
}
```

