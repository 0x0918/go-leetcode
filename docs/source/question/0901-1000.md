# 0901-1000-Easy

* [0901\-1000\-Easy](#0901-1000-easy)
  * [905\.按奇偶排序数组(4)](#905%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%844)
  * [908\.最小差值I(2)](#908%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BCi2)
  * [914\.卡牌分组](#914%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84)
  * [917\.仅仅反转字母(4)](#917%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D4)
  * [922\.按奇偶排序数组 II(3)](#922%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii3)
  * [925\.长按键入(2)](#925%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A52)
  * [929\.独特的电子邮件地址(2)](#929%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%802)
  * [933\.最近的请求次数(2)](#933%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B02)
  * [937\.重新排列日志文件(2)](#937%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B62)
  * [938\.二叉搜索树的范围和(2)](#938%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C2)
  * [941\.有效的山脉数组(2)](#941%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%842)
  * [942\.增减字符串匹配(1)](#942%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D1)
  * [944\.删列造序(1)](#944%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F1)
  * [949\.给定数字能组成的最大时间(2)](#949%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E8%83%BD%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B42)
  * [953\.验证外星语词典(2)](#953%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B82)
  * [961\.重复 N 次的元素(5)](#961%E9%87%8D%E5%A4%8D-n-%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A05)
  * [965\.单值二叉树(4)](#965%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%914)
  * [970\.强整数(2)](#970%E5%BC%BA%E6%95%B4%E6%95%B02)
  * [976\.三角形的最大周长(2)](#976%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF2)
  * [977\.有序数组的平方(3)](#977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B93)
  * [985\.查询后的偶数和(1)](#985%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E5%81%B6%E6%95%B0%E5%92%8C1)
  * [989\.数组形式的整数加法(4)](#989%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%954)
  * [993\.二叉树的堂兄弟节点(2)](#993%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B92)
  * [997\.找到小镇的法官(2)](#997%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%982)
  * [999\.可以被一步捕获的棋子数(2)](#999%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%B8%80%E6%AD%A5%E6%8D%95%E8%8E%B7%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B02)
* [0901\-1000\-Medium](#0901-1000-medium)
  * [901\.股票价格跨度(1)](#901%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A61)
  * [912\.排序数组(7)](#912%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%847)
  * [921\.使括号有效的最少添加(3)](#921%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A03)
  * [945\.使数组唯一的最小增量(3)](#945%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F3)
  * [946\.验证栈序列(2)](#946%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%972)
  * [974\.和可被K整除的子数组(2)](#974%E5%92%8C%E5%8F%AF%E8%A2%ABk%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%842)
  * [983\.最低票价(3)](#983%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B73)
  * [994\.腐烂的橘子(2)](#994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%902)
* [0901\-1000\-Hard](#0901-1000-hard)
  * [956\.最高的广告牌(5)](#956%E6%9C%80%E9%AB%98%E7%9A%84%E5%B9%BF%E5%91%8A%E7%89%8C5)



## 905.按奇偶排序数组(4)

- 题目

```
给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：输入：[3,1,2,4] 输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
提示：
    1 <= A.length <= 5000
    0 <= A[i] <= 5000
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 双指针 | O(n)       | O(1)       |
| 02   | 双指针 | O(n)       | O(1)       |
| 03   | 遍历   | O(n)       | O(n)       |
| 04   | 遍历   | O(n)       | O(1)       |

```go
func sortArrayByParity(A []int) []int {
	i := 0
	j := len(A)-1
	for i < j{
		if A[i] % 2== 0{
			i++
		}else if A[j] % 2 == 1{
			j--
		}else {
			A[i], A[j] = A[j], A[i]
		}
	}
	return A
}

#
func sortArrayByParity(A []int) []int {
	i := 0
	j := len(A) - 1
	for i < j {
		for i < j && A[i]%2 == 0 {
			i++
		}
		for i < j && A[j]%2 == 1 {
			j--
		}
		A[i], A[j] = A[j], A[i]
	}
	return A
}

#
func sortArrayByParity(A []int) []int {
	res := make([]int, 0)
	for i := 0; i < len(A); i++ {
		if A[i]%2 == 0 {
			res = append(res, A[i])
		}
	}
	for i := 0; i < len(A); i++ {
		if A[i]%2 == 1 {
			res = append(res, A[i])
		}
	}
	return res
}

#
func sortArrayByParity(A []int) []int {
	count := 0
	for i := 0; i < len(A); i++{
		if A[i] % 2 == 0{
			A[count],A[i] = A[i], A[count]
			count++
		}
	}
	return A
}
```

## 908.最小差值I(2)

- 题目

```
给你一个整数数组 A，对于每个整数 A[i]，我们可以选择处于区间 [-K, K] 中的任意数 x ，
将 x 与 A[i] 相加，结果存入 A[i] 。
在此过程之后，我们得到一些数组 B。
返回 B 的最大值和 B 的最小值之间可能存在的最小差值。
示例 1：输入：A = [1], K = 0 输出：0
解释：B = [1]
示例 2：输入：A = [0,10], K = 2 输出：6
解释：B = [2,8]
示例 3：输入：A = [1,3,6], K = 3 输出：0
解释：B = [3,3,3] 或 B = [4,4,4]
提示：
    1 <= A.length <= 10000
    0 <= A[i] <= 10000
    0 <= K <= 10000
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func smallestRangeI(A []int, K int) int {
	if len(A) == 1 {
		return 0
	}
	sort.Ints(A)
	if A[len(A)-1]-A[0] > 2*K {
		return A[len(A)-1] - A[0] - 2*K
	}
	return 0
}

#
func smallestRangeI(A []int, K int) int {
	if len(A) == 1 {
		return 0
	}
	min := A[0]
	max := A[0]
	for i := 0; i < len(A); i++ {
		if A[i] > max {
			max = A[i]
		}
		if A[i] < min {
			min = A[i]
		}
	}
	if max-min > 2*K {
		return max - min - 2*K
	}
	return 0
}
```

## 914.卡牌分组

- 题目

```
给定一副牌，每张牌上都写着一个整数。
此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
    每组都有 X 张牌。
    组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

示例 1：输入：[1,2,3,4,4,3,2,1] 输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 
示例 2：输入：[1,1,1,2,2,2,3,3] 输出：false
解释：没有满足要求的分组。
示例 3：输入：[1] 输出：false
解释：没有满足要求的分组。
示例 4：输入：[1,1] 输出：true
解释：可行的分组是 [1,1]
示例 5：输入：[1,1,2,2,2,2] 输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]
提示：
    1 <= deck.length <= 10000
    0 <= deck[i] < 10000
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 哈希辅助+求公约数 | O(nlog(n)) | O(n)       |
| 02   | 暴力法            | O(n^2)     | O(n)       |

```go
func hasGroupsSizeX(deck []int) bool {
	if len(deck) < 2 {
		return false
	}
	m := make(map[int]int)
	for i := 0; i < len(deck); i++ {
		m[deck[i]]++
	}
	v := m[deck[0]]
	for _, value := range m {
		v = gcd(v, value)
		if v < 2 {
			return false
		}
	}
	return true
}

func gcd(x, y int) int {
	a := x % y
	if a > 0 {
		return gcd(y, a)
	}
	return y
}

#
func hasGroupsSizeX(deck []int) bool {
	if len(deck) < 2 {
		return false
	}
	m := make(map[int]int)
	for i := 0; i < len(deck); i++ {
		m[deck[i]]++
	}
	for i := 2; i <= len(deck); i++ {
		flag := true
		if len(deck)%i == 0 {
			for _, v := range m {
				if v%i != 0 {
					flag = false
					break
				}
			}
			if flag == true {
				return true
			}
		}
	}
	return false
}
```

## 917.仅仅反转字母(4)

- 题目

```
给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。
示例 1：输入："ab-cd" 输出："dc-ba"
示例 2：输入："a-bC-dEf-ghIj" 输出："j-Ih-gfE-dCba"
示例 3：输入："Test1ng-Leet=code-Q!" 输出："Qedo1ct-eeLg=ntse-T!"
提示：
    S.length <= 100
    33 <= S[i].ASCIIcode <= 122 
    S 中不包含 \ or "
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 双指针          | O(n)       | O(n)       |
| 02   | 双指针          | O(n)       | O(n)       |
| 03   | 双指针-内置函数 | O(n)       | O(n)       |
| 04   | 栈辅助          | O(n)       | O(n)       |

```go
func reverseOnlyLetters(S string) string {
	i := 0
	j := len(S) - 1
	arr := []byte(S)
	for i < j {
		for i < j && !isLetter(arr[i]) {
			i++
		}
		for i < j && !isLetter(arr[j]) {
			j--
		}
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
	return string(arr)
}

func isLetter(b byte) bool {
	if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') {
		return true
	}
	return false
}

#
func reverseOnlyLetters(S string) string {
	i := 0
	j := len(S) - 1
	arr := []byte(S)
	for i < j {
		if !isLetter(arr[i]) {
			i++
		} else if !isLetter(arr[j]) {
			j--
		} else {
			arr[i], arr[j] = arr[j], arr[i]
			i++
			j--
		}
	}
	return string(arr)
}

func isLetter(b byte) bool {
	if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') {
		return true
	}
	return false
}

#
func reverseOnlyLetters(S string) string {
	i := 0
	j := len(S) - 1
	arr := []rune(S)
	for i < j {
		if !unicode.IsLetter(arr[i]) {
			i++
		} else if !unicode.IsLetter(arr[j]) {
			j--
		} else {
			arr[i], arr[j] = arr[j], arr[i]
			i++
			j--
		}
	}
	return string(arr)
}

#
func reverseOnlyLetters(S string) string {
	stack := make([]rune, 0)
	res := make([]rune, 0)
	arr := []rune(S)
	for i := 0; i < len(arr); i++ {
		if unicode.IsLetter(arr[i]) {
			stack = append(stack, arr[i])
		}
	}
	for i := 0; i < len(arr); i++ {
		if unicode.IsLetter(arr[i]) {
			res = append(res, stack[len(stack)-1])
			stack = stack[:len(stack)-1]
		} else {
			res = append(res, arr[i])
		}
	}
	return string(res)
}
```

## 922.按奇偶排序数组 II(3)

- 题目

```
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
你可以返回任何满足上述条件的数组作为答案。
示例：输入：[4,2,5,7]输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 
提示：
    2 <= A.length <= 20000
    A.length % 2 == 0
    0 <= A[i] <= 1000
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 双指针   | O(n)       | O(1)       |
| 02   | 双指针   | O(n)       | O(1)       |
| 03   | 数组辅助 | O(n)       | O(n)       |

```go
func sortArrayByParityII(A []int) []int {
	i := 0
	j := 1
	for i < len(A) || j < len(A) {
		for i < len(A) && A[i]%2 == 0 {
			i = i + 2
		}
		for j < len(A) && A[j]%2 == 1 {
			j = j + 2
		}
		if i >= len(A) || j >= len(A) {
			break
		}
		A[i], A[j] = A[j], A[i]
	}
	return A
}

#
func sortArrayByParityII(A []int) []int {
	i := 0
	j := 1
	for i < len(A) {
		for A[i]%2 != 0 {
			if A[j]%2 == 0 {
				A[i], A[j] = A[j], A[i]
			} else {
				j = j + 2
			}
		}
		i = i + 2
	}
	return A
}

#
func sortArrayByParityII(A []int) []int {
	i := 0
	j := 1
	res := make([]int, len(A))
	for k := 0; k < len(A); k++ {
		if A[k]%2 == 0 {
			res[i] = A[k]
			i = i + 2
		} else {
			res[j] = A[k]
			j = j + 2
		}
	}
	return res
}
```

## 925.长按键入(2)

- 题目

```
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，
而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。
如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

示例 1： 输入：name = "alex", typed = "aaleex" 输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2： 输入：name = "saeed", typed = "ssaaedd" 输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3： 输入：name = "leelee", typed = "lleeelee" 输出：true
示例 4： 输入：name = "laiden", typed = "laiden" 输出：true
解释：长按名字中的字符并不是必要的。
提示：
    name.length <= 1000
    typed.length <= 1000
    name 和 typed 的字符都是小写字母。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 双指针       | O(n)       | O(1)       |
| 02   | 遍历统计比较 | O(n)       | O(1)       |

```go
func isLongPressedName(name string, typed string) bool {
	i := 0
	j := 0
	for j < len(typed) {
		if i == len(name) {
			i = len(name) - 1
		}
		if name[i] == typed[j] {
			// 正确的话，保证i == len(name) && j == len(typed)
			i++
			j++
		} else {
			if i == 0 {
				return false
			}
			if name[i-1] != typed[j] {
				return false
			} else {
				j++
			}
		}
	}
	return i == len(name) && j == len(typed)
}

#
func isLongPressedName(name string, typed string) bool {
	i := 1
	j := 1
	countI := 0
	countJ := 0
	for i < len(name) || j < len(typed) {
		for i < len(name) && name[i] == name[i-1] {
			i++
			countI++
		}
		for j < len(typed) && typed[j] == typed[j-1] {
			j++
			countJ++
		}
		if name[i-1] != typed[j-1] || countJ < countI {
			return false
		}
		i++
		j++
		countI = 0
		countJ = 0
	}
	return name[len(name)-1] == typed[len(typed)-1]
}
```

## 929.独特的电子邮件地址(2)

- 题目

```
每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。
例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。
除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。
如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），
则发往那里的邮件将会转发到本地名称中没有点的同一地址。
例如，"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 
（请注意，此规则不适用于域名。）
如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。
这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 
（同样，此规则不适用于域名。）
可以同时使用这两个规则。
给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？
示例：
输入：["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com",
"testemail+david@lee.tcode.com"]
输出：2
解释：实际收到邮件的是 "testemail@leetcode.com" 和 "testemail@lee.tcode.com"。
提示：
    1 <= emails[i].length <= 100
    1 <= emails.length <= 100
    每封 emails[i] 都包含有且仅有一个 '@' 字符。
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 哈希辅助+内置函数 | O(n^2)     | O(n)       |
| 02   | 哈希辅助          | O(n^2)     | O(n)       |

```go
func numUniqueEmails(emails []string) int {
	m := make(map[string]bool)
	for i := 0; i < len(emails); i++ {
		addr := ""
		arr := strings.Split(emails[i], "@")
		for j := 0; j < len(arr[0]); j++ {
			if arr[0][j] == '+' {
				break
			} else if arr[0][j] == '.' {
				continue
			} else {
				addr = addr + string(arr[0][j])
			}
		}
		m[addr+"@"+arr[1]] = true
	}
	return len(m)
}

#
func numUniqueEmails(emails []string) int {
	m := make(map[string]bool)
	for i := 0; i < len(emails); i++ {
		addr := ""
		isBreak := false
		for j := 0; j < len(emails[i]); j++ {
			if emails[i][j] == '+' {
				isBreak = true
			} else if emails[i][j] == '.' {
				continue
			} else if emails[i][j] == '@' {
				addr = addr + emails[i][j:]
				break
			} else if isBreak == true {
			} else {
				addr = addr + string(emails[i][j])
			}
		}
		m[addr] = true
	}
	return len(m)
}
```

## 933.最近的请求次数(2)

- 题目

```
写一个 RecentCounter 类来计算最近的请求。
它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。
返回从 3000 毫秒前到现在的 ping 数。
任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。
保证每次对 ping 的调用都使用比之前更大的 t 值。

示例：
输入：inputs = ["RecentCounter","ping","ping","ping","ping"], 
inputs = [[],[1],[100],[3001],[3002]]
输出：[null,1,2,3,3]
提示：
    每个测试用例最多调用 10000 次 ping。
    每个测试用例会使用严格递增的 t 值来调用 ping。
    每次调用 ping 都有 1 <= t <= 10^9。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组操作 | O(n)       | O(1)       |
| 02   | 数组操作 | O(n)       | O(1)       |

```go
type RecentCounter struct {
	arr []int
}

func Constructor() RecentCounter {
	return RecentCounter{
		arr: make([]int, 0),
	}
}

func (r *RecentCounter) Ping(t int) int {
	r.arr = append(r.arr, t)
	res := 1
	for i := len(r.arr) - 2; i >= 0; i-- {
		if t-r.arr[i] <= 3000 {
			res++
		} else {
			r.arr = r.arr[i+1:]
			break
		}
	}
	return res
}

#
type RecentCounter struct {
	arr []int
}

func Constructor() RecentCounter {
	return RecentCounter{
		arr: make([]int, 0),
	}
}

func (r *RecentCounter) Ping(t int) int {
	r.arr = append(r.arr, t)
	start := t - 3000
	for len(r.arr) > 0 && r.arr[0] < start {
		r.arr = r.arr[1:]
	}
	return len(r.arr)
}
```

## 937.重新排列日志文件(2)

- 题目

```
你有一个日志数组 logs。每条日志都是以空格分隔的字串。
对于每条日志，其第一个字为字母与数字混合的 标识符。
    除标识符之外，所有字均由小写字母组成的，称为 字母日志
    除标识符之外，所有字均由数字组成的，称为 数字日志
题目所用数据保证每个日志在其标识符后面至少有一个字。
请按下述规则将日志重新排序：
    所有 字母日志 都排在 数字日志 之前。
    字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序；
    数字日志 应该按原来的顺序排列。
返回日志的最终顺序。
示例 ：
输入：["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
提示：
    0 <= logs.length <= 100
    3 <= logs[i].length <= 100
    logs[i] 保证有一个标识符，并且标识符后面有一个字。
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   |先分类后排序 | O(nlog(n))     | O(n)       |
| 02 |先分类后自定义排序 | O(nlog(n)) | O(n) |

```go
func reorderLogFiles(logs []string) []string {
	numLogs := make([]string, 0)
	wordLogs := make([]string, 0)
	for key := range logs {
		for i := 0; i < len(logs[key]); i++ {
			if logs[key][i] == ' ' && i != len(logs[key])-1 {
				if strings.ContainsAny(logs[key][i+1:], "0123456789") {
					numLogs = append(numLogs, logs[key])
				} else {
					wordLogs = append(wordLogs, logs[key])
				}
				break
			}
		}
	}
	sort.Slice(wordLogs, func(i, j int) bool {
		firstIndex := strings.Index(wordLogs[i], " ")
		secondIndex := strings.Index(wordLogs[j], " ")
		if wordLogs[i][firstIndex+1:] == wordLogs[j][secondIndex+1:] {
			return wordLogs[i][:firstIndex] < wordLogs[j][:secondIndex]
		}
		return wordLogs[i][firstIndex+1:] < wordLogs[j][secondIndex+1:]
	})
	return append(wordLogs, numLogs...)
}

#
type Logs []string

func (l Logs) Len() int {
	return len(l)
}

func (l Logs) Less(i, j int) bool {
	firstIndex := strings.Index(l[i], " ")
	secondIndex := strings.Index(l[j], " ")
	if l[i][firstIndex+1:] == l[j][secondIndex+1:] {
		return l[i][:firstIndex] < l[j][:secondIndex]
	}
	return l[i][firstIndex+1:] < l[j][secondIndex+1:]
}

func (l Logs) Swap(i, j int) {
	l[i], l[j] = l[j], l[i]
}

func reorderLogFiles(logs []string) []string {
	numLogs := make([]string, 0)
	wordLogs := make([]string, 0)
	for key := range logs {
		for i := 0; i < len(logs[key]); i++ {
			if logs[key][i] == ' ' && i != len(logs[key])-1 {
				if strings.ContainsAny(logs[key][i+1:], "0123456789") {
					numLogs = append(numLogs, logs[key])
				} else {
					wordLogs = append(wordLogs, logs[key])
				}
				break
			}
		}
	}
	sort.Sort(Logs(wordLogs))
	return append(wordLogs, numLogs...)
}
```

## 938.二叉搜索树的范围和(2)

- 题目

```
给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。
二叉搜索树保证具有唯一的值。
示例 1：输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32
示例 2：输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23
提示：
    树中的结点数量最多为 10000 个。
    最终的答案保证小于 2^31。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |
| 02   | 迭代 | O(n)       | O(n)       |

```go
func rangeSumBST(root *TreeNode, L int, R int) int {
	if root == nil {
		return 0
	}
	if root.Val < L {
		return rangeSumBST(root.Right, L, R)
	}
	if root.Val > R {
		return rangeSumBST(root.Left, L, R)
	}
	return root.Val + rangeSumBST(root.Right, L, R) + rangeSumBST(root.Left, L, R)
}

#
func rangeSumBST(root *TreeNode, L int, R int) int {
	if root == nil {
		return 0
	}
	stack := make([]*TreeNode, 0)
	if root.Val > R && root.Left != nil {
		stack = append(stack, root.Left)
	} else if root.Val < L && root.Right != nil {
		stack = append(stack, root.Right)
	} else {
		stack = append(stack, root)
	}
	res := 0
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node.Val <= R && node.Val >= L {
			if node.Left != nil {
				stack = append(stack, node.Left)
			}
			if node.Right != nil {
				stack = append(stack, node.Right)
			}
			res = res + node.Val
		} else if node.Val > R && node.Left != nil {
			stack = append(stack, node.Left)
		} else if node.Val < L && node.Right != nil {
			stack = append(stack, node.Right)
		}
	}
	return res
}
```

## 941.有效的山脉数组(2)

- 题目

```
定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。
让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：
    A.length >= 3
    在 0 < i < A.length - 1 条件下，存在 i 使得：
        A[0] < A[1] < ... A[i-1] < A[i]
        A[i] > A[i+1] > ... > A[A.length - 1]
示例 1：输入：[2,1] 输出：false
示例 2：输入：[3,5,5] 输出：false
示例 3：输入：[0,3,2,1] 输出：true
提示：
    0 <= A.length <= 10000
    0 <= A[i] <= 10000 
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 遍历        | O(n)       | O(1)       |
| 02   | 遍历-双指针 | O(n)       | O(1)       |

```go
func validMountainArray(A []int) bool {
	if len(A) < 3 {
		return false
	}
	pre := A[0]
	i := 0
	for i = 1; i < len(A); i++ {
		if pre < A[i] {
			pre = A[i]
		} else if pre == A[i] {
			return false
		} else {
			break
		}
	}
	if i >= len(A) || i == 1 {
		return false
	}
	for ; i < len(A); i++ {
		if pre > A[i] {
			pre = A[i]
		} else if pre == A[i] {
			return false
		} else {
			return false
		}
	}
	return true
}

#
func validMountainArray(A []int) bool {
	if len(A) < 3 {
		return false
	}
	i := 0
	j := len(A) - 1
	for i < j && A[i] < A[i+1] {
		i++
	}
	for i < j && A[j] < A[j-1] {
		j--
	}
	return i == j && i != 0 && j != len(A)-1
}
```

## 942.增减字符串匹配(1)

- 题目

```
给定只含 "I"（增大）或 "D"（减小）的字符串 S ，令 N = S.length。
返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有：
    如果 S[i] == "I"，那么 A[i] < A[i+1]
    如果 S[i] == "D"，那么 A[i] > A[i+1]
示例 1：输出："IDID" 输出：[0,4,1,3,2]
示例 2：输出："III" 输出：[0,1,2,3]
示例 3：输出："DDI" 输出：[3,2,0,1]
提示： 1 <= S.length <= 10000  S 只包含字符 "I" 或 "D"。
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 遍历-双指针 | O(n)       | O(n)       |

```go
func diStringMatch(S string) []int {
	res := make([]int, len(S)+1)
	left := 0
	right := len(S)
	for i := 0; i < len(S); i++ {
		if S[i] == 'I' {
			res[i] = left
			left++
		} else {
			res[i] = right
			right--
		}
	}
	res[len(S)] = left
	return res
}
```

## 944.删列造序(1)

- 题目

```
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。
你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，
然后请你返回 D.length 的最小可能值。
删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，
形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。（可以参见 删除操作范例）
示例 1：输入：["cba", "daf", "ghi"] 输出：1
解释： 当选择 D = {1}，删除后 A 的列为：["c","d","g"] 和 ["a","f","i"]，均为非降序排列。
若选择 D = {}，那么 A 的列 ["b","a","h"] 就不是非降序排列了。
示例 2：输入：["a", "b"] 输出：0 解释：D = {}
示例 3：输入：["zyx", "wvu", "tsr"] 输出：3 解释：D = {0, 1, 2}
提示：
    1 <= A.length <= 100
    1 <= A[i].length <= 1000
删除操作范例：
比如，有 A = ["abcdef", "uvwxyz"]，
要删掉的列为 {0, 2, 3}，删除后 A 为["bef", "vyz"]， 
A 的列分别为["b","v"], ["e","y"], ["f","z"]。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n^2)     | O(1)       |

```go
func minDeletionSize(A []string) int {
	res := 0
	if len(A) == 1 {
		return res
	}
	for i := 0; i < len(A[0]); i++ {
		for j := 1; j < len(A); j++ {
			if A[j][i] < A[j-1][i] {
				res++
				break
			}
		}
	}
	return res
}
```

## 949.给定数字能组成的最大时间(2)

- 题目

```
给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。
最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。
以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。
示例 1：输入：[1,2,3,4] 输出："23:41"
示例 2：输入：[5,5,5,5] 输出：""
提示：
    A.length == 4
    0 <= A[i] <= 9
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 暴力法 | O(1)       | O(1)       |
| 02   | 全排列 | O(1)       | O(1)       |

```go
func largestTimeFromDigits(A []int) string {
	res := ""
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			for k := 0; k < 4; k++ {
				for l := 0; l < 4; l++ {
					if i != j && i != k && i != l &&
						j != k && j != l && k != l {
						hour := A[i]*10 + A[j]
						minute := A[k]*10 + A[l]
						if hour <= 23 && minute <= 59 {
							ans := fmt.Sprintf("%02d:%02d", hour, minute)
							if ans > res && res != "" {
								res = ans
							} else if res == "" {
								res = ans
							}
						}
					}
				}
			}
		}
	}
	return res
}

#
var arr []string

func largestTimeFromDigits(A []int) string {
	res := ""
	arr = make([]string, 0)
	dfs(A, 0, len(A)-1)
	for i := range arr {
		if (arr[i] > res && res != "") || (res == "") {
			res = arr[i]
		}
	}
	return res
}

func dfs(A []int, start, length int) {
	if start == length {
		hour := A[0]*10 + A[1]
		minute := A[2]*10 + A[3]
		if hour <= 23 && minute <= 59 {
			ans := fmt.Sprintf("%02d:%02d", hour, minute)
			arr = append(arr, ans)
		}
	} else {
		for i := start; i <= length; i++ {
			A[i], A[start] = A[start], A[i]
			dfs(A, start+1, length)
			A[i], A[start] = A[start], A[i]
		}
	}
}
```

## 953.验证外星语词典(2)

- 题目

```
某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。
给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，
返回 true；否则，返回 false。
示例 1：
输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
示例 2：
输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
示例 3：
输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
输出：false
解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
提示：
    1 <= words.length <= 100
    1 <= words[i].length <= 20
    order.length == 26
    在 words[i] 和 order 中的所有字符都是英文小写字母。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 哈希辅助-替换 | O(n)       | O(n)       |
| 02   | 遍历比较      | O(n)       | O(1)       |

```go
func isAlienSorted(words []string, order string) bool {
	newWords := make([]string, len(words))
	m := make(map[byte]int)
	for i := 0; i < len(order); i++ {
		m[order[i]] = i
	}
	for i := 0; i < len(words); i++ {
		str := ""
		for j := 0; j < len(words[i]); j++ {
			str = str + string(m[words[i][j]]+'a')
		}
		newWords[i] = str
	}
	for i := 0; i < len(newWords)-1; i++ {
		if newWords[i] > newWords[i+1] {
			return false
		}
	}
	return true
}

#
func isAlienSorted(words []string, order string) bool {
	m := make(map[byte]int)
	for i := 0; i < len(order); i++ {
		m[order[i]] = i
	}

	for i := 0; i < len(words)-1; i++ {
		length := len(words[i])
		if len(words[i+1]) < length {
			length = len(words[i+1])
		}
		for j := 0; j < length; j++ {
			if m[words[i][j]] < m[words[i+1][j]] {
				break
			}
			if m[words[i][j]] > m[words[i+1][j]] {
				return false
			}
			if j == length-1 {
				if len(words[i]) > len(words[i+1]) {
					return false
				}
			}
		}
	}
	return true
}
```

## 961.重复 N 次的元素(5)

- 题目

```
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。
返回重复了 N 次的那个元素。
示例 1：输入：[1,2,3,3] 输出：3
示例 2：输入：[2,1,2,5,3,2] 输出：2
示例 3：输入：[5,1,5,2,5,3,5,4] 输出：5
提示：
    4 <= A.length <= 10000
    0 <= A[i] < 10000
    A.length 为偶数
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(n)       |
| 02   | 排序     | O(nlog(n)) | O(1)       |
| 03   | 哈希统计 | O(n)       | O(n)       |
| 04   | 遍历     | O(n)       | O(1)       |
| 05   | 暴力法   | O(n^2)     | O(1)       |

```go
func repeatedNTimes(A []int) int {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		if _, ok := m[A[i]]; ok {
			return A[i]
		}
		m[A[i]]++
	}
	return 0
}

#
func repeatedNTimes(A []int) int {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		if _, ok := m[A[i]]; ok {
			return A[i]
		}
		m[A[i]]++
	}
	return 0
}

#
func repeatedNTimes(A []int) int {
	m := make(map[int]int)
	for i := 0; i < len(A); i++ {
		m[A[i]]++
	}
	for key, value := range m {
		if value == len(A)/2 {
			return key
		}
	}
	return 0
}

# 4
func repeatedNTimes(A []int) int {
	for i := 0; i < len(A)-2; i++ {
		if A[i] == A[i+1] || A[i] == A[i+2] {
			return A[i]
		}
	}
	return A[len(A)-1]
}

# 5
func repeatedNTimes(A []int) int {
	for i := 0; i < len(A); i++ {
		for j := i + 1; j < len(A); j++ {
			if A[i] == A[j] {
				return A[i]
			}
		}
	}
	return A[len(A)-1]
}
```

## 965.单值二叉树(4)

- 题目

```
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回 true；否则返回 false。
示例 1：输入：[1,1,1,1,1,null,1] 输出：true
示例 2：输入：[2,2,2,5,2] 输出：false
提示：
    给定树的节点数范围是 [1, 100]。
    每个节点的值都是整数，范围为 [0, 99] 。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 递归-数组辅助 | O(n)       | O(n)       |
| 02   | 递归          | O(n)       | O(log(n))  |
| 03   | 递归          | O(n)       | O(log(n))  |
| 04   | 迭代          | O(n)       | O(n)       |

```go
var arr []int

func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	arr = make([]int, 0)
	dfs(root)
	for i := 1; i < len(arr); i++ {
		if arr[i] != arr[i-1] {
			return false
		}
	}
	return true
}

func dfs(root *TreeNode) {
	if root != nil {
		arr = append(arr, root.Val)
		dfs(root.Left)
		dfs(root.Right)
	}
}

#
var value int
var res bool

func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	res = true
	value = root.Val
	dfs(root)
	return res
}

func dfs(root *TreeNode) {
	if root != nil {
		if root.Val != value {
			res = false
			return
		}
		dfs(root.Left)
		dfs(root.Right)
	}
}

#
func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	if (root.Left != nil && root.Left.Val != root.Val) ||
		(root.Right != nil && root.Right.Val != root.Val) {
		return false
	}
	return isUnivalTree(root.Left) && isUnivalTree(root.Right)
}

#
func isUnivalTree(root *TreeNode) bool {
	if root == nil {
		return true
	}
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	value := root.Val
	for len(queue) > 0 {
		node := queue[len(queue)-1]
		queue = queue[:len(queue)-1]
		if node.Val != value {
			return false
		}
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	return true
}
```

## 970.强整数(2)

- 题目

```
给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，
那么我们认为该整数是一个强整数。
返回值小于或等于 bound 的所有强整数组成的列表。
你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。
示例 1：输入：x = 2, y = 3, bound = 10 输出：[2,3,4,5,7,9,10]
解释： 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2
示例 2：输入：x = 3, y = 5, bound = 15
输出：[2,4,6,8,10,14]
提示：
    1 <= x <= 100
    1 <= y <= 100
    0 <= bound <= 10^6
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度  |
| ---- | ---- | ---------- | ----------- |
| 01   | 遍历 | O(log(n))  | O(log(n)^2) |
| 02   | 遍历 | O(log(n))  | O(log(n)^2) |

```go
func powerfulIntegers(x int, y int, bound int) []int {
	res := make([]int, 0)
	m := make(map[int]int)
	if bound < 2 {
		return res
	}
	for i := 1; i < bound; i = i * x {
		for j := 1; i+j <= bound; j = j * y {
			if _, ok := m[i+j]; !ok {
				res = append(res, i+j)
				m[i+j] = 1
			}
			if y == 1 {
				break
			}
		}
		if x == 1 {
			break
		}
	}
	return res
}

#
func powerfulIntegers(x int, y int, bound int) []int {
	res := make([]int, 0)
	m := make(map[int]int)
	if bound < 2 {
		return res
	}
	xArr := make([]int, 0)
	yArr := make([]int, 0)
	for i := 1; i < bound; i = i * x {
		xArr = append(xArr, i)
		if x == 1 {
			break
		}
	}
	for i := 1; i < bound; i = i * y {
		yArr = append(yArr, i)
		if y == 1 {
			break
		}
	}
	for i := 0; i < len(xArr); i++ {
		for j := 0; j < len(yArr); j++ {
			if xArr[i]+yArr[j] <= bound && m[xArr[i]+yArr[j]] == 0 {
				res = append(res, xArr[i]+yArr[j])
				m[xArr[i]+yArr[j]] = 1
			}
		}
	}
	return res
}
```

## 976.三角形的最大周长(2)

- 题目

```
给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。
如果不能形成任何面积不为零的三角形，返回 0。
示例 1：输入：[2,1,2] 输出：5
示例 2：输入：[1,2,1] 输出：0
示例 3：输入：[3,2,3,4] 输出：10
示例 4：输入：[3,6,2,3] 输出：8
提示： 
3 <= A.length <= 10000
1 <= A[i] <= 10^6
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序     | O(nlog(n)) | O(1)       |
| 02   | 冒泡排序 | O(n^2)     | O(1)       |

```go
func largestPerimeter(A []int) int {
	sort.Ints(A)
	for i := len(A) - 3; i >= 0; i-- {
		if A[i]+A[i+1] > A[i+2] {
			return A[i] + A[i+1] + A[i+2]
		}
	}
	return 0
}

#
func largestPerimeter(A []int) int {
	if len(A) < 3 {
		return 0
	}
	for i := 0; i < len(A)-1; i++ {
		for j := 0; j < len(A)-1-i; j++ {
			if A[j] > A[j+1] {
				A[j], A[j+1] = A[j+1], A[j]
			}
		}
		if i >= 2 {
			index := len(A) - 1 - i
			if A[index]+A[index+1] > A[index+2] {
				return A[index] + A[index+1] + A[index+2]
			}
		}
	}
	if A[0]+A[1] > A[2] {
		return A[0] + A[1] + A[2]
	}
	return 0
}
```

## 977.有序数组的平方(3)

- 题目

```
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
示例 1：输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100]
示例 2：输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121]
提示：
    1 <= A.length <= 10000
    -10000 <= A[i] <= 10000
    A 已按非递减顺序排序。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 双指针       | O(n)       | O(n)       |
| 02   | 排序         | O(nlog(n)) | O(n)       |
| 03   | 直接插入排序 | O(n^2)     | O(n)       |

```go
func sortedSquares(A []int) []int {
	res := make([]int, len(A))
	i := 0
	j := len(A) - 1
	index := len(A) - 1
	for i <= j {
		if A[i]*A[i] < A[j]*A[j] {
			res[index] = A[j] * A[j]
			j--
		} else {
			res[index] = A[i] * A[i]
			i++
		}
		index--
	}
	return res
}

#
func sortedSquares(A []int) []int {
	res := make([]int, 0)
	for i := 0; i < len(A); i++ {
		res = append(res, A[i]*A[i])
	}
	sort.Ints(res)
	return res
}

#
func sortedSquares(A []int) []int {
	res := make([]int, len(A))
	res[0] = A[0] * A[0]
	j := 0
	for i := 1; i < len(A); i++ {
		value := A[i] * A[i]
		for j = i - 1; j >= 0; j-- {
			if value < res[j] {
				res[j+1] = res[j]
			} else {
				break
			}
		}
		res[j+1] = value
	}
	return res
}
```

## 985.查询后的偶数和(1)

- 题目

```
给出一个整数数组 A 和一个查询数组 queries。
对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，
我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。
（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）
返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。
示例：输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
输出：[8,6,2,4]
解释：开始时，数组为 [1,2,3,4]。
将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。
将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。
将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。
将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。

提示：
    1 <= A.length <= 10000
    -10000 <= A[i] <= 10000
    1 <= queries.length <= 10000
    -10000 <= queries[i][0] <= 10000
    0 <= queries[i][1] < A.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历模拟 | O(n)       | O(n)       |

```go
func sumEvenAfterQueries(A []int, queries [][]int) []int {
	res := make([]int, 0)
	sum := 0
	for _, value := range A {
		if value%2 == 0 {
			sum = sum + value
		}
	}
	for i := 0; i < len(queries); i++ {
		value := queries[i][0]
		index := queries[i][1]
		if A[index]%2 == 0 {
			sum = sum - A[index]
		}
		A[index] = A[index] + value
		if A[index]%2 == 0 {
			sum = sum + A[index]
		}
		res = append(res, sum)
	}
	return res
}
```

## 989.数组形式的整数加法(4)

- 题目

```
对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。
例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。
给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。
示例 1：输入：A = [1,2,0,0], K = 34 输出：[1,2,3,4]
解释：1200 + 34 = 1234

示例 2：
输入：A = [2,7,4], K = 181
输出：[4,5,5]
解释：274 + 181 = 455

示例 3：
输入：A = [2,1,5], K = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021

示例 4：
输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1
输出：[1,0,0,0,0,0,0,0,0,0,0]
解释：9999999999 + 1 = 10000000000

提示：
    1 <= A.length <= 10000
    0 <= A[i] <= 9
    0 <= K <= 10000
    如果 A.length > 1，那么 A[0] != 0
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组辅助 | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |
| 03   | 遍历     | O(n)       | O(n)       |
| 04   | 遍历     | O(n)       | O(n)       |

```go
func addToArrayForm(A []int, K int) []int {
	B := make([]int, 0)
	for K > 0 {
		B = append([]int{K % 10}, B...)
		K = K / 10
	}
	length := len(A)
	if len(B) > len(A) {
		length = len(B)
	}
	res := make([]int, length)
	flag := 0
	i := len(A) - 1
	j := len(B) - 1
	count := 0
	for i >= 0 && j >= 0 {
		sum := A[i] + B[j] + flag
		if sum >= 10 {
			sum = sum - 10
			flag = 1
		} else {
			flag = 0
		}
		res[length-1-count] = sum
		i--
		j--
		count++
	}
	for i >= 0 {
		sum := A[i] + flag
		if sum >= 10 {
			sum = sum - 10
			flag = 1
		} else {
			flag = 0
		}
		res[length-1-count] = sum
		i--
		count++
	}
	for j >= 0 {
		sum := B[j] + flag
		if sum >= 10 {
			sum = sum - 10
			flag = 1
		} else {
			flag = 0
		}
		res[length-1-count] = sum
		j--
		count++
	}
	if flag == 1 {
		return append([]int{1}, res...)
	}
	return res
}

#
func addToArrayForm(A []int, K int) []int {
	A[len(A)-1] = A[len(A)-1] + K
	carry := 0
	for i := len(A) - 1; i >= 0; i-- {
		carry = A[i] / 10
		A[i] = A[i] % 10
		if i > 0 {
			A[i-1] = A[i-1] + carry
		}
	}
	for carry > 0 {
		A = append([]int{carry % 10}, A...)
		carry = carry / 10
	}
	return A
}

#
func addToArrayForm(A []int, K int) []int {
	i := len(A) - 1
	res := make([]int, 0)
	for i >= 0 || K > 0 {
		if i >= 0 {
			K = K + A[i]
		}
		res = append(res, K%10)
		K = K / 10
		i--
	}
	for i := 0; i < len(res)/2; i++ {
		res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]
	}
	return res
}

#
func addToArrayForm(A []int, K int) []int {
	i := len(A) - 1
	res := make([]int, 0)
	for i >= 0 || K > 0 {
		if i >= 0 {
			K = K + A[i]
		}
		res = append([]int{K % 10}, res...)
		K = K / 10
		i--
	}
	return res
}
```

## 993.二叉树的堂兄弟节点(2)

- 题目

```
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。
示例 1：输入：root = [1,2,3,4], x = 4, y = 3 输出：false
示例 2：输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true
示例 3：输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false

提示：
    二叉树的节点数介于 2 到 100 之间。
    每个节点的值都是唯一的、范围为 1 到 100 的整数。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(log(n))  |
| 02   | 迭代 | O(n)       | O(n)       |
| 03   | 递归 | O(n)       | O(n)       |

```go
func isCousins(root *TreeNode, x int, y int) bool {
	xNode, xDepth := dfs(root, x, 0)
	yNode, yDepth := dfs(root, y, 0)
	return xDepth == yDepth && xNode != yNode
}

func dfs(root *TreeNode, value int, level int) (*TreeNode, int) {
	if root == nil {
		return nil, -1
	}
	if root.Val == value {
		return nil, 0
	}
	if (root.Left != nil && root.Left.Val == value) ||
		(root.Right != nil && root.Right.Val == value) {
		return root, level + 1
	}
	leftNode, leftLevel := dfs(root.Left, value, level+1)
	if leftNode != nil {
		return leftNode, leftLevel
	}
	return dfs(root.Right, value, level+1)
}

#
func isCousins(root *TreeNode, x int, y int) bool {
	if root == nil {
		return true
	}
	fatherM := make(map[int]int)
	levelM := make(map[int]int)
	queue := make([]*TreeNode, 0)
	queue = append(queue, root)
	level := 0
	for len(queue) > 0 {
		length := len(queue)
		for i := 0; i < length; i++ {
			node := queue[i]
			levelM[node.Val] = level
			if node.Left != nil {
				fatherM[node.Left.Val] = node.Val
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				fatherM[node.Right.Val] = node.Val
				queue = append(queue, node.Right)
			}
		}
		queue = queue[length:]
		level++
	}
	return levelM[x] == levelM[y] && fatherM[x] != fatherM[y]
}

#
var fatherM map[int]int
var levelM map[int]int

func isCousins(root *TreeNode, x int, y int) bool {
	fatherM = make(map[int]int)
	levelM = make(map[int]int)
	dfs(root, nil, 0)
	return levelM[x] == levelM[y] && fatherM[x] != fatherM[y]
}

func dfs(root *TreeNode, father *TreeNode, level int) {
	if root == nil {
		return
	}
	if father == nil {
		fatherM[root.Val] = 0
	} else {
		fatherM[root.Val] = father.Val
	}
	levelM[root.Val] = level
	dfs(root.Left, root, level+1)
	dfs(root.Right, root, level+1)
}
```

## 997.找到小镇的法官(2)

- 题目

```
在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。
如果小镇的法官真的存在，那么：
    小镇的法官不相信任何人。
    每个人（除了小镇法官外）都信任小镇的法官。
    只有一个人同时满足属性 1 和属性 2 。
给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。
如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。
示例 1：输入：N = 2, trust = [[1,2]] 输出：2
示例 2：输入：N = 3, trust = [[1,3],[2,3]] 输出：3
示例 3：输入：N = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1
示例 4：输入：N = 3, trust = [[1,2],[2,3]] 输出：-1
示例 5：输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] 输出：3
提示：
    1 <= N <= 1000
    trust.length <= 10000
    trust[i] 是完全不同的
    trust[i][0] != trust[i][1]
    1 <= trust[i][0], trust[i][1] <= N
```

- 解题思路 

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 遍历-数组辅助   | O(n)       | O(n)       |
| 02   | 遍历-双数组辅助 | O(n)       | O(n)       |

```go
func findJudge(N int, trust [][]int) int {
	arr := make([]int, N+1)
	for i := range trust {
		arr[trust[i][0]] = -1
		if arr[trust[i][1]] == -1 {
			continue
		}
		arr[trust[i][1]]++
	}
	for i := 1; i <= N; i++ {
		if arr[i] == N-1 {
			return i
		}
	}
	return -1
}

#
func findJudge(N int, trust [][]int) int {
	out := make([]int, N+1)
	in := make([]int, N+1)
	for i := range trust {
		out[trust[i][0]] = -1
		in[trust[i][1]]++
	}
	for i := 1; i <= N; i++ {
		// 出度为0，入度为N-1
		if out[i] == 0 && in[i] == N-1 {
			return i
		}
	}
	return -1
}
```

## 999.可以被一步捕获的棋子数(2)

- 题目

```
在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，
白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。
不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。

车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，
直到满足下列四个条件之一：
    棋手选择主动停下来。
    棋子因到达棋盘的边缘而停下。
    棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
    车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。
示例 1：输入：
[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],
[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：在本例中，车能够捕获所有的卒。
示例 2：输入：
[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],
[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],
[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],
[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：0
解释：象阻止了车捕获任何卒。
示例 3：输入：
[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],
[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],
[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],
[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释： 车可以捕获位置 b5，d6 和 f5 的卒。
提示：
    board.length == board[i].length == 8
    board[i][j] 可以是 'R'，'.'，'B' 或 'p'
    只有一个格子上存在 board[i][j] == 'R'
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(1)       | O(1)       |
| 02   | 遍历 | O(1)       | O(1)       |

```go
func numRookCaptures(board [][]byte) int {
	res := 0
	var x, y int
	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[0]); j++ {
			if board[i][j] == 'R' {
				x = i
				y = j
				break
			}
		}
	}
	// 向右
	for i := y; i < 8 && board[x][i] != 'B'; i++ {
		if board[x][i] == 'p' {
			res++
			break
		}
	}
	// 向左
	for i := y; i >= 0 && board[x][i] != 'B'; i-- {
		if board[x][i] == 'p' {
			res++
			break
		}
	}
	// 向下
	for i := x; i < 8 && board[i][y] != 'B'; i++ {
		if board[i][y] == 'p' {
			res++
			break
		}
	}
	// 向上
	for i := x; i >= 0 && board[i][y] != 'B'; i-- {
		if board[i][y] == 'p' {
			res++
			break
		}
	}
	return res
}

#
func numRookCaptures(board [][]byte) int {
	res := 0
	var x, y int
	var dx = []int{-1, 1, 0, 0}
	var dy = []int{0, 0, -1, 1}
	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[0]); j++ {
			if board[i][j] == 'R' {
				x = i
				y = j
				break
			}
		}
	}
	for i := 0; i < 4; i++ {
		newX := x + dx[i]
		newY := y + dy[i]
		for newX >= 0 && newX < len(board) && newY >= 0 && newY < len(board[0]) {
			if board[newX][newY] == 'B' {
				break
			}
			if board[newX][newY] == 'p' {
				res++
				break
			}
			newX = newX + dx[i]
			newY = newY + dy[i]
		}
	}
	return res
}
```

# 0901-1000-Medium

## 901.股票价格跨度(1)

- 题目

```
编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。
今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。
例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，
那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。
示例：
输入：["StockSpanner","next","next","next","next","next","next","next"], 
[[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。
注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
提示：
    调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
    每个测试用例最多可以调用  10000 次 StockSpanner.next。
    在所有测试用例中，最多调用 150000 次 StockSpanner.next。
    此问题的总时间限制减少了 50%。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 单调栈 | O(n)       | O(n)       |

```go
type StockSpanner struct {
	prices []int
	count  []int
}

func Constructor() StockSpanner {
	return StockSpanner{
		prices: make([]int, 0),
		count:  make([]int, 0),
	}
}

func (this *StockSpanner) Next(price int) int {
	res := 1
	for len(this.prices) > 0 && this.prices[len(this.prices)-1] <= price {
		this.prices = this.prices[:len(this.prices)-1]
		temp := this.count[len(this.count)-1]
		this.count = this.count[:len(this.count)-1]
		res = res + temp
	}
	this.prices = append(this.prices, price)
	this.count = append(this.count, res)
	return res
}
```

## 912.排序数组(7)

- 题目

```
给你一个整数数组 nums，请你将该数组升序排列。
示例 1：输入：nums = [5,2,3,1] 输出：[1,2,3,5]
示例 2：输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5]
提示：1 <= nums.length <= 50000
    -50000 <= nums[i] <= 50000
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 内置函数        | O(nlog(n)) | O(1)       |
| 02   | 插入排序        | O(n^2)     | O(1)       |
| 03   | 希尔排序        | O(n^1.3)   | O(1)       |
| 04   | 归并排序        | O(nlog(n)) | O(n)       |
| 05   | 快速排序        | O(nlog(n)) | O(log(n))  |
| 06   | 堆排序-内置heap | O(nlog(n)) | O(n)       |
| 07   | 堆排序          | O(nlog(n)) | O(log(n))  |

```go
func sortArray(nums []int) []int {
	sort.Ints(nums)
	return nums
}

# 2
func sortArray(nums []int) []int {
	for i := 1; i < len(nums); i++ {
		pos := i - 1 // 已经有序的最后一个下标
		cur := nums[i]
		for pos >= 0 && nums[pos] > cur {
			nums[pos+1] = nums[pos] // 后移
			pos--
		}
		nums[pos+1] = cur
	}
	return nums
}

# 3
func sortArray(nums []int) []int {
	n := len(nums)
	for gap := n / 2; gap > 0; gap = gap / 2 {
		for i := gap; i < n; i++ {
			j := i
			cur := nums[i]
			for j-gap >= 0 && cur < nums[j-gap] {
				nums[j] = nums[j-gap]
				j = j - gap
			}
			nums[j] = cur
		}
	}
	return nums
}

# 4
func sortArray(nums []int) []int {
	n := len(nums)
	if n < 2 {
		return nums
	}
	return merge(sortArray(nums[:len(nums)/2]), sortArray(nums[len(nums)/2:]))
}

func merge(left, right []int) []int {
	res := make([]int, 0)
	for len(left) > 0 && len(right) > 0 {
		if left[0] <= right[0] {
			res = append(res, left[0])
			left = left[1:]
		} else {
			res = append(res, right[0])
			right = right[1:]
		}
	}
	if len(left) > 0 {
		res = append(res, left...)
	}
	if len(right) > 0 {
		res = append(res, right...)
	}
	return res
}

# 5
func sortArray(nums []int) []int {
	quick(nums, 0, len(nums)-1)
	return nums
}

func quick(arr []int, left, right int) {
	if left >= right {
		return
	}
	index := partition(arr, left, right)
	quick(arr, left, index-1)
	quick(arr, index+1, right)
}

func partition(arr []int, left, right int) int {
	baseValue := arr[left] // 基准值
	for left < right {
		for baseValue <= arr[right] && left < right {
			right-- // 依次查找大于基准值的位置
		}
		arr[left] = arr[right]
		for arr[left] <= baseValue && left < right {
			left++ // 依次查找小于基准值的位置
		}
		arr[right] = arr[left]
	}
	arr[right] = baseValue
	return right
}

# 6
type IntHeap []int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h IntHeap) Less(i, j int) bool {
	return h[i] < h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

func sortArray(nums []int) []int {
	intHeap := make(IntHeap, 0)
	heap.Init(&intHeap)
	for i := 0; i < len(nums); i++ {
		heap.Push(&intHeap, nums[i])
	}
	res := make([]int, 0)
	for i := 0; i < len(nums); i++ {
		value := heap.Pop(&intHeap).(int)
		res = append(res, value)
	}
	return res
}

# 7
func sortArray(nums []int) []int {
	buildHeap(nums, len(nums))
	for i := len(nums) - 1; i > 0; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		heapModify(nums, 0, i-1)
	}
	return nums
}

func buildHeap(arr []int, length int) {
	for i := len(arr)/2 - 1; i >= 0; i-- {
		heapModify(arr, i, length-1)
	}
}

func heapModify(arr []int, start, end int) {
	temp := arr[start]
	for left := 2*start + 1; left <= end; left = 2*left + 1 {
		if left < end && arr[left] < arr[left+1] {
			left++
		}
		if arr[start] < arr[left] {
			arr[start] = arr[left]
			start = left
		}
		arr[start] = temp
	}
}
```

## 921.使括号有效的最少添加(3)

- 题目

```
给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），
以使得到的括号字符串有效。
从形式上讲，只有满足下面几点之一，括号字符串才是有效的：
    它是一个空字符串，或者
    它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
    它可以被写作 (A)，其中 A 是有效字符串。
给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。
示例 1：输入："())" 输出：1
示例 2：输入："(((" 输出：3
示例 3：输入："()" 输出：0
示例 4：输入："()))((" 输出：4
提示：S.length <= 1000  S 只包含 '(' 和 ')' 字符。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 栈辅助   | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |
| 03   | 内置函数 | O(n)       | O(1)       |

```go
func minAddToMakeValid(S string) int {
	stack := make([]byte,0)
	res := 0
	for i := 0; i < len(S); i++{
		if S[i] == '('{
			stack = append(stack, '(')
		}else {
			if len(stack) == 0{
				res++
			}else {
				stack = stack[:len(stack)-1]
			}
		}
	}
	return res+len(stack)
}

# 2
func minAddToMakeValid(S string) int {
	left := 0
	right := 0
	for i := 0; i < len(S); i++ {
		if S[i] == '(' {
			left++
		} else {
			if left > 0 {
				left--
			} else {
				right++
			}
		}
	}
	return left + right
}

# 3
func minAddToMakeValid(S string) int {
	for strings.Contains(S, "()") == true {
		S = strings.ReplaceAll(S, "()", "")
	}
	return len(S)
}
```

## 945.使数组唯一的最小增量(3)

- 题目

```
给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。
返回使 A 中的每个值都是唯一的最少操作次数。
示例 1:输入：[1,2,2] 输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
示例 2:输入：[3,2,1,2,1,7] 输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
提示：
    0 <= A.length <= 40000
    0 <= A[i] < 40000
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 排序遍历      | O(nlog(n)) | O(1)       |
| 02   | 计数          | O(n)       | O(n)       |
| 03   | 状态探测-递归 | O(n)       | O(n)       |

```go
func minIncrementForUnique(A []int) int {
	res := 0
	sort.Ints(A)
	for i := 0; i < len(A)-1; i++ {
		if A[i] >= A[i+1] {
			value := A[i] - A[i+1] + 1
			res = res + value
			A[i+1] = A[i+1] + value
		}
	}
	return res
}

# 2
func minIncrementForUnique(A []int) int {
	res := 0
	arr := make([]int, 80001)
	for i := 0; i < len(A); i++ {
		arr[A[i]]++
	}
	sum := 0
	for i := 0; i < len(arr); i++ {
		if arr[i] >= 2 {
			sum = sum + arr[i] - 1
			res = res - i*(arr[i]-1)
		} else if arr[i] == 0 && sum > 0 {
			sum--
			res = res + i
		}
	}
	return res
}

# 3
var arr []int

func minIncrementForUnique(A []int) int {
	res := 0
	arr = make([]int, 21)
	for i := 0; i < len(arr); i++ {
		arr[i] = -1
	}
	for i := 0; i < len(A); i++ {
		b := findNext(A[i])
		res = res + b - A[i]
	}
	return res
}

func findNext(a int) int {
	b := arr[a]
	if b == -1 {
		arr[a] = a
		return a
	}
	b = findNext(b + 1)
	arr[a] = b
	return b
}
```



## 946.验证栈序列(2)

- 题目

```
给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，
只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。
示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false
解释：1 不能在 2 之前弹出。
提示：
    0 <= pushed.length == popped.length <= 1000
    0 <= pushed[i], popped[i] < 1000
    pushed 是 popped 的排列。
```

- 解题思路 

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 栈辅助 | O(n)       | O(n)       |
| 02   | 栈辅助 | O(n)       | O(n)       |

```go
func validateStackSequences(pushed []int, popped []int) bool {
	stack := make([]int, 0)
	j := 0
	for i := 0; i < len(pushed); i++ {
		stack = append(stack, pushed[i])
		for len(stack) > 0 && stack[len(stack)-1] == popped[j] {
			stack = stack[:len(stack)-1]
			j++
		}
	}
	if len(stack) == 0 {
		return true
	}
	return false
}

# 2
func validateStackSequences(pushed []int, popped []int) bool {
	stack := make([]int, 0)
	res := false
	i := 0
	j := 0
	for j < len(popped) {
		for len(stack) == 0 || stack[len(stack)-1] != popped[j] {
			if i == len(pushed) {
				break
			}
			stack = append(stack, pushed[i])
			i++
		}
		if stack[len(stack)-1] != popped[j] {
			break
		}
		stack = stack[:len(stack)-1]
		j++
	}
	if len(stack) == 0 && j == len(popped) {
		res = true
	}
	return res
}
```

## 974.和可被K整除的子数组(2)

- 题目

```
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
示例：输入：A = [4,5,0,-2,-3,1], K = 5 输出：7
解释： 有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
提示： 1 <= A.length <= 30000
    -10000 <= A[i] <= 10000
    2 <= K <= 10000
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 前缀和-哈希辅助 | O(n)       | O(n)       |
| 02   | 前缀和-哈希辅助 | O(n)       | O(n)       |

```go
func subarraysDivByK(A []int, K int) int {
	m := make(map[int]int)
	m[0] = 1
	sum := 0
	res := 0
	for i := 0; i < len(A); i++ {
		sum = sum + A[i]
		value := (sum%K + K) % K
		res = res + m[value]
		m[value]++
	}
	return res
}

# 2
func subarraysDivByK(A []int, K int) int {
	m := make(map[int]int)
	m[0] = 1
	sum := 0
	res := 0
	for i := 0; i < len(A); i++ {
		sum = sum + A[i]
		value := (sum%K + K) % K
		m[value]++
	}
	for _, v := range m {
		res = res + v*(v-1)/2
	}
	return res
}
```

## 983.最低票价(3)

- 题目

```
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。
在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
    一张为期一天的通行证售价为 costs[0] 美元；
    一张为期七天的通行证售价为 costs[1] 美元；
    一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，
那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
示例 1：输入：days = [1,4,6,7,8,20], costs = [2,7,15] 输出：11
解释：  例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
示例 2：输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] 输出：17
解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
你总共花了 $17，并完成了你计划的每一天旅行。
提示：1 <= days.length <= 365
    1 <= days[i] <= 365
    days 按顺序严格递增
    costs.length == 3
    1 <= costs[i] <= 1000
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 动态规划-递归 | O(n)       | O(n)       |
| 02   | 动态规划      | O(n)       | O(n)       |
| 03   | 动态规划      | O(n)       | O(n)       |

```go
var dp [366]int
var m map[int]bool

func mincostTickets(days []int, costs []int) int {
	dp = [366]int{}
	m = make(map[int]bool)
	for i := 0; i < len(days); i++ {
		m[days[i]] = true
	}
	return dfs(1, costs)
}

func dfs(day int, costs []int) int {
	if day > 365 {
		return 0
	}
	if dp[day] > 0 {
		return dp[day]
	}
	if m[day] == true {
		dp[day] = min(min(dfs(day+1, costs)+costs[0], dfs(day+7, costs)+costs[1]),
			dfs(day+30, costs)+costs[2])
	} else {
		dp[day] = dfs(day+1, costs)
	}
	return dp[day]
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

# 2
var dp [366]int
var duration = []int{1, 7, 30}

func mincostTickets(days []int, costs []int) int {
	dp = [366]int{}
	return dfs(0, costs, days)
}

func dfs(day int, costs []int, days []int) int {
	if day >= len(days) {
		return 0
	}
	if dp[day] > 0 {
		return dp[day]
	}
	dp[day] = math.MaxInt32
	j := day
	for i := 0; i < 3; i++ {
		for ; j < len(days) && days[j] < days[day]+duration[i]; j++ {
		}
		dp[day] = min(dp[day], dfs(j, costs, days)+costs[i])
	}
	return dp[day]
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

# 3
func mincostTickets(days []int, costs []int) int {
	n := days[len(days)-1] + 1
	dp := make([]int, n)
	for i := 0; i < len(days); i++ {
		dp[days[i]] = 1 // 出行日
	}
	for i := 1; i < n; i++ {
		if dp[i] > 0 {
			dp[i] = min(dp[i-1]+costs[0],
				min(dp[max(i-7, 0)]+costs[1], dp[max(i-30, 0)]+costs[2]))
		} else {
			dp[i] = dp[i-1]
		}
	}
	return dp[n-1]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
```



## 994.腐烂的橘子(2)

- 题目

```
在给定的网格中，每个单元格可以有以下三个值之一：
    值 0 代表空单元格；
    值 1 代表新鲜橘子；
    值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
示例 1：输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4
示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
示例 3：输入：[[0,2]] 输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
提示：
    1 <= grid.length <= 10
    1 <= grid[0].length <= 10
    grid[i][j] 仅为 0、1 或 2
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 广度优先搜索 | O(n^2)     | O(n^2)     |
| 02   | 广度优先搜索 | O(n^2)     | O(n^2)     |

```go
// 上、右、下、左
var dx = []int{0, 1, 0, -1}
var dy = []int{1, 0, -1, 0}

func orangesRotting(grid [][]int) int {
	queue := make([][]int, 0)
	count := 0
	times := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[i]); j++ {
			if grid[i][j] == 2 {
				queue = append(queue, []int{i, j})
			} else if grid[i][j] == 1 {
				count = count + 1
			}
		}
	}
	for len(queue) > 0 && count > 0 {
		times++
		length := len(queue)
		for i := 0; i < length; i++ {
			for j := 0; j < 4; j++ {
				x := queue[i][0] + dx[j]
				y := queue[i][1] + dy[j]
				if x >= 0 && x < len(grid) && 
					y >= 0 && y < len(grid[0]) && grid[x][y] == 1 {
					grid[x][y] = 2
					queue = append(queue, []int{x, y})
					count--
				}
			}
		}
		queue = queue[length:]
	}
	if count > 0 {
		return -1
	}
	return times
}

# 2
// 上、右、下、左
var dx = []int{0, 1, 0, -1}
var dy = []int{1, 0, -1, 0}

func orangesRotting(grid [][]int) int {
	queue := make([][]int, 0)
	count := 0
	times := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[i]); j++ {
			if grid[i][j] == 2 {
				queue = append(queue, []int{i, j})
			} else if grid[i][j] == 1 {
				count = count + 1
			}
		}
	}
	for len(queue) > 0 {
		times++
		length := len(queue)
		for i := 0; i < length; i++ {
			for j := 0; j < 4; j++ {
				x := queue[i][0] + dx[j]
				y := queue[i][1] + dy[j]
				if x >= 0 && x < len(grid) &&
					y >= 0 && y < len(grid[0]) && grid[x][y] == 1 {
					grid[x][y] = 2
					queue = append(queue, []int{x, y})
					count--
				}
			}
		}
		queue = queue[length:]
		if len(queue) == 0 {
			times--
		}
	}
	if count > 0 {
		return -1
	}
	return times
}
```

# 0901-1000-Hard

## 956.最高的广告牌(5)

- 题目

```
你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。
举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。
示例 1：输入：[1,2,3,6] 输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：输入：[1,2,3,4,5,6] 输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
示例 3：输入：[1,2] 输出：0
解释：没法安装广告牌，所以返回 0。
提示：0 <= rods.length <= 20
    1 <= rods[i] <= 1000
    钢筋的长度总和最多为 5000
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 动态规划-递归 | O(3^n)     | O(n^2)     |
| 02   | 动态规划      | O(3^n)     | O(n)       |
| 03   | 动态规划      | O(3^n)     | O(n)       |
| 04   | 动态规划      | O(3^n)     | O(n^2)     |
| 05   | 折半搜索      | O(3^(n/2)) | O(3^(n/2)) |

```go
const MinValue = math.MinInt32 / 100

// 官方题解(从后往前比较难理解)
// dp[i][s] 表示当我们可以使用 rods[j] (j >= i) 时能得到的最大 score
// dp[i][s] = max(dp[i+1][s], dp[i+1][s-rods[i]], rods[i] + dp[i+1][s+rods[i]])
// 例如:rods=[1,2,3,6],可以有dp[1][1]=5,
// 在写下1之后,可以写下+2,+3,-6使得剩下的rods[i:]获得score为5
var dp [][]int

func tallestBillboard(rods []int) int {
	dp = make([][]int, len(rods))
	for i := 0; i < len(rods); i++ {
		dp[i] = make([]int, 10001)
	}
	res := dfs(rods, 0, 5000)
	return res
}

func dfs(rods []int, index, total int) int {
	if index == len(rods) {
		if total == 5000 {
			return 0
		}
		return MinValue
	}
	if dp[index][total] != 0 {
		return dp[index][total]
	}
	res := dfs(rods, index+1, total)
	res = max(res, dfs(rods, index+1, total-rods[index]))
	res = max(res, dfs(rods, index+1, total+rods[index])+rods[index])
	dp[index][total] = res
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func tallestBillboard(rods []int) int {
	dp := make(map[int]int) // 保存和为i中正整数的和
	dp[0] = 0
	// 每个rods[i]有3个选择，+rods[i]、-rods[i]、0
	for i := 0; i < len(rods); i++ {
		value := rods[i]
		temp := make(map[int]int)
		for k, v := range dp {
			temp[k+value] = max(temp[k+value], v+value) // +value>0，是正整数，需要加上
			temp[k] = max(temp[k], v)
			temp[k-value] = max(temp[k-value], v) // -value<0，不需要加上
		}
		dp = temp
	}
	return dp[0]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func tallestBillboard(rods []int) int {
	dp := make(map[int]int) // 保存高度差为i时最低一边的高度
	dp[0] = 0
	// 每个rods[i]有3个选择，+rods[i]、-rods[i]、0
	for i := 0; i < len(rods); i++ {
		temp := make(map[int]int)
		for k, v := range dp {
			temp[k] = v
		}
		for k, v := range temp {
			dp[k+rods[i]] = max(dp[k+rods[i]], v)                           // 往高的一侧加，高度差变大，但最低一边高度不变
			dp[k] = dp[k]                                                   // 不加，高度差不变，可忽略
			dp[abs(k-rods[i])] = max(dp[abs(k-rods[i])], v+min(k, rods[i])) // 往低的一侧加，高度差有变化，高度差有增长
		}
	}
	return dp[0]
}

func abs(a int) int {
	if a >= 0 {
		return a
	}
	return -a
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 4
// dp[i][s] 表示当我们可以使用 rods[j] (j >= i) 时能得到的最大 score
// dp[i][s] = max(dp[i+1][s], dp[i+1][s-rods[i]], rods[i] + dp[i+1][s+rods[i]])
// 例如:rods=[1,2,3,6],可以有dp[1][1]=5,
// 在写下1之后,可以写下+2,+3,-6使得剩下的rods[i:]获得score为5
const MinValue = math.MinInt32 / 100

func tallestBillboard(rods []int) int {
	dp := make([][]int, len(rods)+1)
	for i := 0; i < len(rods)+1; i++ {
		dp[i] = make([]int, 10001)
	}
	for j := 0; j < len(dp[len(rods)]); j++ {
		dp[len(rods)][j] = MinValue
	}
	sum := 0
	for i := 0; i < len(rods); i++ {
		sum = sum + rods[i]
	}
	m := 2*sum
	dp[len(rods)][sum] = 0
	for i := len(rods) - 1; i >= 0; i-- {
		for s := rods[i]; s <= m-rods[i]; s++ {
			dp[i][s] = max(dp[i+1][s], max(dp[i+1][s-rods[i]], rods[i]+dp[i+1][s+rods[i]]))
		}
	}
	return dp[0][sum]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 5
func tallestBillboard(rods []int) int {
	leftM := makeM(rods, 0, len(rods)/2)
	rightM := makeM(rods, len(rods)/2, len(rods))
	res := 0
	for k := range leftM {
		if rightM[k] > 0 {
			res = max(res, leftM[k]+rightM[-k])
		}
	}
	return res
}

func makeM(rods []int, left, right int) map[int]int {
	dp := make([][2]int, 100001)
	dp[0] = [2]int{0, 0}
	count := 1
	for i := left; i < right; i++ {
		length := count
		for j := 0; j < length; j++ {
			dp[count] = [2]int{dp[j][0] + rods[i], dp[j][1]}
			count++
			dp[count] = [2]int{dp[j][0], dp[j][1] + rods[i]}
			count++
		}
	}
	m := make(map[int]int)
	for i := 0; i < count; i++ {
		a := dp[i][0]
		b := dp[i][1]
		m[a-b] = max(m[a-b], a)
	}
	return m
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

