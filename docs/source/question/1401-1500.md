# 1401-1500-Easy

* [1401\-1500\-Easy](#1401-1500-easy)
  * [1403\.非递增顺序的最小子序列(2)](#1403%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%972)
  * [1408\.数组中的字符串匹配(3)](#1408%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D3)
  * [1413\.逐步求和得到正数的最小值(2)](#1413%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC2)
  * [1417\.重新格式化字符串(2)](#1417%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B22)
  * [1422\.分割字符串的最大得分(3)](#1422%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%863)
  * [1431\.拥有最多糖果的孩子(2)](#1431%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%902)
  * [1436\.旅行终点站(4)](#1436%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%994)
  * [1441\.用栈操作构建数组(2)](#1441%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%842)
  * [1446\.连续字符(2)](#1446%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A62)
  * [1450\.在既定时间做作业的学生人数(1)](#1450%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B01)
  * [1455\.检查单词是否为句中其他单词的前缀(2)](#1455%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%802)
  * [1460\.通过翻转子数组使两个数组相等(3)](#1460%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%893)
  * [1464\.数组中两元素的最大乘积(3)](#1464%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF3)
  * [1470\.重新排列数组(2)](#1470%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%842)
  * [1475\.商品折扣后的最终价格(2)](#1475%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC2)
  * [1480\.一维数组的动态和(2)](#1480%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C2)
  * [1486\.数组异或操作(1)](#1486%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C1)
  * [1491\.去掉最低工资和最高工资后的工资平均值(2)](#1491%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B7%A5%E8%B5%84%E5%B9%B3%E5%9D%87%E5%80%BC2)
  * [1496\.判断路径是否相交(1)](#1496%E5%88%A4%E6%96%AD%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A41)
* [1401\-1500\-Medium](#1401-1500-medium)
  * [1418\.点菜展示表(1)](#1418%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A81)
  * [1442\.形成两个异或相等数组的三元组数目(3)](#1442%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE3)
  * [1487\.保证文件名唯一(2)](#1487%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%802)
  * [1492\.n的第k个因子(2)](#1492n%E7%9A%84%E7%AC%ACk%E4%B8%AA%E5%9B%A0%E5%AD%902)
  * [1493\.删掉一个元素以后全为 1 的最长子数组(3)](#1493%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA-1-%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%843)

## 1403.非递增顺序的最小子序列(2)

- 题目

```
给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，
也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。
示例 1：输入：nums = [4,3,10,9,8] 输出：[10,9] 
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。
但是 [10,9] 的元素之和最大。 
示例 2：输入：nums = [4,4,7,6,7] 输出：[7,7,6] 
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。
因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  
示例 3：输入：nums = [6] 输出：[6]
提示：
    1 <= nums.length <= 500
    1 <= nums[i] <= 100
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |
| 02   | 排序遍历 | O(nlog(n)) | O(1)       |

```go
func minSubsequence(nums []int) []int {
	sort.Ints(nums)
	sum := 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	target := sum / 2
	sum = 0
	res := make([]int, 0)
	for i := len(nums) - 1; i >= 0; i-- {
		if sum <= target {
			res = append(res, nums[i])
			sum = sum + nums[i]
		}
	}
	return res
}

#
func minSubsequence(nums []int) []int {
	sort.Slice(nums, func(i, j int) bool {
		return nums[i] > nums[j]
	})
	sum := 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
	}
	target := sum / 2
	sum = 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
		if sum > target {
			return nums[:i+1]
		}
	}
	return nil
}
```

## 1408.数组中的字符串匹配(3)

- 题目

```
给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。
请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，
那么字符串 words[i] 就是 words[j] 的一个子字符串。
示例 1：输入：words = ["mass","as","hero","superhero"] 输出：["as","hero"]
解释："as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。
["hero","as"] 也是有效的答案。
示例 2：输入：words = ["leetcode","et","code"] 输出：["et","code"]
解释："et" 和 "code" 都是 "leetcode" 的子字符串。
示例 3：输入：words = ["blue","green","bu"] 输出：[]
提示：
    1 <= words.length <= 100
    1 <= words[i].length <= 30
    words[i] 仅包含小写英文字母。
    题目数据 保证 每个 words[i] 都是独一无二的。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 遍历-内置函数 | O(n^3)     | O(n)       |
| 02   | 遍历-内置函数 | O(n^3)     | O(n)       |
| 03   | 排序          | O(n^3)     | O(n)       |

```go
func stringMatching(words []string) []string {
	res := make([]string, 0)
	m := make(map[string]bool)
	for i := 0; i < len(words); i++ {
		for j := i + 1; j < len(words); j++ {
			if strings.Contains(words[i], words[j]) {
				if _, ok := m[words[j]]; !ok {
					res = append(res, words[j])
					m[words[j]] = true
				}
			} else if strings.Contains(words[j], words[i]) {
				if _, ok := m[words[i]]; !ok {
					res = append(res, words[i])
					m[words[i]] = true
				}
			}
		}
	}
	return res
}

#
func stringMatching(words []string) []string {
	res := make([]string, 0)
	for i := 0; i < len(words); i++ {
		for j := 0; j < len(words); j++ {
			if i != j && strings.Contains(words[j], words[i]) {
				res = append(res, words[i])
				break
			}
		}
	}
	return res
}

#
func stringMatching(words []string) []string {
	sort.Slice(words, func(i, j int) bool {
		return len(words[i]) < len(words[j])
	})
	res := make([]string, 0)
	for i := 0; i < len(words); i++ {
		for j := i + 1; j < len(words); j++ {
			if strings.Contains(words[j], words[i]) {
				res = append(res, words[i])
				break
			}
		}
	}
	return res
}
```

## 1413.逐步求和得到正数的最小值(2)

- 题目

```
给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。
你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。
请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。
示例 1：输入：nums = [-3,2,-3,4,2] 输出：5
解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。
                累加求和
                startValue = 4 | startValue = 5 | nums
                  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
示例 2：输入：nums = [1,2] 输出：1
解释：最小的 startValue 需要是正数。
示例 3：输入：nums = [1,-2,-3] 输出：5
提示：
    1 <= nums.length <= 100
    -100 <= nums[i] <= 100
```

- 解题思路 

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func minStartValue(nums []int) int {
	min := nums[0]
	sum := nums[0]
	for i := 1; i < len(nums); i++ {
		sum = sum + nums[i]
		if sum < min {
			min = sum
		}
	}
	if min >= 0 {
		return 1
	}
	return 1 - min
}

#
func minStartValue(nums []int) int {
	res := 1
	sum := 0
	for i := 0; i < len(nums); i++ {
		sum = sum + nums[i]
		if sum+res < 1 {
			res = 1 - sum
		}
	}
	return res
}
```

## 1417.重新格式化字符串(2)

- 题目

```
给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。
请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。
也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。
请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。
示例 1：输入：s = "a0b1c2" 输出："0a1b2c"
解释："0a1b2c" 中任意两个相邻字符的类型都不同。 
"a0b1c2", "0a1b2c", "0c2a1b" 也是满足题目要求的答案。
示例 2：输入：s = "leetcode" 输出：""
解释："leetcode" 中只有字母，所以无法满足重新格式化的条件。
示例 3：输入：s = "1229857369" 输出：""
解释："1229857369" 中只有数字，所以无法满足重新格式化的条件。
示例 4：输入：s = "covid2019" 输出："c2o0v1i9d"
示例 5：输入：s = "ab123" 输出："1a2b3"
提示：
    1 <= s.length <= 500
    s 仅由小写英文字母和/或数字组成。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |
| 02   | 遍历 | O(n)       | O(n)       |

```go
func reformat(s string) string {
	arr := make([]byte, 0)
	str := make([]byte, 0)
	res := ""
	for i := 0; i < len(s); i++ {
		if s[i] >= '0' && s[i] <= '9' {
			arr = append(arr, s[i])
		} else {
			str = append(str, s[i])
		}
	}
	if abs(len(arr), len(str)) > 1 {
		return res
	} else {
		length := len(arr)
		if len(str) < length {
			length = len(str)
		}
		for i := 0; i < length; i++ {
			res = res + string(arr[i])
			res = res + string(str[i])
		}
		if length == len(str) && length < len(arr) {
			res = res + string(arr[length])
		} else if length == len(arr) && length < len(str) {
			res = string(str[length]) + res
		}
	}
	return res
}

func abs(a, b int) int {
	if a > b {
		return a - b
	}
	return b - a
}

#
func reformat(s string) string {
	res := make([]byte, 0)
	m1 := make([]byte, 0)
	m2 := make([]byte, 0)
	for i := range s {
		if s[i] >= '0' && s[i] <= '9' {
			m1 = append(m1, s[i])
		} else {
			m2 = append(m2, s[i])
		}
	}
	if len(m1)-len(m2) == 1 {
		for i := 0; i < len(m2); i++ {
			res = append(res, m1[i])
			res = append(res, m2[i])
		}
		res = append(res, m1[len(m1)-1])
		return string(res)
	} else if len(m2)-len(m1) == 1 {
		for i := 0; i < len(m1); i++ {
			res = append(res, m2[i])
			res = append(res, m1[i])
		}
		res = append(res, m2[len(m2)-1])
		return string(res)
	} else if len(m2) == len(m1) {
		for i := 0; i < len(m1); i++ {
			res = append(res, m2[i])
			res = append(res, m1[i])
		}
		return string(res)
	} else {
		return ""
	}
}
```

## 1422.分割字符串的最大得分(3)

- 题目

```
给你一个由若干 0 和 1 组成的字符串 s ，
请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。
「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。
示例 1：输入：s = "011101" 输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3
示例 2：输入：s = "00111" 输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5
示例 3：输入：s = "1111" 输出：3
提示：
2 <= s.length <= 500
字符串 s 仅由字符 '0' 和 '1' 组成。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n)       | O(1)       |
| 02   | 暴力法   | O(n^2)     | O(1)       |
| 03   | 数组辅助 | O(n)       | O(n)       |

```go
func maxScore(s string) int {
	one := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '1' {
			one++
		}
	}
	max := 0
	zero := 0
	for i := 0; i < len(s)-1; i++ {
		if s[i] == '1' {
			one--
		} else {
			zero++
		}
		if one+zero > max {
			max = one + zero
		}
	}
	return max
}

#
func maxScore(s string) int {
	max := 0
	for i := 0; i < len(s)-1; i++ {
		zero := 0
		one := 0
		for j := 0; j <= i; j++ {
			if s[j] == '0' {
				zero++
			}
		}
		for j := i + 1; j < len(s); j++ {
			if s[j] == '1' {
				one++
			}
		}
		if zero+one > max {
			max = zero + one
		}
	}
	return max
}

#
func maxScore(s string) int {
	max := 0
	arr := make([]int, len(s)+1)
	for i := 0; i < len(s); i++ {
		if s[i] == '1' {
			arr[i+1] = arr[i] + 1
		} else {
			arr[i+1] = arr[i]
		}
	}
	for i := 1; i < len(s); i++ {
		zero := i - arr[i]
		one := arr[len(s)] - arr[i]
		v := zero + one
		if v > max {
			max = v
		}
	}
	return max
}
```

## 1431.拥有最多糖果的孩子(2)

- 题目

```
给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。
对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。
注意，允许有多个孩子同时拥有 最多 的糖果数目。
示例 1：输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 
解释：
孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
示例 2：输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 
解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。
示例 3：输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true]
提示：
    2 <= candies.length <= 100
    1 <= candies[i] <= 100
    1 <= extraCandies <= 50
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历比较 | O(n)       | O(n)       |
| 02   | 暴力法   | O(n^2)     | O(n)       |

```go
func kidsWithCandies(candies []int, extraCandies int) []bool {
	res := make([]bool, len(candies))
	max := 0
	for i := 0; i < len(candies); i++ {
		if candies[i] > max {
			max = candies[i]
		}
	}
	for i := 0; i < len(candies); i++ {
		if candies[i]+extraCandies >= max {
			res[i] = true
		}
	}
	return res
}

#
func kidsWithCandies(candies []int, extraCandies int) []bool {
	res := make([]bool, len(candies))
	for i := 0; i < len(candies); i++ {
		flag := true
		for j := 0; j < len(candies); j++ {
			if candies[i]+extraCandies < candies[j] {
				flag = false
				res[i] = false
				break
			}
		}
		if flag == true {
			res[i] = true
		}
	}
	return res
}
```

## 1436.旅行终点站(4)

- 题目

```
给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，
其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。
请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。
题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。
示例 1：
输入：paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
输出："Sao Paulo" 
解释：从 "London" 出发，最后抵达终点站 "Sao Paulo" 。
本次旅行的路线是 "London" -> "New York" -> "Lima" -> "Sao Paulo" 。
示例 2：输入：paths = [["B","C"],["D","B"],["C","A"]] 输出："A"
解释：所有可能的线路是：
"D" -> "B" -> "C" -> "A". 
"B" -> "C" -> "A". 
"C" -> "A". 
"A". 
显然，旅行终点站是 "A" 。
示例 3：输入：paths = [["A","Z"]] 输出："Z"
提示：

    1 <= paths.length <= 100
    paths[i].length == 2
    1 <= cityAi.length, cityBi.length <= 10
    cityAi != cityBi
    所有字符串均由大小写英文字母和空格字符组成。
```

- 解题思路

| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- | ---------- |
| 01   | 哈希辅助   | O(n)       | O(n)       |
| 02   | 哈希辅助   | O(n)       | O(n)       |
| 03   | 出入度计算 | O(n)       | O(n)       |
| 04   | 暴力法     | O(n^2)     | O(1)       |

```go
func destCity(paths [][]string) string {
	m := make(map[string]string)
	for i := 0; i < len(paths); i++ {
		m[paths[i][0]] = paths[i][1]
	}
	for _, v := range m {
		if _, ok := m[v]; !ok {
			return v
		}
	}
	return ""
}

#
func destCity(paths [][]string) string {
	m := make(map[string]bool)
	for i := 0; i < len(paths); i++ {
		m[paths[i][1]] = true
	}
	for i := 0; i < len(paths); i++ {
		m[paths[i][0]] = false
	}
	for key, value := range m {
		if value == true {
			return key
		}
	}
	return ""
}

#
func destCity(paths [][]string) string {
	m := make(map[string]int)
	for i := 0; i < len(paths); i++ {
		m[paths[i][1]] -= 1
		m[paths[i][0]] += 1

	}
	for key, value := range m {
		if value == -1 {
			return key
		}
	}
	return ""
}

#
func destCity(paths [][]string) string {
	for i := 0; i < len(paths); i++{
		flag := false
		for j := 0; j < len(paths); j++{
			if j == i {
				continue
			}
			if paths[i][1] == paths[j][0]{
				flag = true
				break
			}
		}
		if flag == false{
			return paths[i][1]
		}
	}
	return ""
}
```

## 1441.用栈操作构建数组(2)

- 题目

```
给你一个目标数组 target 和一个整数 n。每次迭代，需要从  list = {1,2,3..., n} 中依序读取一个数字。
请使用下述操作来构建目标数组 target ：
    Push：从 list 中读取一个新元素， 并将其推入数组中。
    Pop：删除数组中的最后一个元素。
    如果目标数组构建完成，就停止读取更多元素。
题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。
请返回构建目标数组所用的操作序列。
题目数据保证答案是唯一的。
示例 1：输入：target = [1,3], n = 3 输出：["Push","Push","Pop","Push"]
解释： 
读取 1 并自动推入数组 -> [1]
读取 2 并自动推入数组，然后删除它 -> [1]
读取 3 并自动推入数组 -> [1,3]
示例 2：输入：target = [1,2,3], n = 3 输出：["Push","Push","Push"]
示例 3：输入：target = [1,2], n = 4 输出：["Push","Push"]
解释：只需要读取前 2 个数字就可以停止。
示例 4：输入：target = [2,3,4], n = 4 输出：["Push","Pop","Push","Push","Push"]
提示：
    1 <= target.length <= 100
    1 <= target[i] <= 100
    1 <= n <= 100
    target 是严格递增的
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 双指针 | O(n)       | O(n)       |
| 02   | 双指针 | O(n)       | O(n)       |

```go
func buildArray(target []int, n int) []string {
	res := make([]string, 0)
	j := 0
	for i := 1; i <= n; i++ {
		if j >= len(target) {
			break
		}
		if target[j] != i {
			res = append(res, "Push")
			res = append(res, "Pop")
		} else {
			res = append(res, "Push")
			j++
		}
	}
	return res
}

#
func buildArray(target []int, n int) []string {
	res := make([]string, 0)
	j := 1
	for i := 0; i < len(target); i++ {
		for ; j < target[i]; j++ {
			res = append(res, "Push")
			res = append(res, "Pop")
		}
		res = append(res, "Push")
		j++
	}
	return res
}
```

## 1446.连续字符(2)

- 题目

```
给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。
请你返回字符串的能量。
示例 1：输入：s = "leetcode" 输出：2
解释：子字符串 "ee" 长度为 2 ，只包含字符 'e' 。
示例 2：输入：s = "abbcccddddeeeeedcba" 输出：5
解释：子字符串 "eeeee" 长度为 5 ，只包含字符 'e' 。
示例 3：输入：s = "triplepillooooow" 输出：5
示例 4：输入：s = "hooraaaaaaaaaaay" 输出：11
示例 5：输入：s = "tourist" 输出：1
提示：
    1 <= s.length <= 500
    s 只包含小写英文字母。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 遍历   | O(n)       | O(1)       |
| 02   | 双指针 | O(n)       | O(1)       |

```go
func maxPower(s string) int {
	max := 1
	count := 1
	for i := 1; i < len(s); i++ {
		if s[i] == s[i-1] {
			count++
		} else {
			count = 1
		}
		if count > max {
			max = count
		}
	}
	return max
}

#
func maxPower(s string) int {
	max := 1
	left := 0
	right := 1
	for right < len(s) {
		if s[left] != s[right] {
			if right-left > max {
				max = right - left
			}
			left = right
		}
		right++
	}
	if right-left > max {
		return right - left
	}
	return max
}
```

## 1450.在既定时间做作业的学生人数(1)

- 题目

```
给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。
已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。
请返回在查询时间 queryTime 时正在做作业的学生人数。
形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。
示例 1：输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 输出：1
解释：一共有 3 名学生。
第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。
第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。
第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。
示例 2：输入：startTime = [4], endTime = [4], queryTime = 4 输出：1
解释：在查询时间只有一名学生在做作业。
示例 3：输入：startTime = [4], endTime = [4], queryTime = 5 输出：0
示例 4：输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7 输出：0
示例 5：输入：startTime = [9,8,7,6,5,4,3,2,1], 
endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
输出：5
提示：

    startTime.length == endTime.length
    1 <= startTime.length <= 100
    1 <= startTime[i] <= endTime[i] <= 1000
    1 <= queryTime <= 1000
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
func busyStudent(startTime []int, endTime []int, queryTime int) int {
	res := 0
	for i := 0; i < len(startTime); i++ {
		if queryTime >= startTime[i] && queryTime <= endTime[i] {
			res++
		}
	}
	return res
}
```

## 1455.检查单词是否为句中其他单词的前缀(2)

- 题目

```
给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。
请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。
    如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。
    如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。
    如果 searchWord 不是任何单词的前缀，则返回 -1 。
字符串 S 的 「前缀」是 S 的任何前导连续子字符串。
示例 1：输入：sentence = "i love eating burger", searchWord = "burg" 输出：4
解释："burg" 是 "burger" 的前缀，而 "burger" 是句子中第 4 个单词。
示例 2：输入：sentence = "this problem is an easy problem", searchWord = "pro" 输出：2
解释："pro" 是 "problem" 的前缀，而 "problem" 是句子中第 2 个也是第 6 个单词，
但是应该返回最小下标 2 。
示例 3：输入：sentence = "i am tired", searchWord = "you" 输出：-1
解释："you" 不是句子中任何单词的前缀。
示例 4：输入：sentence = "i use triple pillow", searchWord = "pill" 输出：4
示例 5：输入：sentence = "hello from the other side", searchWord = "they" 输出：-1
提示：

    1 <= sentence.length <= 100
    1 <= searchWord.length <= 10
    sentence 由小写英文字母和空格组成。
    searchWord 由小写英文字母组成。
    前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |
| 02   | 遍历 | O(n)       | O(n)       |

```go
func isPrefixOfWord(sentence string, searchWord string) int {
	arr := strings.Split(sentence, " ")
	for k, v := range arr {
		if strings.HasPrefix(v, searchWord) {
			return k + 1
		}
	}
	return -1
}

#
func isPrefixOfWord(sentence string, searchWord string) int {
	arr := strings.Fields(sentence)
	for k, v := range arr {
		if len(v) >= len(searchWord) {
			if v[:len(searchWord)] == searchWord {
				return k + 1
			}
		}
	}
	return -1
}
```

## 1460.通过翻转子数组使两个数组相等(3)

- 题目

```
给你两个长度相同的整数数组 target 和 arr 。
每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。
如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。
示例 1：输入：target = [1,2,3,4], arr = [2,4,1,3] 输出：true
解释：你可以按照如下步骤使 arr 变成 target：
1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]
2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]
3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]
上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。
示例 2：输入：target = [7], arr = [7] 输出：true
解释：arr 不需要做任何翻转已经与 target 相等。
示例 3：输入：target = [1,12], arr = [12,1] 输出：true
示例 4：输入：target = [3,7,9], arr = [3,7,11] 输出：false
解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。
示例 5：输入：target = [1,1,1,1,1], arr = [1,1,1,1,1] 输出：true
提示：
    target.length == arr.length
    1 <= target.length <= 1000
    1 <= target[i] <= 1000
    1 <= arr[i] <= 1000
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(1)       |
| 02   | 数组辅助 | O(n)       | O(1)       |
| 03   | 哈希辅助 | O(n)       | O(1)       |

```go
func canBeEqual(target []int, arr []int) bool {
	sort.Ints(target)
	sort.Ints(arr)
	for i := 0; i < len(target); i++ {
		if target[i] != arr[i] {
			return false
		}
	}
	return true
}

#
func canBeEqual(target []int, arr []int) bool {
	temp := make([]int, 1001)
	for i := 0; i < len(target); i++ {
		temp[target[i]]++
		temp[arr[i]]--
	}
	for i := 0; i < len(temp); i++ {
		if temp[i] != 0 {
			return false
		}
	}
	return true
}
```

## 1464.数组中两元素的最大乘积(3)

- 题目

```
给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。
请你计算并返回该式的最大值。
示例 1：输入：nums = [3,4,5,2] 输出：12 
解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，
(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 
示例 2：输入：nums = [1,5,4,5] 输出：16
解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。
示例 3：输入：nums = [3,7] 输出：12
提示：
    2 <= nums.length <= 500
    1 <= nums[i] <= 10^3
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(1)       |
| 02   | 遍历     | O(n)       | O(1)       |
| 03   | 暴力法   | O(n^2)     | O(1)       |

```go
func maxProduct(nums []int) int {
	sort.Ints(nums)
	return (nums[len(nums)-1] - 1) * (nums[len(nums)-2] - 1)
}

#
func maxProduct(nums []int) int {
	max := math.MinInt32
	next := math.MinInt32
	for i := 0; i < len(nums); i++ {
		if nums[i] > max {
			next, max = max, nums[i]
		} else if nums[i] > next {
			next = nums[i]
		}
	}
	return (max - 1) * (next - 1)
}

#
func maxProduct(nums []int) int {
	res := 0
	for i := 0; i < len(nums); i++ {
		for j := i + 1; j < len(nums); j++ {
			if (nums[i]-1)*(nums[j]-1) > res {
				res = (nums[i] - 1) * (nums[j] - 1)
			}
		}
	}
	return res
}
```

## 1470.重新排列数组(2)

- 题目

```
给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。
请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
示例 1：输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
示例 2：输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1]
示例 3：输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2]
提示：
    1 <= n <= 500
    nums.length == 2n
    1 <= nums[i] <= 10^3
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组辅助 | O(n)       | O(n)       |
| 02   | 前移遍历 | O(n^1)     | O(1)       |

```go
func shuffle(nums []int, n int) []int {
	res := make([]int,0)
	for i := 0; i < n; i++{
		res = append(res, nums[i], nums[i+n])
	}
	return res
}

#
func shuffle(nums []int, n int) []int {
	for i := n; i < 2*n; i++ {
		temp := i
		for j := 0; j < 2*n-1-i; j++ {
			nums[temp], nums[temp-1] = nums[temp-1], nums[temp]
			temp--
		}
	}
	return nums
}
```

## 1475.商品折扣后的最终价格(2)

- 题目

```
给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，
其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，
如果没有满足条件的 j ，你将没有任何折扣。
请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。
示例 1：输入：prices = [8,4,6,2,3] 输出：[4,2,4,2,3]
解释：
商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。
商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。
商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。
商品 3 和 4 都没有折扣。
示例 2：输入：prices = [1,2,3,4,5] 输出：[1,2,3,4,5]
解释：在这个例子中，所有商品都没有折扣。
示例 3：输入：prices = [10,1,1,6] 输出：[9,0,1,6]
提示：
    1 <= prices.length <= 500
    1 <= prices[i] <= 10^3
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历模拟 | O(n^2)     | O(1)       |
| 02   | 栈       | O(n)       | O(n)       |

```go
func finalPrices(prices []int) []int {
	for i := 0; i < len(prices); i++ {
		for j := i + 1; j < len(prices); j++ {
			if prices[j] <= prices[i] {
				prices[i] = prices[i] - prices[j]
				break
			}
		}
	}
	return prices
}

#
func finalPrices(prices []int) []int {
	stack := make([]int, 0)
	for i := 0; i < len(prices); i++ {
		for len(stack) > 0 {
			index := stack[len(stack)-1]
			if prices[i] > prices[index] {
				break
			}
			prices[index] = prices[index] - prices[i]
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, i)
	}
	return prices
}
```

## 1480.一维数组的动态和(2)

- 题目

```
给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
请返回 nums 的动态和。
示例 1：输入：nums = [1,2,3,4] 输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
示例 2：输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
示例 3：输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17]
提示：
    1 <= nums.length <= 1000
    -10^6 <= nums[i] <= 10^6
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n)       | O(1)       |
| 02   | 数组辅助 | O(n)       | O(n)       |

```go
func runningSum(nums []int) []int {
	for i := 1; i < len(nums); i++{
		nums[i] = nums[i-1]+nums[i]
	}
	return nums
}

#
func runningSum(nums []int) []int {
	res := make([]int, len(nums))
	res[0] = nums[0]
	for i := 1; i < len(nums); i++ {
		res[i] = res[i-1] + nums[i]
	}
	return res
}
```

## 1486.数组异或操作(1)

- 题目

```
给你两个整数，n 和 start 。
数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。
请返回 nums 中所有元素按位异或（XOR）后得到的结果。
示例 1：输入：n = 5, start = 0 输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     "^" 为按位异或 XOR 运算符。
示例 2：输入：n = 4, start = 3 输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.
示例 3：输入：n = 1, start = 7 输出：7
示例 4：输入：n = 10, start = 5 输出：2
提示：
    1 <= n <= 1000
    0 <= start <= 1000
    n == nums.length
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
func xorOperation(n int, start int) int {
	res := 0
	for i := 0; i < n; i++ {
		res = res ^ (start + 2*i)
	}
	return res
}
```

## 1491.去掉最低工资和最高工资后的工资平均值(2)

- 题目

```
给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。
请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。
示例 1：输入：salary = [4000,3000,1000,2000] 输出：2500.00000
解释：最低工资和最高工资分别是 1000 和 4000 。
去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500
示例 2：输入：salary = [1000,2000,3000] 输出：2000.00000
解释：最低工资和最高工资分别是 1000 和 3000 。
去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000
示例 3：输入：salary = [6000,5000,4000,3000,2000,1000] 输出：3500.00000
示例 4：输入：salary = [8000,9000,2000,3000,6000,1000] 输出：4750.00000
提示：
    3 <= salary.length <= 100
    10^3 <= salary[i] <= 10^6
    salary[i] 是唯一的。
    与真实值误差在 10^-5 以内的结果都将视为正确答案。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(1)       |
| 02   | 遍历     | O(n)       | O(1)       |

```go
func average(salary []int) float64 {
	sort.Ints(salary)
	sum := 0
	for i := 1; i < len(salary)-1; i++ {
		sum = sum + salary[i]
	}
	return float64(sum) / float64(len(salary)-2)
}

#
func average(salary []int) float64 {
	sum := salary[0]
	max := salary[0]
	min := salary[0]
	for i := 1; i < len(salary); i++ {
		sum = sum + salary[i]
		if salary[i] > max {
			max = salary[i]
		}
		if salary[i] < min {
			min = salary[i]
		}
	}
	return float64(sum-max-min) / float64(len(salary)-2)
}
```

## 1496.判断路径是否相交(1)

- 题目

```
给你一个字符串 path，其中 path[i] 的值可以是 'N'、'S'、'E' 或者 'W'，
分别表示向北、向南、向东、向西移动一个单位。
机器人从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。
如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 True ；否则，返回 False 。
示例 1：输入：path = "NES" 输出：false 
解释：该路径没有在任何位置相交。
示例 2：输入：path = "NESWW" 输出：true
解释：该路径经过原点两次。
提示：
    1 <= path.length <= 10^4
    path 仅由 {'N', 'S', 'E', 'W} 中的字符组成
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(n)       |

```go
func isPathCrossing(path string) bool {
	m := make(map[string]bool)
	m["0,0"] = true
	x := 0
	y := 0
	for i := 0; i < len(path); i++ {
		switch path[i] {
		case 'N':
			y = y + 1
		case 'S':
			y = y - 1
		case 'E':
			x = x + 1
		case 'W':
			x = x - 1
		}
		if m[fmt.Sprintf("%d,%d", x, y)] {
			return true
		}
		m[fmt.Sprintf("%d,%d", x, y)] = true
	}
	return false
}
```

# 1401-1500-Medium

## 1404.将二进制表示减到1的步骤数(2)

- 题目

```
给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数：
    如果当前数字为偶数，则将其除以 2 。
    如果当前数字为奇数，则将其加上 1 。
题目保证你总是可以按上述规则将测试用例变为 1 。
示例 1：输入：s = "1101" 输出：6
解释："1101" 表示十进制数 13 。
Step 1) 13 是奇数，加 1 得到 14 
Step 2) 14 是偶数，除 2 得到 7
Step 3) 7  是奇数，加 1 得到 8
Step 4) 8  是偶数，除 2 得到 4  
Step 5) 4  是偶数，除 2 得到 2 
Step 6) 2  是偶数，除 2 得到 1  
示例 2：输入：s = "10" 输出：1
解释："10" 表示十进制数 2 。
Step 1) 2 是偶数，除 2 得到 1 
示例 3：输入：s = "1" 输出：0
提示：1 <= s.length <= 500
    s 由字符 '0' 或 '1' 组成。
    s[0] == '1'
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 模拟 | O(n^2)     | O(n)       |
| 02   | 遍历 | O(n)       | P          |

```go
func numSteps(s string) int {
	res := 0
	for s != "1" {
		n := len(s)
		if s[n-1] == '0' {
			s = s[:n-1]
		} else {
			s = add(s)
		}
		res++
	}
	return res
}

func add(s string) string {
	arr := []byte(s)
	flag := true
	for i := len(arr) - 1; i >= 0; i-- {
		if arr[i] == '0' {
			arr[i] = '1'
			flag = false
		} else {
			arr[i] = '0'
		}
		if flag == false {
			return string(arr)
		}
	}
	return "1" + string(arr)
}

# 2
func numSteps(s string) int {
	res := 0
	flag := false
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '0' {
			if flag == true {
				res = res + 2
			} else {
				res = res + 1 // 没有进位，遇0加1
			}
		} else {
			if flag == true {
				res++
			} else {
				if i != 0 {
					res = res + 2
				}
				flag = true
			}
		}
	}
	return res
}
```

## 1410.HTML实体解析器(3)

- 题目

```
「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，
并用字符本身替换掉所有这些特殊的字符实体。
HTML 里这些特殊字符和它们对应的字符实体包括：
双引号：字符实体为 &quot; ，对应的字符是 " 。
单引号：字符实体为 &apos; ，对应的字符是 ' 。
与符号：字符实体为 &amp; ，对应对的字符是 & 。
大于号：字符实体为 &gt; ，对应的字符是 > 。
小于号：字符实体为 &lt; ，对应的字符是 < 。
斜线号：字符实体为 &frasl; ，对应的字符是 / 。
给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。
示例 1：输入：text = "&amp; is an HTML entity but &ambassador; is not."
输出："& is an HTML entity but &ambassador; is not."
解释：解析器把字符实体 &amp; 用 & 替换
示例 2：输入：text = "and I quote: &quot;...&quot;"
输出："and I quote: \"...\""
示例 3：输入：text = "Stay home! Practice on Leetcode :)"
输出："Stay home! Practice on Leetcode :)"
示例 4：输入：text = "x &gt; y &amp;&amp; x &lt; y is always false"
输出："x > y && x < y is always false"
示例 5：输入：text = "leetcode.com&frasl;problemset&frasl;all"
输出："leetcode.com/problemset/all"
提示：1 <= text.length <= 10^5
字符串可能包含 256 个ASCII 字符中的任意字符。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n)       | O(n)       |
| 02   | 内置函数 | O(n)       | O(n)       |
| 03   | 遍历     | O(n)       | O(n)       |

```go
func entityParser(text string) string {
	text = html.UnescapeString(text)
	return strings.ReplaceAll(text, "⁄", "/")
}

# 2
func entityParser(text string) string {
	text = strings.ReplaceAll(text, "&quot;", "\"")
	text = strings.ReplaceAll(text, "&apos;", "'")
	text = strings.ReplaceAll(text, "&gt;", ">")
	text = strings.ReplaceAll(text, "&lt;", "<")
	text = strings.ReplaceAll(text, "&frasl;", "/")
	text = strings.ReplaceAll(text, "&amp;", "&")
	return text
}

# 3
func entityParser(text string) string {
	res := make([]byte, 0)
	temp := make([]byte, 0)
	for i := 0; i < len(text); i++ {
		if text[i] == '&' {
			if len(temp) == 0 {
				temp = append(temp, text[i])
			} else {
				res = append(res, temp...)
				temp = make([]byte, 0)
				temp = append(temp, text[i])
			}
		} else if text[i] == ';' {
			temp = append(temp, text[i])
			switch string(temp) {
			case "&gt;":
				res = append(res, '>')
			case "&lt;":
				res = append(res, '<')
			case "&quot;":
				res = append(res, '"')
			case "&apos;":
				res = append(res, '\'')
			case "&frasl;":
				res = append(res, '/')
			case "&amp;":
				res = append(res, '&')
			default:
				res = append(res, temp...)
			}
			temp = make([]byte, 0)
		} else if len(temp) == 0 {
			res = append(res, text[i])
		} else {
			temp = append(temp, text[i])
		}
	}
	if len(temp) > 0 {
		res = append(res, temp...)
	}
	return string(res)
}
```

## 1415.长度为n的开心字符串中字典序第k小的字符串

### 题目

```
一个 「开心字符串」定义为：
仅包含小写字母 ['a', 'b', 'c'].
对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。
比方说，字符串 "abc"，"ac"，"b" 和 "abcbabcbcb" 都是开心字符串，
但是 "aa"，"baa" 和 "ababbc" 都不是开心字符串。
给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。
请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。
示例 1：输入：n = 1, k = 3 输出："c"
解释：列表 ["a", "b", "c"] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 "c" 。
示例 2：输入：n = 1, k = 4 输出：""
解释：长度为 1 的开心字符串只有 3 个。
示例 3：输入：n = 3, k = 9 输出："cab"
解释：长度为 3 的开心字符串总共有 12 个 ["aba", "abc", "aca", "acb", "bab", "bac", 
"bca", "bcb", "cab", "cac", "cba", "cbc"] 。
第 9 个字符串为 "cab"
示例 4：输入：n = 2, k = 7 输出：""
示例 5：输入：n = 10, k = 100 输出："abacbabacb"
提示：1 <= n <= 10
1 <= k <= 100
```

### 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(nlog(n)) | O(n)       |

```go

```

## 1418.点菜展示表(1)

- 题目

```
给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， 
orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，
tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。
请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，
后面每一列都是按字母顺序排列的餐品名称。
接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。
注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。
示例 1：
输入：orders = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],
["David","3","Fried Chicken"],["Carla","5","Water"],
["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
输出：[["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],
["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]] 
解释：点菜展示表如下所示：
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3    ,0           ,2      ,1            ,0
5    ,0           ,1      ,0            ,1
10   ,1           ,0      ,0            ,0
对于餐桌 3：David 点了 "Ceviche" 和 "Fried Chicken"，而 Rous 点了 "Ceviche"
而餐桌 5：Carla 点了 "Water" 和 "Ceviche"
餐桌 10：Corina 点了 "Beef Burrito" 
示例 2：输入：orders = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],
["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],
["Brianna","1","Canadian Waffles"]]
输出：[["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]] 
解释：对于餐桌 1：Adam 和 Brianna 都点了 "Canadian Waffles"
而餐桌 12：James, Ratesh 和 Amadeus 都点了 "Fried Chicken"
示例 3：
输入：orders = [["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]
输出：[["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
提示：
    1 <= orders.length <= 5 * 10^4
    orders[i].length == 3
    1 <= customerNamei.length, foodItemi.length <= 20
    customerNamei 和 foodItemi 由大小写英文字母及空格字符 ' ' 组成。
    tableNumberi 是 1 到 500 范围内的整数。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(nlog(n)) | O(n)       |

```go
func displayTable(orders [][]string) [][]string {
	res := make([][]string, 0)
	titles := make([]string, 0)
	idArr := make([]int, 0)
	m := make(map[string]bool)
	m2 := make(map[string]map[string]int)
	for i := 0; i < len(orders); i++ {
		m[orders[i][2]] = true
		if m2[orders[i][1]] == nil {
			m2[orders[i][1]] = make(map[string]int)
		}
		m2[orders[i][1]][orders[i][2]]++
	}
	for k := range m {
		titles = append(titles, k)
	}
	for k := range m2 {
		tableID, _ := strconv.Atoi(k)
		idArr = append(idArr, tableID)
	}
	sort.Strings(titles)
	sort.Ints(idArr)
	res = append(res, append([]string{"Table"}, titles...))
	for i := 0; i < len(idArr); i++ {
		tableStr := strconv.Itoa(idArr[i])
		temp := make([]string, 0)
		temp = append(temp, tableStr)
		for j := 0; j < len(titles); j++ {
			temp = append(temp, strconv.Itoa(m2[tableStr][titles[j]]))
		}
		res = append(res, temp)
	}
	return res
}
```

## 1419.数青蛙(2)

- 题目

```
给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 "croak" ）的组合。
由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak” 。
请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。
注意：要想发出蛙鸣 "croak"，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。
如果没有输出全部五个字母，那么它就不会发出声音。
如果字符串 croakOfFrogs 不是由若干有效的 "croak" 字符混合而成，请返回 -1 。
示例 1：输入：croakOfFrogs = "croakcroak" 输出：1 
解释：一只青蛙 “呱呱” 两次
示例 2：输入：croakOfFrogs = "crcoakroak" 输出：2 
解释：最少需要两只青蛙，“呱呱” 声用黑体标注
第一只青蛙 "crcoakroak"
第二只青蛙 "crcoakroak"
示例 3：输入：croakOfFrogs = "croakcrook" 输出：-1
解释：给出的字符串不是 "croak" 的有效组合。
示例 4：输入：croakOfFrogs = "croakcroa" 输出：-1
提示：1 <= croakOfFrogs.length <= 10^5
    字符串中的字符只有 'c', 'r', 'o', 'a' 或者 'k'
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func minNumberOfFrogs(croakOfFrogs string) int {
	res := 0
	var c, r, o, a, k int
	temp := 0
	for _, char := range croakOfFrogs {
		if char == 'c' {
			c++
			if temp > 0 {
				temp-- // 有空闲的青蛙
			} else {
				res++ // 没有空闲的青蛙
			}
		} else if r < c && char == 'r' {
			r++
		} else if o < r && char == 'o' {
			o++
		} else if a < o && char == 'a' {
			a++
		} else if k < a && char == 'k' {
			k++
			temp++ // 结束有空闲
		} else {
			return -1
		}
	}
	if temp != res { // 避免出现"croakcroa"的情况
		return -1
	}
	return res
}

# 2
func minNumberOfFrogs(croakOfFrogs string) int {
	res := 0
	var c, r, o, a, k int
	for _, char := range croakOfFrogs {
		if char == 'c' {
			c++
		} else if char == 'r' {
			r++
		} else if char == 'o' {
			o++
		} else if char == 'a' {
			a++
		} else if char == 'k' {
			k++
		} else {
			return -1
		}
		res = max(res, c)
		if c < r || r < o || o < a || a < k {
			return -1
		}
		if k == 1 {
			c--
			r--
			o--
			a--
			k--
		}
	}
	if c == 0 && r == 0 && o == 0 && a == 0 && k == 0 {
		return res
	}
	return -1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 1423.可获得的最大点数(2)

- 题目

```
几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。
每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。
你的点数就是你拿到手中的所有卡牌的点数之和。
给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。
示例 1：输入：cardPoints = [1,2,3,4,5,6,1], k = 3 输出：12
解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。
最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。
示例 2：输入：cardPoints = [2,2,2], k = 2 输出：4
解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。
示例 3：输入：cardPoints = [9,7,7,9,7,7,9], k = 7 输出：55
解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。
示例 4：输入：cardPoints = [1,1000,1], k = 1 输出：1
解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 
示例 5：输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3 输出：202
提示：1 <= cardPoints.length <= 10^5
    1 <= cardPoints[i] <= 10^4
    1 <= k <= cardPoints.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 滑动窗口 | O(n)       | O(1)       |
| 02   | 滑动窗口 | O(n)       | O(1)       |

```go
func maxScore(cardPoints []int, k int) int {
	res := 0
	left := 0
	for i := 0; i < k; i++ {
		left = left + cardPoints[i]
	}
	res = left
	right := 0
	count := k
	for i := len(cardPoints) - 1; i >= len(cardPoints)-k; i-- {
		right = right + cardPoints[i]
		left = left - cardPoints[count-1]
		res = max(res, left+right)
		count--
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxScore(cardPoints []int, k int) int {
	res := 0
	n := len(cardPoints)
	window := 0
	sum := 0
	for i := 0; i < n-k; i++ {
		sum = sum + cardPoints[i]
		window = window + cardPoints[i]
	}
	res = window
	count := 0
	for i := n - k; i < n; i++ {
		sum = sum + cardPoints[i]
		window = window + cardPoints[i] - cardPoints[count]
		res = min(res, window)
		count++
	}
	return sum - res
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
```

## 1424.对角线遍历II

### 题目

```
给你一个列表 nums ，里面每一个元素都是一个整数列表。
请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。
示例 1：输入：nums = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,4,2,7,5,3,8,6,9]
示例 2：输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
示例 3：输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]] 输出：[1,4,2,5,3,8,6,9,7,10,11]
示例 4：输入：nums = [[1,2,3,4,5,6]] 输出：[1,2,3,4,5,6]
提示： 1 <= nums.length <= 10^5
    1 <= nums[i].length <= 10^5
    1 <= nums[i][j] <= 10^9
    nums 中最多有 10^5 个数字。
```

### 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |

```go

```

## 1433.检查一个字符串是否可以打破另一个字符串(2)

- 题目

```
给你两个字符串 s1 和 s2 ，它们长度相等，请你检查是否存在一个 s1  的排列可以打破 s2 的一个排列，
或者是否存在一个 s2 的排列可以打破 s1 的一个排列。
字符串 x 可以打破字符串 y （两者长度都为 n ）需满足对于所有 i（在 0 到 n - 1 之间）
都有 x[i] >= y[i]（字典序意义下的顺序）。
示例 1：输入：s1 = "abc", s2 = "xya" 输出：true
解释："ayx" 是 s2="xya" 的一个排列，"abc" 是字符串 s1="abc" 的一个排列，且 "ayx" 可以打破 "abc" 。
示例 2：输入：s1 = "abe", s2 = "acd" 输出：false 
解释：s1="abe" 的所有排列包括："abe"，"aeb"，"bae"，"bea"，"eab" 和 "eba" ，
s2="acd" 的所有排列包括："acd"，"adc"，"cad"，"cda"，"dac" 和 "dca"。
然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。
示例 3：输入：s1 = "leetcodee", s2 = "interview" 输出：true
提示： s1.length == n
    s2.length == n
    1 <= n <= 10^5
    所有字符串都只包含小写英文字母。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |
| 02   | 计数排序 | O(n)       | O(n)       |

```go
func checkIfCanBreak(s1 string, s2 string) bool {
	arr1 := []byte(s1)
	sort.Slice(arr1, func(i, j int) bool {
		return arr1[i] < arr1[j]
	})
	arr2 := []byte(s2)
	sort.Slice(arr2, func(i, j int) bool {
		return arr2[i] < arr2[j]
	})
	s1 = string(arr1)
	s2 = string(arr2)
	return compare(s1, s2) || compare(s2, s1)
}

func compare(s1 string, s2 string) bool {
	for i := 0; i < len(s1); i++ {
		if s1[i] < s2[i] {
			return false
		}
	}
	return true
}

# 2
func checkIfCanBreak(s1 string, s2 string) bool {
	arr1 := [26]int{}
	arr2 := [26]int{}
	for i := 0; i < len(s1); i++ {
		arr1[int(s1[i]-'a')]++
		arr2[int(s2[i]-'a')]++
	}
	a, b := 0, 0
	totalA, totalB := 0, 0
	for i := 0; i < 26; i++ {
		totalA = totalA + arr1[i]
		totalB = totalB + arr2[i]
		if totalA >= totalB {
			a++
		}
		if totalB >= totalA {
			b++
		}
	}
	return a == 26 || b == 26
}
```

## 1437.是否所有1都至少相隔k个元素(2)

- 题目

```
给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 True ；
否则，返回 False 。
示例 1：输入：nums = [1,0,0,0,1,0,0,1], k = 2 输出：true
解释：每个 1 都至少相隔 2 个元素。
示例 2：输入：nums = [1,0,0,1,0,1], k = 2 输出：false
解释：第二个 1 和第三个 1 之间只隔了 1 个元素。
示例 3：输入：nums = [1,1,1,1,1], k = 0 输出：true
示例 4：输入：nums = [0,1,0,1], k = 1 输出：true
提示：1 <= nums.length <= 10^5
    0 <= k <= nums.length
    nums[i] 的值为 0 或 1
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func kLengthApart(nums []int, k int) bool {
	last := -(k + 1) // 兼容第0个元素是1
	for i := 0; i < len(nums); i++ {
		if nums[i] == 1 {
			if i-last <= k {
				return false
			}
			last = i
		}
	}
	return true
}

# 2
func kLengthApart(nums []int, k int) bool {
	last := -1
	for i := 0; i < len(nums); i++ {
		if nums[i] == 1 {
			if last != -1 && i-last <= k {
				return false
			}
			last = i
		}
	}
	return true
}
```

## 1442.形成两个异或相等数组的三元组数目(3)

- 题目

```
给你一个整数数组 arr 。
现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。
a 和 b 定义如下：
    a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。
请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。
示例 1：输入：arr = [2,3,1,6,7] 输出：4
解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)
示例 2：输入：arr = [1,1,1,1,1] 输出：10
示例 3：输入：arr = [2,3] 输出：0
示例 4：输入：arr = [1,3,5,7,9] 输出：3
示例 5：输入：arr = [7,11,12,9,5,2,7,17,22] 输出：8
提示：
    1 <= arr.length <= 300
    1 <= arr[i] <= 10^8
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 暴力法   | O(n^3)     | O(1)       |
| 02   | 遍历     | O(n^2)     | O(1)       |
| 03   | 哈希辅助 | O(n)       | O(n)       |

```go
func countTriplets(arr []int) int {
	res := 0
	for i := 1; i < len(arr); i++ {
		arr[i] = arr[i] ^ arr[i-1]
	}
	for i := 0; i < len(arr)-1; i++ {
		for j := i + 1; j < len(arr); j++ {
			for k := j; k < len(arr); k++ {
				var a, b int
				if i == 0 {
					a = arr[j-1]
				} else {
					a = arr[j-1] ^ arr[i-1]
				}
				b = arr[k] ^ arr[j-1]
				if a == b {
					res++
				}
			}
		}
	}
	return res
}

#
// a[i]^...a[j-1]^a[j]^...a[k] = 0，则j可以取i+1、i+2、...、..k
func countTriplets(arr []int) int {
	res := 0
	for i := 0; i < len(arr); i++ {
		temp := arr[i]
		for k := i + 1; k < len(arr); k++ {
			temp = temp ^ arr[k]
			if temp == 0 {
				res = res + k - i
			}
		}
	}
	return res
}

#
func countTriplets(arr []int) int {
	res := 0
	sumM := make(map[int]int)
	countM := make(map[int]int)
	countM[0] = 1
	temp := 0
	for i := 0; i < len(arr); i++ {
		temp = temp ^ arr[i]
		if countM[temp] > 0 {
			// 相同异或结果，分别出现在下标[a,b,c,d]
			// 则[a,d]有d-a-1个满足条件的
			// sum = (d-a-1)+(d-b-1)+(d-c-1)
			// ==> nd - [(a+1) + (b+1) + (c+1)]
			// 同理得[a,b], [a,c]
			res = res + i*countM[temp] - sumM[temp]
		}
		countM[temp]++
		sumM[temp] = sumM[temp] + (i + 1)
	}
	return res
}
```

## 1447.最简分数(2)

- 题目

```
给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。
分数可以以 任意 顺序返回。
示例 1：输入：n = 2 输出：["1/2"]
解释："1/2" 是唯一一个分母小于等于 2 的最简分数。
示例 2：输入：n = 3 输出：["1/2","1/3","2/3"]
示例 3：输入：n = 4 输出：["1/2","1/3","1/4","2/3","3/4"]
解释："2/4" 不是最简分数，因为它可以化简为 "1/2" 。
示例 4：输入：n = 1 输出：[]
提示：1 <= n <= 100
```

- 解题思路

| No.  | 思路     | 时间复杂度   | 空间复杂度 |
| ---- | -------- | ------------ | ---------- |
| 01   | 暴力法   | O(n^2log(n)) | O(n^2)     |
| 02   | 哈希辅助 | O(n^3)       | O(n^2)     |

```go
func simplifiedFractions(n int) []string {
	res := make([]string, 0)
	for i := 2; i <= n; i++ {
		for j := 1; j < i; j++ {
			if gcd(i, j) == 1 {
				res = append(res, fmt.Sprintf("%d/%d", j, i))
			}
		}
	}
	return res
}

func gcd(a, b int) int {
	if a%b == 0 {
		return b
	}
	return gcd(b, a%b)
}

# 2
func simplifiedFractions(n int) []string {
	res := make([]string, 0)
	m := make(map[string]bool)
	for i := 2; i <= n; i++ {
		for j := 1; j < i; j++ {
			str := fmt.Sprintf("%d/%d", j, i)
			if _, ok := m[str]; ok{
				continue
			}
			res = append(res, str)
			for k := 1; i *k <= n; k++{
				m[fmt.Sprintf("%d/%d", j*k, i*k)] = true
			}
		}
	}
	return res
}
```

## 1451.重新排列句子中的单词(1)

- 题目

```
「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 text :
    句子的首字母大写
    text 中的每个单词都用单个空格分隔。
请你重新排列 text 中的单词，使所有单词按其长度的升序排列。
如果两个单词的长度相同，则保留其在原句子中的相对顺序。
请同样按上述格式返回新的句子。
示例 1：输入：text = "Leetcode is cool" 输出："Is cool leetcode"
解释：句子中共有 3 个单词，长度为 8 的 "Leetcode" ，长度为 2 的 "is" 以及长度为 4 的 "cool" 。
输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。
示例 2：输入：text = "Keep calm and code on" 输出："On and keep calm code"
解释：输出的排序情况如下：
"On" 2 个字母。
"and" 3 个字母。
"keep" 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。
"calm" 4 个字母。
"code" 4 个字母。
示例 3：输入：text = "To be or not to be" 输出："To be or to be not"
提示： text 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。
    1 <= text.length <= 10^5
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(n)       |

```go
func arrangeWords(text string) string {
	text = strings.ToLower(text)
	arr := strings.Fields(text)
	sort.SliceStable(arr, func(i, j int) bool {
		return len(arr[i]) < len(arr[j])
	})
	arr[0] = strings.Title(arr[0])
	return strings.Join(arr, " ")
}
```

## 1452.收藏清单(1)

- 题目

```
给你一个数组 favoriteCompanies ，
其中 favoriteCompanies[i] 是第 i 名用户收藏的公司清单（下标从 0 开始）。
请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标。下标需要按升序排列。
示例 1：输入：favoriteCompanies = [["leetcode","google","facebook"],
["google","microsoft"],["google","facebook"],["google"],["amazon"]]
输出：[0,1,4] 
解释：favoriteCompanies[2]=["google","facebook"] 是 
favoriteCompanies[0]=["leetcode","google","facebook"] 的子集。
favoriteCompanies[3]=["google"] 是 favoriteCompanies[0]=
["leetcode","google","facebook"] 和 favoriteCompanies[1]=["google","microsoft"] 的子集。
其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。
示例 2：输入：favoriteCompanies = [["leetcode","google","facebook"],
["leetcode","amazon"],["facebook","google"]]
输出：[0,1] 
解释：favoriteCompanies[2]=["facebook","google"] 是 favoriteCompanies[0]=["leetcode","google","facebook"] 的子集，因此，答案为 [0,1] 。
示例 3：输入：favoriteCompanies = [["leetcode"],["google"],["facebook"],["amazon"]]
输出：[0,1,2,3]
提示：1 <= favoriteCompanies.length <= 100
1 <= favoriteCompanies[i].length <= 500
1 <= favoriteCompanies[i][j].length <= 20
favoriteCompanies[i] 中的所有字符串 各不相同 。
用户收藏的公司清单也 各不相同 ，
也就是说，即便我们按字母顺序排序每个清单， favoriteCompanies[i] != favoriteCompanies[j] 仍然成立。
所有字符串仅包含小写英文字母。
```

- 解题思路

| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- | ---------- |
| 01   | 自定义排序 | O(n^3)     | O(n^2)     |

```go
type Node struct {
	index int
	str   []string
}

func peopleIndexes(favoriteCompanies [][]string) []int {
	n := len(favoriteCompanies)
	arr := make([]Node, 0)
	for i := 0; i < len(favoriteCompanies); i++ {
		arr = append(arr, Node{
			index: i,
			str:   favoriteCompanies[i],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		return len(arr[i].str) < len(arr[j].str)
	})
	res := make([]int, 0)
	for i := 0; i < n; i++ {
		flag := true
		for j := i + 1; j < n; j++ {
			if judge(arr[i].str, arr[j].str) == true {
				flag = false
				break
			}
		}
		if flag == true {
			res = append(res, arr[i].index)
		}
	}
	sort.Ints(res)
	return res
}

func judge(a, b []string) bool {
	m := make(map[string]bool)
	for i := 0; i < len(a); i++ {
		m[a[i]] = true
	}
	for i := 0; i < len(b); i++ {
		if _, ok := m[b[i]]; ok {
			delete(m, b[i])
		}
	}
	return len(m) == 0
}
```

## 1456.定长子串中元音的最大数目(2)

- 题目

```
给你字符串 s 和整数 k 。
请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。
英文中的 元音字母 为（a, e, i, o, u）。
示例 1：输入：s = "abciiidef", k = 3 输出：3
解释：子字符串 "iii" 包含 3 个元音字母。
示例 2：输入：s = "aeiou", k = 2 输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
示例 3：输入：s = "leetcode", k = 3 输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。
示例 4：输入：s = "rhythms", k = 4 输出：0
解释：字符串 s 中不含任何元音字母。
示例 5：输入：s = "tryhard", k = 4 输出：1
提示：1 <= s.length <= 10^5
s 由小写英文字母组成
1 <= k <= s.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 滑动窗口 | O(n)       | O(1)       |
| 02   | 前缀和   | O(n)       | O(n)       |

```go
func maxVowels(s string, k int) int {
	res := 0
	total := 0
	for i := 0; i < len(s); i++ {
		if isVowel(s[i]) == true {
			total++
		}
		if i >= k {
			if isVowel(s[i-k]) == true {
				total--
			}
		}
		res = max(res, total)
	}
	return res
}

func isVowel(b byte) bool {
	return b == 'a' || b == 'e' ||
		b == 'i' || b == 'o' || b == 'u'
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxVowels(s string, k int) int {
	res := 0
	total := 0
	arr := make([]int, len(s)+1)
	for i := 0; i < len(s); i++ {
		if isVowel(s[i]) == true {
			total++
		}
		arr[i+1] = total
		if i >= k-1 {
			res = max(res, arr[i+1]-arr[i-k+1])
		}
	}
	return res
}

func isVowel(b byte) bool {
	return b == 'a' || b == 'e' ||
		b == 'i' || b == 'o' || b == 'u'
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 1471.数组中的k个最强值(2)

- 题目

```
给你一个整数数组 arr 和一个整数 k 。
设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 arr[i] 的值比 arr[j] 的值更强：
 |arr[i] - m| > |arr[j] - m|
 |arr[i] - m| == |arr[j] - m|，且 arr[i] > arr[j]
请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。
中位数 是一个有序整数列表中处于中间位置的值。
形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 ((n - 1) / 2) 的元素。
例如 arr = [6, -3, 7, 2, 11]，n = 5：数组排序后得到 arr = [-3, 2, 6, 7, 11] ，
数组的中间位置为 m = ((5 - 1) / 2) = 2 ，中位数 arr[m] 的值为 6 。
例如 arr = [-7, 22, 17, 3]，n = 4：数组排序后得到 arr = [-7, 3, 17, 22] ，
数组的中间位置为 m = ((4 - 1) / 2) = 1 ，中位数 arr[m] 的值为 3 。
示例 1：输入：arr = [1,2,3,4,5], k = 2 输出：[5,1]
解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。
最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。
注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 > 1 。
示例 2：输入：arr = [1,1,3,5,5], k = 2 输出：[5,5]
解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。
示例 3：输入：arr = [6,7,11,7,6,8], k = 5 输出：[11,8,6,6,7]
解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。
[11,8,6,6,7] 的任何排列都是正确答案。
示例 4：输入：arr = [6,-3,7,2,11], k = 3 输出：[-3,11,2]
示例 5：输入：arr = [-7,22,17,3], k = 2 输出：[22,17]
提示：1 <= arr.length <= 10^5
-10^5 <= arr[i] <= 10^5
1 <= k <= arr.length
```

- 解题思路

| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- | ---------- |
| 01   | 自定义排序 | O(nlog(n)) | O(1)       |
| 02   | 双指针     | O(nlog(n)) | O(n)       |

```go
func getStrongest(arr []int, k int) []int {
	sort.Ints(arr)
	mid := arr[(len(arr)-1)/2]
	sort.Slice(arr, func(i, j int) bool {
		if abs(arr[i]-mid) == abs(arr[j]-mid) {
			return arr[i] > arr[j]
		}
		return abs(arr[i]-mid) > abs(arr[j]-mid)
	})
	return arr[:k]
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}

# 2
func getStrongest(arr []int, k int) []int {
	sort.Ints(arr)
	mid := arr[(len(arr)-1)/2]
	res := make([]int, 0)
	left, right := 0, len(arr)-1
	for k > 0 {
		if arr[right]-mid >= mid-arr[left] {
			res = append(res, arr[right])
			right--
		} else {
			res = append(res, arr[left])
			left++
		}
		k--
	}
	return res
}
```

## 1472.设计浏览器历史记录(1)

- 题目

```
你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是 homepage ，
你可以访问其他的网站 url ，也可以在浏览历史中后退 steps 步或前进 steps 步。
请你实现 BrowserHistory 类：
BrowserHistory(string homepage) ，用 homepage 初始化浏览器类。
void visit(string url) 从当前页跳转访问 url 对应的页面  。
执行此操作会把浏览历史前进的记录全部删除。
string back(int steps) 在浏览历史中后退 steps 步。
如果你只能在浏览历史中后退至多 x 步且 steps > x ，那么你只后退 x 步。
请返回后退 至多 steps 步以后的 url 。
string forward(int steps) 在浏览历史中前进 steps 步。
如果你只能在浏览历史中前进至多 x 步且 steps > x ，那么你只前进 x 步。
请返回前进 至多 steps步以后的 url 。
示例：输入：["BrowserHistory","visit","visit","visit","back","back","forward",
"visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],
["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
输出：[null,null,null,null,"facebook.com","google.com","facebook.com",null,
"linkedin.com","google.com","leetcode.com"]
解释：
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // 你原本在浏览 "leetcode.com" 。访问 "google.com"
browserHistory.visit("facebook.com");     // 你原本在浏览 "google.com" 。访问 "facebook.com"
browserHistory.visit("youtube.com");      
// 你原本在浏览 "facebook.com" 。访问 "youtube.com"
browserHistory.back(1);                   
// 你原本在浏览 "youtube.com" ，后退到 "facebook.com" 并返回 "facebook.com"
browserHistory.back(1);                   
// 你原本在浏览 "facebook.com" ，后退到 "google.com" 并返回 "google.com"
browserHistory.forward(1);                
// 你原本在浏览 "google.com" ，前进到 "facebook.com" 并返回 "facebook.com"
browserHistory.visit("linkedin.com");     
// 你原本在浏览 "facebook.com" 。 访问 "linkedin.com"
browserHistory.forward(2);                
// 你原本在浏览 "linkedin.com" ，你无法前进任何步数。
browserHistory.back(2);                   
// 你原本在浏览 "linkedin.com" ，后退两步依次先到 "facebook.com" ，然后到 "google.com" ，并返回 "google.com"
browserHistory.back(7);                   
// 你原本在浏览 "google.com"， 你只能后退一步到 "leetcode.com" ，并返回 "leetcode.com"
提示：1 <= homepage.length <= 20
1 <= url.length <= 20
1 <= steps <= 100
homepage 和 url 都只包含 '.' 或者小写英文字母。
最多调用 5000 次 visit， back 和 forward 函数。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 数组 | O(1)       | O(n)       |

```go
type BrowserHistory struct {
	arr   []string
	index int
}

func Constructor(homepage string) BrowserHistory {
	return BrowserHistory{
		arr:   []string{homepage},
		index: 0,
	}
}

func (this *BrowserHistory) Visit(url string) {
	length := len(this.arr)
	if this.index == length-1 {
		this.arr = append(this.arr, url)
	} else if this.index < length-1 {
		this.arr = this.arr[:this.index+1]
		this.arr = append(this.arr, url)
	}
	this.index++
}

func (this *BrowserHistory) Back(steps int) string {
	if steps > this.index {
		this.index = 0
		return this.arr[0]
	}
	this.index = this.index - steps
	return this.arr[this.index]
}

func (this *BrowserHistory) Forward(steps int) string {
	length := len(this.arr)
	if this.index == length-1 {
	} else if this.index+steps > length-1 {
		this.index = length - 1
	} else {
		this.index = this.index + steps
	}
	return this.arr[this.index]
}
```

## 1481.不同整数的最少数目(1)

- 题目

```
给你一个整数数组 arr 和一个整数 k 。
现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。
示例 1：输入：arr = [5,5,4], k = 1 输出：1
解释：移除 1 个 4 ，数组中只剩下 5 一种整数。
示例 2：输入：arr = [4,3,1,1,3,3,2], k = 3 输出：2
解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。
提示：1 <= arr.length <= 10^5
    1 <= arr[i] <= 10^9
    0 <= k <= arr.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希排序 | O(nlog(n)) | O(n)       |

```go
func findLeastNumOfUniqueInts(arr []int, k int) int {
	m := make(map[int]int)
	for i := 0; i < len(arr); i++ {
		m[arr[i]]++
	}
	temp := make([]int, 0)
	for _, v := range m {
		temp = append(temp, v)
	}
	sort.Ints(temp)
	res := len(temp)
	for i := 0; i < len(temp); i++ {
		if k >= temp[i] {
			res--
			k = k - temp[i]
		} else {
			break
		}
	}
	return res
}
```

## 1482.制作m束花所需的最少天数(1)

- 题目

```
给你一个整数数组 bloomDay，以及两个整数 m 和 k 。
现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。
花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。
请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。
示例 1：输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
示例 2：输入：bloomDay = [1,10,3,10,2], m = 3, k = 2 输出：-1
解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。
而花园中只有 5 朵花，无法满足制作要求，返回 -1 。
示例 3：输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 输出：12
解释：要制作 2 束花，每束需要 3 朵。
花园在 7 天后和 12 天后的情况如下：
7 天后：[x, x, x, x, _, x, x]
可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
12 天后：[x, x, x, x, x, x, x]
显然，我们可以用不同的方式制作两束花。
示例 4：输入：bloomDay = [1000000000,1000000000], m = 1, k = 1 输出：1000000000
解释：需要等 1000000000 天才能采到花来制作花束
示例 5：输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2 输出：9
提示：bloomDay.length == n
    1 <= n <= 10^5
    1 <= bloomDay[i] <= 10^9
    1 <= m <= 10^6
    1 <= k <= n
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 二分查找 | O(nlog(n)) | O(1)       |

```go
func minDays(bloomDay []int, m int, k int) int {
	if m*k > len(bloomDay) {
		return -1
	}
	minValue, maxValue := bloomDay[0], bloomDay[0]
	for i := 1; i < len(bloomDay); i++ {
		if bloomDay[i] > maxValue {
			maxValue = bloomDay[i]
		}
		if bloomDay[i] < minValue {
			minValue = bloomDay[i]
		}
	}
	left, right := minValue, maxValue
	for left < right {
		mid := left + (right-left)/2
		count := judge(bloomDay, mid, k)
		if count >= m {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func judge(bloomDay []int, mid int, k int) int {
	total := 0
	count := 0
	for i := 0; i < len(bloomDay); i++ {
		if bloomDay[i] <= mid {
			total++
		} else {
			total = 0
		}
		if total == k {
			count++
			total = 0
		}
	}
	return count
}
```

## 1487.保证文件名唯一(2)

- 题目

```
给你一个长度为 n 的字符串数组 names 。
你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。
由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，
系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。
返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。
示例 1：
输入：names = ["pes","fifa","gta","pes(2019)"]
输出：["pes","fifa","gta","pes(2019)"]
解释：文件系统将会这样创建文件名：
"pes" --> 之前未分配，仍为 "pes"
"fifa" --> 之前未分配，仍为 "fifa"
"gta" --> 之前未分配，仍为 "gta"
"pes(2019)" --> 之前未分配，仍为 "pes(2019)"
示例 2：
输入：names = ["gta","gta(1)","gta","avalon"]
输出：["gta","gta(1)","gta(2)","avalon"]
解释：文件系统将会这样创建文件名：
"gta" --> 之前未分配，仍为 "gta"
"gta(1)" --> 之前未分配，仍为 "gta(1)"
"gta" --> 文件名被占用，系统为该名称添加后缀 (k)，由于 "gta(1)" 也被占用，所以 k = 2 。
实际创建的文件名为 "gta(2)" 。
"avalon" --> 之前未分配，仍为 "avalon"
示例 3：
输入：names = ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece"]
输出：["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece(4)"]
解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 "onepiece(4)"。
示例 4：
输入：names = ["wano","wano","wano","wano"]
输出：["wano","wano(1)","wano(2)","wano(3)"]
解释：每次创建文件夹 "wano" 时，只需增加后缀中 k 的值即可。
示例 5：
输入：names = ["kaido","kaido(1)","kaido","kaido(1)"]
输出：["kaido","kaido(1)","kaido(2)","kaido(1)(1)"]
解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。
提示：
    1 <= names.length <= 5 * 10^4
    1 <= names[i].length <= 20
    names[i] 由小写英文字母、数字和/或圆括号组成。
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 哈希辅助-递归 | O(n)       | O(n)       |
| 02   | 哈希辅助      | O(n)       | O(n)       |

```go
func getFolderNames(names []string) []string {
	m := make(map[string]int)
	for i, name := range names {
		if value, ok := m[name]; ok {
			names[i] = getName(m, name, value)
			m[names[i]] = 1
		} else {
			m[name] = 1
		}
	}
	return names
}

func getName(m map[string]int, name string, n int) string {
	newName := name + fmt.Sprintf("(%d)", n)
	if _, ok := m[newName]; ok {
		return getName(m, name, n+1)
	}
	m[name] = n + 1
	return newName
}


#
func getFolderNames(names []string) []string {
	m := make(map[string]int)
	res := make([]string, 0)
	for _, name := range names {
		if value, ok := m[name]; ok {
			for {
				newName := name + fmt.Sprintf("(%d)", value)
				if _, ok2 := m[newName]; ok2 {
					value++
					continue
				}
				res = append(res, newName)
				m[newName] = 1
				m[name] = value
				break
			}
		} else {
			res = append(res, name)
			m[name] = 1
		}
	}
	return res
}
```

## 1488.避免洪水泛滥

### 题目

```
你的国家有无数个湖泊，所有湖泊一开始都是空的。
当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。
你的目标是避免任意一个湖泊发生洪水。
给你一个整数数组 rains ，其中：
rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。
rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。
请返回一个数组 ans ，满足：ans.length == rains.length
如果 rains[i] > 0 ，那么ans[i] == -1 。
如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。
如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。
请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。
但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。
示例 1：输入：rains = [1,2,3,4] 输出：[-1,-1,-1,-1]
解释：第一天后，装满水的湖泊包括 [1]
第二天后，装满水的湖泊包括 [1,2]
第三天后，装满水的湖泊包括 [1,2,3]
第四天后，装满水的湖泊包括 [1,2,3,4]
没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。
示例 2：输入：rains = [1,2,0,0,2,1] 输出：[-1,-1,2,1,-1,-1]
解释：第一天后，装满水的湖泊包括 [1]
第二天后，装满水的湖泊包括 [1,2]
第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]
第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。
第五天后，装满水的湖泊包括 [2]。
第六天后，装满水的湖泊包括 [1,2]。
可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。
示例 3：输入：rains = [1,2,0,1,2] 输出：[]
解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。
但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。
示例 4：输入：rains = [69,0,0,0,69] 输出：[-1,69,1,1,-1]
解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是可行的解，
其中 1 <= x,y <= 10^9
示例 5：输入：rains = [10,20,20] 输出：[]
解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。
提示：1 <= rains.length <= 10^5
0 <= rains[i] <= 10^9
```

### 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go

```

## 1492.n的第k个因子(2)

- 题目

```
给你两个正整数 n 和 k 。
如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。
考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。
示例 1：输入：n = 12, k = 3输出：3
解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。
示例 2：输入：n = 7, k = 2 输出：7
解释：因子列表包括 [1, 7] ，第 2 个因子是 7 。
示例 3：输入：n = 4, k = 4 输出：-1
解释：因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。
示例 4：输入：n = 1, k = 1 输出：1
解释：因子列表包括 [1] ，第 1 个因子为 1 。
示例 5：输入：n = 1000, k = 3 输出：4
解释：因子列表包括 [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000] 。
提示：
    1 <= k <= n <= 1000
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 遍历 | O(n^1/2)   | O(1)       |

```go
func kthFactor(n int, k int) int {
	count := 0
	for i := 1; i <= n; i++ {
		if n%i == 0 {
			count++
			if count == k {
				return i
			}
		}
	}
	return -1
}

#
func kthFactor(n int, k int) int {
	count := 0
	i := 1
	for i = 1; i*i <= n; i++ {
		if n%i == 0 {
			count++
			if count == k {
				return i
			}
		}
	}
	i--
	if i*i == n {
		i--
	}
	for ; i > 0; i-- {
		if n%i == 0 {
			count++
			if count == k {
				return n / i
			}
		}
	}
	return -1
}
```

## 1493.删掉一个元素以后全为 1 的最长子数组(3)

- 题目

```
给你一个二进制数组 nums ，你需要从中删掉一个元素。
请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。
如果不存在这样的子数组，请返回 0 。
提示 1：输入：nums = [1,1,0,1] 输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。
示例 2：输入：nums = [0,1,1,1,0,1,1,0,1] 输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。
示例 3：输入：nums = [1,1,1] 输出：2
解释：你必须要删除一个元素。
示例 4：输入：nums = [1,1,0,0,1,1,1,0,1] 输出：4
示例 5：输入：nums = [0,0,0] 输出：0
提示：
    1 <= nums.length <= 10^5
    nums[i] 要么是 0 要么是 1 。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 数组辅助 | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |
| 03   | 数组辅助 | O(n)       | O(n)       |

```go
func longestSubarray(nums []int) int {
	n := len(nums)
	pre := make([]int, n)
	suf := make([]int, n)
	pre[0] = nums[0]
	for i := 1; i < n; i++ {
		if nums[i] == 1 {
			pre[i] = pre[i-1] + 1
		} else {
			pre[i] = 0
		}
	}
	suf[n-1] = nums[n-1]
	for i := n - 2; i >= 0; i-- {
		if nums[i] == 1 {
			suf[i] = suf[i+1] + 1
		} else {
			suf[i] = 0
		}
	}
	res := 0
	for i := 0; i < n; i++ {
		var p, s int
		if i == 0 {
			p = 0
		} else {
			p = pre[i-1]
		}
		if i == n-1 {
			s = 0
		} else {
			s = suf[i+1]
		}
		if p+s > res {
			res = p + s
		}
	}
	return res
}

#
func longestSubarray(nums []int) int {
	res := 0
	p, q := 0, 0 // q=>中间有一个“非1”的和, p=>连续1的和
	for i := 0; i < len(nums); i++ {
		if nums[i] == 0 {
			q = p
			p = 0
		} else {
			p++
			q++
		}
		if q > res {
			res = q
		}
	}
	if res == len(nums) {
		return res - 1
	}
	return res
}

#
func longestSubarray(nums []int) int {
	arr := make([]int, 0)
	count := 0
	for _, v := range nums {
		if v == 0 {
			arr = append(arr, count)
			count = 0
			continue
		}
		count++
	}
	arr = append(arr, count)
	if len(arr) == 1 {
		return arr[0] - 1
	}
	res := 0
	for i := 0; i < len(arr)-1; i++ {
		if arr[i]+arr[i+1] > res {
			res = arr[i] + arr[i+1]
		}
	}
	return res
}
```

## 1497.检查数组对是否可以被k整除(2)

- 题目

```
给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。
现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。
如果存在这样的分法，请返回 True ；否则，返回 False 。
示例 1：输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5 输出：true
解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。
示例 2：输入：arr = [1,2,3,4,5,6], k = 7 输出：true
解释：划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。
示例 3：输入：arr = [1,2,3,4,5,6], k = 10 输出：false
解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。
示例 4：输入：arr = [-10,10], k = 2 输出：true
示例 5：输入：arr = [-1,1,-2,2,-3,3,-4,4], k = 3 输出：true
提示：arr.length == n
    1 <= n <= 10^5
    n 为偶数
    -10^9 <= arr[i] <= 10^9
    1 <= k <= 10^5
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(n)       |
| 02   | 数组辅助 | O(n)       | O(n)       |

```go
func canArrange(arr []int, k int) bool {
	m := make(map[int]int)
	for i := 0; i < len(arr); i++ {
		value := ((arr[i] % k) + k) % k
		m[value]++
	}
	for key, value := range m {
		if key == 0 && value%2 != 0 {
			return false
		}
		target := (k - key) % k // 避免key=0，k-0=k的情况
		if m[target] != value {
			return false
		}
	}
	return true
}

# 2
func canArrange(arr []int, k int) bool {
	temp := make([]int, k)
	for i := 0; i < len(arr); i++ {
		value := ((arr[i] % k) + k) % k
		temp[value]++
	}
	for i := 1; i < k; i++ {
		if temp[i] != temp[k-i] {
			return false
		}
	}
	return temp[0]%2 == 0
}
```

## 1498.满足条件的子序列数目(2)

- 题目

```
给你一个整数数组 nums 和一个整数 target 。
请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。
由于答案可能很大，请将结果对 10^9 + 7 取余后返回。
示例 1：输入：nums = [3,5,6,7], target = 9 输出：4
解释：有 4 个子序列满足该条件。
[3] -> 最小元素 + 最大元素 <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
示例 2：输入：nums = [3,3,6,8], target = 10 输出：6
解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
示例 3：输入：nums = [2,3,3,4,6,7], target = 12 输出：61
解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）
有效序列总数为（63 - 2 = 61）
示例 4：输入：nums = [5,2,4,1,7,6,8], target = 16 输出：127
解释：所有非空子序列都满足条件 (2^7 - 1) = 127
提示：1 <= nums.length <= 10^5
1 <= nums[i] <= 10^6
1 <= target <= 10^6
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 排序双指针   | O(nlog(n)) | O(n)       |
| 02   | 排序二分查找 | O(nlog(n)) | O(n)       |

```go
func numSubseq(nums []int, target int) int {
	sort.Ints(nums)
	// 计算长度为length满足条件的非空子序列的数目
	// 如1、2、3、4，长度为4，1必选，其他3个数可选可不选，组合数：2^3=8
	m := make(map[int]int)
	m[1] = 1
	for i := 2; i <= len(nums); i++ {
		m[i] = (m[i-1] * 2) % 1000000007
	}
	res := 0
	left, right := 0, len(nums)-1
	for left <= right {
		if nums[left]+nums[right] <= target {
			length := right - left + 1
			res = res + m[length]
			left++
		} else {
			right--
		}
	}
	return res % 1000000007
}

# 2
func numSubseq(nums []int, target int) int {
	sort.Ints(nums)
	// 计算长度为length满足条件的非空子序列的数目
	// 如1、2、3、4，长度为4，1必选，其他3个数可选可不选，组合数：2^3=8
	m := make(map[int]int)
	m[1] = 1
	for i := 2; i <= len(nums); i++ {
		m[i] = (m[i-1] * 2) % 1000000007
	}
	res := 0
	for i := 0; i < len(nums); i++ {
		left, right := i, len(nums)
		for left+1 < right {
			mid := left + (right-left)/2
			if nums[mid]+nums[i] <= target {
				left = mid
			} else {
				right = mid
			}
		}
		if nums[left]+nums[i] <= target {
			length := left - i + 1
			res = res + m[length]
		}
	}
	return res % 1000000007
}
```

# 1401-1500-Hard

