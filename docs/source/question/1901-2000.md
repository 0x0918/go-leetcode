# 1901-2000-Easy

## 1903.字符串中的最大奇数(1)

- 题目

```
给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。
如果不存在奇数，则返回一个空字符串 "" 。
子字符串 是字符串中的一个连续的字符序列。
示例 1：输入：num = "52" 输出："5"
解释：非空子字符串仅有 "5"、"2" 和 "52" 。"5" 是其中唯一的奇数。
示例 2：输入：num = "4206" 输出：""
解释：在 "4206" 中不存在奇数。
示例 3：输入：num = "35427" 输出："35427"
解释："35427" 本身就是一个奇数。
提示：1 <= num.length <= 105
num 仅由数字组成且不含前导零
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
func largestOddNumber(num string) string {
	n := len(num)
	for i := n - 1; i >= 0; i-- {
		if int(num[i]-'0')%2 == 1 {
			return num[:i+1]
		}
	}
	return ""
}
```

## 1909.删除一个元素使数组严格递增(3)

- 题目

```
给你一个下标从 0 开始的整数数组 nums ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回 true ，否则返回 false 。
如果数组本身已经是严格递增的，请你也返回 true 。
数组 nums 是 严格递增 的定义为：对于任意下标的 1 <= i < nums.length 都满足 nums[i - 1] < nums[i] 。
示例 1：输入：nums = [1,2,10,5,7] 输出：true
解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。
[1,2,5,7] 是严格递增的，所以返回 true 。
示例 2：输入：nums = [2,3,1,2] 输出：false
解释：[3,1,2] 是删除下标 0 处元素后得到的结果。
[2,1,2] 是删除下标 1 处元素后得到的结果。
[2,3,2] 是删除下标 2 处元素后得到的结果。
[2,3,1] 是删除下标 3 处元素后得到的结果。
没有任何结果数组是严格递增的，所以返回 false 。
示例 3：输入：nums = [1,1,1] 输出：false
解释：删除任意元素后的结果都是 [1,1] 。
[1,1] 不是严格递增的，所以返回 false 。
示例 4：输入：nums = [1,2,3] 输出：true
解释：[1,2,3] 已经是严格递增的，所以返回 true 。
提示：2 <= nums.length <= 1000
1 <= nums[i] <= 1000
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n)       | O(n)       |
| 02   | 暴力法   | O(n^2)     | O(n)       |
| 03   | 动态规划 | O(n^2)     | O(n)       |

```go
func canBeIncreasing(nums []int) bool {
	for i := 0; i < len(nums)-1; i++ {
		if nums[i] >= nums[i+1] {
			return judge(nums, i) == true || judge(nums, i+1) == true
		}
	}
	return true
}

func judge(nums []int, index int) bool {
	arr := append([]int{}, nums[:index]...)
	arr = append(arr, nums[index+1:]...)
	for i := 0; i < len(arr)-1; i++ {
		if arr[i] >= arr[i+1] {
			return false
		}
	}
	return true
}

# 2
func canBeIncreasing(nums []int) bool {
	for i := 0; i < len(nums); i++ {
		if judge(nums, i) == true {
			return true
		}
	}
	return false
}

func judge(nums []int, index int) bool {
	arr := append([]int{}, nums[:index]...)
	arr = append(arr, nums[index+1:]...)
	for i := 0; i < len(arr)-1; i++ {
		if arr[i] >= arr[i+1] {
			return false
		}
	}
	return true
}

# 3
// leetcode300.最长上升子序列
func canBeIncreasing(nums []int) bool {
	n := len(nums)
	dp := make([]int, n)
	res := 1
	for i := 0; i < n; i++ {
		dp[i] = 1
		for j := 0; j < i; j++ {
			if nums[j] < nums[i] {
				dp[i] = max(dp[j]+1, dp[i])
			}
		}
		res = max(res, dp[i])
	}
	return res == n || res == n-1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 1913.两个数对之间的最大乘积差(2)

- 题目

```
两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。
例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。
给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，
使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。
返回以这种方式取得的乘积差中的 最大值 。
示例 1：输入：nums = [5,6,2,7,4] 输出：34
解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)
乘积差是 (6 * 7) - (2 * 4) = 34
示例 2：输入：nums = [4,2,5,9,7,4,8] 输出：64
解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)
乘积差是 (9 * 8) - (2 * 4) = 64
提示：4 <= nums.length <= 104
1 <= nums[i] <= 104
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func maxProductDifference(nums []int) int {
	sort.Ints(nums)
	n := len(nums)
	return nums[n-1]*nums[n-2] - nums[0]*nums[1]
}

# 2
func maxProductDifference(nums []int) int {
	n := len(nums)
	minA, minB := min(nums[0], nums[1]), max(nums[0], nums[1])
	maxA, maxB := max(nums[0], nums[1]), min(nums[0], nums[1])
	for i := 2; i < n; i++ {
		if nums[i] > maxA {
			maxA, maxB = nums[i], maxA
		} else if nums[i] > maxB {
			maxB = nums[i]
		}
		if nums[i] < minA {
			minA, minB = nums[i], minA
		} else if nums[i] < minB {
			minB = nums[i]
		}
	}
	return maxA*maxB - minA*minB
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 1920.基于排列构建数组(2)

- 题目

```
给你一个 从 0 开始的排列 nums（下标也从 0 开始）。
请你构建一个 同样长度 的数组 ans ，其中，对于每个 i（0 <= i < nums.length），都满足 ans[i] = nums[nums[i]] 。
返回构建好的数组 ans 。
从 0 开始的排列 nums 是一个由 0 到 nums.length - 1（0 和 nums.length - 1 也包含在内）的不同整数组成的数组。
示例 1：输入：nums = [0,2,1,5,3,4] 输出：[0,1,2,4,5,3]
解释：数组 ans 构建如下：
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
示例 2：输入：nums = [5,0,1,2,3,4] 输出：[4,5,0,1,2,3]
解释：数组 ans 构建如下：
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
提示：1 <= nums.length <= 1000
0 <= nums[i] < nums.length
nums 中的元素 互不相同
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 遍历          | O(n)       | O(n)       |
| 02   | 遍历-原地构造 | O(n)       | O(1)       |

```go
func buildArray(nums []int) []int {
	n := len(nums)
	res := make([]int, n)
	for i := 0; i < n; i++ {
		res[i] = nums[nums[i]]
	}
	return res
}

# 2
func buildArray(nums []int) []int {
	n := len(nums)
	for i := 0; i < n; i++ {
		nums[i] = nums[i] + 1000*(nums[nums[i]]%1000) // 前3位存储目标值，后3位存储原来值
	}
	for i := 0; i < n; i++ {
		nums[i] = nums[i] / 1000
	}
	return nums
}
```

## 1925.统计平方和三元组的数目(3)

- 题目

```
一个 平方和三元组 (a,b,c) 指的是满足 a2 + b2 = c2 的 整数 三元组 a，b 和 c 。
给你一个整数 n ，请你返回满足 1 <= a, b, c <= n 的 平方和三元组 的数目。
示例 1：输入：n = 5 输出：2
解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。
示例 2：输入：n = 10 输出：4
解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。
提示：1 <= n <= 250
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 暴力法   | O(n^3)     | O(1)       |
| 02   | 哈希辅助 | O(n^2)     | O(n)       |
| 03   | 内置函数 | O(n^2)     | O(1)       |

```go
func countTriples(n int) int {
	res := 0
	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			for k := 1; k <= n; k++ {
				if i*i+j*j == k*k {
					res++
				}
			}
		}
	}
	return res
}

# 2
func countTriples(n int) int {
	res := 0
	m := make(map[int]bool)
	for i := 1; i <= n; i++ {
		m[i*i] = true
	}
	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			if m[i*i+j*j] == true {
				res++
			}
		}
	}
	return res
}

# 3
func countTriples(n int) int {
	res := 0
	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			k := int(math.Sqrt(float64(i*i + j*j)))
			if k*k == i*i+j*j && k <= n {
				res++
			}
		}
	}
	return res
}
```

## 1929.数组串联(3)

- 题目

```
给你一个长度为 n 的整数数组 nums 。请你构建一个长度为 2n 的答案数组 ans ，
数组下标 从 0 开始计数 ，对于所有 0 <= i < n 的 i ，满足下述所有要求：
ans[i] == nums[i]
ans[i + n] == nums[i]
具体而言，ans 由两个 nums 数组 串联 形成。
返回数组 ans 。
示例 1：输入：nums = [1,2,1] 输出：[1,2,1,1,2,1]
解释：数组 ans 按下述方式形成：
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
示例 2：输入：nums = [1,3,2,1] 输出：[1,3,2,1,1,3,2,1]
解释：数组 ans 按下述方式形成：
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
提示：n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 1000
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(n)       |
| 03   | 内置语法 | O(n)       | O(n)       |

```go
func getConcatenation(nums []int) []int {
	n := len(nums)
	res := make([]int, 2*n)
	for i := 0; i < n; i++ {
		res[i] = nums[i]
		res[i+n] = nums[i]
	}
	return res
}

# 2
func getConcatenation(nums []int) []int {
	n := len(nums)
	for i := 0; i < n; i++ {
		nums = append(nums, nums[i])
	}
	return nums
}

# 3
func getConcatenation(nums []int) []int {
	return append(nums, nums...)
}
```

## 1935.可以输入的最大单词数(2)

- 题目

```
键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。
给你一个由若干单词组成的字符串 text ，单词间由单个空格组成（不含前导和尾随空格）；
另有一个字符串 brokenLetters ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 text 中单词的数目。
示例 1：输入：text = "hello world", brokenLetters = "ad" 输出：1
解释：无法输入 "world" ，因为字母键 'd' 已损坏。
示例 2：输入：text = "leet code", brokenLetters = "lt" 输出：1
解释：无法输入 "leet" ，因为字母键 'l' 和 't' 已损坏。
示例 3：输入：text = "leet code", brokenLetters = "e" 输出：0
解释：无法输入任何单词，因为字母键 'e' 已损坏。
提示：1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格
每个单词仅由小写英文字母组成
brokenLetters 由 互不相同 的小写英文字母组成
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n)       | O(n)       |
| 02   | 哈希辅助 | O(n)       | O(n)       |

```go
func canBeTypedWords(text string, brokenLetters string) int {
	res := 0
	arr := strings.Split(text, " ")
	for i := 0; i < len(arr); i++ {
		if strings.ContainsAny(arr[i], brokenLetters) == false {
			res++
		}
	}
	return res
}

# 2
func canBeTypedWords(text string, brokenLetters string) int {
	res := 0
	m := make(map[byte]bool)
	for i := 0; i < len(brokenLetters); i++ {
		m[brokenLetters[i]] = true
	}
	arr := strings.Split(text, " ")
	for i := 0; i < len(arr); i++ {
		flag := true
		for j := 0; j < len(arr[i]); j++ {
			if m[arr[i][j]] == true {
				flag = false
				break
			}
		}
		if flag == true {
			res++
		}
	}
	return res
}
```

## 1941.检查是否所有字符出现次数相同(2)

- 题目

```
给你一个字符串 s ，如果 s 是一个 好 字符串，请你返回 true ，否则请返回 false 。
如果 s 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 s 是 好 字符串。
示例 1：输入：s = "abacbc" 输出：true
解释：s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。
示例 2：输入：s = "aaabb" 输出：false
解释：s 中出现过的字符为 'a' 和 'b' 。
'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。
提示：1 <= s.length <= 1000
s 只包含小写英文字母。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func areOccurrencesEqual(s string) bool {
	m := make(map[byte]int)
	for i := 0; i < len(s); i++ {
		m[s[i]]++
	}
	count := 0
	for _, v := range m {
		if count == 0 {
			count = v
		} else {
			if count != v {
				return false
			}
		}
	}
	return true
}

# 2
func areOccurrencesEqual(s string) bool {
	m := make(map[byte]int)
	for i := 0; i < len(s); i++ {
		m[s[i]]++
	}
	count := len(s)/len(m)
	for _, v := range m {
		if v != count{
			return false
		}
	}
	return true
}
```

## 1945.字符串转化后的各位数字之和(2)

- 题目

```
给你一个由小写字母组成的字符串 s ，以及一个整数 k 。
首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，'a' 用 1 替换，'b' 用 2 替换，... 'z' 用 26 替换）。
接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。
例如，如果 s = "zbax" 且 k = 2 ，那么执行下述步骤后得到的结果是整数 8 ：
转化："zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
转换 #1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
转换 #2：17 ➝ 1 + 7 ➝ 8
返回执行上述操作后得到的结果整数。
示例 1：输入：s = "iiii", k = 1 输出：36
解释：操作如下：- 转化："iiii" ➝ "(9)(9)(9)(9)" ➝ "9999" ➝ 9999
- 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36
因此，结果整数为 36 。
示例 2：输入：s = "leetcode", k = 2 输出：6
解释：操作如下：- 转化："leetcode" ➝ "(12)(5)(5)(20)(3)(15)(4)(5)" ➝ "12552031545" ➝ 12552031545
- 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33
- 转换 #2：33 ➝ 3 + 3 ➝ 6
因此，结果整数为 6 。
提示：1 <= s.length <= 100
1 <= k <= 10
s 由小写英文字母组成
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 模拟 | O(n)       | O(n)       |
| 02   | 模拟 | O(n)       | O(1)       |

```go
func getLucky(s string, k int) int {
	arr := make([]int, 0)
	for i := 0; i < len(s); i++ {
		value := int(s[i]-'a') + 1
		if value < 10 {
			arr = append(arr, value)
		} else {
			arr = append(arr, value/10)
			arr = append(arr, value%10)
		}
	}
	for i := 1; i <= k; i++ {
		arr = trans(arr)
	}
	res := 0
	for i := 0; i < len(arr); i++ {
		res = 10*res + arr[i]
	}
	return res
}

func trans(arr []int) []int {
	sum := 0
	for i := 0; i < len(arr); i++ {
		sum = sum + arr[i]
	}
	res := make([]int, 0)
	for sum > 0 {
		res = append([]int{sum % 10}, res...)
		sum = sum / 10
	}
	return res
}

# 2
func getLucky(s string, k int) int {
	sum := 0
	for i := 0; i < len(s); i++ {
		value := int(s[i]-'a') + 1
		sum = sum + (value/10 + value%10)
	}
	res := sum
	for i := 1; i <= k-1; i++ {
		sum = res
		res = 0
		for sum > 0 {
			res = res + sum%10
			sum = sum / 10
		}
	}
	return res
}
```

# 1901-2000-Medium

## 1904.你完成的完整对局数(1)

- 题目

```
一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。
这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。
游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。
给你两个字符串 startTime 和 finishTime ，均符合 "HH:MM" 格式，分别表示你 进入 和 退出 游戏的确切时间，
请计算在整个游戏会话期间，你完成的 完整对局的对局数 。
例如，如果 startTime = "05:20" 且 finishTime = "05:59" ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。
而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；
同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。
如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。
假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。
示例 1：输入：startTime = "12:01", finishTime = "12:44" 输出：1
解释：你完成了从 12:15 到 12:30 的一个完整对局。
你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。
你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。
示例 2：输入：startTime = "20:00", finishTime = "06:00" 输出：40
解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。
16 + 24 = 40
示例 3：输入：startTime = "00:00", finishTime = "23:59" 输出：95
解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。
提示：startTime 和 finishTime 的格式为 HH:MM
00 <= HH <= 23
00 <= MM <= 59
startTime 和 finishTime 不相等
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(1)       | O(1)       |

```go
func numberOfRounds(startTime string, finishTime string) int {
	a, _ := strconv.Atoi(startTime[:2])
	b, _ := strconv.Atoi(startTime[3:])
	c, _ := strconv.Atoi(finishTime[:2])
	d, _ := strconv.Atoi(finishTime[3:])
	t1 := 60*a + b
	t2 := 60*c + d
	if t2 < t1 {
		t2 = t2 + 1440
	}
	start := int(math.Ceil(float64(t1) / float64(15)))   // 向上取整
	finish := int(math.Floor(float64(t2) / float64(15))) // 向下取整
	if finish - start >= 0{
		return finish-start
	}
	return 0 // 00:47 ~00:48
}
```

## 1905.统计子岛屿(2)

- 题目

```
给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。
一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，
也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。
请你返回 grid2 中 子岛屿 的 数目 。
示例 1：输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], 
grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
输出：3
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。
示例 2：输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], 
grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
输出：2 
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。
提示：m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= 500
grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 深度优先搜索 | O(n^2)     | O(1)       |
| 02   | 广度优先搜索 | O(n^2)     | O(n)       |

```go
func countSubIslands(grid1 [][]int, grid2 [][]int) int {
	res := 0
	for i := 0; i < len(grid2); i++ {
		for j := 0; j < len(grid2[i]); j++ {
			if grid2[i][j] == 1 { // 查找grid2
				if dfs(grid1, grid2, i, j) == true {
					res++
				}
			}
		}
	}
	return res
}

// leetcode200.岛屿数量
func dfs(grid1, grid2 [][]int, i, j int) bool {
	if i < 0 || j < 0 || i >= len(grid2) || j >= len(grid2[0]) || grid2[i][j] == 0 {
		return true
	}
	if grid1[i][j] == 0 {
		return false
	}
	grid1[i][j], grid2[i][j] = 0, 0
	res1 := dfs(grid1, grid2, i+1, j)
	res2 := dfs(grid1, grid2, i-1, j)
	res3 := dfs(grid1, grid2, i, j+1)
	res4 := dfs(grid1, grid2, i, j-1)
	if res1 == false || res2 == false || res3 == false || res4 == false {
		return false
	}
	return true
}

# 2
var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func countSubIslands(grid1 [][]int, grid2 [][]int) int {
	res := 0
	for i := 0; i < len(grid2); i++ {
		for j := 0; j < len(grid2[i]); j++ {
			if grid2[i][j] == 1 { // 查找grid2
				if bfs(grid1, grid2, i, j) == true {
					res++
				}
			}
		}
	}
	return res
}

// leetcode200.岛屿数量
func bfs(grid1, grid2 [][]int, i, j int) bool {
	queue := make([][2]int, 0)
	queue = append(queue, [2]int{i, j})
	flag := true
	if grid1[i][j] == 0 {
		flag = false
	}
	grid1[i][j] = 0
	grid2[i][j] = 0
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		for i := 0; i < 4; i++ {
			x := node[0] + dx[i]
			y := node[1] + dy[i]
			if 0 <= x && x < len(grid2) &&
				0 <= y && y < len(grid2[0]) &&
				grid2[x][y] == 1 {
				queue = append(queue, [2]int{x, y})
				if grid1[x][y] == 0 {
					flag = false
				}
				grid1[x][y] = 0
				grid2[x][y] = 0
			}
		}
	}
	return flag
}
```

## 1906.查询差绝对值的最小值(2)

- 题目

```
一个数组 a 的 差绝对值的最小值 定义为：0 <= i < j < a.length 且 a[i] != a[j] 的 |a[i] - a[j]| 的 最小值。
如果 a 中所有元素都 相同 ，那么差绝对值的最小值为 -1 。
比方说，数组 [5,2,3,7,2] 差绝对值的最小值是 |2 - 3| = 1 。注意答案不为 0 ，因为 a[i] 和 a[j] 必须不相等。
给你一个整数数组 nums 和查询数组 queries ，其中 queries[i] = [li, ri] 。
对于每个查询 i ，计算 子数组 nums[li...ri] 中 差绝对值的最小值 ，
子数组 nums[li...ri] 包含 nums 数组（下标从 0 开始）中下标在 li 和 ri 之间的所有元素（包含 li 和 ri 在内）。
请你返回 ans 数组，其中 ans[i] 是第 i 个查询的答案。
子数组 是一个数组中连续的一段元素。
|x| 的值定义为：
如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。
示例 1：输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]] 输出：[2,1,4,1]
解释：查询结果如下：
- queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。
- queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。
- queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。
- queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。
示例 2：输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
输出：[-1,1,1,3]
解释：查询结果如下：
- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。
- queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。
- queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。
- queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。
提示：2 <= nums.length <= 105
1 <= nums[i] <= 100
1 <= queries.length <= 2 * 104
0 <= li < ri < nums.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 前缀和   | O(n)       | O(n)       |
| 02   | 树状数组 | O(nlog(n)) | O(n)       |

```go
func minDifference(nums []int, queries [][]int) []int {
	n := len(nums)
	arr := make([][101]int, n+1)
	for i := 1; i <= n; i++ {
		arr[i] = arr[i-1]
		arr[i][nums[i-1]]++
	}
	res := make([]int, len(queries))
	for i := 0; i < len(queries); i++ {
		res[i] = -1
		left, right := queries[i][0], queries[i][1]
		prev, minValue := 0, math.MaxInt32
		for j := 1; j <= 100; j++ { // 枚举每个数
			if arr[right+1][j] != arr[left][j] { // 当j出现
				if prev != 0 {
					if j-prev < minValue { // 保存较小的差值
						minValue = j - prev
					}
				}
				prev = j // 更新上一个出现的数
			}
		}
		if minValue != math.MaxInt32 {
			res[i] = minValue
		}
	}
	return res
}

# 2
func minDifference(nums []int, queries [][]int) []int {
	n := len(nums)
	length = n
	c = make([][]int, 101) // 存储每个数对应顺序区间出现的次数
	for i := 0; i < 101; i++ {
		c[i] = make([]int, n+1)
	}
	for i := 1; i <= n; i++ {
		upData(nums[i-1], i, 1)
	}
	res := make([]int, len(queries))
	for i := 0; i < len(queries); i++ {
		res[i] = -1
		left, right := queries[i][0], queries[i][1]
		prev, minValue := 0, math.MaxInt32
		for j := 1; j <= 100; j++ { // 枚举每个数
			count := getSum(j, right+1) - getSum(j, left)
			if count > 0 { // 当j出现
				if prev != 0 {
					if j-prev < minValue { // 保存较小的差值
						minValue = j - prev
					}
				}
				prev = j // 更新上一个出现的数
			}
		}
		if minValue != math.MaxInt32 {
			res[i] = minValue
		}
	}
	return res
}

var length int
var c [][]int // 树状数组

func lowBit(x int) int {
	return x & (-x)
}

// 单点修改
func upData(index, i, k int) { // 在i位置加上k
	for i <= length {
		c[index][i] = c[index][i] + k
		i = i + lowBit(i) // i = i + 2^k
	}
}

// 区间查询
func getSum(index, i int) int {
	res := 0
	for i > 0 {
		res = res + c[index][i]
		i = i - lowBit(i)
	}
	return res
}
```

## 1910.删除一个字符串中所有出现的给定子字符串(2)

- 题目

```
给你两个字符串 s 和 part ，请你对 s 反复执行以下操作直到 所有 子字符串 part 都被删除：
找到 s 中 最左边 的子字符串 part ，并将它从 s 中删除。
请你返回从 s 中删除所有 part 子字符串以后得到的剩余字符串。
一个 子字符串 是一个字符串中连续的字符序列。
示例 1：输入：s = "daabcbaabcbc", part = "abc" 输出："dab"
解释：以下操作按顺序执行：
- s = "daabcbaabcbc" ，删除下标从 2 开始的 "abc" ，得到 s = "dabaabcbc" 。
- s = "dabaabcbc" ，删除下标从 4 开始的 "abc" ，得到 s = "dababc" 。
- s = "dababc" ，删除下标从 3 开始的 "abc" ，得到 s = "dab" 。
此时 s 中不再含有子字符串 "abc" 。
示例 2：输入：s = "axxxxyyyyb", part = "xy" 输出："ab"
解释：以下操作按顺序执行：
- s = "axxxxyyyyb" ，删除下标从 4 开始的 "xy" ，得到 s = "axxxyyyb" 。
- s = "axxxyyyb" ，删除下标从 3 开始的 "xy" ，得到 s = "axxyyb" 。
- s = "axxyyb" ，删除下标从 2 开始的 "xy" ，得到 s = "axyb" 。
- s = "axyb" ，删除下标从 1 开始的 "xy" ，得到 s = "ab" 。
此时 s 中不再含有子字符串 "xy" 。
提示：1 <= s.length <= 1000
1 <= part.length <= 1000
s和 part 只包小写英文字母。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n^2)     | O(n)       |
| 02   | 内置函数 | O(n^2)     | O(n)       |

```go
func removeOccurrences(s string, part string) string {
	for strings.Contains(s, part) {
		s = strings.Replace(s, part, "", 1)
	}
	return s
}

# 2
func removeOccurrences(s string, part string) string {
	for {
		index := strings.Index(s, part)
		if index < 0 {
			return s
		}
		s = s[:index] + s[index+len(part):]
	}
	return s
}
```

## 1911.最大子序列交替和(3)

- 题目

```
一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。
比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。
一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。
比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。
示例 1：输入：nums = [4,2,5,3] 输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
示例 2：输入：nums = [5,6,7,8] 输出：8
解释：最优子序列为 [8] ，交替和为 8 。
示例 3：输入：nums = [6,2,1,2,4,5] 输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。
提示：1 <= nums.length <= 105
1 <= nums[i] <= 105
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 动态规划 | O(n)       | O(1)       |
| 02   | 动态规划 | O(n)       | O(n)       |
| 03   | 贪心法   | O(n)       | O(n)       |

```go
func maxAlternatingSum(nums []int) int64 {
	n := len(nums)
	odd, even := 0, nums[0]
	for i := 1; i < n; i++ {
		odd, even = max(even-nums[i], odd), max(odd+nums[i], even)
	}
	return int64(even)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxAlternatingSum(nums []int) int64 {
	n := len(nums)
	dp := make([][2]int, n)
	dp[0][0] = int(nums[0])
	dp[0][1] = 0
	for i := 1; i < n; i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+nums[i])
		dp[i][1] = max(dp[i-1][1], dp[i][0]-nums[i])
	}
	return int64(max(dp[n-1][0], dp[n-1][1]))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func maxAlternatingSum(nums []int) int64 {
	// leetcode122.买卖股票的最佳时机II
	nums = append([]int{0}, nums...) // 补零
	res := 0
	for i := 1; i < len(nums); i++ {
		if nums[i] > nums[i-1] {
			res = res + nums[i] - nums[i-1]
		}
	}
	return int64(res)
}
```

## 1914.循环轮转矩阵(1)

- 题目

```
给你一个大小为 m x n 的整数矩阵 grid，其中 m 和 n 都是 偶数 ；另给你一个整数 k 。
矩阵由若干层组成，如下图所示，每种颜色代表一层：
矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。
在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下：
返回执行 k 次循环轮转操作后的矩阵。
示例 1：输入：grid = [[40,10],[30,20]], k = 1 输出：[[10,20],[40,30]]
解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。
示例 2：输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。
提示：m == grid.length
n == grid[i].length
2 <= m, n <= 50
m 和 n 都是 偶数
1 <= grid[i][j] <= 5000
1 <= k <= 109
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n^2)     | O(n)       |

```go
func rotateGrid(grid [][]int, k int) [][]int {
	n, m := len(grid), len(grid[0])
	count := min(n/2, m/2)
	for level := 0; level < count; level++ {
		arr := make([][3]int, 0)
		for i := level; i < n-1-level; i++ { // 左上=>左下
			arr = append(arr, [3]int{i, level, grid[i][level]})
		}
		for j := level; j < m-1-level; j++ { // 左下=>右下
			arr = append(arr, [3]int{n - 1 - level, j, grid[n-1-level][j]})
		}
		for i := n - 1 - level; i > level; i-- { // 右下=>右上
			arr = append(arr, [3]int{i, m - 1 - level, grid[i][m-1-level]})
		}
		for j := m - 1 - level; j > level; j-- { // 右上=>左上
			arr = append(arr, [3]int{level, j, grid[level][j]})
		}
		total := len(arr)
		step := k % total
		for i := 0; i < total; i++ {
			index := (i + total - step) % total
			a, b, c := arr[i][0], arr[i][1], arr[index][2]
			grid[a][b] = c
		}
	}
	return grid
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
```

## 1915.最美子字符串的数目(1)

- 题目

```
如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。
例如，"ccjjc" 和 "abab" 都是最美字符串，但 "ab" 不是。
给你一个字符串 word ，该字符串由前十个小写英文字母组成（'a' 到 'j'）。
请你返回 word 中 最美非空子字符串 的数目。如果同样的子字符串在 word 中出现多次，那么应当对 每次出现 分别计数。
子字符串 是字符串中的一个连续字符序列。
示例 1：输入：word = "aba" 输出：4
解释：4 个最美子字符串如下所示：
- "aba" -> "a"
- "aba" -> "b"
- "aba" -> "a"
- "aba" -> "aba"
示例 2：输入：word = "aabb" 输出：9
解释：9 个最美子字符串如下所示：
- "aabb" -> "a"
- "aabb" -> "aa"
- "aabb" -> "aab"
- "aabb" -> "aabb"
- "aabb" -> "a"
- "aabb" -> "abb"
- "aabb" -> "b"
- "aabb" -> "bb"
- "aabb" -> "b"
示例 3：输入：word = "he" 输出：2
解释：2 个最美子字符串如下所示：
- "he" -> "h"
- "he" -> "e"
提示：1 <= word.length <= 105
word 由从 'a' 到 'j' 的小写英文字母组成
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 前缀和+位运算 | O(n)       | O(1)       |

```go
func wonderfulSubstrings(word string) int64 {
	res := 0
	m := make(map[int]int)
	m[0] = 1 // 初始状态没有任何字符，相当于全是偶数
	cur := 0
	for i := 0; i < len(word); i++ {
		value := int(word[i] - 'a')
		cur = cur ^ (1 << value) // 位运算-异或后的状态结果，表示到当前下标各字母出现的奇偶次数
		res = res + m[cur]       // 跟当前状态相同
		for i := 0; i < 10; i++ {
			count := m[cur^(1<<i)] // 跟当前状态差1位相同
			res = res + count
		}
		m[cur]++
	}
	return int64(res)
}
```

## 1921.消灭怪物的最大数量(1)

- 题目

```
你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。
给你一个 下标从 0 开始 且长度为 n 的整数数组 dist ，其中 dist[i] 是第 i 个怪物与城市的 初始距离（单位：米）。
怪物以 恒定 的速度走向城市。
给你一个长度为 n 的整数数组 speed 表示每个怪物的速度，其中 speed[i] 是第 i 个怪物的速度（单位：米/分）。
怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。
但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。
一旦任一怪物到达城市，你就输掉了这场游戏。
如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。
返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。
示例 1：输入：dist = [1,3,4], speed = [1,1,1] 输出：3
解释：第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。
第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。
第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。
所有 3 个怪物都可以被消灭。
示例 2：输入：dist = [1,1,2,3], speed = [1,1,1,1] 输出：1
解释：第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。
你只能消灭 1 个怪物。
示例 3：输入：dist = [3,2,4], speed = [5,3,2] 输出：1
解释：第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 
你只能消灭 1 个怪物。
提示：n == dist.length == speed.length
1 <= n <= 105
1 <= dist[i], speed[i] <= 105
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |

```go
func eliminateMaximum(dist []int, speed []int) int {
	res := 0
	temp := make([]float64, len(dist))
	for i := 0; i < len(dist); i++ {
		temp[i] = float64(dist[i]) / float64(speed[i])
	}
	sort.Slice(temp, func(i, j int) bool {
		return temp[i] < temp[j]
	})
	for i := 0; i < len(dist); i++ {
		if float64(i) < temp[i] {
			res++
		} else {
			break
		}
	}
	return res
}
```

## 1922.统计好数字的数目(2)

- 题目

```
我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。
比方说，"2582" 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。
但 "3245" 不是 好数字，因为 3 在偶数下标处但不是偶数。
给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 109 + 7 取余后返回 。
一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。
示例 1：输入：n = 1 输出：5
解释：长度为 1 的好数字包括 "0"，"2"，"4"，"6"，"8" 。
示例 2：输入：n = 4 输出：400
示例 3：输入：n = 50 输出：564908303
提示：1 <= n <= 1015
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 快速幂 | O(log(n))  | O(1)       |
| 02   | 快速幂 | O(log(n))  | O(1)       |

```go
var mod = int64(1000000007)

func countGoodNumbers(n int64) int {
	res := mypow(20, n/2)
	if n%2 == 1 {
		res = res * 5 % mod
	}
	return int(res)
}

func mypow(a int64, n int64) int64 {
	var res = int64(1)
	for n > 0 {
		if n%2 == 1 {
			res = res * a % mod
		}
		a = a * a % mod
		n = n / 2
	}
	return res
}

# 2
var mod = int64(1000000007)

func countGoodNumbers(n int64) int {
	return int(mypow(5, (n+1)/2) * mypow(4, n/2) % mod)
}

func mypow(a int64, n int64) int64 {
	var res = int64(1)
	for n > 0 {
		if n%2 == 1 {
			res = res * a % mod
		}
		a = a * a % mod
		n = n / 2
	}
	return res
}
```

## 1926.迷宫中离入口最近的出口(1)

- 题目

```
给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 '.' 表示）和墙（用 '+' 表示）。
同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。
每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。
你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。
请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。
示例 1：输入：maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2] 输出：1
解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。
一开始，你在入口格子 (1,2) 处。
- 你可以往左移动 2 步到达 (1,0) 。
- 你可以往上移动 1 步到达 (0,2) 。
从入口处没法到达 (2,3) 。
所以，最近的出口是 (0,2) ，距离为 1 步。
示例 2：输入：maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0] 输出：2
解释：迷宫中只有 1 个出口，在 (1,2) 处。
(1,0) 不算出口，因为它是入口格子。
初始时，你在入口与格子 (1,0) 处。
- 你可以往右移动 2 步到达 (1,2) 处。
所以，最近的出口为 (1,2) ，距离为 2 步。
示例 3：输入：maze = [[".","+"]], entrance = [0,0] 输出：-1
解释：这个迷宫中没有出口。
提示：maze.length == m
maze[i].length == n
1 <= m, n <= 100
maze[i][j] 要么是 '.' ，要么是 '+' 。
entrance.length == 2
0 <= entrancerow < m
0 <= entrancecol < n
entrance 一定是空格子。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 广度优先搜索 | O(n^2)     | O(n)       |

 ```go
 var dx = []int{-1, 1, 0, 0}
 var dy = []int{0, 0, -1, 1}
 
 func nearestExit(maze [][]byte, entrance []int) int {
 	n, m := len(maze), len(maze[0])
 	queue := make([][2]int, 0)
 	visited := make(map[[2]int]bool)
 	queue = append(queue, [2]int{entrance[0], entrance[1]})
 	visited[[2]int{entrance[0], entrance[1]}] = true
 	count := 0
 	for len(queue) > 0 {
 		count++
 		length := len(queue)
 		for i := 0; i < length; i++ {
 			a, b := queue[i][0], queue[i][1]
 			for j := 0; j < 4; j++ {
 				x := a + dx[j]
 				y := b + dy[j]
 				if 0 <= x && x < n && 0 <= y && y < m &&
 					maze[x][y] != '+' && visited[[2]int{x, y}] == false {
 					if (x == 0 || x == n-1 || y == 0 || y == m-1) && maze[x][y] == '.' {
 						return count
 					}
 					queue = append(queue, [2]int{x, y})
 					visited[[2]int{x, y}] = true
 				}
 			}
 		}
 		queue = queue[length:]
 	}
 	return -1
 }
 ```

## 1927.求和游戏(1)

- 题目

```
Alice 和 Bob 玩一个游戏，两人轮流行动，Alice 先手 。
给你一个 偶数长度 的字符串 num ，每一个字符为数字字符或者 '?' 。
每一次操作中，如果 num 中至少有一个 '?' ，那么玩家可以执行以下操作：
选择一个下标 i 满足 num[i] == '?' 。
将 num[i] 用 '0' 到 '9' 之间的一个数字字符替代。
当 num 中没有 '?' 时，游戏结束。
Bob 获胜的条件是 num 中前一半数字的和 等于 后一半数字的和。
Alice 获胜的条件是前一半的和与后一半的和 不相等 。
比方说，游戏结束时 num = "243801" ，那么 Bob 获胜，因为 2+4+3 = 8+0+1 。
如果游戏结束时 num = "243803" ，那么 Alice 获胜，因为 2+4+3 != 8+0+3 。
在 Alice 和 Bob 都采取 最优 策略的前提下，如果 Alice 获胜，请返回 true ，如果 Bob 获胜，请返回 false 。
示例 1：输入：num = "5023" 输出：false
解释：num 中没有 '?' ，没法进行任何操作。
前一半的和等于后一半的和：5 + 0 = 2 + 3 。
示例 2：输入：num = "25??" 输出：true
解释：Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。
示例 3：输入：num = "?3295???" 输出：false
解释：Bob 总是能赢。一种可能的结果是：
- Alice 将第一个 '?' 用 '9' 替换。num = "93295???" 。
- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = "932959??" 。
- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = "9329592?" 。
- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = "93295927" 。
Bob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。
提示：2 <= num.length <= 105
num.length 是 偶数 。
num 只包含数字字符和 '?' 。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 贪心 | O(n)       | O(1)       |

```go
func sumGame(num string) bool {
	n := len(num)
	leftSum, rightSum := 0, 0
	leftCount, rightCount := 0, 0
	for i := 0; i < n; i++ {
		if i < n/2 {
			if num[i] == '?' {
				leftCount++
			} else {
				leftSum = leftSum + int(num[i]-'0')
			}
		} else {
			if num[i] == '?' {
				rightCount++
			} else {
				rightSum = rightSum + int(num[i]-'0')
			}
		}
	}
	if (leftCount+rightCount)%2 == 1 { // ?总数为奇数个
		return true
	}
	if leftSum-rightSum != (rightCount-leftCount)*9/2 {
		return true
	}
	return false
}
```

## 1930.长度为3的不同回文子序列(3)

- 题目

```
给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。
即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。
回文 是正着读和反着读一样的字符串。
子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。
例如，"ace" 是 "abcde" 的一个子序列。
示例 1：输入：s = "aabca"输出：3
解释：长度为 3 的 3 个回文子序列分别是：
- "aba" ("aabca" 的子序列)
- "aaa" ("aabca" 的子序列)
- "aca" ("aabca" 的子序列)
示例 2：输入：s = "adc"输出：0
解释："adc" 不存在长度为 3 的回文子序列。
示例 3：输入：s = "bbcbaba" 输出：4
解释：长度为 3 的 4 个回文子序列分别是：
- "bbb" ("bbcbaba" 的子序列)
- "bcb" ("bbcbaba" 的子序列)
- "bab" ("bbcbaba" 的子序列)
- "aba" ("bbcbaba" 的子序列)
提示：3 <= s.length <= 105
s 仅由小写英文字母组成
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 遍历        | O(n)       | O(n)       |
| 02   | 遍历        | O(n)       | O(1)       |
| 03   | 遍历+位运算 | O(n)       | O(n)       |

```go
func countPalindromicSubsequence(s string) int {
	n := len(s)
	arr := [26][]int{}
	for i := 0; i < n; i++ {
		index := int(s[i] - 'a')
		arr[index] = append(arr[index], i)
	}
	m := make(map[string]bool)
	for i := 0; i < 26; i++ { // 枚举2边字符
		if len(arr[i]) <= 1 {
			continue
		}
		left, right := arr[i][0], arr[i][len(arr[i])-1]
		for j := 0; j < 26; j++ {
			if len(arr[j]) == 0 {
				continue
			}
			if i == j && len(arr[i]) > 2 {
				m[fmt.Sprintf("%d,%d,%d", i, i, i)] = true
				continue
			}
			flag := false
			for k := 0; k < len(arr[j]); k++ {
				if left < arr[j][k] && arr[j][k] < right {
					flag = true
					break
				}
			}
			if flag == true {
				m[fmt.Sprintf("%d,%d,%d", i, j, i)] = true
			}
		}
	}
	return len(m)
}

# 2
func countPalindromicSubsequence(s string) int {
	n := len(s)
	res := 0
	for i := 0; i < 26; i++ { // 枚举2边字符
		left, right := 0, n-1
		for left < n && s[left] != byte(i+'a') {
			left++
		}
		for right >= 0 && s[right] != byte(i+'a') {
			right--
		}
		if left+2 > right {
			continue
		}
		m := make(map[byte]int)
		for k := left + 1; k < right; k++ {
			m[s[k]] = 1
		}
		res = res + len(m)
	}
	return res
}

# 3
func countPalindromicSubsequence(s string) int {
	n := len(s)
	res := 0
	pre, suf := make([]int, n+1), make([]int, n+1)
	arr := make([]int, 26)
	for i := 0; i < n; i++ {
		pre[i+1] = pre[i] | (1 << int(s[i]-'a'))
	}
	for i := n - 1; i >= 0; i-- {
		suf[i] = suf[i+1] | (1 << int(s[i]-'a'))
	}
	for i := 1; i < n-1; i++ {
		index := int(s[i] - 'a')
		arr[index] = arr[index] | (pre[i] & suf[i+1])
	}

	for i := 0; i < 26; i++ {
		res = res + bits.OnesCount(uint(arr[i]))
	}
	return res
}
```

## 1936.新增的最少台阶数(1)

- 题目

```
给你一个 严格递增 的整数数组 rungs ，用于表示梯子上每一台阶的 高度 。
当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。
另给你一个整数 dist 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过 dist 高度的台阶。
当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。
返回爬到最后一阶时必须添加到梯子上的 最少 台阶数。
示例 1：输入：rungs = [1,3,5,10], dist = 2 输出：2
解释：现在无法到达最后一阶。
在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 
梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。
示例 2：输入：rungs = [3,6,8,10], dist = 3 输出：0
解释：这个梯子无需增设新台阶也可以爬上去。
示例 3：输入：rungs = [3,4,6,7], dist = 2 输出：1
解释：现在无法从地板到达梯子的第一阶。 
在高度为 1 的位置增设新的台阶，以爬上梯子。 
梯子在高度为 [1,3,4,6,7] 的位置上有台阶。
示例 4：输入：rungs = [5], dist = 10 输出：0
解释：这个梯子无需增设新台阶也可以爬上去。
提示：1 <= rungs.length <= 105
1 <= rungs[i] <= 109
1 <= dist <= 109
rungs 严格递增
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |

```go
func addRungs(rungs []int, dist int) int {
	res := 0
	cur := 0
	for i := 0; i < len(rungs); i++{
		res = res + (rungs[i]-cur-1)/dist
		cur = rungs[i]
	}
	return res
}
```

## 1937.扣分后的最大得分(3)

- 题目

```
给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。
你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。
然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。
对于相邻行 r 和 r + 1 （其中 0 <= r < m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，
你的总得分 减少 abs(c1 - c2) 。
请你返回你能得到的 最大 得分。
abs(x) 定义为：如果 x >= 0 ，那么值为 x 。如果 x < 0 ，那么值为 -x 。
示例 1：输入：points = [[1,2,3],[1,5,1],[3,1,1]] 输出：9
解释：蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。
你的总得分增加 3 + 5 + 3 = 11 。
但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。
你的最终得分为 11 - 2 = 9 。
示例 2：输入：points = [[1,5],[2,3],[4,2]] 输出：11
解释：蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。
你的总得分增加 5 + 3 + 4 = 12 。
但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。
你的最终得分为 12 - 1 = 11 。
提示：m == points.length
n == points[r].length
1 <= m, n <= 105
1 <= m * n <= 105
0 <= points[r][c] <= 105
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 动态规划        | O(n^2)     | O(n^2)     |
| 02   | 动态规划        | O(n^2)     | O(n)       |
| 03   | 动态规划+前缀和 | O(n^2)     | O(n)       |

```go
func maxPoints(points [][]int) int64 {
	n, m := len(points), len(points[0])
	dp := make([][]int, n) // dp[i][j]表示在第i行第j列选择的格子的最大分数
	// dp[i][j]=max{dp[i−1][j']-abs(j-j')} + points[i][j]
	// j > j' => dp[i][j]=max{dp[i−1][j']+j'} + points[i][j] - j
	// j <= j' => dp[i][j]=max{dp[i−1][j']-j'} + points[i][j] + j
	for i := 0; i < n; i++ {
		dp[i] = make([]int, m)
	}
	for j := 0; j < m; j++ {
		dp[0][j] = points[0][j]
	}
	for i := 1; i < n; i++ {
		maxValue := math.MinInt32 // max{dp[i−1][j']+j'}
		for j := 0; j < m; j++ {  // 正序, j越大=>maxValue越大
			maxValue = max(maxValue, dp[i-1][j]+j)
			// dp[i][j]=max{dp[i−1][j']+j'} + points[i][j] - j
			dp[i][j] = max(dp[i][j], maxValue+points[i][j]-j)
		}
		maxValue = math.MinInt32      // max{dp[i−1][j']-j'}
		for j := m - 1; j >= 0; j-- { // 逆序, j越小=>maxValue越大
			maxValue = max(maxValue, dp[i-1][j]-j)
			// dp[i][j]=max{dp[i−1][j']-j'} + points[i][j] + j
			dp[i][j] = max(dp[i][j], maxValue+points[i][j]+j)
		}
	}
	res := 0
	for j := 0; j < m; j++ {
		res = max(res, dp[n-1][j])
	}
	return int64(res)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxPoints(points [][]int) int64 {
	n, m := len(points), len(points[0])
	dp := make([]int, m) // dp[j]表示在第j列选择的格子的最大分数
	// dp[i][j]=max{dp[i−1][j']-abs(j-j')} + points[i][j]
	// j > j' => dp[i][j]=max{dp[i−1][j']+j'} + points[i][j] - j
	// j <= j' => dp[i][j]=max{dp[i−1][j']-j'} + points[i][j] + j
	for i := 0; i < n; i++ {
		temp := make([]int, m)
		maxValue := math.MinInt32 // max{dp[i−1][j']+j'}
		for j := 0; j < m; j++ {  // 正序, j越大=>maxValue越大
			maxValue = max(maxValue, dp[j]+j)
			// dp[i][j]=max{dp[i−1][j']+j'} + points[i][j] - j
			temp[j] = max(temp[j], maxValue+points[i][j]-j)
		}
		maxValue = math.MinInt32      // max{dp[i−1][j']-j'}
		for j := m - 1; j >= 0; j-- { // 逆序, j越小=>maxValue越大
			maxValue = max(maxValue, dp[j]-j)
			// dp[i][j]=max{dp[i−1][j']-j'} + points[i][j] + j
			temp[j] = max(temp[j], maxValue+points[i][j]+j)
		}
		copy(dp, temp)
	}
	res := 0
	for j := 0; j < m; j++ {
		res = max(res, dp[j])
	}
	return int64(res)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func maxPoints(points [][]int) int64 {
	n, m := len(points), len(points[0])
	dp := make([]int, m) // dp[j]表示在第j列选择的格子的最大分数
	// dp[i][j]=max{dp[i−1][j']-abs(j-j')} + points[i][j]
	// j > j' => dp[i][j]=max{dp[i−1][j']+j'} + points[i][j] - j
	// j <= j' => dp[i][j]=max{dp[i−1][j']-j'} + points[i][j] + j
	for i := 0; i < n; i++ {
		temp := make([]int, m)
		leftArr := make([]int, m)  // 左边最大值
		rightArr := make([]int, m) // 右边最大值
		leftArr[0] = dp[0]
		rightArr[m-1] = dp[m-1] - (m - 1)
		for j := 1; j < m; j++ {
			leftArr[j] = max(leftArr[j-1], dp[j]+j)
		}
		for j := m - 2; j >= 0; j-- {
			rightArr[j] = max(rightArr[j+1], dp[j]-j)
		}
		for j := 0; j < m; j++ {
			temp[j] = points[i][j] + max(leftArr[j]-j, rightArr[j]+j)
		}
		copy(dp, temp)
	}
	res := 0
	for j := 0; j < m; j++ {
		res = max(res, dp[j])
	}
	return int64(res)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 1942.最小未被占据椅子的编号(2)

- 题目

```
有 n 个朋友在举办一个派对，这些朋友从 0 到 n - 1 编号。派对里有 无数 张椅子，编号为 0 到 infinity 。
当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。
比方说，当一个朋友到达时，如果椅子 0 ，1 和 5 被占据了，那么他会占据 2 号椅子。
当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。
给你一个下标从 0 开始的二维整数数组 times ，其中 times[i] = [arrivali, leavingi] 
表示第 i 个朋友到达和离开的时刻，同时给你一个整数 targetFriend 。所有到达时间 互不相同 。
请你返回编号为 targetFriend 的朋友占据的 椅子编号 。
示例 1：输入：times = [[1,4],[2,3],[4,6]], targetFriend = 1 输出：1
解释：- 朋友 0 时刻 1 到达，占据椅子 0 。
- 朋友 1 时刻 2 到达，占据椅子 1 。
- 朋友 1 时刻 3 离开，椅子 1 变成未占据。
- 朋友 0 时刻 4 离开，椅子 0 变成未占据。
- 朋友 2 时刻 4 到达，占据椅子 0 。
朋友 1 占据椅子 1 ，所以返回 1 。
示例 2：输入：times = [[3,10],[1,5],[2,6]], targetFriend = 0 输出：2
解释：- 朋友 1 时刻 1 到达，占据椅子 0 。
- 朋友 2 时刻 2 到达，占据椅子 1 。
- 朋友 0 时刻 3 到达，占据椅子 2 。
- 朋友 1 时刻 5 离开，椅子 0 变成未占据。
- 朋友 2 时刻 6 离开，椅子 1 变成未占据。
- 朋友 0 时刻 10 离开，椅子 2 变成未占据。
朋友 0 占据椅子 2 ，所以返回 2 。
提示：n == times.length
2 <= n <= 104
times[i].length == 2
1 <= arrivali < leavingi <= 105
0 <= targetFriend <= n - 1
每个 arrivali 时刻 互不相同 。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 双堆 | O(nlog(n)) | O(n)       |
| 02   | 堆   | O(nlog(n)) | O(n)       |

```go
type Node struct {
	Index      int
	ArriveTime int
	LeaveTime  int
}

func smallestChair(times [][]int, targetFriend int) int {
	n := len(times)
	arr := make([]Node, 0)
	waitHeap := make(WaitHeap, 0)
	heap.Init(&waitHeap)
	runHeap := make(RunHeap, 0)
	heap.Init(&runHeap)
	for i := 0; i < n; i++ {
		heap.Push(&waitHeap, i)
		arr = append(arr, Node{
			Index:      i,
			ArriveTime: times[i][0],
			LeaveTime:  times[i][1],
		})
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i].ArriveTime < arr[j].ArriveTime
	})
	cur := 0
	for i := 0; i < n; i++ {
		cur = arr[i].ArriveTime
		for runHeap.Len() > 0 && runHeap[0].EndTime <= cur { // 结束时间小于当前时间，出堆
			node := heap.Pop(&runHeap).(RunNode)
			heap.Push(&waitHeap, node.Id)
		}
		node := heap.Pop(&waitHeap).(int)
		heap.Push(&runHeap, RunNode{
			Id:      node,
			EndTime: arr[i].LeaveTime,
		})
		if arr[i].Index == targetFriend { // 目标值
			return node
		}
	}
	return -1
}

type WaitHeap []int // 空闲堆

func (h WaitHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h WaitHeap) Less(i, j int) bool {
	return h[i] < h[j]
}

func (h WaitHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *WaitHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *WaitHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

type RunNode struct {
	Id      int
	EndTime int
}

type RunHeap []RunNode // 运行堆

func (h RunHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h RunHeap) Less(i, j int) bool {
	return h[i].EndTime < h[j].EndTime
}

func (h RunHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *RunHeap) Push(x interface{}) {
	*h = append(*h, x.(RunNode))
}

func (h *RunHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
func smallestChair(times [][]int, targetFriend int) int {
	n := len(times)
	waitHeap := make(WaitHeap, 0)
	heap.Init(&waitHeap)
	arriveArr := make([][2]int, 0)
	leaveArr := make([][2]int, 0)
	for i := 0; i < n; i++ {
		heap.Push(&waitHeap, i)
		arriveArr = append(arriveArr, [2]int{i, times[i][0]})
		leaveArr = append(leaveArr, [2]int{i, times[i][1]})
	}
	sort.Slice(arriveArr, func(i, j int) bool {
		return arriveArr[i][1] < arriveArr[j][1]
	})
	sort.Slice(leaveArr, func(i, j int) bool {
		return leaveArr[i][1] < leaveArr[j][1]
	})

	j := 0
	m := make(map[int]int) // 人=>座位
	for i := 0; i < n; i++ {
		for j < n && leaveArr[j][1] <= arriveArr[i][1] { // 小于当前时间：出堆
			heap.Push(&waitHeap, m[leaveArr[j][0]])
			j++
		}
		target := heap.Pop(&waitHeap).(int)
		m[arriveArr[i][0]] = target
		if arriveArr[i][0] == targetFriend { // 目标值
			return target
		}
	}
	return -1
}

type WaitHeap []int

func (h WaitHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h WaitHeap) Less(i, j int) bool {
	return h[i] < h[j]
}

func (h WaitHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *WaitHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *WaitHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}
```

## 1943.描述绘画结果(3)

- 题目

```
给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 独一无二 的颜色。
给你二维整数数组 segments ，
其中 segments[i] = [starti, endi, colori] 表示线段为 半开区间 [starti, endi) 且颜色为 colori 。
线段间重叠部分的颜色会被 混合 。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 集合 表示这个混合颜色。
比方说，如果颜色 2 ，4 和 6 被混合，那么结果颜色为 {2,4,6} 。
为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 和 来表示颜色集合。
你想要用 最少数目 不重叠 半开区间 来 表示 这幅混合颜色的画。这些线段可以用二维数组 painting 表示，
其中 painting[j] = [leftj, rightj, mixj] 表示一个 半开区间[leftj, rightj) 的颜色 和 为 mixj 。
比方说，这幅画由 segments = [[1,4,5],[1,7,7]] 组成，那么它可以表示为 painting = [[1,4,12],[4,7,7]] ，因为：
[1,4) 由颜色 {5,7} 组成（和为 12），分别来自第一个线段和第二个线段。
[4,7) 由颜色 {7} 组成，来自第二个线段。
请你返回二维数组 painting ，它表示最终绘画的结果（没有 被涂色的部分不出现在结果中）。
你可以按 任意顺序 返回最终数组的结果。
半开区间 [a, b) 是数轴上点 a 和点 b 之间的部分，包含 点 a 且 不包含 点 b 。
示例 1：输入：segments = [[1,4,5],[4,7,7],[1,7,9]] 输出：[[1,4,14],[4,7,16]]
解释：绘画借故偶可以表示为：
- [1,4) 颜色为 {5,9} （和为 14），分别来自第一和第二个线段。
- [4,7) 颜色为 {7,9} （和为 16），分别来自第二和第三个线段。
示例 2：输入：segments = [[1,7,9],[6,8,15],[8,10,7]] 输出：[[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
解释：绘画结果可以以表示为：
- [1,6) 颜色为 9 ，来自第一个线段。
- [6,7) 颜色为 {9,15} （和为 24），来自第一和第二个线段。
- [7,8) 颜色为 15 ，来自第二个线段。
- [8,10) 颜色为 7 ，来自第三个线段。
示例 3：输入：segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]] 输出：[[1,4,12],[4,7,12]]
解释：绘画结果可以表示为：
- [1,4) 颜色为 {5,7} （和为 12），分别来自第一和第二个线段。
- [4,7) 颜色为 {1,11} （和为 12），分别来自第三和第四个线段。
注意，只返回一个单独的线段 [1,7) 是不正确的，因为混合颜色的集合不相同。
提示：1 <= segments.length <= 2 * 104
segments[i].length == 3
1 <= starti < endi <= 105
1 <= colori <= 109
每种颜色 colori 互不相同。
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 双差分数组      | O(n)       | O(n)       |
| 02   | 差分数组+前缀和 | O(nlog(n)) | O(n)       |
| 03   | 差分数组+哈希   | O(n)       | O(n)       |

```go
func splitPainting(segments [][]int) [][]int64 {
	res := make([][]int64, 0)
	arr1 := make([]int64, 100005) // 和
	arr2 := make([]int64, 100005) // 次数
	n := len(segments)
	for i := 0; i < n; i++ {
		start := segments[i][0]
		end := segments[i][1]
		count := segments[i][2]
		arr1[start], arr2[start] = arr1[start]+int64(count), arr1[start]+1
		arr1[end], arr2[end] = arr1[end]-int64(count), arr1[end]-1
	}
	prevIndex := -1
	var prev1, prev2 int64
	var sum1, sum2 int64
	for i := 1; i < 100005; i++ {
		sum1 = sum1 + arr1[i]
		sum2 = sum2 + arr2[i]
		if sum1 > 0 {
			if prevIndex == -1 { // 之前不为-1，开头
				prevIndex = i
				prev1, prev2 = sum1, sum2
			} else if prev1 != sum1 { // 和不同，加入区间
				res = append(res, []int64{int64(prevIndex), int64(i), prev1})
				prevIndex = i
				prev1, prev2 = sum1, sum2
			} else {
				if prev2 != sum2 { // 次数不同。加入区间
					res = append(res, []int64{int64(prevIndex), int64(i), prev1})
					prevIndex = i
					prev1, prev2 = sum1, sum2
				}
			}
		} else if sum1 == 0 {
			if prevIndex > 0 { // 和为0，之前不为0，加入区间
				res = append(res, []int64{int64(prevIndex), int64(i), prev1})
				prevIndex = -1
				prev1, prev2 = sum1, sum2
			}
		}
	}
	return res
}

# 2
func splitPainting(segments [][]int) [][]int64 {
	res := make([][]int64, 0)
	m := make(map[int]int)
	for i := 0; i < len(segments); i++ {
		start := segments[i][0]
		end := segments[i][1]
		count := segments[i][2]
		m[start] = m[start] + count
		m[end] = m[end] - count
	}
	arr := make([][2]int, 0)
	for k, v := range m {
		arr = append(arr, [2]int{k, v})
	}
	sort.Slice(arr, func(i, j int) bool {
		return arr[i][0] < arr[j][0]
	})
	n := len(arr)
	for i := 1; i < n; i++ { // 前缀和
		arr[i][1] = arr[i][1] + arr[i-1][1]
	}
	for i := 0; i < n-1; i++ {
		if arr[i][1] > 0 { // 和大于0
			res = append(res, []int64{
				int64(arr[i][0]),
				int64(arr[i+1][0]),
				int64(arr[i][1]),
			})
		}
	}
	return res
}

# 3
func splitPainting(segments [][]int) [][]int64 {
	res := make([][]int64, 0)
	arr := make([]int64, 100005) // 和
	m := make([]bool, 100005)
	n := len(segments)
	for i := 0; i < n; i++ {
		start := segments[i][0]
		end := segments[i][1]
		count := segments[i][2]
		arr[start] = arr[start] + int64(count)
		arr[end] = arr[end] - int64(count)
		m[start] = true
		m[end] = true
	}
	var sum int64
	var prev int64
	for i := 1; i < 100005; i++ {
		if m[i] == true {
			if sum > 0 {
				res = append(res, []int64{prev, int64(i), sum})
			}
			sum = sum + arr[i]
			prev = int64(i)
		}
	}
	return res
}
```

## 1946.子字符串突变后可能得到的最大整数(2)

- 题目

```
给你一个字符串 num ，该字符串表示一个大整数。另给你一个长度为 10 且 下标从 0  开始 的整数数组 change ，
该数组将 0-9 中的每个数字映射到另一个数字。更规范的说法是，数字 d 映射为数字 change[d] 。
你可以选择 突变  num 的任一子字符串。
突变 子字符串意味着将每位数字 num[i] 替换为该数字在 change 中的映射（也就是说，将 num[i] 替换为 change[num[i]]）。
请你找出在对 num 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 最大整数 ，并用字符串表示返回。
子字符串 是字符串中的一个连续序列。
示例 1：输入：num = "132", change = [9,8,5,0,3,6,4,2,6,8] 输出："832"
解释：替换子字符串 "1"：
- 1 映射为 change[1] = 8 。
因此 "132" 变为 "832" 。
"832" 是可以构造的最大整数，所以返回它的字符串表示。
示例 2：输入：num = "021", change = [9,4,3,5,7,2,1,9,0,6] 输出："934"
解释：替换子字符串 "021"：
- 0 映射为 change[0] = 9 。
- 2 映射为 change[2] = 3 。
- 1 映射为 change[1] = 4 。
因此，"021" 变为 "934" 。
"934" 是可以构造的最大整数，所以返回它的字符串表示。 
示例 3：输入：num = "5", change = [1,4,7,5,3,2,5,6,9,4] 输出："5"
解释："5" 已经是可以构造的最大整数，所以返回它的字符串表示。
提示：1 <= num.length <= 105
num 仅由数字 0-9 组成
change.length == 10
0 <= change[d] <= 9
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 贪心 | O(n)       | O(n)       |
| 02   | 贪心 | O(n)       | O(n)       |

```go
func maximumNumber(num string, change []int) string {
	res := []byte(num)
	flag := false
	for i := 0; i < len(num); i++ {
		value := int(num[i] - '0')
		if value < change[value] {
			flag = true
			res[i] = byte(change[value] + '0')
		} else if value == change[value] {
			res[i] = byte(change[value] + '0')
		} else {
			if flag == true {
				break
			}
		}
	}
	return string(res)
}

# 2
func maximumNumber(num string, change []int) string {
	res := []byte(num)
	for i := 0; i < len(num); i++ {
		if getValue(num[i]) < change[getValue(num[i])] {
			for i < len(num) && change[getValue(num[i])] >= getValue(num[i]) {
				res[i] = byte(change[getValue(num[i])] + '0')
				i++
			}
			break
		}
	}
	return string(res)
}

func getValue(c byte) int {
	return int(c - '0')
}
```

## 1947.最大兼容性评分和(4)

- 题目

```
有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（no，否），要么是 1（yes，是）。
这份调查问卷被分发给 m 名学生和 m 名导师，学生和导师的编号都是从 0 到 m - 1 。
学生的答案用一个二维整数数组 students 表示，
其中 students[i] 是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。
导师的答案用一个二维整数数组 mentors 表示，其中 mentors[j] 是一个整数数组，
包含第 j 名导师对调查问卷给出的答案（下标从 0 开始）。
每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。
例如，学生答案为[1, 0, 1] 而导师答案为 [0, 0, 1] ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。
请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。
给你 students 和 mentors ，返回可以得到的 最大兼容性评分和 。
示例 1：输入：students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]] 输出：8
解释：按下述方式分配学生和导师：
- 学生 0 分配给导师 2 ，兼容性评分为 3 。
- 学生 1 分配给导师 0 ，兼容性评分为 2 。
- 学生 2 分配给导师 1 ，兼容性评分为 3 。
最大兼容性评分和为 3 + 2 + 3 = 8 。
示例 2：输入：students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]] 输出：0
解释：任意学生与导师配对的兼容性评分都是 0 。
提示：m == students.length == mentors.length
n == students[i].length == mentors[j].length
1 <= m, n <= 8
students[i][k] 为 0 或 1
mentors[j][k] 为 0 或 1
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 递归              | O(n^n)     | O(n^2)     |
| 02   | 全排列            | O(n*n!)    | O(n^2)     |
| 03   | 动态规划-状态压缩 | O(n*2^n)   | O(2^n)     |
| 04   | 回溯              | O(n^n)     | O(n^2)     |

```go
var arr [][]int
var res int

func maxCompatibilitySum(students [][]int, mentors [][]int) int {
	n := len(students)
	arr = make([][]int, n)
	for i := 0; i < n; i++ {
		arr[i] = make([]int, n)
		for j := 0; j < n; j++ {
			arr[i][j] = calculate(students[i], mentors[j])
		}
	}
	res = 0
	for i := 0; i < n; i++ {
		visited1, visited2 := make([]int, n), make([]int, n)
		visited1[0], visited2[i] = 1, 1
		dfs(n, visited1, visited2, arr[0][i])
	}
	return res
}

func dfs(n int, visited1, visited2 []int, sum int) {
	if sum > res {
		res = sum
	}
	index := -1
	for i := 0; i < n; i++ {
		if visited1[i] == 0 {
			index = i
			break
		}
	}
	if index == -1 {
		return
	}
	for i := 0; i < n; i++ {
		if visited2[i] == 1 {
			continue
		}
		temp1 := make([]int, n)
		temp2 := make([]int, n)
		copy(temp1, visited1)
		copy(temp2, visited2)
		temp1[index] = 1
		temp2[i] = 1
		dfs(n, temp1, temp2, sum+arr[index][i])
	}
}

func calculate(a, b []int) int {
	res := 0
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			res++
		}
	}
	return res
}

# 2
func maxCompatibilitySum(students [][]int, mentors [][]int) int {
	n := len(students)
	arr := make([][]int, n)
	for i := 0; i < n; i++ {
		arr[i] = make([]int, n)
		for j := 0; j < n; j++ {
			arr[i][j] = calculate(students[i], mentors[j])
		}
	}
	temp := make([]int, n)
	for i := 0; i < n; i++ {
		temp[i] = i
	}
	res := 0
	for {
		if temp == nil {
			break
		}
		sum := 0
		for i := 0; i < n; i++ {
			sum = sum + arr[i][temp[i]]
		}
		if sum > res {
			res = sum
		}
		temp = nextPermutation(temp)
	}
	return res
}

// leetcode31.下一个排列
func nextPermutation(nums []int) []int {
	n := len(nums)
	left := n - 2
	// 以12385764为例，从后往前找到5<7 的升序情况，目标值为左边的数5
	for left >= 0 && nums[left] >= nums[left+1] {
		left--
	}
	if left == -1 { // 排完了，下一个返回nil结束
		return nil
	}
	right := n - 1
	// 从后往前，找到第一个大于目标值的数，如6>5，然后交换
	for right >= 0 && nums[right] <= nums[left] {
		right--
	}
	nums[left], nums[right] = nums[right], nums[left]
	count := 0
	// 后面是降序状态，让它变为升序
	for i := left + 1; i <= (left+1+n-1)/2; i++ {
		nums[i], nums[n-1-count] = nums[n-1-count], nums[i]
		count++
	}
	return nums
}

func calculate(a, b []int) int {
	res := 0
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			res++
		}
	}
	return res
}

# 3
func maxCompatibilitySum(students [][]int, mentors [][]int) int {
	n := len(students)
	arr := make([][]int, n)
	for i := 0; i < n; i++ {
		arr[i] = make([]int, n)
		for j := 0; j < n; j++ {
			arr[i][j] = calculate(students[i], mentors[j])
		}
	}
	target := 1 << n
	dp := make([]int, target) // 所有的状态
	for i := 1; i < target; i++ {
		count := bits.OnesCount(uint(i))
		for j := 0; j < n; j++ {
			if i&(1<<j) != 0 { // 判断第j位是否为1
				prev := i ^ (1 << j)
				dp[i] = max(dp[i], dp[prev]+arr[count-1][j])
			}
		}
	}
	return dp[target-1]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func calculate(a, b []int) int {
	res := 0
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			res++
		}
	}
	return res
}

# 4
var arr [][]int
var res int

func maxCompatibilitySum(students [][]int, mentors [][]int) int {
	n := len(students)
	arr = make([][]int, n)
	for i := 0; i < n; i++ {
		arr[i] = make([]int, n)
		for j := 0; j < n; j++ {
			arr[i][j] = calculate(students[i], mentors[j])
		}
	}
	res = 0
	for i := 0; i < n; i++ {
		visited1, visited2 := make([]int, n), make([]int, n)
		visited1[0], visited2[i] = 1, 1
		dfs(n, visited1, visited2, arr[0][i])
	}
	return res
}

func dfs(n int, visited1, visited2 []int, sum int) {
	if sum > res {
		res = sum
	}
	index := -1
	for i := 0; i < n; i++ {
		if visited1[i] == 0 {
			index = i
			break
		}
	}
	if index == -1 {
		return
	}
	for i := 0; i < n; i++ {
		if visited2[i] == 1 {
			continue
		}
		visited1[index] = 1
		visited2[i] = 1
		dfs(n, visited1, visited2, sum+arr[index][i])
		visited1[index] = 0
		visited2[i] = 0
	}
}

func calculate(a, b []int) int {
	res := 0
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			res++
		}
	}
	return res
}
```

# 1901-2000-Hard

## 1912.设计电影租借系统

### 题目

```
你有一个电影租借公司和 n 个电影商店。
你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。
同时系统还能生成一份当前被借出电影的报告。
所有电影用二维整数数组 entries 表示，其中 entries[i] = [shopi, moviei, pricei] 
表示商店 shopi 有一份电影 moviei 的拷贝，租借价格为 pricei 。
每个商店有 至多一份 编号为 moviei 的电影拷贝。
系统需要支持以下操作：
Search：找到拥有指定电影且 未借出 的商店中 最便宜的 5 个 。
商店需要按照 价格 升序排序，如果价格相同，则 shopi 较小 的商店排在前面。
如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。
Rent：从指定商店借出指定电影，题目保证指定电影在指定商店 未借出 。
Drop：在指定商店返还 之前已借出 的指定电影。
Report：返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID），将结果用二维列表 res 返回，
其中 res[j] = [shopj, moviej] 表示第 j 便宜的已借出电影是从商店 shopj 借出的电影 moviej 。
res 中的电影需要按 价格 升序排序；如果价格相同，则 shopj 较小 的排在前面；
如果仍然相同，则 moviej 较小 的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。
如果当前没有借出电影，则返回一个空的列表。
请你实现 MovieRentingSystem 类：
MovieRentingSystem(int n, int[][] entries) 将 MovieRentingSystem 对象用 n 个商店和 entries 表示的电影列表初始化。
List<Integer> search(int movie) 如上所述，返回 未借出 指定 movie 的商店列表。
void rent(int shop, int movie) 从指定商店 shop 借出指定电影 movie 。
void drop(int shop, int movie) 在指定商店 shop 返还之前借出的电影 movie 。
List<List<Integer>> report() 如上所述，返回最便宜的 已借出 电影列表。
注意：测试数据保证 rent 操作中指定商店拥有 未借出 的指定电影，且 drop 操作指定的商店 之前已借出 指定电影。
示例 1：输入：["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1],
[0, 1], [1, 2], [], [1, 2], [2]]
输出：[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]
解释：MovieRentingSystem movieRentingSystem = 
new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。
商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。
movieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。
movieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。
movieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。
movieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。
movieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。
提示：1 <= n <= 3 * 105
1 <= entries.length <= 105
0 <= shopi < n
1 <= moviei, pricei <= 104
每个商店 至多 有一份电影 moviei 的拷贝。
search，rent，drop 和 report 的调用 总共 不超过 105 次。
```

### 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 单调栈 | O(n)       | O(n)       |

```go

```

## 1944.队列中可以看到的人数(2)

- 题目

```
有 n 个人排成一个队列，从左到右 编号为 0 到 n - 1 。
给你以一个整数数组 heights ，每个整数 互不相同，heights[i] 表示第 i 个人的高度。
一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。
更正式的，第 i 个人能看到第 j 个人的条件是 i < j 且
min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]) 。
请你返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人在他右侧队列中能 看到 的 人数 。
示例 1：输入：heights = [10,6,8,5,11,9] 输出：[3,1,2,1,1,0]
解释：第 0 个人能看到编号为 1 ，2 和 4 的人。
第 1 个人能看到编号为 2 的人。
第 2 个人能看到编号为 3 和 4 的人。
第 3 个人能看到编号为 4 的人。
第 4 个人能看到编号为 5 的人。
第 5 个人谁也看不到因为他右边没人。
示例 2：输入：heights = [5,1,2,3,10] 输出：[4,1,1,1,0]
提示：n == heights.length
1 <= n <= 105
1 <= heights[i] <= 105
heights 中所有数 互不相同 。
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 单调栈 | O(n)       | O(n)       |
| 02   | 单调栈 | O(n)       | O(n)       |

```go
func canSeePersonsCount(heights []int) []int {
	n := len(heights)
	res := make([]int, n)
	stack := make([]int, 0) // 递减栈
	for i := n - 1; i >= 0; i-- {
		for len(stack) > 0 {
			res[i]++ // 答案+1，必然存在1个可以看到的人
			if heights[i] > heights[stack[len(stack)-1]] {
				stack = stack[:len(stack)-1]
			} else {
				break
			}
		}
		stack = append(stack, i)
	}
	return res
}

# 2
func canSeePersonsCount(heights []int) []int {
	n := len(heights)
	res := make([]int, n)
	stack := make([]int, 0) // 递减栈
	for i := n - 1; i >= 0; i-- {
		for len(stack) > 0 && heights[i] > heights[stack[len(stack)-1]] {
			res[i]++
			stack = stack[:len(stack)-1]
		}
		if len(stack) > 0 {
			res[i]++ // 非空，还可以看到一个人
		}
		stack = append(stack, i)
	}
	return res
}
```

