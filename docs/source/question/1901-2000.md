# 1901-2000-Easy

## 1903.字符串中的最大奇数(1)

- 题目

```
给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。
如果不存在奇数，则返回一个空字符串 "" 。
子字符串 是字符串中的一个连续的字符序列。
示例 1：输入：num = "52" 输出："5"
解释：非空子字符串仅有 "5"、"2" 和 "52" 。"5" 是其中唯一的奇数。
示例 2：输入：num = "4206" 输出：""
解释：在 "4206" 中不存在奇数。
示例 3：输入：num = "35427" 输出："35427"
解释："35427" 本身就是一个奇数。
提示：1 <= num.length <= 105
num 仅由数字组成且不含前导零
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
func largestOddNumber(num string) string {
	n := len(num)
	for i := n - 1; i >= 0; i-- {
		if int(num[i]-'0')%2 == 1 {
			return num[:i+1]
		}
	}
	return ""
}
```

## 1909.删除一个元素使数组严格递增(3)

- 题目

```
给你一个下标从 0 开始的整数数组 nums ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回 true ，否则返回 false 。
如果数组本身已经是严格递增的，请你也返回 true 。
数组 nums 是 严格递增 的定义为：对于任意下标的 1 <= i < nums.length 都满足 nums[i - 1] < nums[i] 。
示例 1：输入：nums = [1,2,10,5,7] 输出：true
解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。
[1,2,5,7] 是严格递增的，所以返回 true 。
示例 2：输入：nums = [2,3,1,2] 输出：false
解释：[3,1,2] 是删除下标 0 处元素后得到的结果。
[2,1,2] 是删除下标 1 处元素后得到的结果。
[2,3,2] 是删除下标 2 处元素后得到的结果。
[2,3,1] 是删除下标 3 处元素后得到的结果。
没有任何结果数组是严格递增的，所以返回 false 。
示例 3：输入：nums = [1,1,1] 输出：false
解释：删除任意元素后的结果都是 [1,1] 。
[1,1] 不是严格递增的，所以返回 false 。
示例 4：输入：nums = [1,2,3] 输出：true
解释：[1,2,3] 已经是严格递增的，所以返回 true 。
提示：2 <= nums.length <= 1000
1 <= nums[i] <= 1000
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n)       | O(n)       |
| 02   | 暴力法   | O(n^2)     | O(n)       |
| 03   | 动态规划 | O(n^2)     | O(n)       |

```go
func canBeIncreasing(nums []int) bool {
	for i := 0; i < len(nums)-1; i++ {
		if nums[i] >= nums[i+1] {
			return judge(nums, i) == true || judge(nums, i+1) == true
		}
	}
	return true
}

func judge(nums []int, index int) bool {
	arr := append([]int{}, nums[:index]...)
	arr = append(arr, nums[index+1:]...)
	for i := 0; i < len(arr)-1; i++ {
		if arr[i] >= arr[i+1] {
			return false
		}
	}
	return true
}

# 2
func canBeIncreasing(nums []int) bool {
	for i := 0; i < len(nums); i++ {
		if judge(nums, i) == true {
			return true
		}
	}
	return false
}

func judge(nums []int, index int) bool {
	arr := append([]int{}, nums[:index]...)
	arr = append(arr, nums[index+1:]...)
	for i := 0; i < len(arr)-1; i++ {
		if arr[i] >= arr[i+1] {
			return false
		}
	}
	return true
}

# 3
// leetcode300.最长上升子序列
func canBeIncreasing(nums []int) bool {
	n := len(nums)
	dp := make([]int, n)
	res := 1
	for i := 0; i < n; i++ {
		dp[i] = 1
		for j := 0; j < i; j++ {
			if nums[j] < nums[i] {
				dp[i] = max(dp[j]+1, dp[i])
			}
		}
		res = max(res, dp[i])
	}
	return res == n || res == n-1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 1913.两个数对之间的最大乘积差(2)

- 题目

```
两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。
例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。
给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，
使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。
返回以这种方式取得的乘积差中的 最大值 。
示例 1：输入：nums = [5,6,2,7,4] 输出：34
解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)
乘积差是 (6 * 7) - (2 * 4) = 34
示例 2：输入：nums = [4,2,5,9,7,4,8] 输出：64
解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)
乘积差是 (9 * 8) - (2 * 4) = 64
提示：4 <= nums.length <= 104
1 <= nums[i] <= 104
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func maxProductDifference(nums []int) int {
	sort.Ints(nums)
	n := len(nums)
	return nums[n-1]*nums[n-2] - nums[0]*nums[1]
}

# 2
func maxProductDifference(nums []int) int {
	n := len(nums)
	minA, minB := min(nums[0], nums[1]), max(nums[0], nums[1])
	maxA, maxB := max(nums[0], nums[1]), min(nums[0], nums[1])
	for i := 2; i < n; i++ {
		if nums[i] > maxA {
			maxA, maxB = nums[i], maxA
		} else if nums[i] > maxB {
			maxB = nums[i]
		}
		if nums[i] < minA {
			minA, minB = nums[i], minA
		} else if nums[i] < minB {
			minB = nums[i]
		}
	}
	return maxA*maxB - minA*minB
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

# 1901-2000-Medium

## 1904.你完成的完整对局数(1)

- 题目

```
一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。
这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。
游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。
给你两个字符串 startTime 和 finishTime ，均符合 "HH:MM" 格式，分别表示你 进入 和 退出 游戏的确切时间，
请计算在整个游戏会话期间，你完成的 完整对局的对局数 。
例如，如果 startTime = "05:20" 且 finishTime = "05:59" ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。
而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；
同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。
如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。
假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。
示例 1：输入：startTime = "12:01", finishTime = "12:44" 输出：1
解释：你完成了从 12:15 到 12:30 的一个完整对局。
你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。
你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。
示例 2：输入：startTime = "20:00", finishTime = "06:00" 输出：40
解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。
16 + 24 = 40
示例 3：输入：startTime = "00:00", finishTime = "23:59" 输出：95
解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。
提示：startTime 和 finishTime 的格式为 HH:MM
00 <= HH <= 23
00 <= MM <= 59
startTime 和 finishTime 不相等
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(1)       | O(1)       |

```go
func numberOfRounds(startTime string, finishTime string) int {
	a, _ := strconv.Atoi(startTime[:2])
	b, _ := strconv.Atoi(startTime[3:])
	c, _ := strconv.Atoi(finishTime[:2])
	d, _ := strconv.Atoi(finishTime[3:])
	t1 := 60*a + b
	t2 := 60*c + d
	if t2 < t1 {
		t2 = t2 + 1440
	}
	start := int(math.Ceil(float64(t1) / float64(15)))   // 向上取整
	finish := int(math.Floor(float64(t2) / float64(15))) // 向下取整
	if finish - start >= 0{
		return finish-start
	}
	return 0 // 00:47 ~00:48
}
```

## 1905.统计子岛屿(2)

- 题目

```
给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。
一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，
也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。
请你返回 grid2 中 子岛屿 的 数目 。
示例 1：输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], 
grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
输出：3
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。
示例 2：输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], 
grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
输出：2 
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。
提示：m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= 500
grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 深度优先搜索 | O(n^2)     | O(1)       |
| 02   | 广度优先搜索 | O(n^2)     | O(n)       |

```go
func countSubIslands(grid1 [][]int, grid2 [][]int) int {
	res := 0
	for i := 0; i < len(grid2); i++ {
		for j := 0; j < len(grid2[i]); j++ {
			if grid2[i][j] == 1 { // 查找grid2
				if dfs(grid1, grid2, i, j) == true {
					res++
				}
			}
		}
	}
	return res
}

// leetcode200.岛屿数量
func dfs(grid1, grid2 [][]int, i, j int) bool {
	if i < 0 || j < 0 || i >= len(grid2) || j >= len(grid2[0]) || grid2[i][j] == 0 {
		return true
	}
	if grid1[i][j] == 0 {
		return false
	}
	grid1[i][j], grid2[i][j] = 0, 0
	res1 := dfs(grid1, grid2, i+1, j)
	res2 := dfs(grid1, grid2, i-1, j)
	res3 := dfs(grid1, grid2, i, j+1)
	res4 := dfs(grid1, grid2, i, j-1)
	if res1 == false || res2 == false || res3 == false || res4 == false {
		return false
	}
	return true
}

# 2
var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}

func countSubIslands(grid1 [][]int, grid2 [][]int) int {
	res := 0
	for i := 0; i < len(grid2); i++ {
		for j := 0; j < len(grid2[i]); j++ {
			if grid2[i][j] == 1 { // 查找grid2
				if bfs(grid1, grid2, i, j) == true {
					res++
				}
			}
		}
	}
	return res
}

// leetcode200.岛屿数量
func bfs(grid1, grid2 [][]int, i, j int) bool {
	queue := make([][2]int, 0)
	queue = append(queue, [2]int{i, j})
	flag := true
	if grid1[i][j] == 0 {
		flag = false
	}
	grid1[i][j] = 0
	grid2[i][j] = 0
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		for i := 0; i < 4; i++ {
			x := node[0] + dx[i]
			y := node[1] + dy[i]
			if 0 <= x && x < len(grid2) &&
				0 <= y && y < len(grid2[0]) &&
				grid2[x][y] == 1 {
				queue = append(queue, [2]int{x, y})
				if grid1[x][y] == 0 {
					flag = false
				}
				grid1[x][y] = 0
				grid2[x][y] = 0
			}
		}
	}
	return flag
}
```

## 1906.查询差绝对值的最小值(2)

- 题目

```
一个数组 a 的 差绝对值的最小值 定义为：0 <= i < j < a.length 且 a[i] != a[j] 的 |a[i] - a[j]| 的 最小值。
如果 a 中所有元素都 相同 ，那么差绝对值的最小值为 -1 。
比方说，数组 [5,2,3,7,2] 差绝对值的最小值是 |2 - 3| = 1 。注意答案不为 0 ，因为 a[i] 和 a[j] 必须不相等。
给你一个整数数组 nums 和查询数组 queries ，其中 queries[i] = [li, ri] 。
对于每个查询 i ，计算 子数组 nums[li...ri] 中 差绝对值的最小值 ，
子数组 nums[li...ri] 包含 nums 数组（下标从 0 开始）中下标在 li 和 ri 之间的所有元素（包含 li 和 ri 在内）。
请你返回 ans 数组，其中 ans[i] 是第 i 个查询的答案。
子数组 是一个数组中连续的一段元素。
|x| 的值定义为：
如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。
示例 1：输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]] 输出：[2,1,4,1]
解释：查询结果如下：
- queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。
- queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。
- queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。
- queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。
示例 2：输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
输出：[-1,1,1,3]
解释：查询结果如下：
- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。
- queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。
- queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。
- queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。
提示：2 <= nums.length <= 105
1 <= nums[i] <= 100
1 <= queries.length <= 2 * 104
0 <= li < ri < nums.length
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 前缀和   | O(n)       | O(n)       |
| 02   | 树状数组 | O(nlog(n)) | O(n)       |

```go
func minDifference(nums []int, queries [][]int) []int {
	n := len(nums)
	arr := make([][101]int, n+1)
	for i := 1; i <= n; i++ {
		arr[i] = arr[i-1]
		arr[i][nums[i-1]]++
	}
	res := make([]int, len(queries))
	for i := 0; i < len(queries); i++ {
		res[i] = -1
		left, right := queries[i][0], queries[i][1]
		prev, minValue := 0, math.MaxInt32
		for j := 1; j <= 100; j++ { // 枚举每个数
			if arr[right+1][j] != arr[left][j] { // 当j出现
				if prev != 0 {
					if j-prev < minValue { // 保存较小的差值
						minValue = j - prev
					}
				}
				prev = j // 更新上一个出现的数
			}
		}
		if minValue != math.MaxInt32 {
			res[i] = minValue
		}
	}
	return res
}

# 2
func minDifference(nums []int, queries [][]int) []int {
	n := len(nums)
	length = n
	c = make([][]int, 101) // 存储每个数对应顺序区间出现的次数
	for i := 0; i < 101; i++ {
		c[i] = make([]int, n+1)
	}
	for i := 1; i <= n; i++ {
		upData(nums[i-1], i, 1)
	}
	res := make([]int, len(queries))
	for i := 0; i < len(queries); i++ {
		res[i] = -1
		left, right := queries[i][0], queries[i][1]
		prev, minValue := 0, math.MaxInt32
		for j := 1; j <= 100; j++ { // 枚举每个数
			count := getSum(j, right+1) - getSum(j, left)
			if count > 0 { // 当j出现
				if prev != 0 {
					if j-prev < minValue { // 保存较小的差值
						minValue = j - prev
					}
				}
				prev = j // 更新上一个出现的数
			}
		}
		if minValue != math.MaxInt32 {
			res[i] = minValue
		}
	}
	return res
}

var length int
var c [][]int // 树状数组

func lowBit(x int) int {
	return x & (-x)
}

// 单点修改
func upData(index, i, k int) { // 在i位置加上k
	for i <= length {
		c[index][i] = c[index][i] + k
		i = i + lowBit(i) // i = i + 2^k
	}
}

// 区间查询
func getSum(index, i int) int {
	res := 0
	for i > 0 {
		res = res + c[index][i]
		i = i - lowBit(i)
	}
	return res
}
```

## 1910.删除一个字符串中所有出现的给定子字符串(2)

- 题目

```
给你两个字符串 s 和 part ，请你对 s 反复执行以下操作直到 所有 子字符串 part 都被删除：
找到 s 中 最左边 的子字符串 part ，并将它从 s 中删除。
请你返回从 s 中删除所有 part 子字符串以后得到的剩余字符串。
一个 子字符串 是一个字符串中连续的字符序列。
示例 1：输入：s = "daabcbaabcbc", part = "abc" 输出："dab"
解释：以下操作按顺序执行：
- s = "daabcbaabcbc" ，删除下标从 2 开始的 "abc" ，得到 s = "dabaabcbc" 。
- s = "dabaabcbc" ，删除下标从 4 开始的 "abc" ，得到 s = "dababc" 。
- s = "dababc" ，删除下标从 3 开始的 "abc" ，得到 s = "dab" 。
此时 s 中不再含有子字符串 "abc" 。
示例 2：输入：s = "axxxxyyyyb", part = "xy" 输出："ab"
解释：以下操作按顺序执行：
- s = "axxxxyyyyb" ，删除下标从 4 开始的 "xy" ，得到 s = "axxxyyyb" 。
- s = "axxxyyyb" ，删除下标从 3 开始的 "xy" ，得到 s = "axxyyb" 。
- s = "axxyyb" ，删除下标从 2 开始的 "xy" ，得到 s = "axyb" 。
- s = "axyb" ，删除下标从 1 开始的 "xy" ，得到 s = "ab" 。
此时 s 中不再含有子字符串 "xy" 。
提示：1 <= s.length <= 1000
1 <= part.length <= 1000
s和 part 只包小写英文字母。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n^2)     | O(n)       |
| 02   | 内置函数 | O(n^2)     | O(n)       |

```go
func removeOccurrences(s string, part string) string {
	for strings.Contains(s, part) {
		s = strings.Replace(s, part, "", 1)
	}
	return s
}

# 2
func removeOccurrences(s string, part string) string {
	for {
		index := strings.Index(s, part)
		if index < 0 {
			return s
		}
		s = s[:index] + s[index+len(part):]
	}
	return s
}
```

## 1911.最大子序列交替和(3)

- 题目

```
一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。
比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。
一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。
比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。
示例 1：输入：nums = [4,2,5,3] 输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
示例 2：输入：nums = [5,6,7,8] 输出：8
解释：最优子序列为 [8] ，交替和为 8 。
示例 3：输入：nums = [6,2,1,2,4,5] 输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。
提示：1 <= nums.length <= 105
1 <= nums[i] <= 105
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 动态规划 | O(n)       | O(1)       |
| 02   | 动态规划 | O(n)       | O(n)       |
| 03   | 贪心法   | O(n)       | O(n)       |

```go
func maxAlternatingSum(nums []int) int64 {
	n := len(nums)
	odd, even := 0, nums[0]
	for i := 1; i < n; i++ {
		odd, even = max(even-nums[i], odd), max(odd+nums[i], even)
	}
	return int64(even)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxAlternatingSum(nums []int) int64 {
	n := len(nums)
	dp := make([][2]int, n)
	dp[0][0] = int(nums[0])
	dp[0][1] = 0
	for i := 1; i < n; i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+nums[i])
		dp[i][1] = max(dp[i-1][1], dp[i][0]-nums[i])
	}
	return int64(max(dp[n-1][0], dp[n-1][1]))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func maxAlternatingSum(nums []int) int64 {
	// leetcode122.买卖股票的最佳时机II
	nums = append([]int{0}, nums...) // 补零
	res := 0
	for i := 1; i < len(nums); i++ {
		if nums[i] > nums[i-1] {
			res = res + nums[i] - nums[i-1]
		}
	}
	return int64(res)
}
```

## 1915.最美子字符串的数目(1)

- 题目

```
如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。
例如，"ccjjc" 和 "abab" 都是最美字符串，但 "ab" 不是。
给你一个字符串 word ，该字符串由前十个小写英文字母组成（'a' 到 'j'）。
请你返回 word 中 最美非空子字符串 的数目。如果同样的子字符串在 word 中出现多次，那么应当对 每次出现 分别计数。
子字符串 是字符串中的一个连续字符序列。
示例 1：输入：word = "aba" 输出：4
解释：4 个最美子字符串如下所示：
- "aba" -> "a"
- "aba" -> "b"
- "aba" -> "a"
- "aba" -> "aba"
示例 2：输入：word = "aabb" 输出：9
解释：9 个最美子字符串如下所示：
- "aabb" -> "a"
- "aabb" -> "aa"
- "aabb" -> "aab"
- "aabb" -> "aabb"
- "aabb" -> "a"
- "aabb" -> "abb"
- "aabb" -> "b"
- "aabb" -> "bb"
- "aabb" -> "b"
示例 3：输入：word = "he" 输出：2
解释：2 个最美子字符串如下所示：
- "he" -> "h"
- "he" -> "e"
提示：1 <= word.length <= 105
word 由从 'a' 到 'j' 的小写英文字母组成
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 前缀和+位运算 | O(n)       | O(1)       |

```go
func wonderfulSubstrings(word string) int64 {
	res := 0
	m := make(map[int]int)
	m[0] = 1 // 初始状态没有任何字符，相当于全是偶数
	cur := 0
	for i := 0; i < len(word); i++ {
		value := int(word[i] - 'a')
		cur = cur ^ (1 << value) // 位运算-异或后的状态结果，表示到当前下标各字母出现的奇偶次数
		res = res + m[cur]       // 跟当前状态相同
		for i := 0; i < 10; i++ {
			count := m[cur^(1<<i)] // 跟当前状态差1位相同
			res = res + count
		}
		m[cur]++
	}
	return int64(res)
}
```

# 1901-2000-Hard

