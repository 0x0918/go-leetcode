# 2001-2100-Easy

## 2006.差的绝对值为K的数对数目(2)

- 题目

```
给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i < j 且 |nums[i] - nums[j]| == k 。
|x| 的值定义为：
如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。
示例 1：输入：nums = [1,2,2,1], k = 1 输出：4
解释：差的绝对值为 1 的数对为：
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
示例 2：输入：nums = [1,3], k = 3 输出：0
解释：没有任何数对差的绝对值为 3 。
示例 3：输入：nums = [3,2,1,5,4], k = 2 输出：3
解释：差的绝对值为 2 的数对为：
- [3,2,1,5,4]
- [3,2,1,5,4]
- [3,2,1,5,4]
提示：1 <= nums.length <= 200
1 <= nums[i] <= 100
1 <= k <= 99
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 暴力法 | O(n^2)     | O(1)       |
| 02   | 哈希   | O(n)       | O(n)       |

 ```go
 func countKDifference(nums []int, k int) int {
 	res := 0
 	for i := 0; i < len(nums); i++ {
 		for j := i + 1; j < len(nums); j++ {
 			if nums[i]-nums[j] == k || nums[j]-nums[i] == k {
 				res++
 			}
 		}
 	}
 	return res
 }
 
 # 2
 func countKDifference(nums []int, k int) int {
 	res := 0
 	m := make(map[int]int)
 	for i := 0; i < len(nums); i++ {
 		m[nums[i]]++
 	}
 	for i := 0; i < len(nums); i++ {
 		res = res + m[nums[i]-k]
 	}
 	return res
 }
 ```

## 2011.执行操作后的变量值(2)

- 题目

```
存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：
++X 和 X++ 使变量 X 的值 加 1
--X 和 X-- 使变量 X 的值 减 1
最初，X 的值是 0
给你一个字符串数组 operations ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。
示例 1：输入：operations = ["--X","X++","X++"] 输出：1
解释：操作按下述步骤执行：
最初，X = 0
--X：X 减 1 ，X =  0 - 1 = -1
X++：X 加 1 ，X = -1 + 1 =  0
X++：X 加 1 ，X =  0 + 1 =  1
示例 2：输入：operations = ["++X","++X","X++"] 输出：3
解释：操作按下述步骤执行： 
最初，X = 0
++X：X 加 1 ，X = 0 + 1 = 1
++X：X 加 1 ，X = 1 + 1 = 2
X++：X 加 1 ，X = 2 + 1 = 3
示例 3：输入：operations = ["X++","++X","--X","X--"] 输出：0
解释：操作按下述步骤执行：
最初，X = 0
X++：X 加 1 ，X = 0 + 1 = 1
++X：X 加 1 ，X = 1 + 1 = 2
--X：X 减 1 ，X = 2 - 1 = 1
X--：X 减 1 ，X = 1 - 1 = 0
提示：1 <= operations.length <= 100
operations[i] 将会是 "++X"、"X++"、"--X" 或 "X--"
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |
| 02   | 遍历 | O(n)       | O(1)       |

 ```go
 func finalValueAfterOperations(operations []string) int {
 	res := 0
 	for i := 0; i < len(operations); i++ {
 		if operations[i][1] == '+' {
 			res++
 		} else {
 			res--
 		}
 	}
 	return res
 }
 
 # 2
 func finalValueAfterOperations(operations []string) int {
 	res := 0
 	for i := 0; i < len(operations); i++ {
 		if strings.Contains(operations[i], "+") {
 			res++
 		} else {
 			res--
 		}
 	}
 	return res
 }
 ```

## 2016.增量元素之间的最大差值(2)

- 题目

```
给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，
请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 <= i < j < n 且 nums[i] < nums[j] 。
返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。
示例 1：输入：nums = [7,1,5,4] 输出：4
解释：最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。
注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 > 4 ，但 i > j 不满足题面要求，所以 6 不是有效的答案。
示例 2：输入：nums = [9,4,3,2] 输出：-1
解释：不存在同时满足 i < j 和 nums[i] < nums[j] 这两个条件的 i, j 组合。
示例 3：输入：nums = [1,5,2,10] 输出：9
解释：最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。
提示：n == nums.length
2 <= n <= 1000
1 <= nums[i] <= 109
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 遍历   | O(n)       | O(1)       |
| 02   | 暴力法 | O(n^2)     | O(1)       |

```go
func maximumDifference(nums []int) int {
	res := 0
	minValue := nums[0]
	for i := 1; i < len(nums); i++ {
		res = max(res, nums[i]-minValue)
		minValue = min(minValue, nums[i])
	}
	if res == 0 {
		return -1
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

# 2
func maximumDifference(nums []int) int {
	res := 0
	for i := 0; i < len(nums); i++ {
		for j := i + 1; j < len(nums); j++ {
			if nums[i] < nums[j] {
				res = max(res, nums[j]-nums[i])
			}
		}
	}
	if res == 0 {
		return -1
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2022.将一维数组转变成二维数组(2)

- 题目

```
给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。
你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。
original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，
下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。
请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。
示例 1：输入：original = [1,2,3,4], m = 2, n = 2 输出：[[1,2],[3,4]]
解释：构造出的二维数组应该包含 2 行 2 列。
original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。
original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。
示例 2：输入：original = [1,2,3], m = 1, n = 3 输出：[[1,2,3]]
解释：构造出的二维数组应该包含 1 行 3 列。
将 original 中所有三个元素放入第一行中，构成要求的二维数组。
示例 3：输入：original = [1,2], m = 1, n = 1 输出：[]
解释：original 中有 2 个元素。
无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。
示例 4：输入：original = [3], m = 1, n = 2 输出：[]
解释：original 中只有 1 个元素。
无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。
提示：1 <= original.length <= 5 * 104
1 <= original[i] <= 105
1 <= m, n <= 4 * 104
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |
| 02   | 遍历 | O(n)       | O(n)       |

```go
func construct2DArray(original []int, m int, n int) [][]int {
	total := len(original)
	if n*m != total {
		return nil
	}
	res := make([][]int, 0)
	index := 0
	for i := 0; i < m; i++ {
		temp := make([]int, 0)
		for j := 0; j < n; j++ {
			temp = append(temp, original[index])
			index++
		}
		res = append(res, temp)
	}
	return res
}

# 2
func construct2DArray(original []int, m int, n int) [][]int {
	total := len(original)
	if n*m != total {
		return nil
	}
	res := make([][]int, 0)
	for i := 0; i < total; i = i + n {
		res = append(res, original[i:i+n])
	}
	return res
}
```

## 2027.转换字符串的最少操作次(2)

- 题目

```
给你一个字符串 s ，由 n 个字符组成，每个字符不是 'X' 就是 'O' 。
一次 操作 定义为从 s 中选出 三个连续字符 并将选中的每个字符都转换为 'O' 。注意，如果字符已经是 'O' ，只需要保持 不变 。
返回将 s 中所有字符均转换为 'O' 需要执行的 最少 操作次数。
示例 1：输入：s = "XXX" 输出：1
解释：XXX -> OOO
一次操作，选中全部 3 个字符，并将它们转换为 'O' 。
示例 2：输入：s = "XXOX" 输出：2
解释：XXOX -> OOOX -> OOOO
第一次操作，选择前 3 个字符，并将这些字符转换为 'O' 。
然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 'O' 组成。
示例 3：输入：s = "OOOO" 输出：0
解释：s 中不存在需要转换的 'X' 。
提示：3 <= s.length <= 1000
s[i] 为 'X' 或 'O'
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |
| 02   | 遍历 | O(n)       | O(1)       |

```go
func minimumMoves(s string) int {
	arr := []byte(s)
	res := 0
	for i := 0; i < len(s); i++ {
		if arr[i] == 'X' {
			count := 0
			for j := i; j < len(s); j++ {
				arr[j] = 'O'
				count++
				if count == 3 {
					break
				}
			}
			res++
		}
	}
	return res
}

# 2
func minimumMoves(s string) int {
	res := 0
	for i := 0; i < len(s); i++ {
		if s[i] == 'X' {
			i = i + 2
			res++
		}
	}
	return res
}
```

## 2032.至少在两个数组中出现的值(2)

- 题目

```
给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。
数组中的元素可以按 任意 顺序排列。
示例 1：输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3] 输出：[3,2]
解释：至少在两个数组中出现的所有值为：
- 3 ，在全部三个数组中都出现过。
- 2 ，在数组 nums1 和 nums2 中出现过。
示例 2：输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2] 输出：[2,3,1]
解释：至少在两个数组中出现的所有值为：
- 2 ，在数组 nums2 和 nums3 中出现过。
- 3 ，在数组 nums1 和 nums2 中出现过。
- 1 ，在数组 nums1 和 nums3 中出现过。
示例 3：输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5] 输出：[]
解释：不存在至少在两个数组中出现的值。
提示：1 <= nums1.length, nums2.length, nums3.length <= 100
1 <= nums1[i], nums2[j], nums3[k] <= 100
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 哈希辅助        | O(n)       | O(n)       |
| 02   | 哈希辅助+位运算 | O(n)       | O(n)       |

```go
func twoOutOfThree(nums1 []int, nums2 []int, nums3 []int) []int {
	m1, m2, m3 := make(map[int]int), make(map[int]int), make(map[int]int)
	for i := 0; i < len(nums1); i++ {
		m1[nums1[i]] = 1
	}
	for i := 0; i < len(nums2); i++ {
		m2[nums2[i]] = 1
	}
	for i := 0; i < len(nums3); i++ {
		m3[nums3[i]] = 1
	}
	res := make([]int, 0)
	for i := 1; i <= 300; i++ {
		a := m1[i] + m2[i] + m3[i]
		if a >= 2 {
			res = append(res, i)
		}
	}
	return res
}

# 2
func twoOutOfThree(nums1 []int, nums2 []int, nums3 []int) []int {
	m := make(map[int]int)
	arr := [][]int{nums1, nums2, nums3}
	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {
			value := arr[i][j]
			m[value] = m[value] | (1 << i)
		}
	}
	res := make([]int, 0)
	for k, v := range m {
		if bits.OnesCount(uint(v)) >= 2 {
			res = append(res, k)
		}
	}
	return res
}
```

## 2037.使每位学生都有座位的最少移动次数(1)

- 题目

```
一个房间里有 n 个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 seats[i] 是第 i 个座位的位置。
同时给你一个长度为 n 的数组 students ，其中 students[j] 是第 j 位学生的位置。
你可以执行以下操作任意次：
增加或者减少第 i 位学生的位置，每次变化量为 1 （也就是将第 i 位学生从位置 x 移动到 x + 1 或者 x - 1）
请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。
请注意，初始时有可能有多个座位或者多位学生在 同一 位置。
示例 1：输入：seats = [3,1,5], students = [2,7,4] 输出：4
解释：学生移动方式如下：
- 第一位学生从位置 2 移动到位置 1 ，移动 1 次。
- 第二位学生从位置 7 移动到位置 5 ，移动 2 次。
- 第三位学生从位置 4 移动到位置 3 ，移动 1 次。
总共 1 + 2 + 1 = 4 次移动。
示例 2：输入：seats = [4,1,5,9], students = [1,3,2,6] 输出：7
解释：学生移动方式如下：
- 第一位学生不移动。
- 第二位学生从位置 3 移动到位置 4 ，移动 1 次。
- 第三位学生从位置 2 移动到位置 5 ，移动 3 次。
- 第四位学生从位置 6 移动到位置 9 ，移动 3 次。
总共 0 + 1 + 3 + 3 = 7 次移动。
示例 3：输入：seats = [2,2,6,6], students = [1,3,2,6] 输出：4
解释：学生移动方式如下：
- 第一位学生从位置 1 移动到位置 2 ，移动 1 次。
- 第二位学生从位置 3 移动到位置 6 ，移动 3 次。
- 第三位学生不移动。
- 第四位学生不移动。
总共 1 + 3 + 0 + 0 = 4 次移动。
提示：n == seats.length == students.length
1 <= n <= 100
1 <= seats[i], students[j] <= 100
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(1)       |

```go
func minMovesToSeat(seats []int, students []int) int {
	res := 0
	sort.Ints(seats)
	sort.Ints(students)
	for i := 0; i < len(seats); i++ {
		res = res + abs(students[i]-seats[i])
	}
	return res
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```

## 2042.检查句子中的数字是否递增(1)

- 题目

```
句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。
每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。
示例，"a puppy has 2 eyes 4 legs" 是一个由 7 个 token 组成的句子：
"2" 和 "4" 是数字，其他像 "puppy" 这样的 tokens 属于单词。
给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增
（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。
如果满足题目要求，返回 true ，否则，返回 false 。
示例 1：输入：s = "1 box has 3 blue 4 red 6 green and 12 yellow marbles" 输出：true
解释：句子中的数字是：1, 3, 4, 6, 12 。
这些数字是按从左到右严格递增的 1 < 3 < 4 < 6 < 12 。
示例 2：输入：s = "hello world 5 x 5" 输出：false
解释：句子中的数字是：5, 5 。这些数字不是严格递增的。
示例 3：输入：s = "sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s" 输出：false
解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。
示例 4：输入：s = "4 5 11 26" 输出：true
解释：s 中的数字是：4, 5, 11, 26 。
这些数字是按从左到右严格递增的：4 < 5 < 11 < 26 。
提示：3 <= s.length <= 200
s 由小写英文字母、空格和数字 0 到 9 组成（包含 0 和 9）
s 中数字 token 的数目在 2 和 100 之间（包含 2 和 100）
s 中的 token 之间由单个空格分隔
s 中至少有 两个 数字
s 中的每个数字都是一个 小于 100 的 正 数，且不含前导零
s 不含前导或尾随空格
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n)       | O(n)       |

```go
func areNumbersAscending(s string) bool {
	arr := strings.Split(s, " ")
	prev := -1
	for i := 0; i < len(arr); i++ {
		if '0' <= arr[i][0] && arr[i][0] <= '9' {
			value, _ := strconv.Atoi(arr[i])
			if value > prev {
				prev = value
			} else {
				return false
			}
		}
	}
	return true
}
```



# 2001-2100-Medium

## 2001.可互换矩形的组数(1)

- 题目

```
用一个下标从 0 开始的二维整数数组 rectangles 来表示 n 个矩形，
其中 rectangles[i] = [widthi, heighti] 表示第 i 个矩形的宽度和高度。
如果两个矩形 i 和 j（i < j）的宽高比相同，则认为这两个矩形 可互换 。
更规范的说法是，两个矩形满足 widthi/heighti == widthj/heightj（使用实数除法而非整数除法），则认为这两个矩形 可互换 。
计算并返回 rectangles 中有多少对 可互换 矩形。
示例 1：输入：rectangles = [[4,8],[3,6],[10,20],[15,30]] 输出：6
解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：
- 矩形 0 和矩形 1 ：4/8 == 3/6
- 矩形 0 和矩形 2 ：4/8 == 10/20
- 矩形 0 和矩形 3 ：4/8 == 15/30
- 矩形 1 和矩形 2 ：3/6 == 10/20
- 矩形 1 和矩形 3 ：3/6 == 15/30
- 矩形 2 和矩形 3 ：10/20 == 15/30
示例 2：输入：rectangles = [[4,5],[7,8]] 输出：0
解释：不存在成对的可互换矩形。
提示：n == rectangles.length
1 <= n <= 105
rectangles[i].length == 2
1 <= widthi, heighti <= 105
```

- 解题思路

| No.  | 思路          | 时间复杂度 | 空间复杂度 |
| ---- | ------------- | ---------- | ---------- |
| 01   | 哈希辅助+组合 | O(n)       | O(n)       |

```go
func interchangeableRectangles(rectangles [][]int) int64 {
	m := make(map[string]int64)
	res := int64(0)
	for i := 0; i < len(rectangles); i++ {
		a, b := rectangles[i][0], rectangles[i][1]
		c := gcd(a, b)
		m[fmt.Sprintf("%d,%d", a/c, b/c)]++
	}
	for _, v := range m {
		res = res + (v-1)*v/2
	}
	return res
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}
```

## 2002.两个回文子序列长度的最大乘积(3)

- 题目

```
给你一个字符串 s ，请你找到 s 中两个 不相交回文子序列 ，使得它们长度的 乘积最大 。
两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 不相交 的。
请你返回两个回文子序列长度可以达到的 最大乘积 。
子序列 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。
如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 回文字符串 。
示例 1：输入：s = "leetcodecom" 输出：9
解释：最优方案是选择 "ete" 作为第一个子序列，"cdc" 作为第二个子序列。
它们的乘积为 3 * 3 = 9 。
示例 2：输入：s = "bb" 输出：1
解释：最优方案为选择 "b" （第一个字符）作为第一个子序列，"b" （第二个字符）作为第二个子序列。
它们的乘积为 1 * 1 = 1 。
示例 3：输入：s = "accbcaxxcxx" 输出：25
解释：最优方案为选择 "accca" 作为第一个子序列，"xxcxx" 作为第二个子序列。
它们的乘积为 5 * 5 = 25 。
提示：2 <= s.length <= 12
s 只含有小写英文字母。
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 递归              | O(3^n)     | O(n)       |
| 02   | 状态压缩+遍历     | O(4^n)     | O(2^n)     |
| 03   | 状态压缩+枚举子集 | O(n*2^n)   | O(2^n)     |

```go
var res int

func maxProduct(s string) int {
	res = 0
	dfs(s, "", "", 0)
	return res
}

func dfs(s string, a, b string, index int) {
	if len(a) > 0 && len(b) > 0 &&
		isPalindrome(a, 0, len(a)-1) && isPalindrome(b, 0, len(b)-1) {
		res = max(res, len(a)*len(b))
	}
	if index == len(s) {
		return
	}
	dfs(s, a, b, index+1)                  // a,b都不选
	dfs(s, a+string(s[index]), b, index+1) // a不选
	dfs(s, a, b+string(s[index]), index+1) // b不选
}

func isPalindrome(s string, i, j int) bool {
	for i < j {
		if s[i] != s[j] {
			return false
		}
		i++
		j--
	}
	return true
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxProduct(s string) int {
	res := 0
	n := len(s)
	total := 1 << n
	arr := make([]int, 0)
	for i := 1; i < total; i++ {
		if judge(s, i) {
			arr = append(arr, i)
		}
	}
	for i := 0; i < len(arr); i++ { // 枚举回文状态
		for j := i + 1; j < len(arr); j++ {
			if arr[i]&arr[j] == 0 {
				a, b := bits.OnesCount(uint(arr[i])), bits.OnesCount(uint(arr[j]))
				res = max(res, a*b)
			}
		}
	}
	return res
}

func judge(s string, status int) bool {
	left, right := 0, len(s)-1
	for left < right {
		for left < right && (status&(1<<left)) == 0 {
			left++
		}
		for left < right && (status&(1<<right)) == 0 {
			right--
		}
		if s[left] != s[right] {
			return false
		}
		left++
		right--
	}
	return true
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func maxProduct(s string) int {
	res := 0
	n := len(s)
	total := 1 << n
	m := make(map[int]int, 0)
	for i := 1; i < total; i++ {
		if judge(s, i) {
			m[i] = bits.OnesCount(uint(i))
		}
	}
	for i := 1; i < total; i++ { // 遍历状态
		for j := i; j > 0; j = (j - 1) & i { // 枚举子集
			res = max(res, m[j]*m[j^i]) // 子集 * 子集的补集
		}
	}
	return res
}

func judge(s string, status int) bool {
	left, right := 0, len(s)-1
	for left < right {
		for left < right && (status&(1<<left)) == 0 {
			left++
		}
		for left < right && (status&(1<<right)) == 0 {
			right--
		}
		if s[left] != s[right] {
			return false
		}
		left++
		right--
	}
	return true
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2007.从双倍数组中还原原数组(2)

- 题目

```
一个整数数组 original 可以转变成一个 双倍 数组 changed ，转变方式为将 original 中每个元素 值乘以 2 加入数组中，
然后将所有元素 随机打乱 。
给你一个数组 changed ，如果 change 是 双倍 数组，那么请你返回 original数组，否则请返回空数组。
original 的元素可以以 任意 顺序返回。
示例 1：输入：changed = [1,3,4,2,6,8] 输出：[1,3,4]
解释：一个可能的 original 数组为 [1,3,4] :
- 将 1 乘以 2 ，得到 1 * 2 = 2 。
- 将 3 乘以 2 ，得到 3 * 2 = 6 。
- 将 4 乘以 2 ，得到 4 * 2 = 8 。
其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。
示例 2：输入：changed = [6,3,0,1] 输出：[]
解释：changed 不是一个双倍数组。
示例 3：输入：changed = [1] 输出：[]
解释：changed 不是一个双倍数组。
提示：1 <= changed.length <= 105
0 <= changed[i] <= 105
```

- 解题思路

| No.  | 思路      | 时间复杂度 | 空间复杂度 |
| ---- | --------- | ---------- | ---------- |
| 01   | 排序+哈希 | O(nlog(n)) | O(n)       |
| 02   | 排序+哈希 | O(nlog(n)) | O(n)       |

 ```go
 func findOriginalArray(changed []int) []int {
 	res := make([]int, 0)
 	n := len(changed)
 	if n%2 == 1 {
 		return nil
 	}
 	sort.Ints(changed)
 	m := make(map[int]int)
 	for i := 0; i < n; i++ {
 		value := changed[i]
 		if m[value] == 0 { // 不是双倍的元素
 			m[value*2]++ // 标记双倍
 			res = append(res, value)
 		} else {
 			m[value]--
 			if m[value] == 0 {
 				delete(m, value)
 			}
 		}
 	}
 	if len(m) == 0 {
 		return res
 	}
 	return nil
 }
 
 # 2
 func findOriginalArray(changed []int) []int {
 	res := make([]int, 0)
 	n := len(changed)
 	if n%2 == 1 {
 		return nil
 	}
 	sort.Ints(changed)
 	m := make(map[int]int)
 	for i := 0; i < n; i++ {
 		m[changed[i]]++
 	}
 	for i := 0; i < n; i++ {
 		if m[changed[i]] != 0 {
 			res = append(res, changed[i])
 			m[changed[i]]--
 			m[changed[i]*2]--
 		}
 	}
 	if len(res)*2 != n {
 		return nil
 	}
 	return res
 }
 ```

## 2008.出租车的最大盈利(4)

- 题目

```
你驾驶出租车行驶在一条有 n 个地点的路上。这 n 个地点从近到远编号为 1 到 n ，你想要从 1 开到 n ，通过接乘客订单盈利。
你只能沿着编号递增的方向前进，不能改变方向。
乘客信息用一个下标从 0 开始的二维数组 rides 表示，
其中 rides[i] = [starti, endi, tipi] 表示第 i 位乘客需要从地点 starti 前往 endi ，愿意支付 tipi 元的小费。
每一位 你选择接单的乘客 i ，你可以 盈利 endi - starti + tipi 元。你同时 最多 只能接一个订单。
给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。
注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。
示例 1：输入：n = 5, rides = [[2,5,4],[1,5,1]] 输出：7
解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。
示例 2：输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]] 输出：20
解释：我们可以接以下乘客的订单：
- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。
- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。
- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。
我们总共获得 9 + 5 + 6 = 20 元。
提示：1 <= n <= 105
1 <= rides.length <= 3 * 104
rides[i].length == 3
1 <= starti < endi <= n
1 <= tipi <= 105
```

- 解题思路

| No.  | 思路                       | 时间复杂度 | 空间复杂度 |
| ---- | -------------------------- | ---------- | ---------- |
| 01   | 动态规划+二分查找+内置函数 | O(nlog(n)) | O(n)       |
| 02   | 动态规划+二分查找          | O(nlog(n)) | O(n)       |
| 03   | 动态规划                   | O(n)       | O(n)       |
| 04   | 动态规划                   | O(n)       | O(n)       |

```go
func maxTaxiEarnings(n int, rides [][]int) int64 {
	m := len(rides)
	arr := make([][]int64, 0)
	for i := 0; i < m; i++ {
		a, b, c := rides[i][0], rides[i][1], rides[i][2]
		arr = append(arr, []int64{int64(a), int64(b), int64(b - a + c)})
	}
	sort.Slice(arr, func(i, j int) bool {
		if arr[i][1] == arr[j][1] {
			return arr[i][0] < arr[j][0]
		}
		return arr[i][1] < arr[j][1]
	})
	for i := 1; i < m; i++ {
		target := sort.Search(i, func(j int) bool {
			return arr[j][1] > arr[i][0]
		})
		if target == 0 {
			arr[i][2] = max(arr[i][2], arr[i-1][2])
		} else {
			arr[i][2] = max(arr[i][2]+arr[target-1][2], arr[i-1][2])
		}
	}
	return arr[m-1][2]
}

func max(a, b int64) int64 {
	if a > b {
		return a
	}
	return b
}

# 2
func maxTaxiEarnings(n int, rides [][]int) int64 {
	m := len(rides)
	arr := make([][]int64, 0)
	for i := 0; i < m; i++ {
		a, b, c := rides[i][0], rides[i][1], rides[i][2]
		arr = append(arr, []int64{int64(a), int64(b), int64(b - a + c)})
	}
	sort.Slice(arr, func(i, j int) bool {
		if arr[i][1] == arr[j][1] {
			return arr[i][0] < arr[j][0]
		}
		return arr[i][1] < arr[j][1]
	})
	dp := make([]int64, m)
	dp[0] = arr[0][2]
	for i := 1; i < m; i++ {
		left, right := 0, i-1
		for left < right {
			mid := left + (right-left)/2
			if arr[mid+1][1] <= arr[i][0] {
				left = mid + 1
			} else {
				right = mid
			}
		}
		if arr[left][1] <= arr[i][0] {
			dp[i] = max(dp[i-1], dp[left]+arr[i][2])
		} else {
			dp[i] = max(dp[i-1], arr[i][2])
		}
	}
	return dp[m-1]
}

func max(a, b int64) int64 {
	if a > b {
		return a
	}
	return b
}

# 3
func maxTaxiEarnings(n int, rides [][]int) int64 {
	dp := make([]int, n+1) // dp[i]到达i位置的最大盈利
	arr := make([][][2]int, n+1)
	for i := 0; i < len(rides); i++ {
		a, b, c := rides[i][0], rides[i][1], rides[i][2]
		arr[b] = append(arr[b], [2]int{a, b - a + c})
	}
	for i := 1; i <= n; i++ {
		dp[i] = dp[i-1]
		for j := 0; j < len(arr[i]); j++ {
			a, c := arr[i][j][0], arr[i][j][1]
			dp[i] = max(dp[i], dp[a]+c)
		}
	}
	return int64(dp[n])
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 4
func maxTaxiEarnings(n int, rides [][]int) int64 {
	dp := make([]int, n+1) // dp[i]到达i位置的最大盈利
	sort.Slice(rides, func(i, j int) bool {
		if rides[i][0] == rides[j][0] {
			return rides[i][1] < rides[j][1]
		}
		return rides[i][0] < rides[j][0]
	})
	j := 1
	for i := 0; i < len(rides); i++ { // 遍历订单
		a, b, c := rides[i][0], rides[i][1], rides[i][2]
		for j < a { // 更新指针
			j++
			dp[j] = max(dp[j], dp[j-1])
		}
		dp[b] = max(dp[b], dp[j]+(b-a+c))
	}
	for ; j <= n; j++ {
		dp[j] = max(dp[j], dp[j-1])
	}
	return int64(dp[n])
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2012.数组美丽值求和(1)

- 题目

```
给你一个下标从 0 开始的整数数组 nums 。对于每个下标 i（1 <= i <= nums.length - 2），nums[i] 的 美丽值 等于：
2，对于所有 0 <= j < i 且 i < k <= nums.length - 1 ，满足 nums[j] < nums[i] < nums[k]
1，如果满足 nums[i - 1] < nums[i] < nums[i + 1] ，且不满足前面的条件
0，如果上述条件全部不满足
返回符合 1 <= i <= nums.length - 2 的所有 nums[i] 的 美丽值的总和 。
示例 1：输入：nums = [1,2,3] 输出：2
解释：对于每个符合范围 1 <= i <= 1 的下标 i :
- nums[1] 的美丽值等于 2
示例 2：输入：nums = [2,4,6,4] 输出：1
解释：对于每个符合范围 1 <= i <= 2 的下标 i :
- nums[1] 的美丽值等于 1
- nums[2] 的美丽值等于 0
示例 3：输入：nums = [3,2,1] 输出：0
解释：对于每个符合范围 1 <= i <= 1 的下标 i :
- nums[1] 的美丽值等于 0
提示：3 <= nums.length <= 105
1 <= nums[i] <= 105
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 前缀和 | O(n)       | O(n)       |

```go
func sumOfBeauties(nums []int) int {
	res := 0
	n := len(nums)
	arrA := make([]int, n)
	arrA[0] = nums[0]
	for i := 1; i < n; i++ {
		arrA[i] = max(nums[i], arrA[i-1])
	}
	arrB := make([]int, n)
	arrB[n-1] = nums[n-1]
	for i := n - 2; i >= 0; i-- {
		arrB[i] = min(nums[i], arrB[i+1])
	}
	for i := 1; i <= n-2; i++ {
		if arrA[i-1] < nums[i] && nums[i] < arrB[i+1] {
			res = res + 2
		} else if nums[i-1] < nums[i] && nums[i] < nums[i+1] {
			res = res + 1
		}
	}
	return res
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2013.检测正方形(1)

- 题目

```
给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：
添加 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。
给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。
轴对齐正方形 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。
实现 DetectSquares 类：
DetectSquares() 使用空数据结构初始化对象
void add(int[] point) 向数据结构添加一个新的点 point = [x, y]
int count(int[] point) 统计按上述方式与点 point = [x, y] 共同构造 轴对齐正方形 的方案数。
示例：输入：["DetectSquares", "add", "add", "add", "count", "count", "add", "count"]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
输出：[null, null, null, null, 1, 0, null, 2]
解释：DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // 返回 1 。你可以选择：
                               //   - 第一个，第二个，和第三个点
detectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。
detectSquares.add([11, 2]);    // 允许添加重复的点。
detectSquares.count([11, 10]); // 返回 2 。你可以选择：
                               //   - 第一个，第二个，和第三个点
                               //   - 第一个，第三个，和第四个点
提示：point.length == 2
0 <= x, y <= 1000
调用 add 和 count 的 总次数 最多为 5000
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 哈希 | O(n)       | O(n)       |

```go
type DetectSquares struct {
	m map[int]map[int]int
}

func Constructor() DetectSquares {
	return DetectSquares{
		m: make(map[int]map[int]int),
	}
}

func (this *DetectSquares) Add(point []int) {
	a, b := point[0], point[1]
	if this.m[a] == nil {
		this.m[a] = make(map[int]int)
	}
	this.m[a][b]++
}

func (this *DetectSquares) Count(point []int) int {
	res := 0
	x, y := point[0], point[1]
	for a := range this.m[x] { // 遍历同一列的y坐标
		if a == y {
			continue
		}
		length := abs(a - y) // 获取正方形边长
		b := x + length      // 右边
		if this.m[b] != nil && this.m[b][a] > 0 && this.m[b][y] > 0 {
			res = res + this.m[b][a]*this.m[b][y]*this.m[x][a]
		}
		b = x - length // 左边
		if this.m[b] != nil && this.m[b][a] > 0 && this.m[b][y] > 0 {
			res = res + this.m[b][a]*this.m[b][y]*this.m[x][a]
		}
	}
	return res
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```

## 2017.网格游戏(1)

- 题目

```
给你一个下标从 0 开始的二维数组 grid ，数组大小为 2 x n ，其中 grid[r][c] 表示矩阵中 (r, c) 位置上的点数。
现在有两个机器人正在矩阵上参与一场游戏。
两个机器人初始位置都是 (0, 0) ，目标位置是 (1, n-1) 。
每个机器人只会 向右 ((r, c) 到 (r, c + 1)) 或 向下 ((r, c) 到 (r + 1, c)) 。
游戏开始，第一个 机器人从 (0, 0) 移动到 (1, n-1) ，并收集路径上单元格的全部点数。
对于路径上所有单元格 (r, c) ，途经后 grid[r][c] 会重置为 0 。
然后，第二个 机器人从 (0, 0) 移动到 (1, n-1) ，同样收集路径上单元的全部点数。注意，它们的路径可能会存在相交的部分。
第一个 机器人想要打击竞争对手，使 第二个 机器人收集到的点数 最小化 。
与此相对，第二个 机器人想要 最大化 自己收集到的点数。
两个机器人都发挥出自己的 最佳水平 的前提下，返回 第二个 机器人收集到的 点数 。
示例 1：输入：grid = [[2,5,4],[1,5,1]] 输出：4
解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。
第一个机器人访问过的单元格将会重置为 0 。
第二个机器人将会收集到 0 + 0 + 4 + 0 = 4 个点。
示例 2：输入：grid = [[3,3,1],[8,5,2]] 输出：4
解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。 
第一个机器人访问过的单元格将会重置为 0 。
第二个机器人将会收集到 0 + 3 + 1 + 0 = 4 个点。
示例 3：输入：grid = [[1,3,1,15],[1,3,3,1]] 输出：7
解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。
第一个机器人访问过的单元格将会重置为 0 。
第二个机器人将会收集到 0 + 1 + 3 + 3 + 0 = 7 个点。
提示：grid.length == 2
n == grid[r].length
1 <= n <= 5 * 104
1 <= grid[r][c] <= 105
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 前缀和+贪心 | O(n)       | O(n)       |

```go
func gridGame(grid [][]int) int64 {
	n := len(grid[0])
	a := make([]int, n) // 前缀和：上边：从右到左
	b := make([]int, n) // 前缀和：下边，从左到右
	for i := n - 1; i > 0; i-- {
		a[i-1] = a[i] + grid[0][i]
	}
	for i := 0; i < n-1; i++ {
		b[i+1] = b[i] + grid[1][i]
	}
	res := math.MaxInt64
	// 当第一个机器人选择第i点往下走的时候
	// 第一个机器人不需要选择最大值，只需要考虑让第二个机器人选择最小
	for i := 0; i < n; i++ {
		// 第二个机器人只有2个选择，选其中最大的
		// 1、从第0个点往下走，拿到b[i]值
		// 2、一直往右走，拿到a[i]值
		res = min(res, max(a[i], b[i]))
	}
	return int64(res)
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2018.判断单词是否能放入填字游戏内

### 题目

```

```

### 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 前缀和+贪心 | O(n)       | O(n)       |

```go

```

## 2023.连接后等于目标字符串的字符串对(2)

- 题目

```
给你一个 数字 字符串数组 nums 和一个 数字 字符串 target ，
请你返回 nums[i] + nums[j] （两个字符串连接）结果等于 target 的下标 (i, j) （需满足 i != j）的数目。
示例 1：输入：nums = ["777","7","77","77"], target = "7777" 输出：4
解释：符合要求的下标对包括：
- (0, 1)："777" + "7"
- (1, 0)："7" + "777"
- (2, 3)："77" + "77"
- (3, 2)："77" + "77"
示例 2：输入：nums = ["123","4","12","34"], target = "1234" 输出：2
解释：符合要求的下标对包括
- (0, 1)："123" + "4"
- (2, 3)："12" + "34"
示例 3：输入：nums = ["1","1","1"], target = "11" 输出：6
解释：符合要求的下标对包括
- (0, 1)："1" + "1"
- (1, 0)："1" + "1"
- (0, 2)："1" + "1"
- (2, 0)："1" + "1"
- (1, 2)："1" + "1"
- (2, 1)："1" + "1"
提示：2 <= nums.length <= 100
1 <= nums[i].length <= 100
2 <= target.length <= 100
nums[i] 和 target 只包含数字。
nums[i] 和 target 不含有任何前导 0 。
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 遍历     | O(n^2)     | O(1)       |
| 02   | 哈希辅助 | O(n)       | O(n)       |

```go
func numOfPairs(nums []string, target string) int {
	res := 0
	n := len(nums)
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if nums[i]+nums[j] == target {
				res++
			}
			if nums[j]+nums[i] == target {
				res++
			}
		}
	}
	return res
}

# 2
func numOfPairs(nums []string, target string) int {
	res := 0
	n := len(nums)
	m := make(map[string]int)
	for i := 0; i < n; i++ {
		m[nums[i]]++
	}
	for i := 1; i < len(target); i++ {
		a, b := target[:i], target[i:]
		if a == b {
			res = res + m[a]*(m[a]-1)
		} else {
			res = res + m[a]*m[b]
		}
	}
	return res
}
```

## 2024.考试的最大困扰度(3)

- 题目

```
一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 'T' 表示）或者 false （用 'F' 表示）。
老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。
给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。
除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：
每次操作中，将问题的正确答案改为 'T' 或者 'F' （也就是将 answerKey[i] 改为 'T' 或者 'F' ）。
请你返回在不超过 k 次操作的情况下，最大 连续 'T' 或者 'F' 的数目。
示例 1：输入：answerKey = "TTFF", k = 2 输出：4
解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = "TTTT" 。
总共有四个连续的 'T' 。
示例 2：输入：answerKey = "TFFT", k = 1 输出：3
解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = "FFFT" 。
或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = "TFFF" 。
两种情况下，都有三个连续的 'F' 。
示例 3：输入：answerKey = "TTFTTFTT", k = 1 输出：5
解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = "TTTTTFTT" 。
或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = "TTFTTTTT" 。
两种情况下，都有五个连续的 'T' 。
提示：n == answerKey.length
1 <= n <= 5 * 104
answerKey[i] 要么是 'T' ，要么是 'F'
1 <= k <= n
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 滑动窗口-双指针 | O(n)       | O(n)       |
| 02   | 滑动窗口-双指针 | O(n)       | O(1)       |
| 03   | 滑动窗口-双指针 | O(n)       | O(n)       |

```go
func maxConsecutiveAnswers(answerKey string, k int) int {
	n := len(answerKey)
	arr := make([]int, n)
	for i := 0; i < n; i++ {
		if answerKey[i] == 'T' {
			arr[i] = 1
		}
	}
	a := longestOnes(arr, k)
	arr = make([]int, n)
	for i := 0; i < n; i++ {
		if answerKey[i] == 'F' {
			arr[i] = 1
		}
	}
	b := longestOnes(arr, k)
	return max(a, b)
}

// leetcode 1004.最大连续1的个数III
func longestOnes(A []int, K int) int {
	res := 0
	left, right := 0, 0
	count := 0
	for right = 0; right < len(A); right++ {
		if A[right] == 0 {
			count++
		}
		for count > K {
			if A[left] == 0 {
				count--
			}
			left++
		}
		res = max(res, right-left+1)
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func maxConsecutiveAnswers(answerKey string, k int) int {
	n := len(answerKey)
	res := 0
	left, right := 0, 0
	countA, countB := 0, 0
	for ; right < n; right++ {
		if answerKey[right] == 'T' {
			countA++
		} else {
			countB++
		}
		for countA > k && countB > k { // 都大于k时，滑动窗口才移动
			if answerKey[left] == 'T' {
				countA--
			} else {
				countB--
			}
			left++
		}
		res = max(res, right-left+1)
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func maxConsecutiveAnswers(answerKey string, k int) int {
	arr := []byte(answerKey)
	return max(longestOnes(arr, k, 'T'), longestOnes(arr, k, 'F'))
}

func longestOnes(A []byte, K int, target byte) int {
	res := 0
	left, right := 0, 0
	count := 0
	for right = 0; right < len(A); right++ {
		if A[right] == target {
			count++
		}
		for count > K {
			if A[left] == target {
				count--
			}
			left++
		}
		res = max(res, right-left+1)
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2028.找出缺失的观测数据(2)

- 题目

```
现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。
观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。
给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。
返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。
如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。
k 个数字的 平均值 为这些数字求和后再除以 k 。
注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。
示例 1：输入：rolls = [3,2,4,3], mean = 4, n = 2 输出：[6,6]
解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。
示例 2：输入：rolls = [1,5,6], mean = 3, n = 4 输出：[2,3,2,2]
解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。
示例 3：输入：rolls = [1,2,3,4], mean = 6, n = 4 输出：[]
解释：无论丢失的 4 次数据是什么，平均值都不可能是 6 。
示例 4：输入：rolls = [1], mean = 3, n = 1 输出：[5]
解释：所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。
提示：m == rolls.length
1 <= n, m <= 105
1 <= rolls[i], mean <= 6
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 贪心 | O(n)       | O(n)       |
| 02   | 贪心 | O(n)       | O(n)       |

```go
func missingRolls(rolls []int, mean int, n int) []int {
	sum := 0
	m := len(rolls)
	for i := 0; i < m; i++ {
		sum = sum + rolls[i]
	}
	total := mean * (n + m)
	left := total - sum
	if left > n*6 || left < n {
		return nil
	}
	res := make([]int, n)
	for i := 0; i < n; i++ {
		res[i] = left / n // 平均分配
	}
	for i := 0; i < left%n; i++ {
		res[i] = res[i] + 1
	}
	return res
}

# 2
func missingRolls(rolls []int, mean int, n int) []int {
	sum := 0
	m := len(rolls)
	for i := 0; i < m; i++ {
		sum = sum + rolls[i]
	}
	total := mean * (n + m)
	left := total - sum
	if left > n*6 || left < n {
		return nil
	}
	res := make([]int, n)
	for i := 0; i < n; i++ {
		res[i] = 1
	}
	left = left - n
	for i := 0; i < n; i++ {
		if left < 6 {
			res[i] = res[i] + left
			break
		}
		res[i] = res[i] + 5
		left = left - 5
	}
	return res
}
```

## 2029.石子游戏IX(1)

- 题目

```
Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。
给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。
Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。
如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。
示例 1：输入：stones = [2,1] 输出：true
解释：游戏进行如下：
- 回合 1：Alice 可以移除任意一个石子。
- 回合 2：Bob 移除剩下的石子。 
已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。
示例 2：输入：stones = [2] 输出：false
解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 
由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。
示例 3：输入：stones = [5,1,2,4,3] 输出：false
解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：
- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.
Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。
提示：1 <= stones.length <= 105
1 <= stones[i] <= 104
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 博弈 | O(n)       | O(1)       |

```go
func stoneGameIX(stones []int) bool {
	m := make(map[int]int)
	for i := 0; i < len(stones); i++ {
		m[stones[i]%3]++
	}
	a, b, c := m[0], m[1], m[2] // 0,1,2的个数
	// 以1开头：1、(1、2)、1...
	// 以2开头：2、(2、1)、2...
	if a%2 == 0 { // 0为偶数个，可以抵消
		// 获胜策略：选择较少的1或者2
		// 1、1=2 => Alice赢（以1开始或者2开始都赢）
		// 不等的时候
		// 2.1、1>2 => Alice以2开头=> 2、2、1...(2、1).. 最后Bob没有2可选，只能选择1，Alice就赢了
		// 2.2 2>1 => Alice以1开头=> 1、1、2...(1、2).. 最后Bob没有1可选，只能选择2，Alice就赢了
		return b > 0 && c > 0
	}
	if a%2 == 1 {
		// 奇数个0
		// 获胜策略：选取较多的1或者2
		// 需要差值大于2个Alice才赢
		// 1>2 => Alice以1开头 => 1、(1、0)、2、1、1 / 1、(0、1)、2、1、1
		// 2>1 => Alice以2开头 => 2、(2、0)、1、2、2 / 2、(0、2)、1、2、2
		return b-c > 2 || c-b > 2
	}
	return false
}
```

## 2033.获取单值网格的最小操作数(1)

- 题目

```
给你一个大小为 m x n 的二维整数网格 grid 和一个整数 x 。每一次操作，你可以对 grid 中的任一元素 加 x 或 减 x 。
单值网格 是全部元素都相等的网格。
返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 -1 。
示例 1：输入：grid = [[2,4],[6,8]], x = 2 输出：4
解释：可以执行下述操作使所有元素都等于 4 ： 
- 2 加 x 一次。
- 6 减 x 一次。
- 8 减 x 两次。
共计 4 次操作。
示例 2：输入：grid = [[1,5],[2,3]], x = 1 输出：5
解释：可以使所有元素都等于 3 。
示例 3：输入：grid = [[1,2],[3,4]], x = 2 输出：-1
解释：无法使所有元素相等。
提示：m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
1 <= x, grid[i][j] <= 104
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 排序 | O(nlog(n)) | O(n)       |

```go
func minOperations(grid [][]int, x int) int {
	n, m := len(grid), len(grid[0])
	arr := make([]int, 0)
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			arr = append(arr, grid[i][j])
		}
	}
	sort.Ints(arr)
	target := arr[len(arr)/2]
	res := 0
	for i := 0; i < len(arr); i++ {
		if abs(target-arr[i])%x != 0 {
			return -1
		}
		res = res + abs(target-arr[i])/x
	}
	return res
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```

## 2034.股票价格波动

### 题目

```
给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。
不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。
如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。
请你设计一个算法，实现：
更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。
找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。
找到当前记录里股票的 最高价格 。
找到当前记录里股票的 最低价格 。
请你实现 StockPrice 类：
StockPrice() 初始化对象，当前无股票价格记录。
void update(int timestamp, int price) 在时间点 timestamp 更新股票价格为 price 。
int current() 返回股票 最新价格 。
int maximum() 返回股票 最高价格 。
int minimum() 返回股票 最低价格 。
示例 1：输入：["StockPrice", "update", "update", "current", "maximum", "update", 
"maximum", "update", "minimum"]
[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]
输出：[null, null, null, 5, 10, null, 5, null, 2]
解释：StockPrice stockPrice = new StockPrice();
stockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。
stockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。
stockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。
stockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。
stockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。
                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。
stockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。
stockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。
stockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。
提示：1 <= timestamp, price <= 109
update，current，maximum 和 minimum 总 调用次数不超过 105 。
current，maximum 和 minimum 被调用时，update 操作 至少 已经被调用过 一次 。
```

### 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
|      |      |            |            |
|      |      |            |            |

```go

```

## 2038.如果相邻两个颜色均相同则删除当前颜色(2)

- 题目

```
总共有 n 个颜色片段排成一列，每个颜色片段要么是 'A' 要么是 'B' 。
给你一个长度为 n 的字符串 colors ，其中 colors[i] 表示第 i 个颜色片段的颜色。
Alice 和 Bob 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。Alice 先手 。
如果一个颜色片段为 'A' 且 相邻两个颜色 都是颜色 'A' ，那么 Alice 可以删除该颜色片段。
Alice 不可以 删除任何颜色 'B' 片段。
如果一个颜色片段为 'B' 且 相邻两个颜色 都是颜色 'B' ，那么 Bob 可以删除该颜色片段。
Bob 不可以 删除任何颜色 'A' 片段。
Alice 和 Bob 不能 从字符串两端删除颜色片段。
如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。
假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。
示例 1：输入：colors = "AAABABB" 输出：true
解释：AAABABB -> AABABB
Alice 先操作。
她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。
现在轮到 Bob 操作。
Bob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。
因此，Alice 获胜，返回 true 。
示例 2：输入：colors = "AA" 输出：false
解释：Alice 先操作。
只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。
因此，Bob 获胜，返回 false 。
示例 3：输入：colors = "ABBBBBBBAAA" 输出：false
解释：ABBBBBBBAAA -> ABBBBBBBAA
Alice 先操作。
她唯一的选择是删除从右数起第二个 'A' 。
ABBBBBBBAA -> ABBBBBBAA
接下来轮到 Bob 操作。
他有许多选择，他可以选择任何一个 'B' 删除。
然后轮到 Alice 操作，她无法删除任何片段。
所以 Bob 获胜，返回 false 。
提示：1 <= colors.length <= 105
colors 只包含字母 'A' 和 'B'
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(n)       | O(n)       |
| 02   | 遍历     | O(n)       | O(1)       |

```go
func winnerOfGame(colors string) bool {
	arrA := strings.Split(colors, "B")
	arrB := strings.Split(colors, "A")
	countA, countB := 0, 0
	for i := 0; i < len(arrA); i++ {
		if len(arrA[i]) >= 3 {
			countA = countA + len(arrA[i]) - 2
		}
	}
	for i := 0; i < len(arrB); i++ {
		if len(arrB[i]) >= 3 {
			countB = countB + len(arrB[i]) - 2
		}
	}
	if countA > countB {
		return true
	}
	return false
}

# 2
func winnerOfGame(colors string) bool {
	countA := 0
	countB := 0
	if len(colors) <= 2 {
		return false
	}
	for i := 2; i < len(colors); i++ {
		if colors[i-1] == colors[i-2] && colors[i-1] == colors[i] {
			if colors[i] == 'A' {
				countA++
			} else {
				countB++
			}
		}
	}
	if countA > countB {
		return true
	}
	return false
}
```

## 2039.网络空闲的时刻(2)

- 题目

```
给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。
同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，
在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。
题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。
编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。
信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。
主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。
在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。
从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：
如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，
也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。
否则，该数据服务器 不会重发 信息。
当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。
请返回计算机网络变为 空闲 状态的 最早秒数 。
示例 1：输入：edges = [[0,1],[1,2]], patience = [0,2,1] 输出：8
解释：0 秒最开始时，
- 数据服务器 1 给主服务器发出信息（用 1A 表示）。
- 数据服务器 2 给主服务器发出信息（用 2A 表示）。
1 秒时，
- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。
- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 < patience[1] = 2），所以不会重发信息。
- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。
2 秒时，
- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。
- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。
- 服务器 2 重发一条信息（用 2C 表示）。
...
4 秒时，
- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。
...
7 秒时，回复信息 2D 到达服务器 2 。
从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。
所以第 8 秒是网络变空闲的最早时刻。
示例 2：输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10] 输出：3
解释：数据服务器 1 和 2 第 2 秒初收到回复信息。
从第 3 秒开始，网络变空闲。
提示：n == patience.length
2 <= n <= 105
patience[0] == 0
对于 1 <= i < n ，满足 1 <= patience[i] <= 105
1 <= edges.length <= min(105, n * (n - 1) / 2)
edges[i].length == 2
0 <= ui, vi < n
ui != vi
不会有重边。
每个服务器都直接或间接与别的服务器相连。
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | Dijkstra     | O(nlog(n)) | O(n)       |
| 02   | 广度优先搜索 | O(n)       | O(n)       |

```go
func networkBecomesIdle(edges [][]int, patience []int) int {
	maxValue := math.MaxInt32 / 10
	n := len(patience)
	arr := make([][][2]int, n) // 邻接表：i=>j的集合
	for i := 0; i < len(edges); i++ {
		a, b := edges[i][0], edges[i][1] // a=>b
		arr[a] = append(arr[a], [2]int{b, 1})
		arr[b] = append(arr[b], [2]int{a, 1})
	}
	dis := make([]int, n) // k到其他点的距离
	for i := 0; i < n; i++ {
		dis[i] = maxValue
	}
	dis[0] = 0
	intHeap := make(IntHeap, 0)
	heap.Init(&intHeap)
	heap.Push(&intHeap, [2]int{0, 0})
	for intHeap.Len() > 0 {
		node := heap.Pop(&intHeap).([2]int) // 距离起点最近的点
		a := node[0]
		if dis[a] < node[1] { // 大于最短距离，跳过
			continue
		}
		for i := 0; i < len(arr[a]); i++ {
			b, c := arr[a][i][0], arr[a][i][1]
			if dis[a]+c < dis[b] { // 更新距离
				dis[b] = dis[a] + c
				heap.Push(&intHeap, [2]int{b, dis[b]})
			}
		}
	}
	res := 0
	for i := 1; i < n; i++ {
		total := (2*dis[i]-1)/patience[i]*patience[i] + 2*dis[i]
		res = max(res, total)
	}
	return res + 1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

type IntHeap [][2]int

func (h IntHeap) Len() int {
	return len(h)
}

// 小根堆<,大根堆变换方向>
func (h IntHeap) Less(i, j int) bool {
	return h[i][1] < h[j][1]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.([2]int))
}

func (h *IntHeap) Pop() interface{} {
	value := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return value
}

# 2
func networkBecomesIdle(edges [][]int, patience []int) int {
	n := len(patience)
	arr := make([][]int, n) // 邻接表：i=>j的集合
	for i := 0; i < len(edges); i++ {
		a, b := edges[i][0], edges[i][1] // a=>b
		arr[a] = append(arr[a], b)
		arr[b] = append(arr[b], a)
	}
	res := 0
	visited := make([]bool, n)
	visited[0] = true
	queue := make([][2]int, 0)
	queue = append(queue, [2]int{0, 0})
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		a, dis := node[0], node[1]
		if a != 0 {
			total := (2*dis-1)/patience[a]*patience[a] + 2*dis
			res = max(res, total)
		}
		for i := 0; i < len(arr[a]); i++ {
			b := arr[a][i]
			if visited[b] == false {
				queue = append(queue, [2]int{b, dis + 1})
				visited[b] = true
			}
		}
	}
	return res + 1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 2043.简易银行系统(1)

- 题目

```
你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。
银行共有 n 个账户，编号从 1 到 n 。
每个账号的初始余额存储在一个下标从 0 开始的整数数组 balance 中，其中第 (i + 1) 个账户的初始余额是 balance[i] 。
请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：
指定的账户数量在 1 和 n 之间，且
取款或者转账需要的钱的总数 小于或者等于 账户余额。
实现 Bank 类：
Bank(long[] balance) 使用下标从 0 开始的整数数组 balance 初始化该对象。
boolean transfer(int account1, int account2, long money) 
从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。
boolean deposit(int account, long money) 向编号为 account 的账户存款 money 美元。
如果交易成功，返回 true ；否则，返回 false 。
boolean withdraw(int account, long money) 从编号为 account 的账户取款 money 美元。
如果交易成功，返回 true ；否则，返回 false 。
示例：输入： ["Bank", "withdraw", "transfer", "deposit", "transfer", "withdraw"]
[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]
输出：[null, true, true, true, false, false]
解释：Bank bank = new Bank([10, 100, 20, 50, 30]);
bank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。
                         // 账户 3 余额为 $20 - $10 = $10 。
bank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。
                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。
bank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。
                         // 账户 5 的余额为 $10 + $20 = $30 。
bank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。
                         // 所以无法转账 $15 。
bank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。
提示：n == balance.length
1 <= n, account, account1, account2 <= 105
0 <= balance[i], money <= 1012
transfer, deposit, withdraw 三个函数，每个 最多调用 104 次
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 模拟 | O(n)       | O(n)       |

```go
type Bank struct {
	arr []int64
	n   int
}

func Constructor(balance []int64) Bank {
	return Bank{arr: balance, n: len(balance)}
}

func (this *Bank) Transfer(account1 int, account2 int, money int64) bool {
	if account1 > this.n || account2 > this.n || this.arr[account1-1] < money {
		return false
	}
	this.arr[account1-1] = this.arr[account1-1] - money
	this.arr[account2-1] = this.arr[account2-1] + money
	return true
}

func (this *Bank) Deposit(account int, money int64) bool {
	if account > this.n {
		return false
	}
	this.arr[account-1] = this.arr[account-1] + money
	return true
}

func (this *Bank) Withdraw(account int, money int64) bool {
	if account > this.n || this.arr[account-1] < money {
		return false
	}
	this.arr[account-1] = this.arr[account-1] - money
	return true
}
```

## 2044.统计按位或能得到最大值的子集数目(4)

- 题目

```
给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。
如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。
如果选中的元素下标位置不一样，则认为两个子集 不同 。
对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。
示例 1：输入：nums = [3,1] 输出：2
解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：
- [3]
- [3,1]
示例 2：输入：nums = [2,2,2] 输出：7
解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。
示例 3：输入：nums = [3,2,1,5] 输出：6
解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：
- [3,5]
- [3,1,5]
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]
提示：1 <= nums.length <= 16
1 <= nums[i] <= 105
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 子集 | O(3^n)     | O(2^n)     |
| 02   | 子集 | O(n*2^n)   | O(2^n)     |
| 03   | 子集 | O(n*2^n)   | O(1)       |
| 04   | 递归 | O(2^n)     | O(1)       |

```go
func countMaxOrSubsets(nums []int) int {
	n := len(nums)
	total := 1 << n
	sum := make([]int, total)
	for i := 0; i < n; i++ { // 每次添加1个
		count := 1 << i
		for j := 0; j < count; j++ {
			sum[count|j] = sum[j] | nums[i] // 按位或运算：j前面补1=>子集和加上tasks[i]
		}
	}
	maxValue := 0
	for i := 0; i < total; i++ {
		maxValue = max(maxValue, sum[i])
	}
	res := 0
	for i := 0; i < total; i++ {
		if sum[i] == maxValue {
			res++
		}
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func countMaxOrSubsets(nums []int) int {
	n := len(nums)
	total := 1 << n
	sum := make([]int, total)
	for i := 0; i < total; i++ { // 枚举状态
		for j := 0; j < n; j++ { // 枚举该位
			if (i & (1 << j)) > 0 {
				sum[i] = sum[i] | nums[j]
			}
		}
	}
	maxValue := 0
	for i := 0; i < total; i++ {
		maxValue = max(maxValue, sum[i])
	}
	res := 0
	for i := 0; i < total; i++ {
		if sum[i] == maxValue {
			res++
		}
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 3
func countMaxOrSubsets(nums []int) int {
	n := len(nums)
	total := 1 << n
	maxValue := 0
	res := 0
	for i := 0; i < total; i++ { // 枚举状态
		value := 0
		for j := 0; j < n; j++ { // 枚举该位
			if (i & (1 << j)) > 0 {
				value = value | nums[j]
			}
		}
		if value > maxValue {
			maxValue = value
			res = 1
		} else if value == maxValue {
			res++
		}
	}
	return res
}

# 4
var maxValue int
var res int

func countMaxOrSubsets(nums []int) int {
	n := len(nums)
	maxValue = 0
	res = 0
	for i := 0; i < n; i++ {
		maxValue = maxValue | nums[i]
	}
	dfs(nums, 0, 0)
	return res
}

func dfs(nums []int, index, sum int) {
	if index == len(nums) {
		if sum == maxValue {
			res++
		}
		return
	}
	dfs(nums, index+1, sum)
	dfs(nums, index+1, sum|nums[index])
}
```



# 2001-2100-Hard

## 2025.分割数组的最多方案数(2)

- 题目

```
给你一个下标从 0 开始且长度为 n 的整数数组 nums 。分割 数组 nums 的方案数定义为符合以下两个条件的 pivot 数目：
1 <= pivot < n
nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]
同时给你一个整数 k 。你可以将 nums 中 一个 元素变为 k 或 不改变 数组。
请你返回在 至多 改变一个元素的前提下，最多 有多少种方法 分割 nums 使得上述两个条件都满足。
示例 1：输入：nums = [2,-1,2], k = 3 输出：1
解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。
有一种方法分割数组：
- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。
示例 2：输入：nums = [0,0,0], k = 1 输出：2
解释：一个最优的方案是不改动数组。
有两种方法分割数组：
- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。
- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。
示例 3：输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33 输出：4
解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。
有四种方法分割数组。
提示：n == nums.length
2 <= n <= 105
-105 <= k, nums[i] <= 105
```

- 解题思路

| No.  | 思路        | 时间复杂度 | 空间复杂度 |
| ---- | ----------- | ---------- | ---------- |
| 01   | 前缀和+哈希 | O(n)       | O(n)       |
| 02   | 前缀和      | O(n)       | O(n)       |

```go
func waysToPartition(nums []int, k int) int {
	res := 0
	n := len(nums)
	sum := 0
	prev := make(map[int]int) // 前缀和
	arr := make([]int, n+1)
	for i := 0; i < n; i++ {
		arr[i+1] = arr[i] + nums[i]
		sum = sum + nums[i]
		if i != n-1 {
			prev[sum]++
		}
	}
	if sum%2 == 0 {
		res = prev[sum/2] // 不改变的结果
	}
	suf := make(map[int]int) // 后缀和
	sufSum := 0
	temp := sum
	for i := n - 1; i >= 0; i-- { // 枚举每一位修改后的结果
		target := sum - nums[i] + k // 替换后的总和
		temp = temp - nums[i]
		prev[temp]-- // 前缀和 减一
		sufSum = sufSum + k
		suf[sufSum]++
		if target%2 == 0 {
			res = max(res, prev[target/2]+suf[target/2])
		}
		suf[sufSum]--
		sufSum = sufSum - k + nums[i]
		suf[sufSum]++
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

# 2
func waysToPartition(nums []int, k int) int {
	res := 0
	n := len(nums)
	prev := make(map[int]int) // 前缀和
	arr := make([]int, n)
	arr[0] = nums[0]
	for i := 1; i < n; i++ {
		arr[i] = arr[i-1] + nums[i]
		prev[arr[i-1]]++
	}
	sum := arr[n-1]
	if sum%2 == 0 {
		res = prev[sum/2] // 不改变的结果
	}
	m := make(map[int]int)
	for i := 0; i < len(arr); i++ {
		diff := k - nums[i]
		if (sum+diff)%2 == 0 {
			res = max(res, prev[(sum-diff)/2]+m[(sum+diff)/2])
		}
		m[arr[i]]++    // 左侧+1
		prev[arr[i]]-- // 右侧-1
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

