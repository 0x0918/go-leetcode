# 0201-0300

## 202.快乐数(2)

- 题目

```
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。

示例： 输入：19 输出：true 
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

- 解题思路

 No.  | 思路            | 时间复杂度 | 空间复杂度 
-|-|-|-
 01   | 哈希+遍历       | O(log(n))  | O(log(n))  
 02   | 遍历+快慢判断环 | O(log(n))  | O(1)       

```go
func isHappy(n int) bool {
	now, next := n, nextValue(n)
	m := make(map[int]int)
	m[now] = 1
	for {
		if next == 1 {
			break
		}
		if _, ok := m[next]; ok {
			break
		} else {
			m[next] = 1
		}
		next = nextValue(next)
	}

	if next == 1 {
		return true
	}

	return false
}

func nextValue(n int) int {
	ret := 0
	for n != 0 {
		ret = ret + (n%10)*(n%10)
		n = n / 10
	}
	return ret
}

#
func isHappy(n int) bool {
	now, next := n, nextValue(n)
	for now != next {
		now = nextValue(now)
		next = nextValue(nextValue(next))
	}
	if now == 1 {
		return true
	}
	return false
}

func nextValue(n int) int {
	ret := 0
	for n != 0 {
		ret = ret + (n%10)*(n%10)
		n = n / 10
	}
	return ret
}
```

## 203.移除链表元素(2)

- 题目

```
删除链表中等于给定值 val 的所有节点。

示例:
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 哨兵结点+链表遍历 | O(n)       | O(1)       |
| 02   | 递归              | O(n)       | O(n)       |

```go
func removeElements(head *ListNode, val int) *ListNode {
	headPre := &ListNode{Next: head}
	temp := headPre

	for temp.Next != nil {
		if temp.Next.Val == val {
			//delete
			temp.Next = temp.Next.Next
		} else {
			temp = temp.Next
		}
	}

	return headPre.Next
}

# 递归
func removeElements(head *ListNode, val int) *ListNode {
	if head == nil {
		return nil
	}
	head.Next = removeElements(head.Next, val)
	if head.Val == val {
		return head.Next
	}
	return head
}
```

## 204.计数质数(2)

- 题目

```
统计所有小于非负整数 n 的质数的数量。

示例:
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

- 解题思路

| No.  | 思路                   | 时间复杂度 | 空间复杂度 |
| ---- | ---------------------- | ---------- | ---------- |
| 01   | 筛选质数(厄拉多塞筛法) | O(n^2)     | O(n)       |
| 02   | 筛选质数优化           | O(n^(1/4)) | O(n)       |

```go
func countPrimes(n int) int {
	if n < 3 {
		return 0
	}
	notPrimes := make([]bool, n)
	count := 0
	for i := 2; i < n; i++ {
		if notPrimes[i] {
			continue
		}
		for j := i*2 ; j < n; j += i  {
			notPrimes[j] = true
		}
		count++
	}
	return count
}

#
func countPrimes(n int) int {
	if n < 3 {
		return 0
	}
	isPrimes := make([]bool, n)
	for i := range isPrimes {
		isPrimes[i] = true
	}
	for i := 2; i*i < n; i++ {
		if !isPrimes[i] {
			continue
		}
		for j := i * i; j < n; j += i {
			isPrimes[j] = false
		}
	}
	count := 0
	for i := 2; i < n; i++ {
		if isPrimes[i] {
			count++
		}
	}
	return count
}
```

## 205.同构字符串(3)

- 题目

```
给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。
两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例 1: 输入: s = "egg", t = "add" 输出: true
示例 2:输入: s = "foo", t = "bar" 输出: false
示例 3: 输入: s = "paper", t = "title" 输出: true

说明:你可以假设 s 和 t 具有相同的长度。
```

- 解题思路

| No.  | 思路           | 时间复杂度 | 空间复杂度 |
| ---- | -------------- | ---------- | ---------- |
| 01   | 数组映射       | O(n)       | O(n)       |
| 02   | 哈希映射       | O(n)       | O(n)       |
| 03   | 字符串查找匹配 | O(n)       | O(1)       |

```go
func isIsomorphic(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	m1 := make([]int, 256)
	m2 := make([]int, 256)

	for i := 0; i < len(s); i++ {
		a := int(s[i])
		b := int(t[i])
		if m1[a] != m2[b] {
			return false
		}
		m1[a] = i + 1
		m2[b] = i + 1
	}
	return true
}

#
func isIsomorphic(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	m := make(map[int]int)
	n := make(map[int]int)

	for i := 0; i < len(s); i++ {
		a := int(s[i])
		b := int(t[i])
		if m[a] == 0 && n[b] == 0 {
			m[a] = b
			n[b] = a
		} else if m[a] != b || n[b] != a {
			return false
		}
	}
	return true
}


# 
func isIsomorphic(s string, t string) bool {
	for i := 0; i < len(s); i++ {
		if strings.IndexByte(s[i+1:], s[i]) != strings.IndexByte(t[i+1:], t[i]) {
			return false
		}
	}
	return true
}
```

## 206.反转链表(2)

- 题目

```
反转一个单链表。
示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(n)       |
| 02   | 迭代 | O(n)       | O(1)       |

```go
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}

	result := reverseList(head.Next)
	head.Next.Next = head
	head.Next = nil
	return result
}

//
func reverseList(head *ListNode) *ListNode {
	var result *ListNode
	var temp *ListNode
	for head != nil {
		temp = head.Next
		head.Next = result
		result = head
		head = temp
	}
	return result
}
```

## 217.存在重复元素(2)

- 题目

```
给定一个整数数组，判断是否存在重复元素。
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

示例 1:输入: [1,2,3,1] 输出: true
示例 2:输入: [1,2,3,4] 输出: false
示例 3:输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 哈希辅助遍历 | O(n)       | O(n)       |
| 02   | 排序后遍历   | O(nlog(n)) | O(1)       |

```go
func containsDuplicate(nums []int) bool {
	m := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		if _, ok := m[nums[i]]; ok {
			return true
		} else {
			m[nums[i]] = 1
		}
	}
	return false
}

#
func containsDuplicate(nums []int) bool {
	sort.Ints(nums)
	for i := 0; i < len(nums)-1; i++{
		if nums[i] == nums[i+1]{
			return true
		}
	}
	return false
}
```

## 219.存在重复元素 II(2)

- 题目

```
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，
使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

示例 1:输入: nums = [1,2,3,1], k = 3输出: true
示例 2:输入: nums = [1,0,1,1], k = 1 输出: true
示例 3:输入: nums = [1,2,3,1,2,3], k = 2 输出: false
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 哈希辅助遍历    | O(n)       | O(n)       |
| 02   | 哈希表+滑动窗口 | O(n)       | O(n)       |

```go
#
func containsNearbyDuplicate(nums []int, k int) bool {
	m := make(map[int]int)

	for i, n := range nums {
		if m[n] != 0 && (i+1)-m[n] <= k {
			return true
		}
		m[n] = i + 1
	}
	return false
}

#
func containsNearbyDuplicate(nums []int, k int) bool {
	m := make(map[int]int)

	for i, n := range nums {
		if m[n] != 0 {
			return true
		}
		m[n] = i + 1
		if len(m) > k {
			delete(m, nums[i-k])
		}
	}
	return false
}
```

## 225.用队列实现栈(4)

- 题目

```
使用队列实现栈的下列操作：
    push(x) -- 元素 x 入栈
    pop() -- 移除栈顶元素
    top() -- 获取栈顶元素
    empty() -- 返回栈是否为空

注意:
    你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 
    和 is empty 这些操作是合法的。
    你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 
    只要是标准的队列操作即可。
    你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。
```

- 解题思路

| No.  | 思路                     | 时间复杂度 | 空间复杂度 |
| ---- | ------------------------ | ---------- | ---------- |
| 01   | 使用切片实现             | O(1)       | O(n)       |
| 02   | 使用1个list实现          | O(1)       | O(n)       |
| 03   | 使用2个list实现          | O(n)       | O(n)       |
| 04   | 使用2个双端队列deque实现 | O(n)       | O(n)       |

```go
type MyStack struct {
	arr []int
}

func Constructor() MyStack {
	return MyStack{}
}

func (m *MyStack) Push(x int) {
	m.arr = append(m.arr, x)
}

func (m *MyStack) Pop() int {
	if len(m.arr) == 0 {
		return 0
	}
	last := m.arr[len(m.arr)-1]
	m.arr = m.arr[0 : len(m.arr)-1]
	return last
}

func (m *MyStack) Top() int {
	if len(m.arr) == 0 {
		return 0
	}
	return m.arr[len(m.arr)-1]
}

func (m *MyStack) Empty() bool {
	if len(m.arr) == 0 {
		return true
	}
	return false
}

# 使用1个list实现
type MyStack struct {
	*list.List
}
func Constructor() MyStack {
	return MyStack{
		list.New(),
	}
}

func (m *MyStack) Push(x int) {
	m.PushBack(x)
}

func (m *MyStack) Pop() int {
	if m.Len() == 0 {
		return -1
	}
	return m.Remove(m.Back()).(int)
}

func (m *MyStack) Top() int {
	if m.Len() == 0 {
		return -1
	}
	return m.Back().Value.(int)
}

func (m *MyStack) Empty() bool {
	return m.Len() == 0
}

#  使用2个list实现
/*
入栈过程：
1、q1 为空，放入 q2，否则放入 q1
出栈过程：
1、q1为空：依次取出q2中的元素（除了最后一个），并且放入q1中 取出q2中的最后一个元素，返回结果
否则 依次取出q1中的元素（除了最后一个），并且放入q2中 取出q1中的最后一个元素，返回结果
*/
type MyStack struct {
	l1 *list.List
	l2 *list.List
}

func Constructor() MyStack {
	return MyStack{
		l1: list.New(),
		l2: list.New(),
	}
}

func (m *MyStack) Push(x int) {
	if m.l1.Len() == 0 {
		m.l2.PushBack(x)
	} else {
		m.l1.PushBack(x)
	}
}

func (m *MyStack) Pop() int {
	var top int
	if m.l1.Len() > 0 {
		for m.l1.Len() > 1 {
			m.l2.PushBack(m.l1.Remove(m.l1.Front()))
		}
		top = m.l1.Remove(m.l1.Front()).(int)
	} else {
		for m.l2.Len() > 1 {
			m.l1.PushBack(m.l2.Remove(m.l2.Front()))
		}
		top = m.l2.Remove(m.l2.Front()).(int)
	}
	return top
}

func (m *MyStack) Top() int {
	var top int
	if m.l1.Len() > 0 {
		for m.l1.Len() > 1 {
			m.l2.PushBack(m.l1.Remove(m.l1.Front()))
		}
		top = m.l1.Back().Value.(int)
		m.l2.PushBack(m.l1.Remove(m.l1.Front()))

	} else {
		for m.l2.Len() > 1 {
			m.l1.PushBack(m.l2.Remove(m.l2.Front()))
		}
		top = m.l2.Back().Value.(int)
		m.l1.PushBack(m.l2.Remove(m.l2.Front()))
	}
	return top
}

func (m *MyStack) Empty() bool {
	return m.l1.Len() == 0 && m.l2.Len() == 0
}

# 使用2个双端队列deque实现
type MyStack struct {
	l1 *Queue
	l2 *Queue
}

func Constructor() MyStack {
	return MyStack{
		l1: NewQueue(),
		l2: NewQueue(),
	}
}

func (m *MyStack) Push(x int) {
	m.l1.Push(x)
}

func (m *MyStack) Pop() int {
	if m.l2.Len() == 0 {
		m.l1, m.l2 = m.l2, m.l1
	}

	for m.l2.Len() > 1 {
		m.l1.Push(m.l2.Pop())
	}
	return m.l2.Pop()
}

func (m *MyStack) Top() int {
	res := m.Pop()
	m.l1.Push(res)
	return res
}

func (m *MyStack) Empty() bool {
	return (m.l1.Len() + m.l2.Len()) == 0
}

type Queue struct {
	nums []int
}

func NewQueue() *Queue {
	return &Queue{
		nums: []int{},
	}
}

func (q *Queue) Push(n int) {
	q.nums = append(q.nums, n)
}

func (q *Queue) Pop() int {
	if len(q.nums) == 0 {
		return 0
	}
	res := q.nums[0]
	q.nums = q.nums[1:]
	return res
}

func (q *Queue) Len() int {
	return len(q.nums)
}

func (q *Queue) IsEmpty() bool {
	return q.Len() == 0
}
```

## 226.翻转二叉树(2)

- 题目

```
翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：
    谷歌：我们90％的工程师使用您编写的软件(Homebrew)，
    但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(n)       |
| 02   | 迭代 | O(n)       | O(n)       |

```go
func invertTree(root *TreeNode) *TreeNode {
	if root == nil || (root.Left == nil && root.Right == nil) {
		return root
	}
	root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
	return root
}

# 
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}

	var queue []*TreeNode
	queue = append(queue, root)
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		node.Left, node.Right = node.Right, node.Left
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	return root
}
```

## 231.2的幂(3)

- 题目

```
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例 1:输入: 1 输出: true 解释: 2^0 = 1
示例 2:输入: 16 输出: true 解释: 2^4 = 16
示例 3:输入: 218 输出: false
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 迭代   | O(log(n))  | O(1)       |
| 02   | 位运算 | O(1)       | O(1)       |
| 03   | 递归   | O(log(n))  | O(log(n))  |

```go
func isPowerOfTwo(n int) bool {
	if n < 1 {
		return false
	}
	for n > 1 {
		if n%2 == 1 {
			return false
		}
		n = n / 2
	}
	return true
}

#
func isPowerOfTwo(n int) bool {
	if n < 1 {
		return false
	}
	return n & (n-1) == 0
}

#
func isPowerOfTwo(n int) bool {
	if n < 1 {
		return false
	}
	if n == 1{
		return true
	}
	if n % 2 != 0{
		return false
	}
	return isPowerOfTwo(n/2)
}
```

## 232.用栈实现队列(3)

- 题目

```
使用栈实现队列的下列操作：
    push(x) -- 将一个元素放入队列的尾部。
    pop() -- 从队列首部移除元素。
    peek() -- 返回队列首部的元素。
    empty() -- 返回队列是否为空。

示例:
MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false

说明:
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 
和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
```

- 解题思路

| No.  | 思路            | 时间复杂度 | 空间复杂度 |
| ---- | --------------- | ---------- | ---------- |
| 01   | 使用切片实现    | O(1)       | O(n)       |
| 02   | 使用2个栈实现   | O(n)       | O(n)       |
| 03   | 使用2个切片实现 | O(n)       | O(n)       |

```go
type MyQueue struct {
	a []int
}

func Constructor() MyQueue {
	return MyQueue{}
}

func (m *MyQueue) Push(x int) {
	m.a = append(m.a, x)
}

func (m *MyQueue) Pop() int {
	if len(m.a) == 0 {
		return 0
	}
	first := m.a[0]
	m.a = m.a[1:]
	return first
}

func (m *MyQueue) Peek() int {
	if len(m.a) == 0 {
		return 0
	}
	return m.a[0]
}

func (m *MyQueue) Empty() bool {
	if len(m.a) == 0 {
		return true
	}
	return false
}

# 使用2个栈实现
/*
入队: 直接入栈a
出队: 栈b为空，则把栈a中全部数据出栈进入栈b，然后出栈b,不为空直接出栈b
*/
type MyQueue struct {
	a, b *Stack
}

func Constructor() MyQueue {
	return MyQueue{
		a: NewStack(),
		b: NewStack(),
	}
}

func (m *MyQueue) Push(x int) {
	m.a.Push(x)
}

func (m *MyQueue) Pop() int {
	if m.b.Len() == 0 {
		for m.a.Len() > 0 {
			m.b.Push(m.a.Pop())
		}
	}
	return m.b.Pop()
}

func (m *MyQueue) Peek() int {
	res := m.Pop()
	m.b.Push(res)
	return res
}

func (m *MyQueue) Empty() bool {
	return m.a.Len() == 0 && m.b.Len() == 0
}

type Stack struct {
	nums []int
}

func NewStack() *Stack {
	return &Stack{
		nums: []int{},
	}
}

func (s *Stack) Push(n int) {
	s.nums = append(s.nums, n)
}

func (s *Stack) Pop() int {
	res := s.nums[len(s.nums)-1]
	s.nums = s.nums[:len(s.nums)-1]
	return res
}

func (s *Stack) Len() int {
	return len(s.nums)
}

func (s *Stack) IsEmpty() bool {
	return s.Len() == 0
}

# 使用2个切片实现
type MyQueue struct {
	a []int
	b []int
}

func Constructor() MyQueue {
	return MyQueue{}
}

func (m *MyQueue) Push(x int) {
	m.a = append(m.a, x)
}

func (m *MyQueue) Pop() int {
	m.Peek()
	temp := m.b[len(m.b)-1]
	m.b = m.b[:len(m.b)-1]
	return temp
}

func (m *MyQueue) Peek() int {
	if len(m.b) == 0 {
		for len(m.a) > 0 {
			m.b = append(m.b, m.a[len(m.a)-1])
			m.a = m.a[:len(m.a)-1]
		}
	}
	if len(m.b) == 0 {
		return -1
	}
	return m.b[len(m.b)-1]
}

func (m *MyQueue) Empty() bool {
	return len(m.a) == 0 && len(m.b) == 0
}
```

## 234.回文链表(4)

- 题目

```
请判断一个链表是否为回文链表。
示例 1:输入: 1->2 输出: false
示例 2:输入: 1->2->2->1 输出: true
```

- 解题思路

| No.  | 思路             | 时间复杂度 | 空间复杂度 |
| ---- | ---------------- | ---------- | ---------- |
| 01   | 哈希辅助遍历     | O(n)       | O(n)       |
| 02   | 快慢指针反转链表 | O(n)       | O(1)       |
| 03   | 栈辅助           | O(n)       | O(n)       |
| 04   | 递归             | O(n)       | O(n)       |

```go
func isPalindrome(head *ListNode) bool {
	m := make([]int, 0)
	for head != nil {
		m = append(m, head.Val)
		head = head.Next
	}
	i, j := 0, len(m)-1
	for i < j {
		if m[i] != m[j] {
			return false
		}
		i++
		j--
	}
	return true
}

#
func isPalindrome(head *ListNode) bool {
	fast, slow := head, head
	for fast != nil && fast.Next != nil {
		fast = fast.Next.Next
		slow = slow.Next
	}
	var pre *ListNode
	cur := slow
	for cur != nil{
		next := cur.Next
		cur.Next = pre
		pre = cur
		cur = next
	}
	for pre != nil{
		if head.Val != pre.Val{
			return false
		}
		pre = pre.Next
		head = head.Next
	}
	return true
}

#
func isPalindrome(head *ListNode) bool {
	m := make([]int, 0)
	temp := head
	for temp != nil {
		m = append(m, temp.Val)
		temp = temp.Next
	}
	for head != nil {
		val := m[len(m)-1]
		m = m[:len(m)-1]
		if head.Val != val {
			return false
		}
		head = head.Next
	}
	return true
}

#
var p *ListNode
func isPalindrome(head *ListNode) bool {
	if head == nil{
		return true
	}
	if p == nil{
		p = head
	}
	if isPalindrome(head.Next) && (p.Val == head.Val){
		p = p.Next
		return true
	}
	p = nil
	return false
}
```

## 235.二叉搜索树的最近公共祖先(2)

- 题目

```
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。

说明:
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉搜索树中。
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(log(n))  | O(log(n))  |
| 02   | 迭代 | O(log(n))  | O(1)       |

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if p.Val > root.Val && q.Val > root.Val{
		return lowestCommonAncestor(root.Right, p, q)
	}else if p.Val < root.Val && q.Val < root.Val{
		return lowestCommonAncestor(root.Left, p, q)
	}else {
		return root
	}
}

#
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	for root != nil{
		if p.Val > root.Val && q.Val > root.Val{
			root = root.Right
		}else if p.Val < root.Val && q.Val < root.Val{
			root = root.Left
		}else {
			return root
		}
	}
	return nil
}
```

## 237.删除链表中的节点(1)

- 题目

```
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1: 输入: head = [4,5,1,9], node = 5  输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

示例 2:输入: head = [4,5,1,9], node = 1 输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

说明:
    链表至少包含两个节点。
    链表中所有节点的值都是唯一的。
    给定的节点为非末尾节点并且一定是链表中的一个有效节点。
    不要从你的函数中返回任何结果。
```

- 解题思路

| No.  | 思路                       | 时间复杂度 | 空间复杂度 |
| ---- | -------------------------- | ---------- | ---------- |
| 01   | 把当前节点替换成下一个节点 | O(1)       | O(1)       |

```go
func deleteNode(node *ListNode) {
	node.Val = node.Next.Val
	node.Next = node.Next.Next
}
```

## 242.有效的字母异位词(2)

- 题目

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
示例 1:输入: s = "anagram", t = "nagaram"输出: true
示例 2:输入: s = "rat", t = "car"输出: false

说明:你可以假设字符串只包含小写字母。
进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 哈希辅助 | O(n)       | O(1)       |
| 02   | 排序比较 | O(nlog(n)) | O(n)       |

```go
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	sr := []rune(s)
	tr := []rune(t)

	rec := make(map[rune]int, len(sr))
	for i := range sr {
		rec[sr[i]]++
		rec[tr[i]]--
	}

	for _, n := range rec {
		if n != 0 {
			return false
		}
	}
	return true
}

#
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}
	sArr := make([]int, len(s))
	tArr := make([]int, len(t))
	for i := 0; i < len(s); i++ {
		sArr[i] = int(s[i] - 'a')
		tArr[i] = int(t[i] - 'a')
	}
	sort.Ints(sArr)
	sort.Ints(tArr)
	for i := 0; i < len(s); i++ {
		if sArr[i] != tArr[i] {
			return false
		}
	}
	return true
}
```

## 257.二叉树的所有路径