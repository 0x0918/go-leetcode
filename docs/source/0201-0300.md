# 0201-0300

## 202.快乐数(2)

- 题目

```
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。

示例： 输入：19 输出：true 
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

- 解题思路

 No.  | 思路            | 时间复杂度 | 空间复杂度 
-|-|-|-
 01   | 哈希+遍历       | O(log(n))  | O(log(n))  
 02   | 遍历+快慢判断环 | O(log(n))  | O(1)       

```go
func isHappy(n int) bool {
	now, next := n, nextValue(n)
	m := make(map[int]int)
	m[now] = 1
	for {
		if next == 1 {
			break
		}
		if _, ok := m[next]; ok {
			break
		} else {
			m[next] = 1
		}
		next = nextValue(next)
	}

	if next == 1 {
		return true
	}

	return false
}

func nextValue(n int) int {
	ret := 0
	for n != 0 {
		ret = ret + (n%10)*(n%10)
		n = n / 10
	}
	return ret
}

#
func isHappy(n int) bool {
	now, next := n, nextValue(n)
	for now != next {
		now = nextValue(now)
		next = nextValue(nextValue(next))
	}
	if now == 1 {
		return true
	}
	return false
}

func nextValue(n int) int {
	ret := 0
	for n != 0 {
		ret = ret + (n%10)*(n%10)
		n = n / 10
	}
	return ret
}
```

## 203.移除链表元素(2)

- 题目

```
删除链表中等于给定值 val 的所有节点。

示例:
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

- 解题思路

| No.  | 思路              | 时间复杂度 | 空间复杂度 |
| ---- | ----------------- | ---------- | ---------- |
| 01   | 哨兵结点+链表遍历 | O(n)       | O(1)       |
| 02   | 递归              | O(n)       | O(n)       |

```go
func removeElements(head *ListNode, val int) *ListNode {
	headPre := &ListNode{Next: head}
	temp := headPre

	for temp.Next != nil {
		if temp.Next.Val == val {
			//delete
			temp.Next = temp.Next.Next
		} else {
			temp = temp.Next
		}
	}

	return headPre.Next
}

# 递归
func removeElements(head *ListNode, val int) *ListNode {
	if head == nil {
		return nil
	}
	head.Next = removeElements(head.Next, val)
	if head.Val == val {
		return head.Next
	}
	return head
}
```

## 204.计数质数(2)

- 题目

```
统计所有小于非负整数 n 的质数的数量。

示例:
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

- 解题思路

| No.  | 思路                   | 时间复杂度 | 空间复杂度 |
| ---- | ---------------------- | ---------- | ---------- |
| 01   | 筛选质数(厄拉多塞筛法) | O(n^2)     | O(n)       |
| 02   | 筛选质数优化           | O(n^(1/4)) | O(n)       |

```go
func countPrimes(n int) int {
	if n < 3 {
		return 0
	}
	notPrimes := make([]bool, n)
	count := 0
	for i := 2; i < n; i++ {
		if notPrimes[i] {
			continue
		}
		for j := i*2 ; j < n; j += i  {
			notPrimes[j] = true
		}
		count++
	}
	return count
}

#
func countPrimes(n int) int {
	if n < 3 {
		return 0
	}
	isPrimes := make([]bool, n)
	for i := range isPrimes {
		isPrimes[i] = true
	}
	for i := 2; i*i < n; i++ {
		if !isPrimes[i] {
			continue
		}
		for j := i * i; j < n; j += i {
			isPrimes[j] = false
		}
	}
	count := 0
	for i := 2; i < n; i++ {
		if isPrimes[i] {
			count++
		}
	}
	return count
}
```

## 205.同构字符串(3)

- 题目

```
给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。
两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例 1: 输入: s = "egg", t = "add" 输出: true
示例 2:输入: s = "foo", t = "bar" 输出: false
示例 3: 输入: s = "paper", t = "title" 输出: true

说明:你可以假设 s 和 t 具有相同的长度。
```

- 解题思路

| No.  | 思路           | 时间复杂度 | 空间复杂度 |
| ---- | -------------- | ---------- | ---------- |
| 01   | 数组映射       | O(n)       | O(n)       |
| 02   | 哈希映射       | O(n)       | O(n)       |
| 03   | 字符串查找匹配 | O(n)       | O(1)       |

```go
func isIsomorphic(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	m1 := make([]int, 256)
	m2 := make([]int, 256)

	for i := 0; i < len(s); i++ {
		a := int(s[i])
		b := int(t[i])
		if m1[a] != m2[b] {
			return false
		}
		m1[a] = i + 1
		m2[b] = i + 1
	}
	return true
}

#
func isIsomorphic(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	m := make(map[int]int)
	n := make(map[int]int)

	for i := 0; i < len(s); i++ {
		a := int(s[i])
		b := int(t[i])
		if m[a] == 0 && n[b] == 0 {
			m[a] = b
			n[b] = a
		} else if m[a] != b || n[b] != a {
			return false
		}
	}
	return true
}


# 
func isIsomorphic(s string, t string) bool {
	for i := 0; i < len(s); i++ {
		if strings.IndexByte(s[i+1:], s[i]) != strings.IndexByte(t[i+1:], t[i]) {
			return false
		}
	}
	return true
}
```

## 206.反转链表(2)

- 题目

```
反转一个单链表。
示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 递归 | O(n)       | O(n)       |
| 02   | 迭代 | O(n)       | O(1)       |

```go
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}

	result := reverseList(head.Next)
	head.Next.Next = head
	head.Next = nil
	return result
}

//
func reverseList(head *ListNode) *ListNode {
	var result *ListNode
	var temp *ListNode
	for head != nil {
		temp = head.Next
		head.Next = result
		result = head
		head = temp
	}
	return result
}
```

## 217.存在重复元素(2)

- 题目

```
给定一个整数数组，判断是否存在重复元素。
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

示例 1:输入: [1,2,3,1] 输出: true
示例 2:输入: [1,2,3,4] 输出: false
示例 3:输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
```

- 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 哈希辅助遍历 | O(n)       | O(n)       |
| 02   | 排序后遍历   | O(nlog(n)) | O(1)       |

```go
func containsDuplicate(nums []int) bool {
	m := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		if _, ok := m[nums[i]]; ok {
			return true
		} else {
			m[nums[i]] = 1
		}
	}
	return false
}

#
func containsDuplicate(nums []int) bool {
	sort.Ints(nums)
	for i := 0; i < len(nums)-1; i++{
		if nums[i] == nums[i+1]{
			return true
		}
	}
	return false
}
```

## 219.存在重复元素 II

### 题目

```
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，
使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

示例 1:输入: nums = [1,2,3,1], k = 3输出: true
示例 2:输入: nums = [1,0,1,1], k = 1 输出: true
示例 3:输入: nums = [1,2,3,1,2,3], k = 2 输出: false
```

### 解题思路

| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| ---- | ------------ | ---------- | ---------- |
| 01   | 哈希辅助遍历 | O(n)       | O(n)       |
| 02   | 排序后遍历   | O(nlog(n)) | O(1)       |

```go

```

